{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/33375/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33375/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/33375"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/33375"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33375/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/33375"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/509692b704270d98016884043be882ce3e93c036"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6002,
            "forks_count": 6002,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1923,
            "open_issues_count": 1923,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-04-08T00:52:19Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 315764,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 88451,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-04-08T02:13:00Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 88451,
            "watchers_count": 88451,
            "web_commit_signoff_required": false
        },
        "sha": "2c960e8f047cf78b34e581990846fce08b62e586",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Problem: No type information for `vim.uv`.\r\n\r\nSolution: Vendor https://github.com/LuaCATS/luv (which is what luals bundles). This will allow other tooling to work out-of-the-box and make these files available to users and plugins without the need for `lazydev.nvim` etc.\r\n\r\nThese files are basically unmaintained and have not been adjusted for recent (>3y) libuv releases (fixing which will be a massive hence separate undertaking). The endgame here is to \r\n\r\n1. generate `luvref.txt` from this;\r\n2. upstream this to luvit/luv (so we can just copy it to our runtime as part of the installation).\r\n\r\n\r\n\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/33375#discussion_r2031699703"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/33375"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2031699703"
                }
            },
            "author_association": "MEMBER",
            "body": "Stylua insists on making this multiline, but this seems to confuse luals' \"meta detection\".\r\n\r\n(Another argument for increasing line lengths...)",
            "commit_id": "509692b704270d98016884043be882ce3e93c036",
            "created_at": "2025-04-07T17:33:11Z",
            "diff_hunk": "@@ -0,0 +1,2794 @@\n+---@meta\n+-- luacheck: no unused args\n+error('Cannot require a meta file')\n+\n+--- The luv project provides access to the multi-platform support library\n+--- libuv in Lua code. It was primarily developed for the luvit project as\n+--- the built-in `uv` module, but can be used in other Lua environments.\n+---\n+--- More information about the core libuv library can be found at the original\n+--- libuv documentation page.\n+---\n+---\n+--- Here is a small example showing a TCP echo server:\n+---\n+--- ```lua\n+--- local uv = require(\"luv\") -- \"luv\" when stand-alone, \"uv\" in luvi apps\n+---\n+--- local server = uv.new_tcp()\n+--- server:bind(\"127.0.0.1\", 1337)\n+--- server:listen(128, function (err)\n+---   assert(not err, err)\n+---   local client = uv.new_tcp()\n+---   server:accept(client)\n+---   client:read_start(function (err, chunk)\n+---     assert(not err, err)\n+---     if chunk then\n+---       client:write(chunk)\n+---     else\n+---       client:shutdown()\n+---       client:close()\n+---     end\n+---   end)\n+--- end)\n+--- print(\"TCP server listening at 127.0.0.1 port 1337\")\n+--- uv.run() -- an explicit run call is necessary outside of luvit\n+--- ```\n+---\n+---\n+--- The luv library contains a single Lua module referred to hereafter as `uv` for\n+--- simplicity. This module consists mostly of functions with names corresponding to\n+--- their original libuv versions. For example, the libuv function `uv_tcp_bind` has\n+--- a luv version at `uv.tcp_bind`. Currently, only one non-function field exists:\n+--- `uv.constants`, which is a table.\n+---\n+---\n+--- In addition to having simple functions, luv provides an optional method-style\n+--- API. For example, `uv.tcp_bind(server, host, port)` can alternatively be called\n+--- as `server:bind(host, port)`. Note that the first argument `server` becomes the\n+--- object and `tcp_` is removed from the function name. Method forms are\n+--- documented below where they exist.\n+---\n+---\n+--- Functions that accept a callback are asynchronous. These functions may\n+--- immediately return results to the caller to indicate their initial status, but\n+--- their final execution is deferred until at least the next libuv loop iteration.\n+--- After completion, their callbacks are executed with any results passed to it.\n+---\n+--- Functions that do not accept a callback are synchronous. These functions\n+--- immediately return their results to the caller.\n+---\n+--- Some (generally FS and DNS) functions can behave either synchronously or\n+--- asynchronously. If a callback is provided to these functions, they behave\n+--- asynchronously; if no callback is provided, they behave synchronously.\n+---\n+---\n+--- Some unique types are defined. These are not actual types in Lua, but they are\n+--- used here to facilitate documenting consistent behavior:\n+--- - `fail`: an assertable `nil, string, string` tuple (see Error handling)\n+--- - `callable`: a `function`; or a `table` or `userdata` with a `__call`\n+---   metamethod\n+--- - `buffer`: a `string` or a sequential `table` of `string`s\n+--- - `threadargs`: variable arguments (`...`) of type `nil`, `boolean`, `number`,\n+---   `string`, or `userdata`\n+---\n+---\n+--- This documentation is mostly a retelling of the libuv API documentation\n+--- within the context of luv's Lua API. Low-level implementation details and\n+--- unexposed C functions and types are not documented here except for when they\n+--- are relevant to behavior seen in the Lua module.\n+---\n+--- [Error handling]: #error-handling\n+---\n+--- In libuv, errors are negative numbered constants; however, these errors and the\n+--- functions used to handle them are not exposed to luv users. Instead, if an\n+--- internal error is encountered, the luv function will return to the caller an\n+--- assertable `nil, err, name` tuple.\n+---\n+--- - `nil` idiomatically indicates failure\n+--- - `err` is a string with the format `{name}: {message}`\n+---   - `{name}` is the error name provided internally by `uv_err_name`\n+---   - `{message}` is a human-readable message provided internally by `uv_strerror`\n+--- - `name` is the same string used to construct `err`\n+---\n+--- This tuple is referred to below as the `fail` pseudo-type.\n+---\n+--- When a function is called successfully, it will return either a value that is\n+--- relevant to the operation of the function, or the integer `0` to indicate\n+--- success, or sometimes nothing at all. These cases are documented below.\n+---\n+---\n+--- [reference counting]: #reference-counting\n+---\n+--- The libuv event loop (if run in the default mode) will run until there are no\n+--- active and referenced handles left. The user can force the loop to exit early by\n+--- unreferencing handles which are active, for example by calling `uv.unref()`\n+--- after calling `uv.timer_start()`.\n+---\n+--- A handle can be referenced or unreferenced, the refcounting scheme doesn't use a\n+--- counter, so both operations are idempotent.\n+---\n+--- All handles are referenced when active by default, see `uv.is_active()` for a\n+--- more detailed explanation on what being active involves.\n+---\n+---\n+--- [File system operations]: #file-system-operations\n+---\n+--- Most file system functions can operate synchronously or asynchronously. When a synchronous version is called (by omitting a callback), the function will\n+--- immediately return the results of the FS call. When an asynchronous version is\n+--- called (by providing a callback), the function will immediately return a\n+--- `uv_fs_t userdata` and asynchronously execute its callback; if an error is encountered, the first and only argument passed to the callback will be the `err` error string; if the operation completes successfully, the first argument will be `nil` and the remaining arguments will be the results of the FS call.\n+---\n+--- Synchronous and asynchronous versions of `readFile` (with naive error handling)\n+--- are implemented below as an example:\n+---\n+--- ```lua\n+--- local function readFileSync(path)\n+---   local fd = assert(uv.fs_open(path, \"r\", 438))\n+---   local stat = assert(uv.fs_fstat(fd))\n+---   local data = assert(uv.fs_read(fd, stat.size, 0))\n+---   assert(uv.fs_close(fd))\n+---   return data\n+--- end\n+---\n+--- local data = readFileSync(\"main.lua\")\n+--- print(\"synchronous read\", data)\n+--- ```\n+---\n+--- ```lua\n+--- local function readFile(path, callback)\n+---   uv.fs_open(path, \"r\", 438, function(err, fd)\n+---     assert(not err, err)\n+---     uv.fs_fstat(fd, function(err, stat)\n+---       assert(not err, err)\n+---       uv.fs_read(fd, stat.size, 0, function(err, data)\n+---         assert(not err, err)\n+---         uv.fs_close(fd, function(err)\n+---           assert(not err, err)\n+---           return callback(data)\n+---         end)\n+---       end)\n+---     end)\n+---   end)\n+--- end\n+---\n+--- readFile(\"main.lua\", function(data)\n+---   print(\"asynchronous read\", data)\n+--- end)\n+--- ```\n+---\n+---\n+--- [Thread pool work scheduling]: #thread-pool-work-scheduling\n+---\n+--- Libuv provides a threadpool which can be used to run user code and get notified\n+--- in the loop thread. This threadpool is internally used to run all file system\n+--- operations, as well as `getaddrinfo` and `getnameinfo` requests.\n+---\n+--- ```lua\n+--- local function work_callback(a, b)\n+---   return a + b\n+--- end\n+---\n+--- local function after_work_callback(c)\n+---   print(\"The result is: \" .. c)\n+--- end\n+---\n+--- local work = uv.new_work(work_callback, after_work_callback)\n+---\n+--- work:queue(1, 2)\n+---\n+--- -- output: \"The result is: 3\"\n+--- ```\n+---\n+---\n+--- [DNS utility functions]: #dns-utility-functions\n+---\n+---\n+--- [Threading and synchronization utilities]: #threading-and-synchronization-utilities\n+---\n+--- Libuv provides cross-platform implementations for multiple threading an\n+---  synchronization primitives. The API largely follows the pthreads API.\n+---\n+---\n+--- [Miscellaneous utilities]: #miscellaneous-utilities\n+---\n+---\n+--- [Metrics operations]: #metrics-operations\n+---\n+---@class uv\n+---\n+---@field errno uv.errno\n+---\n+local uv\n+\n+--- This call is used in conjunction with `uv.listen()` to accept incoming\n+--- connections. Call this function after receiving a callback to accept the\n+--- connection.\n+---\n+--- When the connection callback is called it is guaranteed that this function\n+--- will complete successfully the first time. If you attempt to use it more than\n+--- once, it may fail. It is suggested to only call this function once per\n+--- connection call.\n+---\n+--- ```lua\n+--- server:listen(128, function (err)\n+---   local client = uv.new_tcp()\n+---   server:accept(client)\n+--- end)\n+--- ```\n+---\n+---@param  stream        uv.uv_stream_t\n+---@param  client_stream uv.uv_stream_t\n+---@return 0|nil         success\n+---@return uv.error.message|nil    err\n+---@return uv.error.name|nil    err_name\n+function uv.accept(stream, client_stream) end\n+\n+--- Wakeup the event loop and call the async handle's callback.\n+---\n+--- **Note**: It's safe to call this function from any thread. The callback will be\n+--- called on the loop thread.\n+---\n+--- **Warning**: libuv will coalesce calls to `uv.async_send(async)`, that is, not\n+--- every call to it will yield an execution of the callback. For example: if\n+--- `uv.async_send()` is called 5 times in a row before the callback is called, the\n+--- callback will only be called once. If `uv.async_send()` is called again after\n+--- the callback was called, it will be called again.\n+---\n+---@param  async      uv.uv_async_t\n+---@param  ...        uv.threadargs\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.async_send(async, ...) end\n+\n+--- Returns an estimate of the default amount of parallelism a program should use. Always returns a non-zero value.\n+---\n+--- On Linux, inspects the calling thread’s CPU affinity mask to determine if it has been pinned to specific CPUs.\n+---\n+--- On Windows, the available parallelism may be underreported on systems with more than 64 logical CPUs.\n+---\n+--- On other platforms, reports the number of CPUs that the operating system considers to be online.\n+---\n+---@return integer\n+function uv.available_parallelism() end\n+\n+--- Get backend file descriptor. Only kqueue, epoll, and event ports are supported.\n+---\n+--- This can be used in conjunction with `uv.run(\"nowait\")` to poll in one thread\n+--- and run the event loop's callbacks in another\n+---\n+--- **Note**: Embedding a kqueue fd in another kqueue pollset doesn't work on all\n+--- platforms. It's not an error to add the fd but it never generates events.\n+---\n+---@return integer|nil fd\n+function uv.backend_fd() end\n+\n+--- Get the poll timeout. The return value is in milliseconds, or -1 for no timeout.\n+---\n+---@return integer\n+function uv.backend_timeout() end\n+\n+--- Cancel a pending request. Fails if the request is executing or has finished\n+--- executing. Only cancellation of `uv_fs_t`, `uv_getaddrinfo_t`,\n+--- `uv_getnameinfo_t` and `uv_work_t` requests is currently supported.\n+---\n+---@param  req        uv.uv_req_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.cancel(req) end\n+\n+--- Sets the current working directory with the string `cwd`.\n+---\n+---@param  cwd        string\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.chdir(cwd) end\n+\n+--- Start the handle with the given callback.\n+---\n+---@param  check      uv.uv_check_t\n+---@param  callback   function\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.check_start(check, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---\n+---@param  check      uv.uv_check_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.check_stop(check) end\n+\n+--- Request handle to be closed. `callback` will be called asynchronously after this\n+--- call. This MUST be called on each handle before memory is released.\n+---\n+--- Handles that wrap file descriptors are closed immediately but `callback` will\n+--- still be deferred to the next iteration of the event loop. It gives you a chance\n+--- to free up any resources associated with the handle.\n+---\n+--- In-progress requests, like `uv_connect_t` or `uv_write_t`, are cancelled and\n+--- have their callbacks called asynchronously with `ECANCELED`.\n+---\n+---@param handle uv.uv_handle_t\n+---@param callback? function\n+function uv.close(handle, callback) end\n+\n+--- Returns information about the CPU(s) on the system as a table of tables for each\n+--- CPU found.\n+---\n+--- **Returns:** `table` or `fail`\n+--- - `[1, 2, 3, ..., n]` : `table`\n+---   - `model` : `string`\n+---   - `speed` : `number`\n+---   - `times` : `table`\n+---     - `user` : `number`\n+---     - `nice` : `number`\n+---     - `sys` : `number`\n+---     - `idle` : `number`\n+---     - `irq` : `number`\n+---\n+---@return uv.cpu_info.cpu[]|nil info\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.cpu_info() end\n+\n+--- Returns the current working directory.\n+---\n+---@return string|nil cwd\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.cwd() end\n+\n+--- Disables inheritance for file descriptors / handles that this process inherited\n+--- from its parent. The effect is that child processes spawned by this process\n+--- don't accidentally inherit these handles.\n+---\n+--- It is recommended to call this function as early in your program as possible,\n+--- before the inherited file descriptors can be closed or duplicated.\n+---\n+--- **Note:** This function works on a best-effort basis: there is no guarantee that\n+--- libuv can discover all file descriptors that were inherited. In general it does\n+--- a better job on Windows than it does on Unix.\n+function uv.disable_stdio_inheritance() end\n+\n+--- Returns the executable path.\n+---\n+---@return string|nil exepath\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.exepath() end\n+\n+--- Gets the platform dependent file descriptor equivalent.\n+---\n+--- The following handles are supported: TCP, pipes, TTY, UDP and poll. Passing any\n+--- other handle type will fail with `EINVAL`.\n+---\n+--- If a handle doesn't have an attached file descriptor yet or the handle itself\n+--- has been closed, this function will return `EBADF`.\n+---\n+--- **Warning**: Be very careful when using this function. libuv assumes it's in\n+--- control of the file descriptor so any change to it may lead to malfunction.\n+---\n+---@param  handle      uv.uv_handle_t\n+---@return integer|nil fileno\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fileno(handle) end\n+\n+--- Equivalent to `access(2)` on Unix. Windows uses `GetFileAttributesW()`. Access\n+--- `mode` can be an integer or a string containing `\"R\"` or `\"W\"` or `\"X\"`.\n+--- Returns `true` or `false` indicating access permission.\n+---\n+---@param  path        string\n+---@param  mode        integer|string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, mode:integer|string, callback:uv.fs_access.callback):uv.uv_fs_t\n+function uv.fs_access(path, mode) end\n+\n+--- Equivalent to `chmod(2)`.\n+---\n+---@param  path        string\n+---@param  mode        integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, mode:integer, callback:uv.fs_chmod.callback):uv.uv_fs_t\n+function uv.fs_chmod(path, mode) end\n+\n+--- Equivalent to `chown(2)`.\n+---\n+---@param  path        string\n+---@param  uid         integer\n+---@param  gid         integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, uid:integer, gid:integer, callback:uv.fs_chown.callback):uv.uv_fs_t\n+function uv.fs_chown(path, uid, gid) end\n+\n+--- Equivalent to `close(2)`.\n+---\n+---@param  fd          integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, callback:uv.fs_close.callback):uv.uv_fs_t\n+function uv.fs_close(fd) end\n+\n+--- Closes a directory stream returned by a successful `uv.fs_opendir()` call.\n+---\n+---@param  dir         uv.luv_dir_t\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(dir:uv.luv_dir_t, callback:uv.fs_closedir.callback):uv.uv_fs_t\n+function uv.fs_closedir(dir) end\n+\n+--- Copies a file from path to new_path. If the `flags` parameter is omitted, then the 3rd parameter will be treated as the `callback`.\n+---\n+--- **Returns (sync version):** `boolean` or `fail`\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param  path        string\n+---@param  new_path    string\n+---@param  flags?      uv.fs_copyfile.flags\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, new_path:string, flags?:uv.fs_copyfile.flags, callback:uv.fs_copyfile.callback):uv.uv_fs_t\n+---@overload fun(path:string, new_path:string, callback:uv.fs_copyfile.callback):uv.uv_fs_t\n+function uv.fs_copyfile(path, new_path, flags) end\n+\n+--- Get the path being monitored by the handle.\n+---\n+---@param  fs_event   uv.uv_fs_event_t\n+---@return string|nil path\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_event_getpath(fs_event) end\n+\n+--- Start the handle with the given callback, which will watch the specified path\n+--- for changes.\n+---\n+---@param  fs_event   uv.uv_fs_event_t\n+---@param  path       string\n+---@param  flags      uv.fs_event_start.flags\n+---@param  callback   uv.fs_event_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_event_start(fs_event, path, flags, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---\n+---@param  fs_event   uv.uv_fs_event_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_event_stop(fs_event) end\n+\n+--- Equivalent to `fchmod(2)`.\n+---\n+---@param  fd          integer\n+---@param  mode        integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, mode:integer, callback:uv.fs_fchmod.callback):uv.uv_fs_t\n+function uv.fs_fchmod(fd, mode) end\n+\n+--- Equivalent to `fchown(2)`.\n+---\n+---@param  fd          integer\n+---@param  uid         integer\n+---@param  gid         integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, uid:integer, gid:integer, callback:uv.fs_fchown.callback):uv.uv_fs_t\n+function uv.fs_fchown(fd, uid, gid) end\n+\n+--- Equivalent to `fdatasync(2)`.\n+---\n+---@param  fd          integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, callback:uv.fs_fdatasync.callback):uv.uv_fs_t\n+function uv.fs_fdatasync(fd) end\n+\n+--- Equivalent to `fstat(2)`.\n+---\n+--- **Returns (sync version):** `table` or `fail` (see `uv.fs_stat`)\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param  fd                    integer\n+---@return uv.fs_stat.result|nil stat\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, callback:uv.fs_fstat.callback):uv.uv_fs_t\n+function uv.fs_fstat(fd) end\n+\n+--- Equivalent to `fsync(2)`.\n+---\n+---@param  fd          integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, callback:uv.fs_fsync.callback):uv.uv_fs_t\n+function uv.fs_fsync(fd) end\n+\n+--- Equivalent to `ftruncate(2)`.\n+---\n+---@param  fd          integer\n+---@param  offset      integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, offset:integer, callback:uv.fs_ftruncate.callback):uv.uv_fs_t\n+function uv.fs_ftruncate(fd, offset) end\n+\n+--- Equivalent to `futime(2)`.\n+---\n+---@param  fd          integer\n+---@param  atime       number\n+---@param  mtime       number\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, atime:number, mtime:number, callback:uv.fs_futime.callback):uv.uv_fs_t\n+function uv.fs_futime(fd, atime, mtime) end\n+\n+--- Equivalent to `lchown(2)`.\n+---\n+---@param  fd          integer\n+---@param  uid         integer\n+---@param  gid         integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, uid:integer, gid:integer, callback:uv.fs_lchown.callback):uv.uv_fs_t\n+function uv.fs_lchown(fd, uid, gid) end\n+\n+--- Equivalent to `link(2)`.\n+---\n+--- **Returns (sync version):** `boolean` or `fail`\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param  path        string\n+---@param  new_path    string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, new_path:string, callback:uv.fs_link.callback):uv.uv_fs_t\n+function uv.fs_link(path, new_path) end\n+\n+--- Equivalent to `lstat(2)`.\n+---\n+--- **Returns (sync version):** `table` or `fail` (see `uv.fs_stat`)\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param  path                  integer\n+---@return uv.fs_stat.result|nil stat\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:integer, callback:uv.fs_lstat.callback):uv.uv_fs_t\n+function uv.fs_lstat(path) end\n+\n+--- Equivalent to `lutime(2)`.\n+---\n+---@param  path        string\n+---@param  atime       number\n+---@param  mtime       number\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, atime:number, mtime:number, callback:uv.fs_lutime.callback):uv.uv_fs_t\n+function uv.fs_lutime(path, atime, mtime) end\n+\n+--- Equivalent to `mkdir(2)`.\n+---\n+---@param  path        string\n+---@param  mode        integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, mode:integer, callback:uv.fs_mkdir.callback):uv.uv_fs_t\n+function uv.fs_mkdir(path, mode) end\n+\n+--- Equivalent to `mkdtemp(3)`.\n+---\n+---@param  template   string\n+---@return string|nil path\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(template:string, callback:uv.fs_mkdtemp.callback):uv.uv_fs_t\n+function uv.fs_mkdtemp(template) end\n+\n+--- Equivalent to `mkstemp(3)`. Returns a temporary file handle and filename.\n+---\n+---@param  template    string\n+---@return integer|nil fd\n+---@return string      path_or_errmsg\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(template:string, callback:uv.fs_mkstemp.callback):uv.uv_fs_t\n+function uv.fs_mkstemp(template) end\n+\n+--- Equivalent to `open(2)`. Access `flags` may be an integer or one of: `\"r\"`,\n+--- `\"rs\"`, `\"sr\"`, `\"r+\"`, `\"rs+\"`, `\"sr+\"`, `\"w\"`, `\"wx\"`, `\"xw\"`, `\"w+\"`,\n+--- `\"wx+\"`, `\"xw+\"`, `\"a\"`, `\"ax\"`, `\"xa\"`, `\"a+\"`, `\"ax+\"`, or \"`xa+`\".\n+---\n+--- **Returns (sync version):** `integer` or `fail`\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+--- **Note:** On Windows, libuv uses `CreateFileW` and thus the file is always\n+--- opened in binary mode. Because of this, the `O_BINARY` and `O_TEXT` flags are\n+--- not supported.\n+---\n+---@param  path        string\n+---@param  flags       uv.fs_open.flags\n+---@param  mode        integer\n+---@return integer|nil fd\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, flags:uv.fs_open.flags, mode:integer, callback:uv.fs_open.callback):uv.uv_fs_t\n+function uv.fs_open(path, flags, mode) end\n+\n+--- Opens path as a directory stream. Returns a handle that the user can pass to\n+--- `uv.fs_readdir()`. The `entries` parameter defines the maximum number of entries\n+--- that should be returned by each call to `uv.fs_readdir()`.\n+---\n+--- **Returns (sync version):** `luv_dir_t userdata` or `fail`\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param  path             string\n+---@return uv.luv_dir_t|nil dir\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path: string, callback: uv.fs_opendir.callback, entries?: integer):uv.uv_fs_t\n+function uv.fs_opendir(path) end\n+\n+--- Get the path being monitored by the handle.\n+---\n+---@param  fs_poll    uv.uv_fs_poll_t\n+---@return string|nil path\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_poll_getpath(fs_poll) end\n+\n+--- Check the file at `path` for changes every `interval` milliseconds.\n+---\n+--- **Note:** For maximum portability, use multi-second intervals. Sub-second\n+--- intervals will not detect all changes on many file systems.\n+---\n+---@param  fs_poll    uv.uv_fs_poll_t\n+---@param  path       string\n+---@param  interval   integer\n+---@param  callback   uv.fs_poll_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_poll_start(fs_poll, path, interval, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---\n+---@param fs_poll uv.uv_fs_poll_t\n+---@return 0|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_poll_stop(fs_poll) end\n+\n+--- Equivalent to `preadv(2)`. Returns any data. An empty string indicates EOF.\n+---\n+--- If `offset` is nil or omitted, it will default to `-1`, which indicates 'use and update the current file offset.'\n+---\n+--- **Note:** When `offset` is >= 0, the current file offset will not be updated by the read.\n+---\n+---@param  fd         integer\n+---@param  size       integer\n+---@param  offset?    integer\n+---@return string|nil data\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, size:integer, offset?:integer, callback:uv.fs_read.callback):uv.uv_fs_t\n+function uv.fs_read(fd, size, offset) end\n+\n+--- Iterates over the directory stream `luv_dir_t` returned by a successful\n+--- `uv.fs_opendir()` call. A table of data tables is returned where the number\n+--- of entries `n` is equal to or less than the `entries` parameter used in\n+--- the associated `uv.fs_opendir()` call.\n+---\n+---@param  dir                       uv.luv_dir_t\n+---@return uv.fs_readdir.entry[]|nil entries\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(dir:uv.luv_dir_t, callback:uv.fs_readdir.callback):uv.uv_fs_t\n+function uv.fs_readdir(dir) end\n+\n+--- Equivalent to `readlink(2)`.\n+---\n+---@param  path       string\n+---@return string|nil path\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, callback:uv.fs_readlink.callback):uv.uv_fs_t\n+function uv.fs_readlink(path) end\n+\n+--- Equivalent to `realpath(3)`.\n+---\n+---@param  path       string\n+---@return string|nil realpath\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, callback:uv.fs_realpath.callback):uv.uv_fs_t\n+function uv.fs_realpath(path) end\n+\n+--- Equivalent to `rename(2)`.\n+---\n+---@param  path        string\n+---@param  new_path    string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, new_path:string, callback:uv.fs_rename.callback):uv.uv_fs_t\n+function uv.fs_rename(path, new_path) end\n+\n+--- Equivalent to `rmdir(2)`.\n+---\n+---@param  path        string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, callback:uv.fs_rmdir.callback):uv.uv_fs_t\n+function uv.fs_rmdir(path) end\n+\n+--- Equivalent to `scandir(3)`, with a slightly different API. Returns a handle that\n+--- the user can pass to `uv.fs_scandir_next()`.\n+---\n+--- **Note:** This function can be used synchronously or asynchronously. The request\n+--- userdata is always synchronously returned regardless of whether a callback is\n+--- provided and the same userdata is passed to the callback if it is provided.\n+---\n+---@param  path           string\n+---@param  callback?      uv.fs_scandir.callback\n+---@return uv.uv_fs_t|nil fs\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.fs_scandir(path, callback) end\n+\n+--- Called on a `uv_fs_t` returned by `uv.fs_scandir()` to get the next directory\n+--- entry data as a `name, type` pair. When there are no more entries, `nil` is\n+--- returned.\n+---\n+--- **Note:** This function only has a synchronous version. See `uv.fs_opendir` and\n+--- its related functions for an asynchronous version.\n+---\n+---@param  fs         uv.uv_fs_t\n+---@return string|nil name\n+---@return string     type_or_errmsg\n+---@return uv.error.name|nil err_name\n+function uv.fs_scandir_next(fs) end\n+\n+--- Limited equivalent to `sendfile(2)`. Returns the number of bytes written.\n+---\n+---@param  out_fd      integer\n+---@param  in_fd       integer\n+---@param  in_offset   integer\n+---@param  size        integer\n+---@return integer|nil bytes\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(out_fd:integer, in_fd:integer, in_offset:integer, size:integer, callback:uv.fs_sendfile.callback):uv.uv_fs_t\n+function uv.fs_sendfile(out_fd, in_fd, in_offset, size) end\n+\n+--- Equivalent to `stat(2)`.\n+---\n+--- **Returns (sync version):** `table` or `fail`\n+--- - `dev` : `integer`\n+--- - `mode` : `integer`\n+--- - `nlink` : `integer`\n+--- - `uid` : `integer`\n+--- - `gid` : `integer`\n+--- - `rdev` : `integer`\n+--- - `ino` : `integer`\n+--- - `size` : `integer`\n+--- - `blksize` : `integer`\n+--- - `blocks` : `integer`\n+--- - `flags` : `integer`\n+--- - `gen` : `integer`\n+--- - `atime` : `table`\n+---   - `sec` : `integer`\n+---   - `nsec` : `integer`\n+--- - `mtime` : `table`\n+---   - `sec` : `integer`\n+---   - `nsec` : `integer`\n+--- - `ctime` : `table`\n+---   - `sec` : `integer`\n+---   - `nsec` : `integer`\n+--- - `birthtime` : `table`\n+---   - `sec` : `integer`\n+---   - `nsec` : `integer`\n+--- - `type` : `string`\n+---\n+--- **Returns (async version):** `uv_fs_t userdata`\n+---\n+---@param path string\n+---@return uv.fs_stat.result|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, callback:uv.fs_stat.callback):uv.uv_fs_t\n+function uv.fs_stat(path) end\n+\n+--- Equivalent to `statfs(2)`.\n+---\n+--- **Returns** `table` or `nil`\n+--- - `type` : `integer`\n+--- - `bsize` : `integer`\n+--- - `blocks` : `integer`\n+--- - `bfree` : `integer`\n+--- - `bavail` : `integer`\n+--- - `files` : `integer`\n+--- - `ffree` : `integer`\n+---\n+---@param path string\n+---@return uv.fs_statfs.result|nil stat\n+---\n+---@overload fun(path: string, callback: uv.fs_statfs.callback)\n+function uv.fs_statfs(path) end\n+\n+--- Equivalent to `symlink(2)`. If the `flags` parameter is omitted, then the 3rd parameter will be treated as the `callback`.\n+---\n+---\n+---@param  path        string\n+---@param  new_path    string\n+---@param  flags?      uv.fs_symlink.flags|integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, new_path:string, flags?:uv.fs_symlink.flags|integer, callback:uv.fs_symlink.callback):uv.uv_fs_t\n+---@overload fun(path:string, new_path:string, callback:uv.fs_symlink.callback):uv.uv_fs_t\n+function uv.fs_symlink(path, new_path, flags) end\n+\n+--- Equivalent to `unlink(2)`.\n+---\n+---@param  path        string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, callback:uv.fs_unlink.callback):uv.uv_fs_t\n+function uv.fs_unlink(path) end\n+\n+--- Equivalent to `utime(2)`.\n+---\n+---@param  path        string\n+---@param  atime       number\n+---@param  mtime       number\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(path:string, atime:number, mtime:number, callback:uv.fs_utime.callback):uv.uv_fs_t\n+function uv.fs_utime(path, atime, mtime) end\n+\n+--- Equivalent to `pwritev(2)`. Returns the number of bytes written.\n+---\n+--- If `offset` is nil or omitted, it will default to `-1`, which indicates 'use and update the current file offset.'\n+---\n+--- **Note:** When `offset` is >= 0, the current file offset will not be updated by the write.\n+---\n+---@param  fd          integer\n+---@param  data        uv.buffer\n+---@param  offset?     integer\n+---@return integer|nil bytes\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(fd:integer, data:uv.buffer, offset?:integer, callback:uv.fs_write.callback):uv.uv_fs_t\n+function uv.fs_write(fd, data, offset) end\n+\n+--- Gets the amount of memory available to the process in bytes based on limits\n+--- imposed by the OS. If there is no such constraint, or the constraint is unknown,\n+--- 0 is returned. Note that it is not unusual for this value to be less than or\n+--- greater than the total system memory.\n+---\n+---@return number\n+function uv.get_constrained_memory() end\n+\n+--- Returns the current free system memory in bytes.\n+---\n+---@return number\n+function uv.get_free_memory() end\n+\n+--- Returns the title of the current process.\n+---\n+---@return string|nil title\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.get_process_title() end\n+\n+--- Returns the current total system memory in bytes.\n+---\n+--- **Returns:** `number`\n+---\n+---@return number\n+function uv.get_total_memory() end\n+\n+--- Equivalent to `getaddrinfo(3)`. Either `node` or `service` may be `nil` but not\n+--- both.\n+---\n+--- Valid hint strings for the keys that take a string:\n+--- - `family`: `\"unix\"`, `\"inet\"`, `\"inet6\"`, `\"ipx\"`,\n+--- `\"netlink\"`, `\"x25\"`, `\"ax25\"`, `\"atmpvc\"`, `\"appletalk\"`, or `\"packet\"`\n+--- - `socktype`: `\"stream\"`, `\"dgram\"`, `\"raw\"`,\n+--- `\"rdm\"`, or `\"seqpacket\"`\n+--- - `protocol`: will be looked up using the `getprotobyname(3)` function (examples: `\"ip\"`, `\"icmp\"`, `\"tcp\"`, `\"udp\"`, etc)\n+---\n+--- **Returns (sync version):** `table` or `fail`\n+--- - `[1, 2, 3, ..., n]` : `table`\n+---   - `addr` : `string`\n+---   - `family` : `string`\n+---   - `port` : `integer` or `nil`\n+---   - `socktype` : `string`\n+---   - `protocol` : `string`\n+---   - `canonname` : `string` or `nil`\n+---\n+--- **Returns (async version):** `uv_getaddrinfo_t userdata` or `fail`\n+---\n+---@param  host                        string\n+---@param  service                     string\n+---@param  hints?                      uv.getaddrinfo.hints\n+---@return uv.getaddrinfo.result[]|nil info\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(host:string, service:string, hints?:uv.getaddrinfo.hints, callback:uv.getaddrinfo.callback):uv.uv_getaddrinfo_t userdata|nil, string?, string?\n+function uv.getaddrinfo(host, service, hints) end\n+\n+--- Returns the group ID of the process.\n+---\n+--- **Note:** This is not a libuv function and is not supported on Windows.\n+---\n+---@return integer\n+function uv.getgid() end\n+\n+--- Equivalent to `getnameinfo(3)`.\n+---\n+--- When specified, `family` must be one of `\"unix\"`, `\"inet\"`, `\"inet6\"`, `\"ipx\"`,\n+--- `\"netlink\"`, `\"x25\"`, `\"ax25\"`, `\"atmpvc\"`, `\"appletalk\"`, or `\"packet\"`.\n+---\n+--- **Returns (sync version):** `string, string` or `fail`\n+---\n+--- **Returns (async version):** `uv_getnameinfo_t userdata` or `fail`\n+---\n+---@param  address    uv.getnameinfo.address\n+---@return string|nil host\n+---@return string     service_or_errmsg\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(address:uv.getnameinfo.address, callback:uv.getnameinfo.callback):uv.uv_getnameinfo_t|nil, string|nil, string|nil\n+function uv.getnameinfo(address) end\n+\n+--- **Deprecated:** Please use `uv.os_getpid()` instead.\n+---\n+function uv.getpid() end\n+\n+--- Returns the resource usage.\n+---\n+--- **Returns:** `table` or `fail`\n+--- - `utime` : `table` (user CPU time used)\n+---   - `sec` : `integer`\n+---   - `usec` : `integer`\n+--- - `stime` : `table` (system CPU time used)\n+---   - `sec` : `integer`\n+---   - `usec` : `integer`\n+--- - `maxrss` : `integer` (maximum resident set size)\n+--- - `ixrss` : `integer` (integral shared memory size)\n+--- - `idrss` : `integer` (integral unshared data size)\n+--- - `isrss` : `integer` (integral unshared stack size)\n+--- - `minflt` : `integer` (page reclaims (soft page faults))\n+--- - `majflt` : `integer` (page faults (hard page faults))\n+--- - `nswap` : `integer` (swaps)\n+--- - `inblock` : `integer` (block input operations)\n+--- - `oublock` : `integer` (block output operations)\n+--- - `msgsnd` : `integer` (IPC messages sent)\n+--- - `msgrcv` : `integer` (IPC messages received)\n+--- - `nsignals` : `integer` (signals received)\n+--- - `nvcsw` : `integer` (voluntary context switches)\n+--- - `nivcsw` : `integer` (involuntary context switches)\n+---\n+---@return uv.getrusage.result|nil usage\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.getrusage() end\n+\n+--- Cross-platform implementation of `gettimeofday(2)`. Returns the seconds and\n+--- microseconds of a unix time as a pair.\n+---\n+---@return integer|nil    seconds\n+---@return integer|string usecs_or_errmsg\n+---@return uv.error.name|nil err_name\n+function uv.gettimeofday() end\n+\n+--- Returns the user ID of the process.\n+---\n+--- **Note:** This is not a libuv function and is not supported on Windows.\n+---\n+---@return integer\n+function uv.getuid() end\n+\n+--- Used to detect what type of stream should be used with a given file\n+--- descriptor `fd`. Usually this will be used during initialization to guess the\n+--- type of the stdio streams.\n+---\n+---@param fd integer\n+---@return string\n+function uv.guess_handle(fd) end\n+\n+--- Returns the name of the struct for a given handle (e.g. `\"pipe\"` for `uv_pipe_t`)\n+--- and the libuv enum integer for the handle's type (`uv_handle_type`).\n+---\n+---@param  handle  uv.uv_handle_t\n+---@return string  type\n+---@return integer enum\n+function uv.handle_get_type(handle) end\n+\n+--- Returns `true` if the handle referenced, `false` if not.\n+---\n+--- See [Reference counting][].\n+---\n+---@param  handle      uv.uv_handle_t\n+---@return boolean|nil has_ref\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.has_ref(handle) end\n+\n+--- Returns a current high-resolution time in nanoseconds as a number. This is\n+--- relative to an arbitrary time in the past. It is not related to the time of day\n+--- and therefore not subject to clock drift. The primary use is for measuring\n+--- time between intervals.\n+---\n+--- **Returns:** `number`\n+---\n+---@return number\n+function uv.hrtime() end\n+\n+--- Start the handle with the given callback.\n+---\n+---@param  idle       uv.uv_idle_t\n+---@param  callback   function\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.idle_start(idle, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---\n+---@param  idle       uv.uv_idle_t\n+---@param  check      any\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.idle_stop(idle, check) end\n+\n+--- Retrieves a network interface identifier suitable for use in an IPv6 scoped\n+--- address. On Windows, returns the numeric `ifindex` as a string. On all other\n+--- platforms, `uv.if_indextoname()` is used.\n+---\n+---@param  ifindex    integer\n+---@return string|nil id\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.if_indextoiid(ifindex) end\n+\n+--- IPv6-capable implementation of `if_indextoname(3)`.\n+---\n+---@param  ifindex    integer\n+---@return string|nil name\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.if_indextoname(ifindex) end\n+\n+--- Returns address information about the network interfaces on the system in a\n+--- table. Each table key is the name of the interface while each associated value\n+--- is an array of address information where fields are `ip`, `family`, `netmask`,\n+--- `internal`, and `mac`.\n+---\n+---@return table<string, uv.interface_addresses.addr>\n+function uv.interface_addresses() end\n+\n+--- Returns `true` if the handle is active, `false` if it's inactive. What \"active”\n+--- means depends on the type of handle:\n+---\n+---   - A [`uv_async_t`][] handle is always active and cannot be deactivated, except\n+---   by closing it with `uv.close()`.\n+---\n+---   - A [`uv_pipe_t`][], [`uv_tcp_t`][], [`uv_udp_t`][], etc. handle - basically\n+---   any handle that deals with I/O - is active when it is doing something that\n+---   involves I/O, like reading, writing, connecting, accepting new connections,\n+---   etc.\n+---\n+---   - A [`uv_check_t`][], [`uv_idle_t`][], [`uv_timer_t`][], etc. handle is active\n+---   when it has been started with a call to `uv.check_start()`, `uv.idle_start()`,\n+---   `uv.timer_start()` etc. until it has been stopped with a call to its\n+---   respective stop function.\n+---\n+---@param  handle      uv.uv_handle_t\n+---@return boolean|nil active\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.is_active(handle) end\n+\n+--- Returns `true` if the handle is closing or closed, `false` otherwise.\n+---\n+--- **Note**: This function should only be used between the initialization of the\n+--- handle and the arrival of the close callback.\n+---\n+---@param  handle      uv.uv_handle_t\n+---@return boolean|nil closing\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.is_closing(handle) end\n+\n+--- Returns `true` if the stream is readable, `false` otherwise.\n+---\n+---@param stream uv.uv_stream_t\n+---@return boolean\n+function uv.is_readable(stream) end\n+\n+--- Returns `true` if the stream is writable, `false` otherwise.\n+---\n+---@param stream uv.uv_stream_t\n+---@return boolean\n+function uv.is_writable(stream) end\n+\n+--- Sends the specified signal to the given PID. Check the documentation on\n+--- `uv_signal_t` for signal support, specially on Windows.\n+---\n+---@param  pid        integer\n+---@param  signum     integer|string\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.kill(pid, signum) end\n+\n+--- Start listening for incoming connections. `backlog` indicates the number of\n+--- connections the kernel might queue, same as `listen(2)`. When a new incoming\n+--- connection is received the callback is called.\n+---\n+--- **Returns:** `0` or `fail`\n+---\n+---@param  stream     uv.uv_stream_t\n+---@param  backlog    integer\n+---@param  callback   uv.listen.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.listen(stream, backlog, callback) end\n+\n+--- Returns the load average as a triad. Not supported on Windows.\n+---\n+---@return number\n+---@return number\n+---@return number\n+function uv.loadavg() end\n+\n+--- Returns `true` if there are referenced active handles, active requests, or\n+--- closing handles in the loop; otherwise, `false`.\n+---\n+---@return boolean|nil alive\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.loop_alive() end\n+\n+--- Closes all internal loop resources. In normal execution, the loop will\n+--- automatically be closed when it is garbage collected by Lua, so it is not\n+--- necessary to explicitly call `loop_close()`. Call this function only after the\n+--- loop has finished executing and all open handles and requests have been closed,\n+--- or it will return `EBUSY`.\n+---\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.loop_close() end\n+\n+--- Set additional loop options. You should normally call this before the first call\n+--- to uv_run() unless mentioned otherwise.\n+---\n+--- Supported options:\n+---\n+---   - `\"block_signal\"`: Block a signal when polling for new events. The second argument\n+---   to loop_configure() is the signal name (as a lowercase string) or the signal number.\n+---   This operation is currently only implemented for `\"sigprof\"` signals, to suppress\n+---   unnecessary wakeups when using a sampling profiler. Requesting other signals will\n+---   fail with `EINVAL`.\n+---   - `\"metrics_idle_time\"`: Accumulate the amount of idle time the event loop spends\n+---   in the event provider. This option is necessary to use `metrics_idle_time()`.\n+---\n+--- An example of a valid call to this function is:\n+---\n+--- ```lua\n+--- uv.loop_configure(\"block_signal\", \"sigprof\")\n+--- ```\n+---\n+--- **Note:** Be prepared to handle the `ENOSYS` error; it means the loop option is\n+--- not supported by the platform.\n+---\n+---@param  option     \"block_signal\"\n+---@param  value      \"sigprof\"\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(option: \"metrics_idle_time\"):(success:0|nil, err:uv.error.message|nil, err_name:uv.error.name|nil)\n+function uv.loop_configure(option, value) end\n+\n+--- If the loop is running, returns a string indicating the mode in use. If the loop\n+--- is not running, `nil` is returned instead.\n+---\n+---@return string|nil\n+function uv.loop_mode() end\n+\n+--- Retrieve the amount of time the event loop has been idle in the kernel’s event\n+--- provider (e.g. `epoll_wait`). The call is thread safe.\n+---\n+--- The return value is the accumulated time spent idle in the kernel’s event\n+--- provider starting from when the [`uv_loop_t`][] was configured to collect the idle time.\n+---\n+--- **Note:** The event loop will not begin accumulating the event provider’s idle\n+--- time until calling `loop_configure` with `\"metrics_idle_time\"`.\n+---\n+--- **Returns:** `number`\n+---\n+--- ---\n+---\n+--- [luv]: https://github.com/luvit/luv\n+--- [luvit]: https://github.com/luvit/luvit\n+--- [libuv]: https://github.com/libuv/libuv\n+--- [libuv documentation page]: http://docs.libuv.org/\n+--- [libuv API documentation]: http://docs.libuv.org/en/v1.x/api.html\n+---\n+---@return number\n+function uv.metrics_idle_time() end\n+\n+--- Creates and initializes a new `uv_async_t`. Returns the Lua userdata wrapping\n+--- it. A `nil` callback is allowed.\n+---\n+--- **Note**: Unlike other handle initialization functions, this immediately starts\n+--- the handle.\n+---\n+---@param  callback?         uv.new_async.callback\n+---@return uv.uv_async_t|nil async\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_async(callback) end\n+\n+--- Creates and initializes a new `uv_check_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_check_t|nil check\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_check() end\n+\n+--- Creates and initializes a new `uv_fs_event_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_fs_event_t|nil fs_event\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_fs_event() end\n+\n+--- Creates and initializes a new `uv_fs_poll_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_fs_poll_t|nil fs_poll\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_fs_poll() end\n+\n+--- Creates and initializes a new `uv_idle_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_idle_t|nil idle\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_idle() end\n+\n+--- Creates and initializes a new `uv_pipe_t`. Returns the Lua userdata wrapping\n+--- it. The `ipc` argument is a boolean to indicate if this pipe will be used for\n+--- handle passing between processes.\n+---\n+---@param  ipc?             boolean|false\n+---@return uv.uv_pipe_t|nil pipe\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_pipe(ipc) end\n+\n+--- Initialize the handle using a file descriptor.\n+---\n+--- The file descriptor is set to non-blocking mode.\n+---\n+---@param  fd               integer\n+---@return uv.uv_poll_t|nil poll\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_poll(fd) end\n+\n+--- Creates and initializes a new `uv_prepare_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_prepare_t|nil prepare\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_prepare() end\n+\n+--- Creates and initializes a new `uv_signal_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+---@return uv.uv_signal_t|nil signal\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_signal() end\n+\n+--- Initialize the handle using a socket descriptor. On Unix this is identical to\n+--- `uv.new_poll()`. On windows it takes a SOCKET handle.\n+---\n+--- The socket is set to non-blocking mode.\n+---\n+---@param  fd               integer\n+---@return uv.uv_poll_t|nil poll\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_socket_poll(fd) end\n+\n+--- Creates and initializes a new `uv_tcp_t`. Returns the Lua userdata wrapping it.\n+--- Flags may be a family string: `\"unix\"`, `\"inet\"`, `\"inet6\"`, `\"ipx\"`,\n+--- `\"netlink\"`, `\"x25\"`, `\"ax25\"`, `\"atmpvc\"`, `\"appletalk\"`, or `\"packet\"`.\n+---\n+---@param  flags?          uv.socket.family\n+---@return uv.uv_tcp_t|nil tcp\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_tcp(flags) end\n+\n+--- Creates and initializes a `luv_thread_t` (not `uv_thread_t`). Returns the Lua\n+--- userdata wrapping it and asynchronously executes `entry`, which can be either\n+--- a Lua function or a Lua function dumped to a string. Additional arguments `...`\n+--- are passed to the `entry` function and an optional `options` table may be\n+--- provided. Currently accepted `option` fields are `stack_size`.\n+---\n+---@param  options?            uv.new_thread.options\n+---@param  entry               function\n+---@param  ...                 uv.threadargs\n+---@return uv.luv_thread_t|nil thread\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_thread(options, entry, ...) end\n+\n+--- Creates and initializes a new `uv_timer_t`. Returns the Lua userdata wrapping\n+--- it.\n+---\n+--- ```lua\n+--- -- Creating a simple setTimeout wrapper\n+--- local function setTimeout(timeout, callback)\n+---   local timer = uv.new_timer()\n+---   timer:start(timeout, 0, function ()\n+---     timer:stop()\n+---     timer:close()\n+---     callback()\n+---   end)\n+---   return timer\n+--- end\n+---\n+--- -- Creating a simple setInterval wrapper\n+--- local function setInterval(interval, callback)\n+---   local timer = uv.new_timer()\n+---   timer:start(interval, interval, function ()\n+---     callback()\n+---   end)\n+---   return timer\n+--- end\n+---\n+--- -- And clearInterval\n+--- local function clearInterval(timer)\n+---   timer:stop()\n+---   timer:close()\n+--- end\n+--- ```\n+---\n+---@return uv.uv_timer_t|nil timer\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_timer() end\n+\n+--- Initialize a new TTY stream with the given file descriptor. Usually the file\n+--- descriptor will be:\n+---\n+---  - 0 - stdin\n+---  - 1 - stdout\n+---  - 2 - stderr\n+---\n+--- On Unix this function will determine the path of the fd of the terminal using\n+--- ttyname_r(3), open it, and use it if the passed file descriptor refers to a TTY.\n+--- This lets libuv put the tty in non-blocking mode without affecting other\n+--- processes that share the tty.\n+---\n+--- This function is not thread safe on systems that don’t support ioctl TIOCGPTN or TIOCPTYGNAME, for instance OpenBSD and Solaris.\n+---\n+--- **Note:** If reopening the TTY fails, libuv falls back to blocking writes.\n+---\n+---@param  fd              integer\n+---@param  readable        boolean\n+---@return uv.uv_tty_t|nil tty\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_tty(fd, readable) end\n+\n+--- Creates and initializes a new `uv_udp_t`. Returns the Lua userdata wrapping\n+--- it. The actual socket is created lazily.\n+---\n+--- When specified, `family` must be one of `\"unix\"`, `\"inet\"`, `\"inet6\"`,\n+--- `\"ipx\"`, `\"netlink\"`, `\"x25\"`, `\"ax25\"`, `\"atmpvc\"`, `\"appletalk\"`, or\n+--- `\"packet\"`.\n+---\n+--- When specified, `mmsgs` determines the number of messages able to be received\n+--- at one time via `recvmmsg(2)` (the allocated buffer will be sized to be able\n+--- to fit the specified number of max size dgrams). Only has an effect on\n+--- platforms that support `recvmmsg(2)`.\n+---\n+--- **Note:** For backwards compatibility reasons, `flags` can also be a string or\n+--- integer. When it is a string, it will be treated like the `family` key above.\n+--- When it is an integer, it will be used directly as the `flags` parameter when\n+--- calling `uv_udp_init_ex`.\n+---\n+--- **Returns:** `uv_udp_t userdata` or `fail`\n+---\n+---@param  flags?          uv.new_udp.flags|uv.new_udp.flags.family|integer\n+---@return uv.uv_udp_t|nil udp\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.new_udp(flags) end\n+\n+--- Creates and initializes a new `luv_work_ctx_t` (not `uv_work_t`). Returns the\n+--- Lua userdata wrapping it.\n+---\n+--- **Parameters:**\n+--- - `work_callback`: `function`\n+---   - `...`: `threadargs` passed to/from `uv.queue_work(work_ctx, ...)`\n+--- - `after_work_callback`: `function`\n+---   - `...`: `threadargs` returned from `work_callback`\n+---\n+---@param work_callback uv.new_work.work_callback\n+---@param after_work_callback uv.new_work.after_work_callback\n+---@return uv.luv_work_ctx_t\n+function uv.new_work(work_callback, after_work_callback) end\n+\n+--- Returns the current timestamp in milliseconds. The timestamp is cached at the\n+--- start of the event loop tick, see `uv.update_time()` for details and rationale.\n+---\n+--- The timestamp increases monotonically from some arbitrary point in time. Don't\n+--- make assumptions about the starting point, you will only get disappointed.\n+---\n+--- **Note**: Use `uv.hrtime()` if you need sub-millisecond granularity.\n+---\n+---@return integer\n+function uv.now() end\n+\n+--- Returns all environmental variables as a dynamic table of names associated with\n+--- their corresponding values.\n+---\n+--- **Warning:** This function is not thread safe.\n+---\n+---@return table<string, string>\n+function uv.os_environ() end\n+\n+--- Returns password file information.\n+---\n+---@return uv.os_get_passwd.info\n+function uv.os_get_passwd() end\n+\n+--- Returns the environment variable specified by `name` as string. The internal\n+--- buffer size can be set by defining `size`. If omitted, `LUAL_BUFFERSIZE` is\n+--- used. If the environment variable exceeds the storage available in the internal\n+--- buffer, `ENOBUFS` is returned. If no matching environment variable exists,\n+--- `ENOENT` is returned.\n+---\n+--- **Warning:** This function is not thread safe.\n+---\n+---@param name string\n+---@param size? integer # (default = `LUAL_BUFFERSIZE`)\n+---@return string|nil value\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_getenv(name, size) end\n+\n+--- Returns the hostname.\n+---\n+---@return string\n+function uv.os_gethostname() end\n+\n+--- Returns the current process ID.\n+---\n+---@return number\n+function uv.os_getpid() end\n+\n+--- Returns the parent process ID.\n+---\n+---@return number\n+function uv.os_getppid() end\n+\n+--- Returns the scheduling priority of the process specified by `pid`.\n+---\n+---@param  pid        integer\n+---@return number|nil priority\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_getpriority(pid) end\n+\n+--- **Warning:** This function is not thread safe.\n+---\n+---@return string|nil homedir\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_homedir() end\n+\n+--- Sets the environmental variable specified by `name` with the string `value`.\n+---\n+--- **Warning:** This function is not thread safe.\n+---\n+---@param  name        string\n+---@param  value       string\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_setenv(name, value) end\n+\n+--- Sets the scheduling priority of the process specified by `pid`. The `priority`\n+--- range is between -20 (high priority) and 19 (low priority).\n+---\n+---@param  pid         integer\n+---@param  priority    integer\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_setpriority(pid, priority) end\n+\n+--- **Warning:** This function is not thread safe.\n+---\n+---@return string|nil tmpdir\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_tmpdir() end\n+\n+--- Returns system information.\n+---\n+---@return uv.os_uname.info\n+function uv.os_uname() end\n+\n+--- **Warning:** This function is not thread safe.\n+---\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.os_unsetenv() end\n+\n+--- Create a pair of connected pipe handles. Data may be written to the `write` fd and read from the `read` fd. The resulting handles can be passed to `pipe_open`, used with `spawn`, or for any other purpose.\n+---\n+--- Flags:\n+---  - `nonblock`: Opens the specified socket handle for `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is recommended for handles that will be used by libuv, and not usually recommended otherwise.\n+---\n+--- Equivalent to `pipe(2)` with the `O_CLOEXEC` flag set.\n+---\n+--- **Returns:** `table` or `fail`\n+--- - `read` : `integer` (file descriptor)\n+--- - `write` : `integer` (file descriptor)\n+---\n+--- ```lua\n+--- -- Simple read/write with pipe_open\n+--- local fds = uv.pipe({nonblock=true}, {nonblock=true})\n+---\n+--- local read_pipe = uv.new_pipe()\n+--- read_pipe:open(fds.read)\n+---\n+--- local write_pipe = uv.new_pipe()\n+--- write_pipe:open(fds.write)\n+---\n+--- write_pipe:write(\"hello\")\n+--- read_pipe:read_start(function(err, chunk)\n+---   assert(not err, err)\n+---   print(chunk)\n+--- end)\n+--- ```\n+---\n+---@param  read_flags      uv.pipe.read_flags\n+---@param  write_flags     uv.pipe.write_flags\n+---@return uv.pipe.fds|nil fds\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe(read_flags, write_flags) end\n+\n+--- Bind the pipe to a file path (Unix) or a name (Windows).\n+---\n+--- **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,\n+--- typically between 92 and 108 bytes.\n+---\n+---@param  pipe       uv.uv_pipe_t\n+---@param  name       string\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_bind(pipe, name) end\n+\n+--- Alters pipe permissions, allowing it to be accessed from processes run by different users.\n+--- Makes the pipe writable or readable by all users. `flags` are: `\"r\"`, `\"w\"`, `\"rw\"`, or `\"wr\"`\n+--- where `r` is `READABLE` and `w` is `WRITABLE`. This function is blocking.\n+---\n+---@param  pipe       uv.uv_pipe_t\n+---@param  flags      uv.pipe_chmod.flags\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_chmod(pipe, flags) end\n+\n+--- Connect to the Unix domain socket or the named pipe.\n+---\n+--- **Note**: Paths on Unix get truncated to sizeof(sockaddr_un.sun_path) bytes,\n+--- typically between 92 and 108 bytes.\n+---\n+---@param  pipe                uv.uv_pipe_t\n+---@param  name                string\n+---@param  callback?           uv.pipe_connect.callback\n+---@return uv.uv_connect_t|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_connect(pipe, name, callback) end\n+\n+--- Get the name of the Unix domain socket or the named pipe to which the handle is\n+--- connected.\n+---\n+---@param  pipe       uv.uv_pipe_t\n+---@return string|nil peername\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_getpeername(pipe) end\n+\n+--- Get the name of the Unix domain socket or the named pipe.\n+---\n+---@param  pipe       uv.uv_pipe_t\n+---@return string|nil sockname\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_getsockname(pipe) end\n+\n+--- Open an existing file descriptor or [`uv_handle_t`][] as a pipe.\n+---\n+--- **Note**: The file descriptor is set to non-blocking mode.\n+---\n+---@param  pipe       uv.uv_pipe_t\n+---@param  fd         integer\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.pipe_open(pipe, fd) end\n+\n+--- Returns the pending pipe count for the named pipe.\n+---\n+---@param pipe uv.uv_pipe_t\n+---@return integer\n+function uv.pipe_pending_count(pipe) end\n+\n+--- Set the number of pending pipe instance handles when the pipe server is waiting\n+--- for connections.\n+---\n+--- **Note**: This setting applies to Windows only.\n+---\n+---@param pipe uv.uv_pipe_t\n+---@param count integer\n+function uv.pipe_pending_instances(pipe, count) end\n+\n+--- Used to receive handles over IPC pipes.\n+---\n+--- First - call `uv.pipe_pending_count()`, if it's > 0 then initialize a handle of\n+--- the given type, returned by `uv.pipe_pending_type()` and call\n+--- `uv.accept(pipe, handle)`.\n+---\n+---@param pipe uv.uv_pipe_t\n+---@return string\n+function uv.pipe_pending_type(pipe) end\n+\n+--- Starts polling the file descriptor.\n+---\n+--- `events` are: `\"r\"`, `\"w\"`, `\"rw\"`, `\"d\"`,\n+--- `\"rd\"`, `\"wd\"`, `\"rwd\"`, `\"p\"`, `\"rp\"`, `\"wp\"`, `\"rwp\"`, `\"dp\"`, `\"rdp\"`,\n+--- `\"wdp\"`, or `\"rwdp\"` where `r` is `READABLE`, `w` is `WRITABLE`, `d` is\n+--- `DISCONNECT`, and `p` is `PRIORITIZED`. As soon as an event is detected\n+--- the callback will be called with status set to 0, and the detected events set on\n+--- the events field.\n+---\n+--- The user should not close the socket while the handle is active. If the user\n+--- does that anyway, the callback may be called reporting an error status, but this\n+--- is not guaranteed.\n+---\n+--- **Note** Calling `uv.poll_start()` on a handle that is already active is fine.\n+--- Doing so will update the events mask that is being watched for.\n+---\n+---@param  poll       uv.uv_poll_t\n+---@param  events     uv.poll.eventspec\n+---@param  callback   uv.poll_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.poll_start(poll, events, callback) end\n+\n+--- Stop polling the file descriptor, the callback will no longer be called.\n+---\n+---@param  poll       uv.uv_poll_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.poll_stop(poll) end\n+\n+--- Start the handle with the given callback.\n+---\n+---@param  prepare    uv.uv_prepare_t\n+---@param  callback   function\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.prepare_start(prepare, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---\n+---@param  prepare    uv.uv_prepare_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.prepare_stop(prepare) end\n+\n+--- The same as `uv.print_all_handles()` except only active handles are printed.\n+---\n+--- **Note:** This is not available on Windows.\n+---\n+--- **Warning:** This function is meant for ad hoc debugging, there are no API/ABI\n+--- stability guarantees.\n+function uv.print_active_handles() end\n+\n+--- Prints all handles associated with the main loop to stderr. The format is\n+--- `[flags] handle-type handle-address`. Flags are `R` for referenced, `A` for\n+--- active and `I` for internal.\n+---\n+--- **Note:** This is not available on Windows.\n+---\n+--- **Warning:** This function is meant for ad hoc debugging, there are no API/ABI\n+--- stability guarantees.\n+function uv.print_all_handles() end\n+\n+--- Returns the handle's pid.\n+---\n+---@param process uv.uv_process_t\n+---@return integer pid\n+function uv.process_get_pid(process) end\n+\n+--- Sends the specified signal to the given process handle. Check the documentation\n+--- on `uv_signal_t` for signal support, specially on Windows.\n+---\n+---@param  process    uv.uv_process_t\n+---@param  signum     integer|string\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.process_kill(process, signum) end\n+\n+--- Queues a work request which will run `work_callback` in a new Lua state in a\n+--- thread from the threadpool with any additional arguments from `...`. Values\n+--- returned from `work_callback` are passed to `after_work_callback`, which is\n+--- called in the main loop thread.\n+---\n+---@param  work_ctx    uv.luv_work_ctx_t\n+---@param  ...         uv.threadargs\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.queue_work(work_ctx, ...) end\n+\n+--- Fills a string of length `len` with cryptographically strong random bytes\n+--- acquired from the system CSPRNG. `flags` is reserved for future extension\n+--- and must currently be `nil` or `0` or `{}`.\n+---\n+--- Short reads are not possible. When less than `len` random bytes are available,\n+--- a non-zero error value is returned or passed to the callback. If the callback\n+--- is omitted, this function is completed synchronously.\n+---\n+--- The synchronous version may block indefinitely when not enough entropy is\n+--- available. The asynchronous version may not ever finish when the system is\n+--- low on entropy.\n+---\n+--- **Returns (sync version):** `string` or `fail`\n+---\n+--- **Returns (async version):** `0` or `fail`\n+---\n+---@param  len        integer\n+---@param  flags?     nil|0|{}\n+---@return string|nil bytes\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+---\n+---@overload fun(len:integer, flags?:nil, callback:uv.random.callback):0|nil, string?, string?\n+function uv.random(len, flags) end\n+\n+--- Read data from an incoming stream. The callback will be made several times until\n+--- there is no more data to read or `uv.read_stop()` is called. When we've reached\n+--- EOF, `data` will be `nil`.\n+---\n+--- ```lua\n+--- stream:read_start(function (err, chunk)\n+---   if err then\n+---     -- handle read error\n+---   elseif chunk then\n+---     -- handle data\n+---   else\n+---     -- handle disconnect\n+---   end\n+--- end)\n+--- ```\n+---\n+---@param  stream     uv.uv_stream_t\n+---@param  callback   uv.read_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.read_start(stream, callback) end\n+\n+--- Stop reading data from the stream. The read callback will no longer be called.\n+---\n+--- This function is idempotent and may be safely called on a stopped stream.\n+---\n+---@param  stream     uv.uv_stream_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.read_stop(stream) end\n+\n+--- Gets or sets the size of the receive buffer that the operating system uses for\n+--- the socket.\n+---\n+--- If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.\n+---\n+--- This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP\n+--- handles on Windows.\n+---\n+--- **Note**: Linux will set double the size and return double the size of the\n+--- original set value.\n+---\n+---@param  handle      uv.uv_handle_t\n+---@param  size?       integer  # default is `0`\n+---@return integer|nil size_or_ok\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.recv_buffer_size(handle, size) end\n+\n+--- Reference the given handle. References are idempotent, that is, if a handle is\n+--- already referenced calling this function again will have no effect.\n+---\n+--- See [Reference counting][].\n+---\n+---@param handle uv.uv_handle_t\n+function uv.ref(handle) end\n+\n+--- Returns the name of the struct for a given request (e.g. `\"fs\"` for `uv_fs_t`)\n+--- and the libuv enum integer for the request's type (`uv_req_type`).\n+---\n+---@param  req              uv.uv_req_t\n+---@return uv.req_type.name type\n+---@return uv.req_type.enum enum\n+function uv.req_get_type(req) end\n+\n+--- Returns the resident set size (RSS) for the current process.\n+---\n+---@return integer|nil rss\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.resident_set_memory() end\n+\n+--- This function runs the event loop. It will act differently depending on the\n+--- specified mode:\n+---\n+---   - `\"default\"`: Runs the event loop until there are no more active and\n+---   referenced handles or requests. Returns `true` if `uv.stop()` was called and\n+---   there are still active handles or requests. Returns `false` in all other\n+---   cases.\n+---\n+---   - `\"once\"`: Poll for I/O once. Note that this function blocks if there are no\n+---   pending callbacks. Returns `false` when done (no active handles or requests\n+---   left), or `true` if more callbacks are expected (meaning you should run the\n+---   event loop again sometime in the future).\n+---\n+---   - `\"nowait\"`: Poll for I/O once but don't block if there are no pending\n+---   callbacks. Returns `false` if done (no active handles or requests left),\n+---   or `true` if more callbacks are expected (meaning you should run the event\n+---   loop again sometime in the future).\n+---\n+--- **Note:** Luvit will implicitly call `uv.run()` after loading user code, but if\n+--- you use the luv bindings directly, you need to call this after registering\n+--- your initial set of event callbacks to start the event loop.\n+---\n+---@param mode? uv.run.mode\n+---@return boolean\n+function uv.run(mode) end\n+\n+--- Gets or sets the size of the send buffer that the operating system uses for the\n+--- socket.\n+---\n+--- If `size` is omitted (or `0`), this will return the current send buffer size; otherwise, this will use `size` to set the new send buffer size.\n+---\n+--- This function works for TCP, pipe and UDP handles on Unix and for TCP and UDP\n+--- handles on Windows.\n+---\n+--- **Returns:**\n+--- - `integer` or `fail` (if `size` is `nil` or `0`)\n+--- - `0` or `fail` (if `size` is not `nil` and not `0`)\n+---\n+--- **Note**: Linux will set double the size and return double the size of the\n+--- original set value.\n+---\n+---@param  handle               uv.uv_handle_t\n+---@param  size?                integer|0\n+---@return integer|nil          success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil    err_name\n+---\n+---@overload fun(handle: uv.uv_handle_t):(size:integer|nil, err:uv.error.message|nil, err_name:uv.error.name|nil)\n+---@overload fun(handle: uv.uv_handle_t, size:0):(size:integer|nil, err:uv.error.message|nil, err_name:uv.error.name|nil)\n+function uv.send_buffer_size(handle, size) end\n+\n+--- Sets the title of the current process with the string `title`.\n+---\n+---@param  title      string\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.set_process_title(title) end\n+\n+--- Sets the group ID of the process with the integer `id`.\n+---\n+--- **Note:** This is not a libuv function and is not supported on Windows.\n+---\n+---@param id integer\n+function uv.setgid(id) end\n+\n+--- Sets the user ID of the process with the integer `id`.\n+---\n+--- **Note:** This is not a libuv function and is not supported on Windows.\n+---\n+---@param id integer\n+function uv.setuid(id) end\n+\n+--- Shutdown the outgoing (write) side of a duplex stream. It waits for pending\n+--- write requests to complete. The callback is called after shutdown is complete.\n+---\n+---@param  stream               uv.uv_stream_t\n+---@param  callback?            uv.shutdown.callback\n+---@return uv.uv_shutdown_t|nil shutdown\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.shutdown(stream, callback) end\n+\n+--- Start the handle with the given callback, watching for the given signal.\n+---\n+---@param  signal     uv.uv_signal_t\n+---@param  signum     integer|string\n+---@param  callback   uv.signal_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.signal_start(signal, signum, callback) end\n+\n+--- Same functionality as `uv.signal_start()` but the signal handler is reset the moment the signal is received.\n+---\n+---@param  signal     uv.uv_signal_t\n+---@param  signum     integer|string\n+---@param  callback   uv.signal_start_oneshot.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.signal_start_oneshot(signal, signum, callback) end\n+\n+--- Stop the handle, the callback will no longer be called.\n+---@param  signal     uv.uv_signal_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.signal_stop(signal) end\n+\n+--- Pauses the thread in which this is called for a number of milliseconds.\n+---@param msec integer\n+function uv.sleep(msec) end\n+\n+--- Create a pair of connected sockets with the specified properties. The resulting handles can be passed to `uv.tcp_open`, used with `uv.spawn`, or for any other purpose.\n+---\n+--- When specified as a string, `socktype` must be one of `\"stream\"`, `\"dgram\"`, `\"raw\"`,\n+--- `\"rdm\"`, or `\"seqpacket\"`.\n+---\n+--- When `protocol` is set to 0 or nil, it will be automatically chosen based on the socket's domain and type. When `protocol` is specified as a string, it will be looked up using the `getprotobyname(3)` function (examples: `\"ip\"`, `\"icmp\"`, `\"tcp\"`, `\"udp\"`, etc).\n+---\n+--- Flags:\n+---  - `nonblock`: Opens the specified socket handle for `OVERLAPPED` or `FIONBIO`/`O_NONBLOCK` I/O usage. This is recommended for handles that will be used by libuv, and not usually recommended otherwise.\n+---\n+--- Equivalent to `socketpair(2)` with a domain of `AF_UNIX`.\n+---\n+--- **Returns:** `table` or `fail`\n+--- - `[1, 2]` : `integer` (file descriptor)\n+---\n+--- ```lua\n+--- -- Simple read/write with tcp\n+--- local fds = uv.socketpair(nil, nil, {nonblock=true}, {nonblock=true})\n+---\n+--- local sock1 = uv.new_tcp()\n+--- sock1:open(fds[1])\n+---\n+--- local sock2 = uv.new_tcp()\n+--- sock2:open(fds[2])\n+---\n+--- sock1:write(\"hello\")\n+--- sock2:read_start(function(err, chunk)\n+---   assert(not err, err)\n+---   print(chunk)\n+--- end)\n+--- ```\n+---\n+---@param  socktype?  uv.socketpair.socktype\n+---@param  protocol?  uv.socketpair.protocol\n+---@param  flags1?    uv.socketpair.flags\n+---@param  flags2?    uv.socketpair.flags\n+---@return uv.socketpair.fds|nil fds\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.socketpair(socktype, protocol, flags1, flags2) end\n+\n+--- Initializes the process handle and starts the process. If the process is\n+--- successfully spawned, this function will return the handle and pid of the child\n+--- process.\n+---\n+--- Possible reasons for failing to spawn would include (but not be limited to) the\n+--- file to execute not existing, not having permissions to use the setuid or setgid\n+--- specified, or not having enough memory to allocate for the new process.\n+---\n+--- ```lua\n+--- local stdin = uv.new_pipe()\n+--- local stdout = uv.new_pipe()\n+--- local stderr = uv.new_pipe()\n+---\n+--- print(\"stdin\", stdin)\n+--- print(\"stdout\", stdout)\n+--- print(\"stderr\", stderr)\n+---\n+--- local handle, pid = uv.spawn(\"cat\", {\n+---   stdio = {stdin, stdout, stderr}\n+--- }, function(code, signal) -- on exit\n+---   print(\"exit code\", code)\n+---   print(\"exit signal\", signal)\n+--- end)\n+---\n+--- print(\"process opened\", handle, pid)\n+---\n+--- uv.read_start(stdout, function(err, data)\n+---   assert(not err, err)\n+---   if data then\n+---     print(\"stdout chunk\", stdout, data)\n+---   else\n+---     print(\"stdout end\", stdout)\n+---   end\n+--- end)\n+---\n+--- uv.read_start(stderr, function(err, data)\n+---   assert(not err, err)\n+---   if data then\n+---     print(\"stderr chunk\", stderr, data)\n+---   else\n+---     print(\"stderr end\", stderr)\n+---   end\n+--- end)\n+---\n+--- uv.write(stdin, \"Hello World\")\n+---\n+--- uv.shutdown(stdin, function()\n+---   print(\"stdin shutdown\", stdin)\n+---   uv.close(handle, function()\n+---     print(\"process closed\", handle, pid)\n+---   end)\n+--- end)\n+--- ```\n+---\n+--- The `options` table accepts the following fields:\n+---\n+---   - `options.args` - Command line arguments as a list of string. The first\n+---   string should be the path to the program. On Windows, this uses CreateProcess\n+---   which concatenates the arguments into a string. This can cause some strange\n+---   errors. (See `options.verbatim` below for Windows.)\n+---   - `options.stdio` - Set the file descriptors that will be made available to\n+---   the child process. The convention is that the first entries are stdin, stdout,\n+---   and stderr. (**Note**: On Windows, file descriptors after the third are\n+---   available to the child process only if the child processes uses the MSVCRT\n+---   runtime.)\n+---   - `options.env` - Set environment variables for the new process.\n+---   - `options.cwd` - Set the current working directory for the sub-process.\n+---   - `options.uid` - Set the child process' user id.\n+---   - `options.gid` - Set the child process' group id.\n+---   - `options.verbatim` - If true, do not wrap any arguments in quotes, or\n+---   perform any other escaping, when converting the argument list into a command\n+---   line string. This option is only meaningful on Windows systems. On Unix it is\n+---   silently ignored.\n+---   - `options.detached` - If true, spawn the child process in a detached state -\n+---   this will make it a process group leader, and will effectively enable the\n+---   child to keep running after the parent exits. Note that the child process\n+---   will still keep the parent's event loop alive unless the parent process calls\n+---   `uv.unref()` on the child's process handle.\n+---   - `options.hide` - If true, hide the subprocess console window that would\n+---   normally be created. This option is only meaningful on Windows systems. On\n+---   Unix it is silently ignored.\n+---\n+--- The `options.stdio` entries can take many shapes.\n+---\n+---   - If they are numbers, then the child process inherits that same zero-indexed\n+---   fd from the parent process.\n+---   - If `uv_stream_t` handles are passed in, those are used as a read-write pipe\n+---   or inherited stream depending if the stream has a valid fd.\n+---   - Including `nil` placeholders means to ignore that fd in the child process.\n+---\n+--- When the child process exits, `on_exit` is called with an exit code and signal.\n+---\n+---@param  path            string\n+---@param  options         uv.spawn.options\n+---@param  on_exit         uv.spawn.on_exit\n+---@return uv.uv_process_t proc\n+---@return integer         pid\n+function uv.spawn(path, options, on_exit) end\n+\n+--- Stop the event loop, causing `uv.run()` to end as soon as possible. This\n+--- will happen not sooner than the next loop iteration. If this function was called\n+--- before blocking for I/O, the loop won't block for I/O on this iteration.\n+function uv.stop() end\n+\n+--- Returns the stream's write queue size.\n+---\n+---@param stream uv.uv_stream_t\n+---@return integer\n+function uv.stream_get_write_queue_size(stream) end\n+\n+--- Enable or disable blocking mode for a stream.\n+---\n+--- When blocking mode is enabled all writes complete synchronously. The interface\n+--- remains unchanged otherwise, e.g. completion or failure of the operation will\n+--- still be reported through a callback which is made asynchronously.\n+---\n+--- **Warning**: Relying too much on this API is not recommended. It is likely to\n+--- change significantly in the future. Currently this only works on Windows and\n+--- only for `uv_pipe_t` handles. Also libuv currently makes no ordering guarantee\n+--- when the blocking mode is changed after write requests have already been\n+--- submitted. Therefore it is recommended to set the blocking mode immediately\n+--- after opening or creating the stream.\n+---\n+---@param  stream     uv.uv_stream_t\n+---@param  blocking   boolean\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.stream_set_blocking(stream, blocking) end\n+\n+--- Bind the handle to an host and port. `host` should be an IP address and\n+--- not a domain name. Any `flags` are set with a table with field `ipv6only`\n+--- equal to `true` or `false`.\n+---\n+--- When the port is already taken, you can expect to see an `EADDRINUSE` error\n+--- from either `uv.tcp_bind()`, `uv.listen()` or `uv.tcp_connect()`. That is, a\n+--- successful call to this function does not guarantee that the call to `uv.listen()`\n+--- or `uv.tcp_connect()` will succeed as well.\n+---\n+--- Use a port of `0` to let the OS assign an ephemeral port.  You can look it up\n+--- later using `uv.tcp_getsockname()`.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  host       string\n+---@param  port       integer\n+---@param  flags?     uv.tcp_bind.flags\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_bind(tcp, host, port, flags) end\n+\n+--- Resets a TCP connection by sending a RST packet. This is accomplished by setting\n+--- the SO_LINGER socket option with a linger interval of zero and then calling\n+--- `uv.close()`. Due to some platform inconsistencies, mixing of `uv.shutdown()`\n+--- and `uv.tcp_close_reset()` calls is not allowed.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  callback?  function\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_close_reset(tcp, callback) end\n+\n+--- Establish an IPv4 or IPv6 TCP connection.\n+---\n+--- ```lua\n+--- local client = uv.new_tcp()\n+--- client:connect(\"127.0.0.1\", 8080, function (err)\n+---   -- check error and carry on.\n+--- end)\n+--- ```\n+---\n+---@param  tcp                 uv.uv_tcp_t\n+---@param  host                string\n+---@param  port                integer\n+---@param  callback            uv.tcp_connect.callback\n+---@return uv.uv_connect_t|nil conn\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_connect(tcp, host, port, callback) end\n+\n+--- Get the address of the peer connected to the handle.\n+---\n+---@param  tcp               uv.uv_tcp_t\n+---@return uv.socketinfo|nil sockname\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_getpeername(tcp) end\n+\n+--- Get the current address to which the handle is bound.\n+---\n+---@param  tcp               uv.uv_tcp_t\n+---@return uv.socketinfo|nil sockname\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_getsockname(tcp) end\n+\n+--- Enable / disable TCP keep-alive. `delay` is the initial delay in seconds,\n+--- ignored when enable is `false`.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  enable     boolean\n+---@param  delay?     integer\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_keepalive(tcp, enable, delay) end\n+\n+--- Enable / disable Nagle's algorithm.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  enable     boolean\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_nodelay(tcp, enable) end\n+\n+--- Open an existing file descriptor or SOCKET as a TCP handle.\n+---\n+--- **Note:** The passed file descriptor or SOCKET is not checked for its type, but it's required that it represents a valid stream socket.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  sock       integer\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_open(tcp, sock) end\n+\n+--- Enable / disable simultaneous asynchronous accept requests that are queued by\n+--- the operating system when listening for new TCP connections.\n+---\n+--- This setting is used to tune a TCP server for the desired performance. Having\n+--- simultaneous accepts can significantly improve the rate of accepting connections\n+--- (which is why it is enabled by default) but may lead to uneven load distribution\n+--- in multi-process setups.\n+---\n+---@param  tcp        uv.uv_tcp_t\n+---@param  enable     boolean\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tcp_simultaneous_accepts(tcp, enable) end\n+\n+--- **Deprecated:** Please use `uv.stream_get_write_queue_size()` instead.\n+---\n+---@param tcp uv.uv_tcp_t\n+function uv.tcp_write_queue_size(tcp) end\n+\n+--- Returns a boolean indicating whether two threads are the same. This function is\n+--- equivalent to the `__eq` metamethod.\n+---\n+---@param  thread       uv.luv_thread_t\n+---@param  other_thread uv.luv_thread_t\n+---@return boolean      equal\n+function uv.thread_equal(thread, other_thread) end\n+\n+--- Waits for the `thread` to finish executing its entry function.\n+---\n+---@param  thread      uv.luv_thread_t\n+---@return boolean|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.thread_join(thread) end\n+\n+--- Returns the handle for the thread in which this is called.\n+---\n+---@return uv.luv_thread_t\n+function uv.thread_self() end\n+\n+--- Stop the timer, and if it is repeating restart it using the repeat value as the\n+--- timeout. If the timer has never been started before it raises `EINVAL`.\n+---\n+---@param  timer      uv.uv_timer_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.timer_again(timer) end\n+\n+--- Get the timer due value or 0 if it has expired. The time is relative to `uv.now()`.\n+---\n+--- **Note**: New in libuv version 1.40.0.\n+---\n+---@param timer uv.uv_timer_t\n+---@return integer\n+function uv.timer_get_due_in(timer) end\n+\n+--- Get the timer repeat value.\n+---\n+---@param timer uv.uv_timer_t\n+---@return integer\n+function uv.timer_get_repeat(timer) end\n+\n+--- Set the repeat interval value in milliseconds. The timer will be scheduled to\n+--- run on the given interval, regardless of the callback execution duration, and\n+--- will follow normal timer semantics in the case of a time-slice overrun.\n+---\n+--- For example, if a 50 ms repeating timer first runs for 17 ms, it will be\n+--- scheduled to run again 33 ms later. If other tasks consume more than the 33 ms\n+--- following the first timer callback, then the callback will run as soon as\n+--- possible.\n+---\n+---@param timer uv.uv_timer_t\n+---@param repeat_ integer\n+function uv.timer_set_repeat(timer, repeat_) end\n+\n+--- Start the timer. `timeout` and `repeat` are in milliseconds.\n+---\n+--- If `timeout` is zero, the callback fires on the next event loop iteration. If\n+--- `repeat` is non-zero, the callback fires first after `timeout` milliseconds and\n+--- then repeatedly after `repeat` milliseconds.\n+---\n+---@param  timer      uv.uv_timer_t\n+---@param  timeout    integer\n+---@param  repeat_    integer\n+---@param  callback   function\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.timer_start(timer, timeout, repeat_, callback) end\n+\n+--- Stop the timer, the callback will not be called anymore.\n+---\n+---@param  timer      uv.uv_timer_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.timer_stop(timer) end\n+\n+--- Returns the libuv error message and error name (both in string form, see [`err` and `name` in Error Handling](#error-handling)) equivalent to the given platform dependent error code: POSIX error codes on Unix (the ones stored in errno), and Win32 error codes on Windows (those returned by GetLastError() or WSAGetLastError()).\n+---\n+---@param errcode integer\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.translate_sys_error(errcode) end\n+\n+--- Same as `uv.write()`, but won't queue a write request if it can't be completed\n+--- immediately.\n+---\n+--- Will return number of bytes written (can be less than the supplied buffer size).\n+---\n+---@param  stream      uv.uv_stream_t\n+---@param  data        uv.buffer\n+---@return integer|nil bytes\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.try_write(stream, data) end\n+\n+--- Like `uv.write2()`, but with the properties of `uv.try_write()`. Not supported on Windows, where it returns `UV_EAGAIN`.\n+---\n+--- Will return number of bytes written (can be less than the supplied buffer size).\n+---\n+--- **Returns:** `integer` or `fail`\n+---\n+---@param  stream      uv.uv_stream_t\n+---@param  data        uv.buffer\n+---@param  send_handle uv.uv_stream_t\n+---@return integer|nil bytes\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.try_write2(stream, data, send_handle) end\n+\n+--- Get the current state of whether console virtual terminal sequences are handled\n+--- by libuv or the console. The return value is `\"supported\"` or `\"unsupported\"`.\n+---\n+--- This function is not implemented on Unix, where it returns `ENOTSUP`.\n+---\n+---@return \"supported\"|\"unsupported\"|nil state\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tty_get_vterm_state() end\n+\n+--- Gets the current Window width and height.\n+---\n+--- **Returns:** `integer, integer` or `fail`\n+---\n+---@param  tty            uv.uv_tty_t\n+---@return integer|nil    width\n+---@return integer|string height_or_errmsg\n+---@return uv.error.name|nil err_name\n+function uv.tty_get_winsize(tty) end\n+\n+--- To be called when the program exits. Resets TTY settings to default values for\n+--- the next process to take over.\n+---\n+--- This function is async signal-safe on Unix platforms but can fail with error\n+--- code `EBUSY` if you call it when execution is inside `uv.tty_set_mode()`.\n+---\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tty_reset_mode() end\n+\n+--- Set the TTY using the specified terminal mode.\n+---\n+--- Parameter `mode` is a C enum with the following values:\n+---\n+---   - 0 - UV_TTY_MODE_NORMAL: Initial/normal terminal mode\n+---   - 1 - UV_TTY_MODE_RAW: Raw input mode (On Windows, ENABLE_WINDOW_INPUT is\n+---   also enabled)\n+---   - 2 - UV_TTY_MODE_IO: Binary-safe I/O mode for IPC (Unix-only)\n+---\n+---@param  tty        uv.uv_tty_t\n+---@param  mode       uv.tty.mode\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.tty_set_mode(tty, mode) end\n+\n+--- Controls whether console virtual terminal sequences are processed by libuv or\n+--- console. Useful in particular for enabling ConEmu support of ANSI X3.64 and\n+--- Xterm 256 colors. Otherwise Windows10 consoles are usually detected\n+--- automatically. State should be one of: `\"supported\"` or `\"unsupported\"`.\n+---\n+--- This function is only meaningful on Windows systems. On Unix it is silently\n+--- ignored.\n+---\n+---@param state \"supported\"|\"unsupported\"\n+function uv.tty_set_vterm_state(state) end\n+\n+--- Bind the UDP handle to an IP address and port. Any `flags` are set with a table\n+--- with fields `reuseaddr` or `ipv6only` equal to `true` or `false`.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  host       string\n+---@param  port       integer\n+---@param  flags?     uv.udp_bind.flags\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_bind(udp, host, port, flags) end\n+\n+--- Associate the UDP handle to a remote address and port, so every message sent by\n+--- this handle is automatically sent to that destination. Calling this function\n+--- with a NULL addr disconnects the handle. Trying to call `uv.udp_connect()` on an\n+--- already connected handle will result in an `EISCONN` error. Trying to disconnect\n+--- a handle that is not connected will return an `ENOTCONN` error.\n+---\n+---@param udp uv.uv_udp_t\n+---@param host string\n+---@param port integer\n+---@return 0|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_connect(udp, host, port) end\n+\n+--- Returns the handle's send queue count.\n+---\n+---@param  udp     uv.uv_udp_t\n+---@return integer count\n+function uv.udp_get_send_queue_count(udp) end\n+\n+--- Returns the handle's send queue size.\n+---\n+---@param  udp     uv.uv_udp_t\n+---@return integer size\n+function uv.udp_get_send_queue_size(udp) end\n+\n+--- Get the remote IP and port of the UDP handle on connected UDP handles.\n+---\n+---@param  udp                 uv.uv_udp_t\n+---@return uv.udp.sockname|nil peername\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_getpeername(udp) end\n+\n+--- Get the local IP and port of the UDP handle.\n+---\n+---@param  udp                 uv.uv_udp_t\n+---@return uv.udp.sockname|nil sockname\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_getsockname(udp) end\n+\n+--- Opens an existing file descriptor or Windows SOCKET as a UDP handle.\n+---\n+--- Unix only: The only requirement of the sock argument is that it follows the\n+--- datagram contract (works in unconnected mode, supports sendmsg()/recvmsg(),\n+--- etc). In other words, other datagram-type sockets like raw sockets or netlink\n+--- sockets can also be passed to this function.\n+---\n+--- The file descriptor is set to non-blocking mode.\n+---\n+--- Note: The passed file descriptor or SOCKET is not checked for its type, but\n+--- it's required that it represents a valid datagram socket.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  fd         integer\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_open(udp, fd) end\n+\n+--- Prepare for receiving data. If the socket has not previously been bound with\n+--- `uv.udp_bind()` it is bound to `0.0.0.0` (the \"all interfaces\" IPv4 address)\n+--- and a random port number.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  callback   uv.udp_recv_start.callback\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_recv_start(udp, callback) end\n+\n+--- Stop listening for incoming datagrams.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_recv_stop(udp) end\n+\n+--- Send data over the UDP socket. If the socket has not previously been bound\n+--- with `uv.udp_bind()` it will be bound to `0.0.0.0` (the \"all interfaces\" IPv4\n+--- address) and a random port number.\n+---\n+---@param  udp                  uv.uv_udp_t\n+---@param  data                 uv.buffer\n+---@param  host                 string\n+---@param  port                 integer\n+---@param  callback             uv.udp_send.callback\n+---@return uv.uv_udp_send_t|nil success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_send(udp, data, host, port, callback) end\n+\n+--- Set broadcast on or off.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  on         boolean\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_broadcast(udp, on) end\n+\n+--- Set membership for a multicast address. `multicast_addr` is multicast address to\n+--- set membership for. `interface_addr` is interface address. `membership` can be\n+--- the string `\"leave\"` or `\"join\"`.\n+---\n+---@param  udp            uv.uv_udp_t\n+---@param  multicast_addr string\n+---@param  interface_addr string\n+---@param  membership     \"leave\"|\"join\"\n+---@return 0|nil          success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_membership(udp, multicast_addr, interface_addr, membership) end\n+\n+--- Set the multicast interface to send or receive data on.\n+---\n+---@param  udp            uv.uv_udp_t\n+---@param  interface_addr string\n+---@return 0|nil          success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_multicast_interface(udp, interface_addr) end\n+\n+--- Set IP multicast loop flag. Makes multicast packets loop back to local\n+--- sockets.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  on         boolean\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_multicast_loop(udp, on) end\n+\n+--- Set the multicast ttl.\n+---\n+--- `ttl` is an integer 1 through 255.\n+---\n+---@param  udp        uv.uv_udp_t\n+---@param  ttl        integer\n+---@return 0|nil      success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_multicast_ttl(udp, ttl) end\n+\n+--- Set membership for a source-specific multicast group. `multicast_addr` is multicast\n+--- address to set membership for. `interface_addr` is interface address. `source_addr`\n+--- is source address. `membership` can be the string `\"leave\"` or `\"join\"`.\n+---\n+---@param  udp            uv.uv_udp_t\n+---@param  multicast_addr string\n+---@param  interface_addr string|nil\n+---@param  source_addr    string\n+---@param  membership     \"leave\"|\"join\"\n+---@return 0|nil          success\n+---@return uv.error.message|nil err\n+---@return uv.error.name|nil err_name\n+function uv.udp_set_source_membership(\n+  udp,\n+  multicast_addr,\n+  interface_addr,\n+  source_addr,\n+  membership\n+)",
            "html_url": "https://github.com/neovim/neovim/pull/33375#discussion_r2031699703",
            "id": 2031699703,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM55GUb3",
            "original_commit_id": "f76df91095647d48597cb691516debfabdb4c81d",
            "original_line": 2688,
            "original_position": 2688,
            "original_start_line": 2682,
            "path": "runtime/lua/vim/uv/_meta/uv.lua",
            "position": null,
            "pull_request_review_id": 2747583304,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/33375",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2031699703/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-07T17:33:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2031699703",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Also, can we get rid of luacheck already? 🥺 ",
            "created_at": "2025-04-07T17:38:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/33375#issuecomment-2784099327",
            "id": 2784099327,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/33375",
            "node_id": "IC_kwDOAPphoM6l8fv_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2784099327/reactions"
            },
            "updated_at": "2025-04-07T17:38:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2784099327",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/33375/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/33375/commits",
    "created_at": "2025-04-07T17:06:53Z",
    "diff_url": "https://github.com/neovim/neovim/pull/33375.diff",
    "draft": false,
    "head": {
        "label": "clason:meta-luv",
        "ref": "meta-luv",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/clason/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/clason/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/clason/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/clason/neovim/branches{/branch}",
            "clone_url": "https://github.com/clason/neovim.git",
            "collaborators_url": "https://api.github.com/repos/clason/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/clason/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/clason/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/clason/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/clason/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/clason/neovim/contributors",
            "created_at": "2022-06-19T14:32:07Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/clason/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/clason/neovim/downloads",
            "events_url": "https://api.github.com/repos/clason/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/clason/neovim/forks",
            "full_name": "clason/neovim",
            "git_commits_url": "https://api.github.com/repos/clason/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/clason/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/clason/neovim/git/tags{/sha}",
            "git_url": "git://github.com/clason/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/clason/neovim/hooks",
            "html_url": "https://github.com/clason/neovim",
            "id": 505133677,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/clason/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/clason/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/clason/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/clason/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/clason/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/clason/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/clason/neovim/merges",
            "milestones_url": "https://api.github.com/repos/clason/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOHhu6bQ",
            "notifications_url": "https://api.github.com/repos/clason/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/clason/neovim/pulls{/number}",
            "pushed_at": "2025-04-07T18:00:20Z",
            "releases_url": "https://api.github.com/repos/clason/neovim/releases{/id}",
            "size": 309572,
            "ssh_url": "git@github.com:clason/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/clason/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/clason/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/clason/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/clason/neovim/subscription",
            "svn_url": "https://github.com/clason/neovim",
            "tags_url": "https://api.github.com/repos/clason/neovim/tags",
            "teams_url": "https://api.github.com/repos/clason/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/clason/neovim/git/trees{/sha}",
            "updated_at": "2025-02-18T16:51:16Z",
            "url": "https://api.github.com/repos/clason/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "509692b704270d98016884043be882ce3e93c036",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
            "events_url": "https://api.github.com/users/clason/events{/privacy}",
            "followers_url": "https://api.github.com/users/clason/followers",
            "following_url": "https://api.github.com/users/clason/following{/other_user}",
            "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/clason",
            "id": 2361214,
            "login": "clason",
            "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
            "organizations_url": "https://api.github.com/users/clason/orgs",
            "received_events_url": "https://api.github.com/users/clason/received_events",
            "repos_url": "https://api.github.com/users/clason/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/clason",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/33375",
    "id": 2443878471,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/33375",
    "labels": [],
    "locked": false,
    "merge_commit_sha": "15609bf28c0602419f2b4439f764016c8c7612f7",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6RqqBH",
    "number": 33375,
    "patch_url": "https://github.com/neovim/neovim/pull/33375.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/33375/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/509692b704270d98016884043be882ce3e93c036",
    "title": "feat(meta): vendor luv meta files",
    "updated_at": "2025-04-07T18:00:21Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/33375",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
        "events_url": "https://api.github.com/users/clason/events{/privacy}",
        "followers_url": "https://api.github.com/users/clason/followers",
        "following_url": "https://api.github.com/users/clason/following{/other_user}",
        "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/clason",
        "id": 2361214,
        "login": "clason",
        "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
        "organizations_url": "https://api.github.com/users/clason/orgs",
        "received_events_url": "https://api.github.com/users/clason/received_events",
        "repos_url": "https://api.github.com/users/clason/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/clason",
        "user_view_type": "public"
    }
}