{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34009/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/34009"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34009"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/d21b8c949ad7213b372486b45225f691934d6a6d"
        }
    },
    "active_lock_reason": "resolved",
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6168,
            "forks_count": 6168,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1965,
            "open_issues_count": 1965,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-07-08T01:56:22Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 332418,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 90922,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-07-08T02:01:52Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 90922,
            "watchers_count": 90922,
            "web_commit_signoff_required": false
        },
        "sha": "3694fcec286763d21e30eb3f479aea4fe6d8d873",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "This PR adds a minimal built-in plugin manager `vim.pack`. This is a first step towards resolving #20893. A general design is a minimized (496 LOC for core functionality when PR is opened) and reworked ['mini.deps'](https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-deps.md) plugin. There is a first-pass documentation mostly aimed for reviewers and no tests yet (as it is an open question about how to do that reasonably).\r\n\r\nHere is a demo of common workflows at the latest PR state:\r\n\r\nhttps://github.com/user-attachments/assets/9b6c52ed-f8c4-4a2f-8656-6c9eddd338f2\r\n\r\n<details><summary>Demo of initial PR state (for history)</summary>\r\n\r\nhttps://github.com/user-attachments/assets/f99c8adf-c01d-4dfe-86a5-95d8e4cbc1b4\r\n\r\nTop right window comes from 'mini.notify' plugin; that is not part of `vim.pack`:\r\n\r\nTimestamps:\r\n- 00:00 - initial \"clean\" run (i.e. just like after installing Neovim and adding 'init.lua' that is shown in demo).\r\n- 00:10 - install new plugin (add line and restart).\r\n- 00:28 - updating existing plugins (simulate new upstream changes, run `vim.pack.update()`, review, confirm).\r\n- 01:10 - change version of existing plugin (update 'init.lua', restart, run `vim.pack.update()` with `{ offline = true }` to skip downloading new changes, review, confirm).\r\n\r\n</details>\r\n\r\n---\r\n\r\nGeneral notes about design decisions:\r\n\r\n<details><summary>Design decisions notes</summary>\r\n\r\n- Plugin spec is designed to be minimal yet versatile with an eye for future automated packspec support, i.e. plugins themselves containing a special 'pkg.json' file which should contain at least the following information:\r\n    - Dependencies: repo urls and versions. If plugin doesn't support packspec, user can register dependencies manually by explicitly adding them to `vim.pack.add()`.\r\n    - Hooks: paths to scripts to be executed before/after install/update. Without them user can register hooks by creating autocommand for dedicated events. Note: custom events are generally better than hooks because they can be used by plugins to tweak install/update behavior of *other* plugins. Plus smaller `vim.pack.Spec`.\r\n\r\n- Showing \"interactive\" confirmation buffer might be considered too much, but being able to review updates before approving them is a huge QoL improvement. Right now it also includes in-process LSP server to show structure via `vim.lsp.buf.document_symbol()` (or with default `gO`). The whole LSP approach might be an overkill, but:\r\n    - It works nicely with plugin ecosystem around LSP lifting the burden of having to create dedicated conventions for `vim.pack`. Most useful mappings are already built-in.\r\n    - Can serve as a reference implementation of an in-process LSP server (which is a decided way forward for several built-in things, like custom `vim.lsp.completion` sources and code actions).\r\n    - It reinforces the \"LSP out of the box\" approach.\r\n\r\n  There are more LSP-based interactive features planned (see next section).\r\n\r\n</details>\r\n\r\n---\r\n\r\nLeft out from this PR but planned after discussions and executive decisions:\r\n\r\n<details><summary>Planned future work</summary>\r\n\r\n- ~~**\"Scripting way\" to remove installed plugins from disk**. I do have plans to support \"delete plugin\" code action from inside confirmation buffer, but it needs green light. The \"scripting way\" can be designed in several ways:~~\r\n    - ~~A `vim.pack.remove()` - simple wrapper around `vim.fn.delete()`. Might also trigger dedicated events.~~\r\n    - ~~A `vim.pack.clean()` - delete plugins that are not added to current session. Without interactive confirmation, this can become tricky for configs which will lazy load plugins on events/ModeChanged/etc.~~\r\n    - ~~Do nothing and suggest using `vim.fn.delete()` directly with (possibly exported) path to a special plugin's directory. This is meant as minimal plugin manager, after all.~~\r\n\r\n    After relevant discussions ([this](https://github.com/neovim/neovim/pull/34009#discussion_r2094172936) and [this](https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306)), there is a `vim.pack.del()` present in this PR.\r\n\r\n- **User commands**. Like `:Pack add` or `:PackAdd`. The latter is more natural when it comes to `!` and easier to implement completion.\r\n\r\n- **Allowing \"local plugins\"** (as \"unmanaged plugins\" in 'vim-plug'). This can be skipped entirely in favor of suggesting putting those plugins in custom 'pack/mine/opt' package and use `:packadd`. But initial Matrix discussions showed interest in having this supported.\r\n\r\n    As far as I can tell, they don't quite fit into the current design: they usually don't require automated installation or update. They require manual handling during `add` (explicit source of 'plugin/' and 'after/plugin/') and book keeping to ignore it during `update()`. Doable, but requires executive decision and extra effort/code.\r\n\r\n- **Consider adding `vim.pack.config()`**. It will configure how `vim.pack` operates. Possible options:\r\n    - `job_threads` - how many threads can parallel steps (like \"install\" and \"download updates\") use. Current and default value - 80% of all available threads.\r\n    - `job_timeout` - amount of time to wait until force stopping any job. Current and default value - 30 seconds.\r\n    - `default_version` - default `version` to use in `vim.pack.Spec`. It can be used to have \"install latest available version\" by default with `vim.version.range('*')` value. Current and default value - `nil` to infer the default repo branch.\r\n\r\n- **Consider moving documentation to a dedicated `pack.txt`**. Maybe also move the `:help packages` section in there.\r\n\r\n- **Consider re-introducing dedicated highlight groups for 'nvim-pack' confirmation report**.  Needs discussing the scope of highlighting groups and the best place to define them.\r\n\r\n- **Consider making `vim.pack.add()` more flexible**. Either via flags/enums on `vim.pack.add()` level or as part of per-plugin spec. Some common requested use cases:\r\n    - Allow skipping automated installation of not presently installed plugins in favor of doing that manually later.\r\n    - Allow skipping `:packadd` (even `:packadd!`) to only ensure that all plugins are installed in favor of manually loading them later. One way to do it is to allow `load` as function that accepts a single resolved plugin spec and is responsible for loading into current session.\r\n    - Allow skipping installation confirmation.\r\n\r\n- **More interactive update features**:\r\n    - Code lenses/actions \"update this plugin\", \"skip updating this plugin\", maybe \"delete\" this plugin.\r\n\r\n- **Make progress update user-customizable**. Either after `vim.ui.progress` (#32537) is a thing or there is a built-in `$/progress` handler that actually shows progress (#34254, #28809)..\r\n\r\n- **Discuss and enforce order of event triggering**. Right now due to totally async install/update/checkout there is no guaranteed order of `Pack{Install,Update}{Pre,}` events across *different* plugins. This might lead to conflicts when callback of some plugin event relies on features from dependency plugin. As there is no guaranteed order, callback for \"main\" plugin can trigger before installing/updating \"dependency\" plugin. The installation order can be enforced by separate `vim.pack.add()` calls, but update/checkout can not.\r\n\r\n    One approach can be to guarantee processing necessary steps in order that plugins are `:packadd`ed. This is currently done for `vim.pack.del()` and its events.\r\n\r\n    See more discussions [here](https://github.com/echasnovski/neovim/pull/3#discussion_r2135577470).\r\n\r\n- **Lockfile support**. Basically, store state/commit per source and prefer it *only during initial install* over resolving `version`. Will help with reproducible setups.\r\n\r\n    It (or its \"private\" alternative) can also contain an information about `version` to be used during `update()` if the plugin was not (yet) added to current session. In theory, this can also be used to detect if the user has changed plugin's `version` in an attempt to switch version/branch and automatically do so during startup (without having to do an extra `vim.pack.update()` call). One thing why this might not be good is that it breaks the separation of \"`add()` is for installing and loading plugins\" and \"`update()` is for updating already installed plugins\".\r\n\r\n- **More straightforward plugin freeze/pin/lock**. Originally this PR proposed a special value of `version` (`'HEAD'` string or `false` boolean) to be treated as \"freeze the installed plugin from updates\". It was decided to postpone the decision about the better \"freeze\" approach until there is a lockfile support. See [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2096143432) for details.\r\n\r\n- **More straightforward `version` change of already installed plugin**. Currently it requires extra step of `vim.pack.update()` (which needs internet connection) to \"sync\" plugin on disk with to have proper `version`. After there is lockfile support, an alternative approach would be to have \"`add()` ensures both presence and correct on disk spec (like `source` and `version`)\" and \"`update()` is only for downloading and applying changes from source\". This simplifies the \"change version\" step at the cost of not being able to see beforehand and confirm/deny which changes will be applied. They would still be present in the log file for inspection, though. Relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094170341).\r\n\r\n- **`:checkhealth` support**. It can include suggestions like \"the latest tag of this plugin is very far behind default branch; consider setting version = 'master'\".\r\n\r\n- **Packspec support**. It is rather big and needs discussions about the degree of support vs complexity.\r\n\r\n</details>\r\n\r\n---\r\n\r\nNot planned as `vim.pack` functionality:\r\n\r\n<details><summary>Not planned</summary>\r\n\r\n- Manage plugins from 'start/' directory. As `vim.pack.add()` only installs in 'opt/' directory (as it is all that is needed), it seems unnecessary to also manage 'start/' from the same package path. Plus it is known to cause confusion about how to not load its plugins.\r\n- Lazy loading out of the box. This can be done like in 'mini.deps': via `now()` and `later()` functions. They *safely* execute its input function immediately and \"soon\" while reporting errors only after all those functions are finished. These are general enough to live outside of `vim.pack` and should be useful to have in `vim.func`.\r\n\r\n</details>",
    "closed_at": "2025-07-04T13:32:55Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087290998"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998"
                }
            },
            "author_association": "MEMBER",
            "body": "Notes about spec:\r\n- Maybe naming of both `source` and `version` might be improved. Maybe `url`/`uri` and `follow`/`target`/`checkout`? The current ones are general enough for possible leeway in the future.\r\n- ~~Is using \"FREEZE\" instead of \"HEAD\" a better choice (as it is less Git-specific; suggested [here](https://github.com/neovim/neovim/pull/34009#discussion_r20876143530))? If `version->checkout` is renamed, then using \"HEAD\" should be fine.~~ ~~After [this discussion](https://github.com/neovim/neovim/pull/34009#discussion_r2094172722), `version = false` now means freezing from updates.~~ The decision about better approach to freezing plugin is postponed until after lockfile support (see [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2096143432) for details).\r\n- Allowing version to be explicit `vim.VersionRange` is needed to avoid conflicts with branch names that look similar to version range (\"1.0\", \"v1.0.0\", \"0-x\", \"tmux 3.2a\", etc.). If that is not a concern, then only allowing string `version` with trying to parsing it as version range is doable.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:11:27Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087290998",
            "id": 2087290998,
            "line": 220,
            "node_id": "PRRC_kwDOAPphoM58aYh2",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 220,
            "original_position": 197,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 220,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-19T17:01:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294117"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117"
                }
            },
            "author_association": "MEMBER",
            "body": "How much \"magic\" for inferring `source` and `name` should be allowed? Right now `source` should be set explicitly as URI. Possible improvements:\r\n- Allow setting source as `[1]` key to avoid explicitly setting `source` as key?\r\n- Allow `string|vim.pack.Spec` directly and not inside list?\r\n- Allow setting source (wherever it is possible) as \"user/repo\" and infer it as \"https://github.com/user/repo\". Can be behind `vim.pack.config()` as `format_source`?\r\n\r\nAlso, should `name` be cleaned as well? Like stripping '.git' suffix, etc.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:13:34Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294117",
            "id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aZSl",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294852"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852"
                }
            },
            "author_association": "MEMBER",
            "body": "Consider making it configurable, like via `vim.pack.config()`?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:14:06Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294852",
            "id": 2087294852,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aZeE",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 335,
            "original_position": 293,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087296122"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122"
                }
            },
            "author_association": "MEMBER",
            "body": "Showing progress report might wait for `vim.ui.progress()`, but as this can already be done with in-process LSP server (which is useful for interactive confirm), seems okay to add. Even if later during 0.12 cycle replaced with `vim.ui.progress`.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:14:59Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087296122",
            "id": 2087296122,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aZx6",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 380,
            "original_position": 380,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087298163"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163"
                }
            },
            "author_association": "MEMBER",
            "body": "This will only not add plugins that did not install to disk. Plugin can still be installed but not in correct version after installation (like if target doesn't exist), which will be shown as error during initial install and error during update.\r\n\r\nThis decision is mostly due to the fact that this plugin would still load after restart (as there is no check if the version is correct; for performance).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:15:57Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    -- Allow 'HEAD' to mean 'HEAD' (freeze current state from updates)\n+    if version == 'HEAD' then\n+      p.info.version_str = 'HEAD'\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    if not is_version_range(version) then\n+      --- @cast version string\n+      local branches = git_get_branches(p.plug.path)\n+      p.info.version_str = version\n+      p.info.version_ref = (vim.tbl_contains(branches, version) and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag = nil\n+    for _, tag in ipairs(git_get_tags(p.plug.path)) do\n+      local ver_tag = vim.version.parse(tag)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No tags matching version range. Consider increasing it or switch to branch.'\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      notify(msg, 'ERROR')\n+    end\n+  end\n+end\n+\n+--- Keep this as map and not array for faster checks during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory and update state to match `version`.\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| (possibly with `{ offline = true }`) to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  -- TODO(echasnovski): Normalize all plugins as a whole, mostly process\n+  -- duplicates. This has little benefit now, but will be more sore after\n+  -- packspec processing (as it might introduce conflicting dependencies).\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087298163",
            "id": 2087298163,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aaRz",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 752,
            "original_position": 663,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087299188"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188"
                }
            },
            "author_association": "MEMBER",
            "body": "Module name is `vim.pack`, but using 'vimpack' as file/filetype name feels wrong (as it doesn't use 'nvim'). So it is 'nvimpack' for now.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:16:27Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    -- Allow 'HEAD' to mean 'HEAD' (freeze current state from updates)\n+    if version == 'HEAD' then\n+      p.info.version_str = 'HEAD'\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    if not is_version_range(version) then\n+      --- @cast version string\n+      local branches = git_get_branches(p.plug.path)\n+      p.info.version_str = version\n+      p.info.version_ref = (vim.tbl_contains(branches, version) and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag = nil\n+    for _, tag in ipairs(git_get_tags(p.plug.path)) do\n+      local ver_tag = vim.version.parse(tag)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No tags matching version range. Consider increasing it or switch to branch.'\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      notify(msg, 'ERROR')\n+    end\n+  end\n+end\n+\n+--- Keep this as map and not array for faster checks during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory and update state to match `version`.\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| (possibly with `{ offline = true }`) to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  -- TODO(echasnovski): Normalize all plugins as a whole, mostly process\n+  -- duplicates. This has little benefit now, but will be more sore after\n+  -- packspec processing (as it might introduce conflicting dependencies).\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    table.insert(parts, 'Path:   ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source: ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State:  ' .. p.info.sha_target .. ' (' .. p.info.version_str .. ')')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      table.insert(parts, '\\n\\nAvailable newer tags:\\n• ' .. details)\n+    end\n+  else\n+    table.insert(parts, 'Path:         ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source:       ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State before: ' .. p.info.sha_head .. '\\n')\n+    table.insert(parts, 'State after:  ' .. p.info.sha_target .. ' (' .. p.info.version_str .. ')')\n+\n+    table.insert(parts, '\\n\\nPending updates:\\n' .. p.info.update_details)\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = string.format('========== Update %s ==========', get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+local function show_confirm_buf(lines, opts)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num, win_id = api.nvim_tabpage_get_number(0), api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    opts.exec_on_write(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified, vim.bo[bufnr].modifiable = false, false\n+  vim.bo[bufnr].buftype, vim.bo[bufnr].filetype = 'acwrite', 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087299188",
            "id": 2087299188,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aah0",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 873,
            "original_position": 782,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087330410"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410"
                }
            },
            "author_association": "MEMBER",
            "body": "This should be added to checkhealth then (same as `rg`).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T17:31:13Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087330410",
            "id": 2087330410,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aiJq",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2522,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2837613109,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:31:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087579420"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> as \"user/repo\" and infer it as \"https://github.com/user/repo\"\r\n\r\nMy two cents on this: While the vast majority of plugins are on github, I'm not so much a fan of the current convention of github favouritism without providing shorthands for other hosts.\r\nI'd personally prefer `<host>:<owner>/<repo>`, which would result in shorthands like `github:user/repo`, `gitlab:user/repo`, `sourcehut:user/repo`, `codeberg:user/repo`, and so on.\r\nWith support for some other hosts, having `user/repo` default to github for user convenience doesn't feel quite as \"evil\" :sweat_smile:\r\nIf shorthand support for multiple hosts is \"too much magic\", then my vote would be for no shorthand support at all.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T20:26:52Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087579420",
            "id": 2087579420,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58be8c",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 16,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 16,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087585745"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "question: This has to be a git source URL, right?\r\nIf so, I'd suggest to clarify that in the docs, so people know they can't specify things like source archive URLs.\r\nPerhaps it would also be good to document (un)supported formats (`ssh://`, `https://` `git+ssh://` `git+https://`, `git+file://`, `.git` suffix, ...), if there are any limitations due to plugin name inferring.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T20:31:16Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087585745",
            "id": 2087585745,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58bgfR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 198,
            "original_position": 198,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087614353"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "question: Lockfile support isn't implemented yet. What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\nThis isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nquibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\nFor consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-13T20:51:26Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087614353",
            "id": 2087614353,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58bneR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2584,
            "original_position": 63,
            "original_start_line": 2573,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087933137"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Or can also use Golang-like format \"github.com/user/repo\" (`https://` is ommitted)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-14T02:49:14Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087933137",
            "id": 2087933137,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58c1TR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2838571319,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-14T05:15:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2090889590"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I strongly agree with @mrcjkb.\r\n\r\nI think it would be most flexible if all specifications were unified to `provider:identifier`.\r\n\r\nThis is what the internal implementation looks like.\r\n\r\n```lua\r\nvim.pack.providers:add('github', {\r\n  fetch = function(ctx, callback)\r\n    vim.system({\r\n      'git',\r\n      'clone',\r\n      ('https://github.com/%s'):format(ctx.identifier),\r\n      ctx.dist_path\r\n    }, {\r\n      on_exit = function(output)\r\n        callback(output.code == 0)\r\n      end\r\n    })\r\n  end\r\n})\r\n```\r\n_It's just a example_",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T10:49:51Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2090889590",
            "id": 2090889590,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58oHF2",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843224811,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T10:49:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091036566"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566"
                }
            },
            "author_association": "MEMBER",
            "body": "I am completely open to adding `<host>:<owner>/<repo>` support (was not aware of this convention, by the way, it's nice). It is better to wait for an \"executive decision\" on this, though. Plus can always be added in a follow up PR.\r\n\r\n> This is what the internal implementation looks like.\r\n\r\n*This* level of flexibility is definitely too much. Not only because making everything as flexible as possible is probably not the best goal here, but mostly because `vim.pack` makes assumptions about how `git clone` is done (like explicitly set \"origin\" as remote's name, extra useful arguments `--filter=blob:none`, etc.).\r\n\r\nIf any customization here is deemed to be acceptable, I am leaning towards creating a separate `vim.pack.config()` (like `vim.diagnostic.config()`) which can have `format_source` callable. By default it can transform 'domain:user/repo' into 'https://domain.com/user/repo.git' and users can adjust to their liking (like allowing 'user/repo' to mean 'github:user/repo').",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:15:09Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091036566",
            "id": 2091036566,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58oq-W",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843470729,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:15:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091049777"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777"
                }
            },
            "author_association": "MEMBER",
            "body": "Just make users specify the full URL to a git repo; no point in being clever for the sake of it (and very minor convenience). The built-in manager needs to be minimal (but functional), nothing more.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:22:31Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091049777",
            "id": 2091049777,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58ouMx",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843492390,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 7,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 7,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:22:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091066897"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This example is not intended to expose an API for customization for users. It's just an idea of ​​how to handle user-specified \"identifiers\".\r\n\r\nMy concern was the fact that deno/node eventually introduced `node:`, `npm:`, etc.\r\n\r\nI'm not against the introduction of a minimal manager, I just suggested it now to pave the way for the future.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:32:11Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091066897",
            "id": 2091066897,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58oyYR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843520661,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:32:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091077947"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947"
                }
            },
            "author_association": "MEMBER",
            "body": "We are more interested in future maintainability in this regard; any future extensibility will be controlled through options. The string is either a full URL or a full local path, nothing \"magic\"; this is a hard line.\r\n\r\nSo the blunt answer to the initial question is \"**zero** magic\" (which has the benefit of supporting _any_ git hoster as long as `git clone <url>` works as expected). Non-git version control is completely out of scope for core (sorry not sorry).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:38:22Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091077947",
            "id": 2091077947,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58o1E7",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843539089,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:42:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091094199"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "From the viewpoint of maintainability, wouldn't it be easier to maintain if it was clear whether the specified thing was a URL or a local path?\r\n\r\nIs it possible to distinguish between them using prefixes such as `~/`, `./`, `$HOME/`, `https://github.com`, and `git@`? (Sorry, I can't think of any concrete examples.)\r\n\r\nThat's my opinion, but I support the official position.\r\nI wanted to make a suggestion as a community member.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:47:01Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091094199",
            "id": 2091094199,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58o5C3",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843565110,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:47:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091104201"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe we can special case missing protocol (which a full URL always requires!) as a local path (since at least in my opinion that is an important enough usecase); but that is still TBD since local plugins are not part of this PR. Having to explicitly specify `local = true` (or variants thereof) is acceptable as long as the functionality is there.\r\n\r\nWe want to remove friction for users, but we are _not_ interested in maximizing convenience at the cost of maintenance (which includes sufficiently clear documentation for \"magic\" behavior).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T12:52:18Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091104201",
            "id": 2091104201,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58o7fJ",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843581513,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:53:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091158037"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037"
                }
            },
            "author_association": "MEMBER",
            "body": "I've added the \"Any format supported by `git clone` is allowed.\" (which *should* be technically true, I hope). At least for now, until there is a local plugin support or an explicitly limited support of formats.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T13:19:21Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091158037",
            "id": 2091158037,
            "in_reply_to_id": 2087585745,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pIoV",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 198,
            "original_position": 198,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843670856,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T13:19:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091167529"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529"
                }
            },
            "author_association": "MEMBER",
            "body": "> What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\n> This isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nTechnically - whichever is after `git clone`. On paper - added that \"HEAD\" is \"... for already installed plugin\" only. At least indeed until there is a lockfile support.\r\n\r\n> quibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\n> For consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.\r\n\r\nI am also not 100% happy with either \"version\" or \"HEAD\". Using \"FREEZE\" indeed might be a good idea, although I personally would prefer using \"checkout\" instead of \"version\". But that seems too Git-specific and needs a review.\r\n\r\nI've updated [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2087290998) to keep these kind of suggestions in one place.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T13:23:54Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091167529",
            "id": 2091167529,
            "in_reply_to_id": 2087614353,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pK8p",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2584,
            "original_position": 63,
            "original_start_line": 2573,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2843686203,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T13:23:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091170938"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938"
                }
            },
            "author_association": "MEMBER",
            "body": "Done.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T13:25:32Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091170938",
            "id": 2091170938,
            "in_reply_to_id": 2087330410,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pLx6",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2522,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2843691917,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T13:25:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091371243"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243"
                }
            },
            "author_association": "MEMBER",
            "body": "Although the strict \"try to use greatest available version\" should be a good approach for most \"popular\"/\"serious\" plugins, many smaller ones would probably not have semver tags at all. The current logic is for those users to set an explicit `version = 'master'` or `version = 'main'` (which one - should be specified in the plugin's help or just by two trials and one error). This sounds okay to me.\r\n\r\nPlus, some older (i.e. Vimscript) plugins might also have very old semver tag compared to the progress on default branch (like 'tpope/vim-fugitive').\r\n\r\nOne possible solution for both of this might be the following compromise:\r\n\r\n- Have default that *tries* to use latest semver tag. If there is no semver tags at all - fall back to default branch. This is more magic than requiring to explicitly set `version = 'main'/'master'`, but should reduce friction for such cases.\r\n- Add 'pack/health.lua' with checks like \"the latest tag of this plugin is very far behind of default branch; consider setting `version = 'master'`\". This can also be done inside confirmation buffer in the same fashion as there are currently \"Available newer tags\" suggestions.\r\n\r\nBoth of these can be done in a follow up PR.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-15T14:48:02Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091371243",
            "id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58p8rr",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2844024077,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T14:50:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2092749902"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902"
                }
            },
            "author_association": "MEMBER",
            "body": "Another approach for solving both of these is, of course, to use default branch (`main` / `master` / etc.) by default. The rationale for using `vim.version.range('*')` as default was to nudge plugins towards adopting semver tags versions. The cons of this are:\r\n- Adds friction for developing \"small\" plugins, i.e. which don't plan to become state-of-the-art implementations with large code bases. Those usually tend to be developed inside a single default branch. This can be resolved by providing installation instructions that use `version = 'main'`, yet it is still friction.\r\n- Adds friction for users when using outdated releases for old Vimscript plugins. It can be mitigated by adding checkhealth entry mentioned above.\r\n- Not all plugins might be suitable for semver release model. A collection of runtime files (like 'nvim-lspconfig', 'nvim-treesitter') might be better managed with \"calendar versioning\" (like a once a month release instead of following semver major-minor-patch convention).\r\n- Most currently popular plugin managers seem to have default branch as default version. Not following that might be going too much against user expectations.\r\n\r\nI personally would always use default branch, but having built-in plugin manager use versions by default seemed like a \"good kind of friction\" in a long term. I just need a decision to which kind of default is best here.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-16T10:01:28Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2092749902",
            "id": 2092749902,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58vNRO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2846163099,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T10:03:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2093496585"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585"
                }
            },
            "author_association": "MEMBER",
            "body": "My vote is to use the default branch. The versioning scheme needs to be specified by the plugin for us to automatically select tags.\n\nOther package managers allow setting something like `version = \"v*\"` to pick the latest tag beginning with `v`. Some versioning schemes omit the leading `v`.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-16T18:16:49Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2093496585",
            "id": 2093496585,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58yDkJ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2847339802,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T18:16:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2093533944"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944"
                }
            },
            "author_association": "MEMBER",
            "body": "> Other package managers allow setting something like `version = \"v*\"` to pick the latest tag beginning with `v`. Some versioning schemes omit the leading `v`.\r\n\r\nFor semantic versioning there is no such need for `vim.pack`, as `vim.version.parse` is smart enough (with `strict = false`) to [extract version number](https://github.com/neovim/neovim/blob/3659058e80485c64cdd8a980337058ca0e40555d/runtime/lua/vim/version.lua#L174). Yes, there might be false positives if there are numbers in tags, but it should be good enough if it is known that tags have semantic versioning.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-16T18:50:22Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2093533944",
            "id": 2093533944,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58yMr4",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2847399048,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T18:50:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169208"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208"
                }
            },
            "author_association": "MEMBER",
            "body": "Will this work outside of init.lua, for those of us who still use init.vim? For example, can I use `plugin/pack.lua` or even `lua/pack.lua` (and execute manually with `:lua require('pack')` when I want to modify my plugins)?\r\n\r\nOne reason I like using `start/` is that I don't have to dedicate any source code to loading plugins. I literally just `git clone` them to the right location and let Nvim handle the rest. Since it sounds like `vim.pack` puts everything in `opt`, I'm assuming that is not a use case that will be supported and I will have to use `vim.pack.add` to load plugins out of `opt`? ",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:09:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169208",
            "id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580nx4",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2581,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848354438,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:09:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169684"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684"
                }
            },
            "author_association": "MEMBER",
            "body": "Does this download happen automatically? So if a user has `vim.pack.add` in their init.lua, as soon as they start Nvim it will automatically start downloading things?\r\n\r\nI wonder if this should be a more explicit action. Nvim automatically downloading things without any user action feels a bit iffy (I don't think there's any precedent for that?)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:11:51Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169684",
            "id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580n5U",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848355087,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:11:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169923"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923"
                }
            },
            "author_association": "MEMBER",
            "body": "Spell files? I would consider a `vim.pack.add` line as \"explicitly opting in\" here.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:13:08Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169923",
            "id": 2094169923,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580n9D",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848355360,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:13:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094170341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure I understand what this does if `offline` is false?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:16:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094170341",
            "id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oDl",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848355887,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:16:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171165"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165"
                }
            },
            "author_association": "MEMBER",
            "body": "This comment and the way these two lines are grouped together is confusing (I had to read this 3 times and I'm still not 100% confident I'm understanding it correctly).\r\n\r\nIIUC, this installs two different plugins, `github.com/user/plugin1` and `github.com/user/plugin2`. The 1st example is demonstrating the \"shortcut\" method of installing a plugin and the 2nd example is showing the more verbose version.\r\n\r\nThe single comment and grouping of these lines makes it seem like this is installing a single plugin under a directory `plugin1/plugin2`.\r\n\r\nIf my understanding is correct, I think formatting it like this would make it clearer:\r\n\r\n```\r\n-- Install \"plugin1\" and use greatest available version.\r\n'https://github.com/user/plugin1',\r\n\r\n-- Same as above, but using a full table, which allows setting other options.\r\n{ source = 'https://github.com/user/plugin1' },\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:20:40Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171165",
            "id": 2094171165,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oQd",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2539,
            "original_position": 27,
            "original_start_line": 2537,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848356705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:20:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171449"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe clarify here that if `name` is omitted it's inferred from the URL?\r\n\r\n```suggestion\r\n      -- Specify plugin's name (here the plugin will be called \"plugin3\"\r\n      -- instead of \"generic-name\")\r\n      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:22:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171449",
            "id": 2094171449,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oU5",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2542,
            "original_position": 30,
            "original_start_line": 2541,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848356964,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:22:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172111"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure what \"Greatest version matching range\" means. Maybe call this the \"version constraint\" instead (with a link to the docs).\r\n\r\nI had to read the `vim.version.range` docs to understand exactly what `vim.version.range('1.0')` means. This matches `1.0.0` and `1.0.1`, but not `1.1`, for example.\r\n\r\n```suggestion\r\n        version = vim.version.range('1.0'), -- Version constraint. See |vim.version.range()|\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:25:40Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172111",
            "id": 2094172111,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ofP",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2547,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357554,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:25:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172321"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n• Restart Nvim. The plugin's actual state on disk is not yet changed.\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:26:37Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172321",
            "id": 2094172321,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oih",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2569,
            "original_position": 57,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357717,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:26:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172538"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n• Review changes and either confirm or discard them. If discarded, revert any changes in 'init.lua' as well or you will be prompted again next time you run |vim.pack.update()|.\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:28:04Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172538",
            "id": 2094172538,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ol6",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2573,
            "original_position": 61,
            "original_start_line": 2572,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357948,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:28:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172722"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722"
                }
            },
            "author_association": "MEMBER",
            "body": "I find it pretty counter-intuitive that `HEAD` implies freezing the plugin. In Git parlance, `HEAD` is the current tip, which is always changing.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:29:17Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172722",
            "id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ooy",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358116,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:29:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172936"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936"
                }
            },
            "author_association": "MEMBER",
            "body": "No API to delete plugins? Having to manually run `rm -rf ~/.local/share/nvim/site/pack/core/plugin-name` is a bit tedious. Not to mention it leaks an abstraction (the installation directory of plugins).\r\n\r\nWhy not provide `vim.pack.del(\"plugin-name\")`?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:30:38Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172936",
            "id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580osI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358433,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:30:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094173407"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407"
                }
            },
            "author_association": "MEMBER",
            "body": "I think the plan is to\r\n1. remove/comment out `vim.pack.add()`\r\n2. call `vim.clean()`\r\n\r\n(Agreed that we absolutely need a way to clean up what we put in.)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:32:44Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094173407",
            "id": 2094173407,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ozf",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:32:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174058"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058"
                }
            },
            "author_association": "MEMBER",
            "body": "> that I don't have to dedicate any source code to loading plugins\n\nIf you use `vim.pack` wouldn't you then have source code for loading plugins regardless of whether it uses `opt` or `start` internally?\n\nAnd if you are thinking from a perf pov, using a plugin manager with `opt` will be more efficient than using `start` since you can avoid an unnecessary directory path scan as the package manager knows where to look for plugins.\n\n`start` really only makes sense if you do not want any plugin knowledge in your `init.lua`, and manage them externally, in which case a built-in package manager has no place. Unless I'm missing something?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:36:18Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174058",
            "id": 2094174058,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580o9q",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2581,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:36:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174061"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061"
                }
            },
            "author_association": "MEMBER",
            "body": "I've never downloaded a spell file in Vim, but reading the docs briefly it says \r\n\r\n>But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nIn this case it's still requiring an explicit action (confirmation) from the user, not just immediately downloading.\r\n\r\n>I would consider a vim.pack.add line as \"explicitly opting in\" here.\r\n\r\nUsers are required to have `vim.pack.add` in their init file to even load/enable the plugin. So I don't think it's acceptable to treat that as tacit approval of \"yes please download things automatically\".\r\n\r\nIt's not difficult to show a single confirmation dialog that says \"Install the following plugins? [Y/n]\"",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:36:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174061",
            "id": 2094174061,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580o9t",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360004,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:36:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174802"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802"
                }
            },
            "author_association": "MEMBER",
            "body": "No, I mean adding `vim.pack.add('thisplugin')` _is_ giving confirmation to \"yes, please download _this plugin_\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\n> But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nWhich it is by default, in Nvim (not Vim IIRC). You're right that this shows a prompt (correctly in this case, because the action is not directly tied to what triggers it, unlike here).\r\n",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:40:28Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174802",
            "id": 2094174802,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pJS",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360776,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:45:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175054"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054"
                }
            },
            "author_association": "MEMBER",
            "body": "I was a bit careless with my words/phrasing. Yes there will of course always be some code to specify the list of plugins which should be installed (even in the `start` world). I was referring to requiring code to just enable/load the plugin.\r\n\r\nBut I'm also speaking more from personal preference here. I think in regard to the builtin plugin manager, this design is perfectly fine. And the small minority of users still using init.vim instead of init.lua can use a Lua heredoc or something.\r\n\r\nSo consider this comment resolved.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:41:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175054",
            "id": 2094175054,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pNO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2581,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:41:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175776"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776"
                }
            },
            "author_association": "MEMBER",
            "body": ">Which it is by default, in Nvim (not Vim IIRC).\r\n\r\nThe plugin is enabled, but still \"offers to download the spell file\" (implying there is a prompt).\r\n\r\n>No, I mean adding vim.pack.add('thisplugin') is giving confirmation to \"yes, please download this plugin\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\nThe bootstrapping situation is exactly the one I'm thinking of where I would want a prompt. If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBut if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:45:25Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175776",
            "id": 2094175776,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pYg",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848361660,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:45:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175991"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991"
                }
            },
            "author_association": "MEMBER",
            "body": ">If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBeing able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:46:49Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175991",
            "id": 2094175991,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pb3",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848361902,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:46:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094176570"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570"
                }
            },
            "author_association": "MEMBER",
            "body": "> Will this work outside of init.lua, for those of us who still use init.vim? For example, can I use `plugin/pack.lua` or even `lua/pack.lua` (and execute manually with `:lua require('pack')` when I want to modify my plugins)?\r\n\r\nThis should work as any \"regular\" `vim.xxx()` function, even via `:lua vim.pack.add(...)`.\r\n\r\nAnd yes, 'start/' vs 'opt/' shouldn't make a difference here if they both are required to be listed in the config somewhere.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:49:57Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094176570",
            "id": 2094176570,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pk6",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2581,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848362436,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:49:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094177352"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352"
                }
            },
            "author_association": "MEMBER",
            "body": "Everything that is listed afterwards: infer the matching states from `version` field of plugins and either update (`force = true`) or show confirmation buffer (`force = false`, default). This is useful for changing the version of plugin on disk, as it doesn't require internet connection. Strictly speaking, having `offline` field is not needed if checking for upstream changes is considered a \"cheap\" enough operation.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:53:37Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094177352",
            "id": 2094177352,
            "in_reply_to_id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pxI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848363083,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:53:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094178068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068"
                }
            },
            "author_association": "MEMBER",
            "body": "> I'm not sure what \"Greatest version matching range\" means. Maybe call this the \"version constraint\" instead (with a link to the docs).\r\n\r\nIn `vim.version` terminology it is \"last\", which I don't find correct/intuitive. It is the largest/biggest/greatest available version that matches any constraint specified via `vim.version.range()`. In this particular case it is indeed larger than or equal `1.0.0` but strictly less than `1.1.0`.\r\n\r\nYes, linking to `vim.version.range()` makes sense.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T17:56:49Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094178068",
            "id": 2094178068,
            "in_reply_to_id": 2094172111,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580p8U",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2547,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848363681,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:56:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134"
                }
            },
            "author_association": "MEMBER",
            "body": "The logic is as follows. The `version` describes what target state to use when updating plugin. If target state is always \"HEAD\" (i.e. current), it means that updating will always \"update\" to the current state. I.e. no new changes.\r\n\r\nI think this name best works if `version` is named `checkout`.\r\n\r\nNaming \"FREEZE\" instead of \"HEAD\" is possible, but it makes it a \"reserved\" word which would make it impossible to use branch named \"FREEZE\". A *very* unlikely scenario which might be worth the risk, of course.\r\n\r\nOther plugin managers use a separate spec field for that, but I really don't think it is needed here.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:02:04Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179134",
            "id": 2094179134,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qM-",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848364934,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:02:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179150"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150"
                }
            },
            "author_association": "MEMBER",
            "body": "Pretty sure there is a prompt for spell files, and I also agree plugin installs should require a prompt.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:02:11Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179150",
            "id": 2094179150,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qNO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848364959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:02:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180255"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255"
                }
            },
            "author_association": "MEMBER",
            "body": "> Why not provide `vim.pack.del(\"plugin-name\")`?\r\n\r\nIt is one of the possibility (listed in \"Planned future work\" of the first comment), which I am not against. There are/were others:\r\n\r\n1. Provide a `vim.pack.clean()` to clean not used plugins. This might get tricky if there is no way to cherry-pick plugins, because there is no good way to see which plugins are intended to be removed and which are just not (yet) loaded. See [this comment](https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306) and what it responds to. So I think it is only a good option if it provides an *interactive* confirmation buffer allowing to filter out plugins that don't need to be removed. This is what 'mini.deps' does, but I think it is too much for `vim.pack.add`.\r\n1. Export a way to get plugin's path based on the name and suggest to use `vim.fn.delete()`. So it might be something like `vim.fn.delete(vim.pack.get('plugin-name').path)`.\r\n1. Indeed provide `vim.pack.del('plugin-name')`. This can also trigger dedicated events (`PackDelPre` and `PackDel`) which can be used by plugins to do some kind of \"cleanup\".\r\n\r\nAt the moment, I think either option 2. or 3. are fine. They 3. indeed might be a bit cleaner.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:09:36Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180255",
            "id": 2094180255,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qef",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848366306,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:09:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180525"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525"
                }
            },
            "author_association": "MEMBER",
            "body": "At best `HEAD` is ambiguous here.\n\nI think a separate field is warranted. Adding special keywords that can conflict in a namespace is a worse way of solving this and a separate field is much more intuitive and easier to understand.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:11:10Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180525",
            "id": 2094180525,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qit",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848366589,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:11:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181422"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422"
                }
            },
            "author_association": "MEMBER",
            "body": "> because there is no good way to see which plugins are intended to be removed and which are just not (yet) loaded\n\nThis is exactly why I added a `cond = function(load) end` spec field in pckr.nvim to defer loading a plugin. In order for a package manager to manage plugins, it needs to know what plugins it is managing. There isn't really a way around this.\n\nSince you have the constraint that `vim.pack.add` _must_ load the plugin, I don't think we'll ever be able to robustly manage the removal of unused plugins. That will just need to be an accepted limitation.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:18:14Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181422",
            "id": 2094181422,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qwu",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848367702,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:18:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181976"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976"
                }
            },
            "author_association": "MEMBER",
            "body": "> vim.fn.delete()\n\nOr `vim.fs.rm()`",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:20:58Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181976",
            "id": 2094181976,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580q5Y",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848368123,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:20:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094183625"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625"
                }
            },
            "author_association": "MEMBER",
            "body": "My thinking is what @clason described: putting explicit `vim.pack.add()` in the config should be enough of a confirmation already. \r\n\r\n> Being able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.\r\n\r\nPlugin will be installed already after `vim.pack.add()`, no need to either restart Nvim or `vim.pack.update()`. So I don't really understand what this is about.\r\n\r\n> But if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.\r\n\r\nWell, right now it is known (all plugins are listed), but if/when there is packspec support, this indeed won't be known 100% in advance.\r\n\r\nI am open to adding some confirmation before installing. Some questions:\r\n- Is something like `vim.fn.confirm('These plugins will be installed:\\n...')` enough or should be more interactive (like allowing to specify which plugins to install)? I'd guess it should be enough.\r\n- Should it be one confirmation per install (i.e. several times pressing `y`) or one confirm for all installs? I'd guess one for all plugins should be enough, otherwise it is a tedious amount of \"y\" during bootstrap.\r\n- Should it be run only during startup (i.e. `vim.v.vim_did_enter == 0`) or for every install? I'd go with only during startup, because otherwise it should be a conscious decision (i.e. enough of confirmation already).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:28:46Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094183625",
            "id": 2094183625,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rTJ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848369343,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:28:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184571"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571"
                }
            },
            "author_association": "MEMBER",
            "body": "> ... it needs to know what plugins it is managing. There isn't really a way around this.\r\n\r\nRight now it is \"all plugins inside '~/.local/share/nvim/site/pack/core/opt'\". All of them can be updated, i.e. \"managed\".\r\n\r\n> I don't think we'll ever be able to robustly manage the removal of unused plugins. That will just need to be an accepted limitation.\r\n\r\nYes, I did come to that conclusion also (as a result of comments in this PR). And I think this limitation is worthwhile as the idea of \"just add `vim.pack.add()` line to config and assume plugin is present afterwards\" is very convenient when used inside config.\r\n\r\nHence why I think providing only a manual way of `vim.pack.del()` is good enough. It is explicit and atomic operation, which can be more than just deleting a directory.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:35:29Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184571",
            "id": 2094184571,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rh7",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848370378,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:35:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184911"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911"
                }
            },
            "author_association": "MEMBER",
            "body": "> I think a separate field is warranted. Adding special keywords that can conflict in a namespace is a worse way of solving this and a separate field is much more intuitive and easier to understand.\r\n\r\nSure, sounds good. My objective here is to have as simple spec as possible. There are precedents of having too fields in plugin spec bring more confusion than good.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:37:45Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184911",
            "id": 2094184911,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rnP",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848370934,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:37:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094185053"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053"
                }
            },
            "author_association": "MEMBER",
            "body": "I think a single prompt for a list of plugins and done any time a plugin is installed.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T18:38:41Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094185053",
            "id": 2094185053,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rpd",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848371086,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:39:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094194341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341"
                }
            },
            "author_association": "MEMBER",
            "body": ">Is something like vim.fn.confirm('These plugins will be installed:\\n...') enough or should be more interactive \r\n\r\nYes I think that's fine\r\n\r\n>Should it be one confirmation per install (i.e. several times pressing y) or one confirm for all installs\r\n\r\nOne for all, just list all of the ones that are going to be installed (this can be done in a floating window or something if there are a lot)\r\n\r\n>putting explicit vim.pack.add() in the config should be enough of a confirmation already.\r\n\r\nThere are cases where you DIDN'T put `vim.pack.add` in the config though (you are using a config that somebody else provided to reproduce a bug), or when you did the context/situation was different (maybe I put `vim.pack.add` in my config several months ago, but now I'm cloning onto a new machine and I want to review what's going to be downloaded before Nvim starts cloning a bunch of repos automatically).\r\n\r\n> Plugin will be installed already after vim.pack.add(), no need to either restart Nvim or vim.pack.update(). So I don't really understand what this is about.\r\n\r\nAs a general design rule Nvim shouldn't be downloading things from the internet without some explicit consent/action from the user. If the user runs `vim.pack.add()` interactively then I agree that is sufficiently explicit. But if it's run programmatically (as part of startup in init.lua) I don't think it is, at least not as a default.\r\n\r\nIn Emacs, `use-package` has an `ensure` option that users can set to have the plugin automatically downloaded. That is another option we could explore (set either per-plugin as part of `vim.pack.add()` or globally as part of `vim.pack.config()`). But as a **default**, we should err on the side of requiring user action.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T19:30:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094194341",
            "id": 2094194341,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580t6l",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848381093,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T19:30:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094197044"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044"
                }
            },
            "author_association": "MEMBER",
            "body": "Another idea would be to use another type like `version=false`? Isn't as easy to understand as a separate field but avoids the name clashing problem.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-17T19:47:12Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094197044",
            "id": 2094197044,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580uk0",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848383792,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 2,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T19:47:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094484236"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, sorry, I misunderstood the question (thought it was about `offline = true`) :facepalm:\r\nIf `offline` is `false` (which is default), it downloads new changes from the source. Under the hood it is `git fetch` with some set of useful flags, which makes local copy of `origin` remote have the same state as on remote. After that, it proceeds with next steps.\r\n\r\n---\r\n\r\nA note. If/when there is a lockfile capability which would allow to track data (like `version`) between Nvim sessions, the `offline = true` use case might be replaced with making `vim.pack.add()` always ensure that plugin is at correct target state. Without lockfile it is not quite performant to do so (as \"happy path\" of being in the proper target version is much more common and explicitly checking takes non-trivial-during-startup amount of time). Whether this is a good behavior or it is better to require an explicit `vim.pack.update()` to actually see which changes are being applied is a topic of another discussion.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T10:54:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094484236",
            "id": 2094484236,
            "in_reply_to_id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5810sM",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848892677,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-18T11:03:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094507024"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024"
                }
            },
            "author_association": "MEMBER",
            "body": "> Oh, sorry, I misunderstood the question (thought it was about offline = true)\r\n\r\nHa that is actually what I meant, so you understood my question even though I asked it incorrectly. ",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T12:17:39Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094507024",
            "id": 2094507024,
            "in_reply_to_id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5816QQ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848921755,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-18T12:17:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571350"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350"
                }
            },
            "author_association": "MEMBER",
            "body": "I did go with `version = false` to freeze plugins. Is it enough to resolve this?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T16:28:10Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571350",
            "id": 2094571350,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582J9W",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849037248,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:28:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592"
                }
            },
            "author_association": "MEMBER",
            "body": "There is now `vim.pack.del()` in this PR. It accepts array of names and removes those plugins from disk. Along with triggering dedicated events and some proper bookkeeping.\r\nIs it enough to resolve this conversation?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T16:29:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571592",
            "id": 2094571592,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582KBI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849037477,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:29:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094575524"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524"
                }
            },
            "author_association": "MEMBER",
            "body": "If someone wants to freeze/pin a plugin to an exact version can’t they just set the tag/commit hash? Do we need this extra field/value at all?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T16:49:08Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094575524",
            "id": 2094575524,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582K-k",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849041508,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:49:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094598936"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes, that's a fair point. The special case of \"freezing\" a plugin is mostly due to:\r\n- Having a recipe of \"Just set `version = false` to prevent updates\" is more straightforward than \"Run `vim.pack.update({ 'plugin-name' }, { offline = true })`, yank the hash for current state, and set `version` to it\".\r\n- There is a similar functionality in other plugin managers (although with a separate field). So this concept should be familiar to users of other plugin managers.\r\n\r\nAs \"freezing\" the plugin from updates is more or less common operation, I decided to have this to reduce friction.\r\n\r\nIf both of the above points are not important enough for the added complexity, it can indeed be removed. I also \"prepared\" for it just now by having shorter hashes (`--abbrev-commit`) be reported as state in the `vim.pack.update()` output. Another reason for removing it might be that it is possible to add later, while removing this capability is less easy.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-18T18:45:33Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094598936",
            "id": 2094598936,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582QsY",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849063536,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T18:45:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096135993"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993"
                }
            },
            "author_association": "MEMBER",
            "body": "There is now a confirm before any plugin(s) install. It uses `vim.fn.confirm()`, but during startup it is drawing issues (see #34088), so for now it is a bit hacky workaround with delayed `vim.print()` and manual processing of the key asked via `vim.fn.getcharstr()`. After #34088 is solved (or 'extui' becomes default, whichever is sooner), the `vim.fn.confirm()` can be used universally.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-19T16:47:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096135993",
            "id": 2096135993,
            "in_reply_to_id": 2094169684,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM588H85",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2642,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2851436368,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-19T16:47:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096138197"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197"
                }
            },
            "author_association": "MEMBER",
            "body": "The default `version` is now default branch, which is computed automatically (i.e. doesn't hard code `main` or `master`).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-19T16:48:36Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096138197",
            "id": 2096138197,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM588IfV",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2851439498,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-19T16:48:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096143432"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432"
                }
            },
            "author_association": "MEMBER",
            "body": "After further discussion on Matrix, it seemed best to postpone the support for `version = false` for freezing plugin in favor of suggesting to use explicit commit hash. At least until there is a lockfile support, because:\r\n- It will provide a more proper initial install of plugin (and not only checkout the default branch) if there is a decision to have `version = false` support.\r\n- It will make easier to get the commit hash of current state if there will be no `version = false` (or separate `pin = true`) support.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-19T16:52:13Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096143432",
            "id": 2096143432,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM588JxI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2584,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2851447354,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-19T16:52:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2101870948"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101870948"
                }
            },
            "author_association": "MEMBER",
            "body": "After thinking about it, maybe it is worth postponing the decision about whether `offline = true` is necessary until after there is a lockfile support. Similar to `version = false`.\r\n\r\nThe reason for this is that with lockfile it will be feasible to have the design of \"`add()` ensures both presence and correct on disk spec (like `source` and `version`)\" and \"`update()` is only for downloading and applying changes from source\". This simplifies the \"change `version`\" step at the cost of not being able to see beforehand and confirm/deny which changes will be applied: they would still be present in the log file for inspection, though.\r\n\r\nThe only downside right now would be that changing `version` of already installed plugin would require Internet connection. Which can be reasonable enough as a temporary (hopefully not for long) restriction.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-22T07:42:36Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2101870948",
            "id": 2101870948,
            "in_reply_to_id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59SAFk",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2860145587,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101870948/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T07:42:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101870948",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2104464414"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104464414"
                }
            },
            "author_association": "MEMBER",
            "body": "The `vim.pack.update()` now doesn't have `opts.offline` option. The decision about its usefulness is postponed until after there is lockfile support.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-23T12:14:20Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2104464414",
            "id": 2104464414,
            "in_reply_to_id": 2094170341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59b5Qe",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2864211384,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104464414/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-23T12:14:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104464414",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2104473491"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104473491"
                }
            },
            "author_association": "MEMBER",
            "body": "Added this to future work.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-05-23T12:20:01Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2104473491",
            "id": 2104473491,
            "in_reply_to_id": 2087294852,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59b7eT",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 335,
            "original_position": 293,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2864224660,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104473491/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-23T12:20:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104473491",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2123790910"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2123790910"
                }
            },
            "author_association": "MEMBER",
            "body": "@lewis6991, if [this](https://github.com/neovim/neovim/pull/34009#issuecomment-2925307322) is absolutely crucial to get resolved before there is better built-in showing progress (`vim.ui.progress` and/or default `'$/progress'`), there is this hack:\r\n\r\n```suggestion\r\n    dispatchers.notification('$/progress', { token = progress_token_count, value = value })\r\n    if vim.v.vim_did_enter == 0 then\r\n      print(vim.lsp.status())\r\n      vim.cmd.redraw({ bang = true })\r\n    end\r\n```\r\n\r\nIt works in most common situation of a single `vim.pack.add()` that adds all the plugins, including possibly the one implementing `'$/progress'`. It will show duplicated progress messages if there was custom `'$/progress'` added before (via explicit custom code or a separate `vim.pack.add()`). This also will have no effect after startup (i.e. requires user to have custom `'$/progress\"` handler).\r\n\r\nInstead of `vim.v.vim_did_enter == 0` a better condition would be \"if there is no custom `'$/progress'` handler\", but I am not sure if that is reasonably possible.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-03T13:20:14Z",
            "diff_hunk": "@@ -0,0 +1,186 @@\n+local M = {}\n+\n+local capabilities = {\n+  codeActionProvider = true,\n+  documentSymbolProvider = true,\n+  hoverProvider = true,\n+}\n+--- @type table<string,function>\n+local methods = {}\n+\n+--- @param callback function\n+function methods.initialize(_, callback)\n+  return callback(nil, { capabilities = capabilities })\n+end\n+\n+--- @param callback function\n+function methods.shutdown(_, callback)\n+  return callback(nil, nil)\n+end\n+\n+local get_confirm_bufnr = function(uri)\n+  return tonumber(uri:match('^nvimpack://(%d+)/confirm%-update$'))\n+end\n+\n+--- @param params { textDocument: { uri: string } }\n+--- @param callback function\n+methods['textDocument/documentSymbol'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return callback(nil, {})\n+  end\n+\n+  --- @alias vim.pack.lsp.Position { line: integer, character: integer }\n+  --- @alias vim.pack.lsp.Range { start: vim.pack.lsp.Position, end: vim.pack.lsp.Position }\n+  --- @alias vim.pack.lsp.Symbol {\n+  ---   name: string,\n+  ---   kind: number,\n+  ---   range: vim.pack.lsp.Range,\n+  ---   selectionRange: vim.pack.lsp.Range,\n+  ---   children: vim.pack.lsp.Symbol[]?,\n+  --- }\n+\n+  --- @return vim.pack.lsp.Symbol?\n+  local new_symbol = function(name, start_line, end_line, kind)\n+    if name == nil then\n+      return nil\n+    end\n+    local range = {\n+      start = { line = start_line, character = 0 },\n+      ['end'] = { line = end_line, character = 0 },\n+    }\n+    return { name = name, kind = kind, range = range, selectionRange = range }\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+\n+  --- @return vim.pack.lsp.Symbol[]\n+  local parse_headers = function(pattern, start_line, end_line, kind)\n+    local res, cur_match, cur_start = {}, nil, nil\n+    for i = start_line, end_line do\n+      local m = lines[i + 1]:match(pattern)\n+      if m ~= nil and m ~= cur_match then\n+        table.insert(res, new_symbol(cur_match, cur_start, i, kind))\n+        cur_match, cur_start = m, i\n+      end\n+    end\n+    table.insert(res, new_symbol(cur_match, cur_start, end_line, kind))\n+    return res\n+  end\n+\n+  local group_kind = vim.lsp.protocol.SymbolKind.Namespace\n+  local symbols = parse_headers('^# (%S+)', 0, #lines - 1, group_kind)\n+\n+  local plug_kind = vim.lsp.protocol.SymbolKind.Module\n+  for _, group in ipairs(symbols) do\n+    local start_line, end_line = group.range.start.line, group.range['end'].line\n+    group.children = parse_headers('^## (.+)$', start_line, end_line, plug_kind)\n+  end\n+\n+  return callback(nil, symbols)\n+end\n+\n+--- @param callback function\n+methods['textDocument/codeAction'] = function(_, callback)\n+  -- TODO(echasnovski)\n+  -- Suggested actions for \"plugin under cursor\":\n+  -- - Delete plugin from disk.\n+  -- - Update only this plugin.\n+  -- - Exclude this plugin from update.\n+  return callback(_, {})\n+end\n+\n+--- @param params { textDocument: { uri: string }, position: { line: integer, character: integer } }\n+--- @param callback function\n+methods['textDocument/hover'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local lnum = params.position.line + 1\n+  local commit = lines[lnum]:match('^[<>] (%x+) │') or lines[lnum]:match('^State.*:%s+(%x+)')\n+  local tag = lines[lnum]:match('^• (.+)$')\n+  if commit == nil and tag == nil then\n+    return\n+  end\n+\n+  local path, path_lnum = nil, lnum - 1\n+  while path == nil and path_lnum >= 1 do\n+    path = lines[path_lnum]:match('^Path:%s+(.+)$')\n+    path_lnum = path_lnum - 1\n+  end\n+  if path == nil then\n+    return\n+  end\n+\n+  local cmd = { 'git', 'show', '--no-color', commit or tag }\n+  --- @param sys_out vim.SystemCompleted\n+  local on_exit = function(sys_out)\n+    local markdown = '```diff\\n' .. sys_out.stdout .. '\\n```'\n+    local res = { contents = { kind = vim.lsp.protocol.MarkupKind.Markdown, value = markdown } }\n+    callback(nil, res)\n+  end\n+  vim.system(cmd, { cwd = path }, vim.schedule_wrap(on_exit))\n+end\n+\n+local dispatchers = {}\n+\n+-- TODO: Simplify after `vim.lsp.server` is a thing\n+-- https://github.com/neovim/neovim/pull/24338\n+local cmd = function(disp)\n+  -- Store dispatchers to use for showing progress notifications\n+  dispatchers = disp\n+  local res, closing, request_id = {}, false, 0\n+\n+  function res.request(method, params, callback)\n+    local method_impl = methods[method]\n+    if method_impl ~= nil then\n+      method_impl(params, callback)\n+    end\n+    request_id = request_id + 1\n+    return true, request_id\n+  end\n+\n+  function res.notify(method, _)\n+    if method == 'exit' then\n+      dispatchers.on_exit(0, 15)\n+    end\n+    return false\n+  end\n+\n+  function res.is_closed()\n+    return closing\n+  end\n+\n+  function res.terminate()\n+    closing = true\n+  end\n+\n+  return res\n+end\n+\n+M.client_id = vim.lsp.start(\n+  { cmd = cmd, name = 'vim.pack', root_dir = vim.uv.cwd() },\n+  { attach = false }\n+)\n+\n+local progress_token_count = 0\n+\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+function M.new_progress_report(title)\n+  progress_token_count = progress_token_count + 1\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local value = { kind = kind, message = msg, percentage = percent }\n+    if kind == 'begin' then\n+      value.title = title\n+    elseif kind == 'end' then\n+      value.percentage = nil\n+    end\n+    dispatchers.notification('$/progress', { token = progress_token_count, value = value })",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2123790910",
            "id": 2123790910,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-lno-",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 182,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack/_lsp.lua",
            "position": null,
            "pull_request_review_id": 2892333566,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2123790910/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-03T13:20:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2123790910",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126685704"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126685704"
                }
            },
            "author_association": "MEMBER",
            "body": "> @lewis6991, if https://github.com/neovim/neovim/pull/34009#issuecomment-2925307322 is absolutely crucial to get resolved before there is better built-in showing progress (vim.ui.progress and/or default '$/progress'), there is this hack:\r\n\r\nIt's important, but not a blocker for now.\r\n\r\nI do think that maybe for now that we remove the lsp progress stuff and wait for `vim.ui.progress`. In the meantime we just use `print` or `vim.notify` or something. We just need to make sure the lsp progress stuff can be tacked on easily enough, but that should be mostly possible with the added autocmds.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T14:01:37Z",
            "diff_hunk": "@@ -0,0 +1,186 @@\n+local M = {}\n+\n+local capabilities = {\n+  codeActionProvider = true,\n+  documentSymbolProvider = true,\n+  hoverProvider = true,\n+}\n+--- @type table<string,function>\n+local methods = {}\n+\n+--- @param callback function\n+function methods.initialize(_, callback)\n+  return callback(nil, { capabilities = capabilities })\n+end\n+\n+--- @param callback function\n+function methods.shutdown(_, callback)\n+  return callback(nil, nil)\n+end\n+\n+local get_confirm_bufnr = function(uri)\n+  return tonumber(uri:match('^nvimpack://(%d+)/confirm%-update$'))\n+end\n+\n+--- @param params { textDocument: { uri: string } }\n+--- @param callback function\n+methods['textDocument/documentSymbol'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return callback(nil, {})\n+  end\n+\n+  --- @alias vim.pack.lsp.Position { line: integer, character: integer }\n+  --- @alias vim.pack.lsp.Range { start: vim.pack.lsp.Position, end: vim.pack.lsp.Position }\n+  --- @alias vim.pack.lsp.Symbol {\n+  ---   name: string,\n+  ---   kind: number,\n+  ---   range: vim.pack.lsp.Range,\n+  ---   selectionRange: vim.pack.lsp.Range,\n+  ---   children: vim.pack.lsp.Symbol[]?,\n+  --- }\n+\n+  --- @return vim.pack.lsp.Symbol?\n+  local new_symbol = function(name, start_line, end_line, kind)\n+    if name == nil then\n+      return nil\n+    end\n+    local range = {\n+      start = { line = start_line, character = 0 },\n+      ['end'] = { line = end_line, character = 0 },\n+    }\n+    return { name = name, kind = kind, range = range, selectionRange = range }\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+\n+  --- @return vim.pack.lsp.Symbol[]\n+  local parse_headers = function(pattern, start_line, end_line, kind)\n+    local res, cur_match, cur_start = {}, nil, nil\n+    for i = start_line, end_line do\n+      local m = lines[i + 1]:match(pattern)\n+      if m ~= nil and m ~= cur_match then\n+        table.insert(res, new_symbol(cur_match, cur_start, i, kind))\n+        cur_match, cur_start = m, i\n+      end\n+    end\n+    table.insert(res, new_symbol(cur_match, cur_start, end_line, kind))\n+    return res\n+  end\n+\n+  local group_kind = vim.lsp.protocol.SymbolKind.Namespace\n+  local symbols = parse_headers('^# (%S+)', 0, #lines - 1, group_kind)\n+\n+  local plug_kind = vim.lsp.protocol.SymbolKind.Module\n+  for _, group in ipairs(symbols) do\n+    local start_line, end_line = group.range.start.line, group.range['end'].line\n+    group.children = parse_headers('^## (.+)$', start_line, end_line, plug_kind)\n+  end\n+\n+  return callback(nil, symbols)\n+end\n+\n+--- @param callback function\n+methods['textDocument/codeAction'] = function(_, callback)\n+  -- TODO(echasnovski)\n+  -- Suggested actions for \"plugin under cursor\":\n+  -- - Delete plugin from disk.\n+  -- - Update only this plugin.\n+  -- - Exclude this plugin from update.\n+  return callback(_, {})\n+end\n+\n+--- @param params { textDocument: { uri: string }, position: { line: integer, character: integer } }\n+--- @param callback function\n+methods['textDocument/hover'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local lnum = params.position.line + 1\n+  local commit = lines[lnum]:match('^[<>] (%x+) │') or lines[lnum]:match('^State.*:%s+(%x+)')\n+  local tag = lines[lnum]:match('^• (.+)$')\n+  if commit == nil and tag == nil then\n+    return\n+  end\n+\n+  local path, path_lnum = nil, lnum - 1\n+  while path == nil and path_lnum >= 1 do\n+    path = lines[path_lnum]:match('^Path:%s+(.+)$')\n+    path_lnum = path_lnum - 1\n+  end\n+  if path == nil then\n+    return\n+  end\n+\n+  local cmd = { 'git', 'show', '--no-color', commit or tag }\n+  --- @param sys_out vim.SystemCompleted\n+  local on_exit = function(sys_out)\n+    local markdown = '```diff\\n' .. sys_out.stdout .. '\\n```'\n+    local res = { contents = { kind = vim.lsp.protocol.MarkupKind.Markdown, value = markdown } }\n+    callback(nil, res)\n+  end\n+  vim.system(cmd, { cwd = path }, vim.schedule_wrap(on_exit))\n+end\n+\n+local dispatchers = {}\n+\n+-- TODO: Simplify after `vim.lsp.server` is a thing\n+-- https://github.com/neovim/neovim/pull/24338\n+local cmd = function(disp)\n+  -- Store dispatchers to use for showing progress notifications\n+  dispatchers = disp\n+  local res, closing, request_id = {}, false, 0\n+\n+  function res.request(method, params, callback)\n+    local method_impl = methods[method]\n+    if method_impl ~= nil then\n+      method_impl(params, callback)\n+    end\n+    request_id = request_id + 1\n+    return true, request_id\n+  end\n+\n+  function res.notify(method, _)\n+    if method == 'exit' then\n+      dispatchers.on_exit(0, 15)\n+    end\n+    return false\n+  end\n+\n+  function res.is_closed()\n+    return closing\n+  end\n+\n+  function res.terminate()\n+    closing = true\n+  end\n+\n+  return res\n+end\n+\n+M.client_id = vim.lsp.start(\n+  { cmd = cmd, name = 'vim.pack', root_dir = vim.uv.cwd() },\n+  { attach = false }\n+)\n+\n+local progress_token_count = 0\n+\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+function M.new_progress_report(title)\n+  progress_token_count = progress_token_count + 1\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local value = { kind = kind, message = msg, percentage = percent }\n+    if kind == 'begin' then\n+      value.title = title\n+    elseif kind == 'end' then\n+      value.percentage = nil\n+    end\n+    dispatchers.notification('$/progress', { token = progress_token_count, value = value })",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126685704",
            "id": 2126685704,
            "in_reply_to_id": 2123790910,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-wqYI",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 182,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack/_lsp.lua",
            "position": null,
            "pull_request_review_id": 2896869342,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126685704/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T14:01:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126685704",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126905831"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126905831"
                }
            },
            "author_association": "MEMBER",
            "body": "My preference would be `url` and `revision`.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T15:36:08Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126905831",
            "id": 2126905831,
            "in_reply_to_id": 2087290998,
            "line": 220,
            "node_id": "PRRC_kwDOAPphoM5-xgHn",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 220,
            "original_position": 197,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 220,
            "pull_request_review_id": 2897234651,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126905831/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T15:36:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126905831",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126930386"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126930386"
                }
            },
            "author_association": "MEMBER",
            "body": "Can `report_progress` be pulled in from the callers and instead this argument is replaced with a string which is used the initialize `report_progress`?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T15:48:17Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126930386",
            "id": 2126930386,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xmHS",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 372,
            "original_position": 372,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126930386/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126930386",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126932032"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126932032"
                }
            },
            "author_association": "MEMBER",
            "body": "This actually break typing. I found type errors when I removed these and gated the calls to `prepare` and `process`",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T15:49:09Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126932032",
            "id": 2126932032,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xmhA",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 373,
            "original_position": 373,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126932032/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126932032",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126941070"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126941070"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this number is too reserved. \r\n\r\nFirstly, it's unlikely nvim will run anything on other cores so using CPU cores as an input is quite fuzzy.\r\n\r\nSecondly, a single core can happily run many threads as that is the main task of the OS. For example right now my mouse driver is using 120 threads and firefox is using 100 threads.\r\n\r\nnvim-treesitter and pckr.nvim use somwhere between 50-100 threads.\r\n\r\nSo instead of a `0.8` I suggest you just crank this up to at least 2 or even 4, so for example on a Macbook air with 8 cores, you get 16 or 32 threads, which is still quite conservative.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T15:53:33Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126941070",
            "id": 2126941070,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xouO",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126941070/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126941070",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126950179"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126950179"
                }
            },
            "author_association": "MEMBER",
            "body": "Can this block be outlined into a function that returns a boolean.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T15:58:19Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126950179",
            "id": 2126950179,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xq8j",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 441,
            "original_position": 476,
            "original_start_line": 459,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126950179/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126950179",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126956351"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126956351"
                }
            },
            "author_association": "MEMBER",
            "body": "can you break these kinds of decls/assignments. It's not too bad when the RHS are simple expressions (e.g. `0, 0`), but when they are more complex expressions this becomes hard to read. This is especially true if the RHS is a function call since they can return multiple values.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:01:36Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126956351",
            "id": 2126956351,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xsc_",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 601,
            "original_position": 601,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126956351/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126956351",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126962338"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126962338"
                }
            },
            "author_association": "MEMBER",
            "body": "Unless you're working with booleans, I find it's cleaner to rely on the truthiness of the value.\r\n\r\n```suggestion\r\n      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\r\n      local is_in_range = ver_tag and version:has(ver_tag)\r\n      if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\r\n        p.info.version_str, last_ver_tag = tag, ver_tag\r\n      end\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:05:01Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126962338",
            "id": 2126962338,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xt6i",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 614,
            "original_position": 614,
            "original_start_line": 610,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126962338/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126962338",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126963301"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126963301"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    for tag in vim.gsplit(cur_tags, '\\n') do\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:05:34Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126963301",
            "id": 2126963301,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xuJl",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 674,
            "original_position": 674,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126963301/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126963301",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126966507"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126966507"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    if warn ~= '' then\r\n      notify(('Warnings in `%s` during %s:\\n%s'):format(name, action_name, warn), 'WARN')\r\n    end\r\n    local err = p.job.err\r\n    if err ~= '' then\r\n      error(('Error in `%s` during %s:\\n%s'):format(name, action_name, err))\r\n    end\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:07:31Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126966507",
            "id": 2126966507,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xu7r",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 707,
            "original_position": 707,
            "original_start_line": 699,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126966507/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126966507",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126972372"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126972372"
                }
            },
            "author_association": "MEMBER",
            "body": "There are redundant `fs_stat` calls here which can be reduced. You can add a private `installed: boolean?` field to `vim.pack.Plug` to effectively cache these calls. `nil`: unknown, `true`: installed, `false`: not installed.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:10:37Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126972372",
            "id": 2126972372,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xwXU",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 791,
            "original_position": 791,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126972372/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:23:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126972372",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126976540"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126976540"
                }
            },
            "author_association": "MEMBER",
            "body": "If a string has multiple concatenations, best to use `string.format`.\r\n\r\n```suggestion\r\n    return ('## %s\\n\\n %s':format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  ')\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:12:54Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126976540",
            "id": 2126976540,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xxYc",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 804,
            "original_position": 804,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126976540/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126976540",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126984146"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126984146"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    parts[#parts + 1] = table.concat({\r\n      'Path:         ' .. p.plug.path,\r\n      'Source:       ' .. p.plug.spec.source,\r\n      'State before: ' .. p.info.sha_head,\r\n      'State after:  ' .. p.info.sha_target .. version_suffix,\r\n      ''\r\n      'Pending updates:' \r\n       p.info.update_details,\r\n    }, '\\n')\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:16:53Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and ''\n+    or string.format(' (%s)', p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    table.insert(parts, 'Path:   ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source: ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State:  ' .. p.info.sha_target .. version_suffix)\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      table.insert(parts, '\\n\\nAvailable newer tags:\\n• ' .. details)\n+    end\n+  else\n+    table.insert(parts, 'Path:         ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source:       ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State before: ' .. p.info.sha_head .. '\\n')\n+    table.insert(parts, 'State after:  ' .. p.info.sha_target .. version_suffix)\n+\n+    table.insert(parts, '\\n\\nPending updates:\\n' .. p.info.update_details)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126984146",
            "id": 2126984146,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-xzPS",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 826,
            "original_position": 826,
            "original_start_line": 821,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126984146/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126984146",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126988212"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126988212"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- @param lines string[]\r\n--- @param on_finish fun()\r\nlocal function show_confirm_buf(lines, on_finish)\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:19:19Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and ''\n+    or string.format(' (%s)', p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    table.insert(parts, 'Path:   ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source: ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State:  ' .. p.info.sha_target .. version_suffix)\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      table.insert(parts, '\\n\\nAvailable newer tags:\\n• ' .. details)\n+    end\n+  else\n+    table.insert(parts, 'Path:         ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source:       ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State before: ' .. p.info.sha_head .. '\\n')\n+    table.insert(parts, 'State after:  ' .. p.info.sha_target .. version_suffix)\n+\n+    table.insert(parts, '\\n\\nPending updates:\\n' .. p.info.update_details)\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = string.format('========== Update %s ==========', get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+local function show_confirm_buf(lines, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126988212",
            "id": 2126988212,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-x0O0",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 876,
            "original_position": 876,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126988212/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126988212",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2126990106"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126990106"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    on_finish(bufnr)\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:20:25Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and ''\n+    or string.format(' (%s)', p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    table.insert(parts, 'Path:   ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source: ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State:  ' .. p.info.sha_target .. version_suffix)\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      table.insert(parts, '\\n\\nAvailable newer tags:\\n• ' .. details)\n+    end\n+  else\n+    table.insert(parts, 'Path:         ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source:       ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State before: ' .. p.info.sha_head .. '\\n')\n+    table.insert(parts, 'State after:  ' .. p.info.sha_target .. version_suffix)\n+\n+    table.insert(parts, '\\n\\nPending updates:\\n' .. p.info.update_details)\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = string.format('========== Update %s ==========', get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+local function show_confirm_buf(lines, opts)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num, win_id = api.nvim_tabpage_get_number(0), api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    opts.exec_on_write(bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2126990106",
            "id": 2126990106,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-x0sa",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 892,
            "original_position": 892,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897276185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126990106/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:22:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2126990106",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2127002099"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2127002099"
                }
            },
            "author_association": "MEMBER",
            "body": "You'll be hit by GH rate limits before anything happens anyway. (Unless you're on Windows, which is a crybaby.)\r\n\r\nNvim-treesitter experience is that 10 parallel jobs that actually download things is mostly safe for CI; on my local Macbook, I don't need any throttling because of the heterogeneous nature of the tasks. On a simple chained `git ls-remote`, about 100 parallel jobs seems to be the breaking point.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-04T16:27:22Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2127002099",
            "id": 2127002099,
            "in_reply_to_id": 2126941070,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-x3nz",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2897389823,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2127002099/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-04T16:29:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2127002099",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2128533959"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128533959"
                }
            },
            "author_association": "MEMBER",
            "body": "> Firstly, it's unlikely nvim will run anything on other cores so using CPU cores as an input is quite fuzzy.\r\n> \r\n> Secondly, a single core can happily run many threads as that is the main task of the OS. For example right now my mouse driver is using 120 threads and firefox is using 100 threads.\r\n\r\nDespite the `cpu_info()` name, its output *seems* to be the number of available *threads*, not cores. For example, for me it returns 12 (as is number of threads) instead of 6 (the number of cores). So the default value is basically \"80% of all available threads\".\r\n\r\nOr do I misunderstand the output of `vim.uv.cpu_info()`?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-05T10:40:22Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2128533959",
            "id": 2128533959,
            "in_reply_to_id": 2126941070,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-3tnH",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2899790428,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128533959/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-05T10:40:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128533959",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2128551370"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128551370"
                }
            },
            "author_association": "MEMBER",
            "body": "These are hardware threads, not software/os threads, very different things. A hardware thread can run many os threads.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-05T10:50:46Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2128551370",
            "id": 2128551370,
            "in_reply_to_id": 2126941070,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-3x3K",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 376,
            "original_position": 376,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2899817801,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128551370/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-05T10:50:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2128551370",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2129401858"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129401858"
                }
            },
            "author_association": "MEMBER",
            "body": "I opted for separate assignments in most places, except where it felt like simple expressions.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-05T17:11:53Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2129401858",
            "id": 2129401858,
            "in_reply_to_id": 2126956351,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-7BgC",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 601,
            "original_position": 601,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2901217648,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129401858/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-05T17:11:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129401858",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2129407076"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129407076"
                }
            },
            "author_association": "MEMBER",
            "body": "I also opted for consistently using `('text'):format(...)` style instead of `string.format('text', ...)`.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-05T17:13:03Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local confirm_msg = 'These plugins will be installed:\\n\\n' .. table.concat(sources, '\\n') .. '\\n'\n+  --- @type integer\n+  local confirm_res\n+  if vim.v.vim_did_enter == 1 then\n+    confirm_res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question')\n+  else\n+    -- Work around confirmation message not showing during startup.\n+    -- This is a semi-regression of #31525: some redraw during startup makes\n+    -- confirmation message disappear.\n+    -- TODO: Remove when #34088 is resolved.\n+    confirm_msg = confirm_msg .. '\\nProceed? [Y]es, (N)o'\n+    vim.defer_fn(function()\n+      vim.print(confirm_msg)\n+    end, 100)\n+    local ok, char = pcall(vim.fn.getcharstr)\n+    confirm_res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+    vim.cmd.redraw()\n+  end\n+\n+  if confirm_res ~= 1 then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack._lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches, tags = git_get_branches(p.plug.path), git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_sync, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = string.format('`%s` is not a branch/tag/commit. Available:', version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str, p.info.version_ref = version, (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      error(msg)\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2129407076",
            "id": 2129407076,
            "in_reply_to_id": 2126976540,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-7Cxk",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 804,
            "original_position": 804,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2901224394,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129407076/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-05T17:13:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2129407076",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132076918"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132076918"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n  local name = (spec.name or spec.source):match('[^/]+$'):gsub('%.git$', '')\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T12:08:57Z",
            "diff_hunk": "@@ -0,0 +1,1105 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132076918",
            "id": 2132076918,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_FOl2",
            "original_commit_id": "359f235d78f8ee552a7ae0d94f1d93d602db908e",
            "original_line": 252,
            "original_position": 252,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2904727972,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132076918/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-06T12:09:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132076918",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132084538"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132084538"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I would personally prefer the golang like convention because is much more simple and straight foward to implement (also I find it more familiar). But I don't really mind also the more nix like `<host>:<user>/<repo`, you just need to handle it a bit more than just prepend a protocol.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T12:13:50Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132084538",
            "id": 2132084538,
            "in_reply_to_id": 2087294117,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_FQc6",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 241,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2904741157,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132084538/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-06T12:13:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132084538",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132093865"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132093865"
                }
            },
            "author_association": "MEMBER",
            "body": "These should be merged now we have async.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T12:20:20Z",
            "diff_hunk": "@@ -0,0 +1,1105 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @async\n+--- @package\n+--- @param prepare? async fun(job: vim.pack.PlugJob): nil\n+--- @param process? async fun(job: vim.pack.PlugJob): nil\n+--- @param progress_title? string\n+function PlugList:run(prepare, process, progress_title)\n+  prepare = prepare or function(_) end\n+  process = process or function(_) end\n+  local report_progress = function(_, _, _) end\n+  if progress_title ~= nil then\n+    report_progress = require('vim.pack._lsp').new_progress_report(progress_title)\n+  end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_finished = #list_noerror, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(list_noerror) do\n+    --- @async\n+    funs[#funs + 1] = function()\n+      prepare(p)\n+      if #p.job.cmd == 0 or p.job.err ~= '' then\n+        register_finished()\n+        return\n+      end\n+\n+      local sys_opts = { cwd = p.job.cwd, text = true, clear_env = true }\n+      local sys_res = async.await(3, vim.system, p.job.cmd, sys_opts) --- @type vim.SystemCompleted\n+      async.await(1, vim.schedule)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+    end\n+  end\n+\n+  async.join(n_threads, funs)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd = {}\n+    p.job.cwd = p.plug.path\n+    p.job.out = ''\n+  end\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  self:run(prepare, nil, 'Installing plugins')\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.plug.spec.name), 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  self:run(prepare, nil, 'Downloading updates')\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches = git_get_branches(p.plug.path)\n+    local tags = git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str = version\n+      p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag and version:has(ver_tag)\n+      if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from = p.info.sha_head\n+    local to = p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags pointing at target (there might be several)\n+    local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for tag in vim.gsplit(cur_tags, '\\n') do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @async\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name = p.plug.spec.name\n+    local warn = p.info.warn\n+    if warn ~= '' then\n+      notify(('Warnings in `%s` during %s:\\n%s'):format(name, action_name, warn), 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      error(('Error in `%s` during %s:\\n%s'):format(name, action_name, err))\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    --- @async\n+    local function do_install()\n+      pluglist_to_install:install()\n+    end\n+    async.run(do_install):wait()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.plug.path,\n+      'Source: ' .. p.plug.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.plug.path,\n+      'Source:       ' .. p.plug.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = ('========== Update %s =========='):format(get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun(bufnr: integer)\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'\n+\n+  -- Attach in-process LSP for more capabilities\n+  vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_confirm(plug_list)\n+  local function finish_update(_)\n+    -- TODO(echasnovski): Allow to not update all plugins via LSP code actions\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.job.err == ''\n+    end, plug_list.list)\n+\n+    --- @async\n+    async.run(function()\n+      plug_list:checkout({ skip_same_sha = true })\n+      feedback_log(plug_list)\n+    end)\n+  end\n+\n+  -- Show report in new buffer in separate tabpage\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = false })\n+  show_confirm_buf(lines, finish_update)\n+end\n+\n+--- @class vim.pack.keyset.update\n+--- @inlinedoc\n+--- @field force? boolean Whether to skip confirmation and make updates immediately. Default `false`.\n+\n+--- Update plugins\n+---\n+--- - Download new changes from source.\n+--- - Infer update info (current/target state, changelog, etc.).\n+--- - Depending on `force`:\n+---     - If `false`, show confirmation buffer. It lists data about all set to\n+---       update plugins. Pending changes starting with `>` will be applied while\n+---       the ones starting with `<` will be reverted.\n+---       It has special in-process LSP server attached to provide more interactive\n+---       features. Currently supported methods:\n+---         - 'textDocument/documentSymbol' (`gO` via |lsp-defaults|\n+---           or |vim.lsp.buf.document_symbol()|) - show structure of the buffer.\n+---         - 'textDocument/hover' (`K` via |lsp-defaults| or |vim.lsp.buf.hover()|) -\n+---           show more information at cursor. Like details of particular pending\n+---           change or newer tag.\n+---\n+---       Execute |:write| to confirm update, execute |:quit| to discard the update.\n+---     - If `true`, make updates right away.\n+---\n+--- Notes:\n+--- - Every actual update is logged in \"nvimpack.log\" file inside \"log\" |stdpath()|.\n+---\n+--- @param names? string[] List of plugin names to update. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+--- Default: names of all plugins added to current session via |vim.pack.add()|.\n+--- @param opts? vim.pack.keyset.update\n+function M.update(names, opts)\n+  vim.validate('names', names, vim.islist, true, 'list')\n+  opts = vim.tbl_extend('force', { force = false }, opts or {})\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to update', 'WARN')\n+    return\n+  end\n+  git_ensure_exec()\n+\n+  --- @async\n+  local function do_update()\n+    -- Download new changes\n+    plug_list:download_updates()\n+\n+    -- Compute change info: changelog if any, new tags if nothing to update\n+    plug_list:infer_update_details()",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132093865",
            "id": 2132093865,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_FSup",
            "original_commit_id": "359f235d78f8ee552a7ae0d94f1d93d602db908e",
            "original_line": 1017,
            "original_position": 1017,
            "original_start_line": 1014,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2904756044,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132093865/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-06T12:31:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132093865",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132095047"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132095047"
                }
            },
            "author_association": "MEMBER",
            "body": "The trigger event should be called for a _single_ plugin and the start and end of the loop body.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T12:21:13Z",
            "diff_hunk": "@@ -0,0 +1,1105 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @async\n+--- @package\n+--- @param prepare? async fun(job: vim.pack.PlugJob): nil\n+--- @param process? async fun(job: vim.pack.PlugJob): nil\n+--- @param progress_title? string\n+function PlugList:run(prepare, process, progress_title)\n+  prepare = prepare or function(_) end\n+  process = process or function(_) end\n+  local report_progress = function(_, _, _) end\n+  if progress_title ~= nil then\n+    report_progress = require('vim.pack._lsp').new_progress_report(progress_title)\n+  end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_finished = #list_noerror, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(list_noerror) do\n+    --- @async\n+    funs[#funs + 1] = function()\n+      prepare(p)\n+      if #p.job.cmd == 0 or p.job.err ~= '' then\n+        register_finished()\n+        return\n+      end\n+\n+      local sys_opts = { cwd = p.job.cwd, text = true, clear_env = true }\n+      local sys_res = async.await(3, vim.system, p.job.cmd, sys_opts) --- @type vim.SystemCompleted\n+      async.await(1, vim.schedule)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+    end\n+  end\n+\n+  async.join(n_threads, funs)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd = {}\n+    p.job.cwd = p.plug.path\n+    p.job.out = ''\n+  end\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  self:run(prepare, nil, 'Installing plugins')\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.plug.spec.name), 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  self:run(prepare, nil, 'Downloading updates')\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches = git_get_branches(p.plug.path)\n+    local tags = git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str = version\n+      p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag and version:has(ver_tag)\n+      if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from = p.info.sha_head\n+    local to = p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags pointing at target (there might be several)\n+    local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for tag in vim.gsplit(cur_tags, '\\n') do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @async\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name = p.plug.spec.name\n+    local warn = p.info.warn\n+    if warn ~= '' then\n+      notify(('Warnings in `%s` during %s:\\n%s'):format(name, action_name, warn), 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      error(('Error in `%s` during %s:\\n%s'):format(name, action_name, err))\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    --- @async\n+    local function do_install()\n+      pluglist_to_install:install()\n+    end\n+    async.run(do_install):wait()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.plug.path,\n+      'Source: ' .. p.plug.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.plug.path,\n+      'Source:       ' .. p.plug.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = ('========== Update %s =========='):format(get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun(bufnr: integer)\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'\n+\n+  -- Attach in-process LSP for more capabilities\n+  vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_confirm(plug_list)\n+  local function finish_update(_)\n+    -- TODO(echasnovski): Allow to not update all plugins via LSP code actions\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.job.err == ''\n+    end, plug_list.list)\n+\n+    --- @async\n+    async.run(function()\n+      plug_list:checkout({ skip_same_sha = true })\n+      feedback_log(plug_list)\n+    end)\n+  end\n+\n+  -- Show report in new buffer in separate tabpage\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = false })\n+  show_confirm_buf(lines, finish_update)\n+end\n+\n+--- @class vim.pack.keyset.update\n+--- @inlinedoc\n+--- @field force? boolean Whether to skip confirmation and make updates immediately. Default `false`.\n+\n+--- Update plugins\n+---\n+--- - Download new changes from source.\n+--- - Infer update info (current/target state, changelog, etc.).\n+--- - Depending on `force`:\n+---     - If `false`, show confirmation buffer. It lists data about all set to\n+---       update plugins. Pending changes starting with `>` will be applied while\n+---       the ones starting with `<` will be reverted.\n+---       It has special in-process LSP server attached to provide more interactive\n+---       features. Currently supported methods:\n+---         - 'textDocument/documentSymbol' (`gO` via |lsp-defaults|\n+---           or |vim.lsp.buf.document_symbol()|) - show structure of the buffer.\n+---         - 'textDocument/hover' (`K` via |lsp-defaults| or |vim.lsp.buf.hover()|) -\n+---           show more information at cursor. Like details of particular pending\n+---           change or newer tag.\n+---\n+---       Execute |:write| to confirm update, execute |:quit| to discard the update.\n+---     - If `true`, make updates right away.\n+---\n+--- Notes:\n+--- - Every actual update is logged in \"nvimpack.log\" file inside \"log\" |stdpath()|.\n+---\n+--- @param names? string[] List of plugin names to update. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+--- Default: names of all plugins added to current session via |vim.pack.add()|.\n+--- @param opts? vim.pack.keyset.update\n+function M.update(names, opts)\n+  vim.validate('names', names, vim.islist, true, 'list')\n+  opts = vim.tbl_extend('force', { force = false }, opts or {})\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to update', 'WARN')\n+    return\n+  end\n+  git_ensure_exec()\n+\n+  --- @async\n+  local function do_update()\n+    -- Download new changes\n+    plug_list:download_updates()\n+\n+    -- Compute change info: changelog if any, new tags if nothing to update\n+    plug_list:infer_update_details()\n+\n+    -- Perform update\n+    if not opts.force then\n+      feedback_confirm(plug_list)\n+      return\n+    end\n+\n+    plug_list:checkout({ skip_same_sha = true })\n+    feedback_log(plug_list)\n+  end\n+  async.run(do_update):wait()\n+end\n+\n+--- Remove plugins from disk\n+---\n+--- @param names string[] List of plugin names to remove from disk. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+function M.del(names)\n+  vim.validate('names', names, vim.islist, false, 'list')\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to remove', 'WARN')\n+    return\n+  end\n+\n+  --- @async\n+  async.run(function()\n+    plug_list:trigger_event('PackDeletePre')\n+    for _, p in ipairs(plug_list.list) do\n+      vim.fs.rm(p.plug.path, { recursive = true, force = true })\n+      added_plugins[p.plug.path] = nil\n+      notify('Removed plugin `' .. p.plug.spec.name .. '`', 'INFO')\n+    end\n+    plug_list:trigger_event('PackDelete')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132095047",
            "id": 2132095047,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_FTBH",
            "original_commit_id": "359f235d78f8ee552a7ae0d94f1d93d602db908e",
            "original_line": 1052,
            "original_position": 1052,
            "original_start_line": 1046,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2904756044,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132095047/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-06T12:31:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132095047",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132126193"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132126193"
                }
            },
            "author_association": "MEMBER",
            "body": "> The trigger event should be called for a _single_ plugin and the start and end of the loop body.\r\n\r\nWhy triggering event inside a loop is important? Right now events are triggered for every deleted plugin, just before and after *all* of them are deleted. This is the same approach as with other events, which is important for 'install' and 'update' events and here is just convenient to reuse.\r\n\r\nTriggering `'PackDelete'` for 'plugin1' while some 'plugin2'  is \"scheduled to be deleted\" can be confusing for autocommand callbacks if they condition themselves on presence of that 'plugin2'.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T12:42:05Z",
            "diff_hunk": "@@ -0,0 +1,1105 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @async\n+--- @package\n+--- @param prepare? async fun(job: vim.pack.PlugJob): nil\n+--- @param process? async fun(job: vim.pack.PlugJob): nil\n+--- @param progress_title? string\n+function PlugList:run(prepare, process, progress_title)\n+  prepare = prepare or function(_) end\n+  process = process or function(_) end\n+  local report_progress = function(_, _, _) end\n+  if progress_title ~= nil then\n+    report_progress = require('vim.pack._lsp').new_progress_report(progress_title)\n+  end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_finished = #list_noerror, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(list_noerror) do\n+    --- @async\n+    funs[#funs + 1] = function()\n+      prepare(p)\n+      if #p.job.cmd == 0 or p.job.err ~= '' then\n+        register_finished()\n+        return\n+      end\n+\n+      local sys_opts = { cwd = p.job.cwd, text = true, clear_env = true }\n+      local sys_res = async.await(3, vim.system, p.job.cmd, sys_opts) --- @type vim.SystemCompleted\n+      async.await(1, vim.schedule)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+    end\n+  end\n+\n+  async.join(n_threads, funs)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd = {}\n+    p.job.cwd = p.plug.path\n+    p.job.out = ''\n+  end\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  self:run(prepare, nil, 'Installing plugins')\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.plug.spec.name), 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  self:run(prepare, nil, 'Downloading updates')\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches = git_get_branches(p.plug.path)\n+    local tags = git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str = version\n+      p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag and version:has(ver_tag)\n+      if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from = p.info.sha_head\n+    local to = p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags pointing at target (there might be several)\n+    local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for tag in vim.gsplit(cur_tags, '\\n') do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @async\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name = p.plug.spec.name\n+    local warn = p.info.warn\n+    if warn ~= '' then\n+      notify(('Warnings in `%s` during %s:\\n%s'):format(name, action_name, warn), 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      error(('Error in `%s` during %s:\\n%s'):format(name, action_name, err))\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    --- @async\n+    local function do_install()\n+      pluglist_to_install:install()\n+    end\n+    async.run(do_install):wait()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.plug.path,\n+      'Source: ' .. p.plug.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.plug.path,\n+      'Source:       ' .. p.plug.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = ('========== Update %s =========='):format(get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun(bufnr: integer)\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'\n+\n+  -- Attach in-process LSP for more capabilities\n+  vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_confirm(plug_list)\n+  local function finish_update(_)\n+    -- TODO(echasnovski): Allow to not update all plugins via LSP code actions\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.job.err == ''\n+    end, plug_list.list)\n+\n+    --- @async\n+    async.run(function()\n+      plug_list:checkout({ skip_same_sha = true })\n+      feedback_log(plug_list)\n+    end)\n+  end\n+\n+  -- Show report in new buffer in separate tabpage\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = false })\n+  show_confirm_buf(lines, finish_update)\n+end\n+\n+--- @class vim.pack.keyset.update\n+--- @inlinedoc\n+--- @field force? boolean Whether to skip confirmation and make updates immediately. Default `false`.\n+\n+--- Update plugins\n+---\n+--- - Download new changes from source.\n+--- - Infer update info (current/target state, changelog, etc.).\n+--- - Depending on `force`:\n+---     - If `false`, show confirmation buffer. It lists data about all set to\n+---       update plugins. Pending changes starting with `>` will be applied while\n+---       the ones starting with `<` will be reverted.\n+---       It has special in-process LSP server attached to provide more interactive\n+---       features. Currently supported methods:\n+---         - 'textDocument/documentSymbol' (`gO` via |lsp-defaults|\n+---           or |vim.lsp.buf.document_symbol()|) - show structure of the buffer.\n+---         - 'textDocument/hover' (`K` via |lsp-defaults| or |vim.lsp.buf.hover()|) -\n+---           show more information at cursor. Like details of particular pending\n+---           change or newer tag.\n+---\n+---       Execute |:write| to confirm update, execute |:quit| to discard the update.\n+---     - If `true`, make updates right away.\n+---\n+--- Notes:\n+--- - Every actual update is logged in \"nvimpack.log\" file inside \"log\" |stdpath()|.\n+---\n+--- @param names? string[] List of plugin names to update. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+--- Default: names of all plugins added to current session via |vim.pack.add()|.\n+--- @param opts? vim.pack.keyset.update\n+function M.update(names, opts)\n+  vim.validate('names', names, vim.islist, true, 'list')\n+  opts = vim.tbl_extend('force', { force = false }, opts or {})\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to update', 'WARN')\n+    return\n+  end\n+  git_ensure_exec()\n+\n+  --- @async\n+  local function do_update()\n+    -- Download new changes\n+    plug_list:download_updates()\n+\n+    -- Compute change info: changelog if any, new tags if nothing to update\n+    plug_list:infer_update_details()\n+\n+    -- Perform update\n+    if not opts.force then\n+      feedback_confirm(plug_list)\n+      return\n+    end\n+\n+    plug_list:checkout({ skip_same_sha = true })\n+    feedback_log(plug_list)\n+  end\n+  async.run(do_update):wait()\n+end\n+\n+--- Remove plugins from disk\n+---\n+--- @param names string[] List of plugin names to remove from disk. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+function M.del(names)\n+  vim.validate('names', names, vim.islist, false, 'list')\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to remove', 'WARN')\n+    return\n+  end\n+\n+  --- @async\n+  async.run(function()\n+    plug_list:trigger_event('PackDeletePre')\n+    for _, p in ipairs(plug_list.list) do\n+      vim.fs.rm(p.plug.path, { recursive = true, force = true })\n+      added_plugins[p.plug.path] = nil\n+      notify('Removed plugin `' .. p.plug.spec.name .. '`', 'INFO')\n+    end\n+    plug_list:trigger_event('PackDelete')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132126193",
            "id": 2132126193,
            "in_reply_to_id": 2132095047,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_Fanx",
            "original_commit_id": "359f235d78f8ee552a7ae0d94f1d93d602db908e",
            "original_line": 1052,
            "original_position": 1052,
            "original_start_line": 1046,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2904807138,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132126193/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-06T12:42:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132126193",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132533720"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132533720"
                }
            },
            "author_association": "MEMBER",
            "body": "If I understood correctly, you wanted to have `if prepare ~= nil then prepare(p) end` type of invocation instead of prior inferring with `prepare or function(_) end`. I've replaced it, but there were no new errors.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T16:50:45Z",
            "diff_hunk": "@@ -0,0 +1,1059 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+local function git_get_default_branch(cwd)\n+  local res = cli_sync(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref, spec = p_data.plug.spec, p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1, src_2 = tostring(spec_ref.source), tostring(spec.source)\n+      local msg = string.format('Conflicting `source` for `%s`:\\n%s\\n%s', spec.name, src_1, src_2)\n+      error(msg)\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1, ver_2 = tostring(spec_ref.version), tostring(spec.version)\n+      local msg = string.format('Conflicting `version` for `%s`:\\n%s\\n%s', spec.name, ver_1, ver_2)\n+      error(msg)\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins, plugs = M.get(), {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132533720",
            "id": 2132533720,
            "in_reply_to_id": 2126932032,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_G-HY",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 373,
            "original_position": 373,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2905492761,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132533720/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-06T16:50:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132533720",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132534911"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132534911"
                }
            },
            "author_association": "MEMBER",
            "body": "I've resorted to only using `print()` with an extensively documented TODO on how to improve this later.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T16:51:30Z",
            "diff_hunk": "@@ -0,0 +1,186 @@\n+local M = {}\n+\n+local capabilities = {\n+  codeActionProvider = true,\n+  documentSymbolProvider = true,\n+  hoverProvider = true,\n+}\n+--- @type table<string,function>\n+local methods = {}\n+\n+--- @param callback function\n+function methods.initialize(_, callback)\n+  return callback(nil, { capabilities = capabilities })\n+end\n+\n+--- @param callback function\n+function methods.shutdown(_, callback)\n+  return callback(nil, nil)\n+end\n+\n+local get_confirm_bufnr = function(uri)\n+  return tonumber(uri:match('^nvimpack://(%d+)/confirm%-update$'))\n+end\n+\n+--- @param params { textDocument: { uri: string } }\n+--- @param callback function\n+methods['textDocument/documentSymbol'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return callback(nil, {})\n+  end\n+\n+  --- @alias vim.pack.lsp.Position { line: integer, character: integer }\n+  --- @alias vim.pack.lsp.Range { start: vim.pack.lsp.Position, end: vim.pack.lsp.Position }\n+  --- @alias vim.pack.lsp.Symbol {\n+  ---   name: string,\n+  ---   kind: number,\n+  ---   range: vim.pack.lsp.Range,\n+  ---   selectionRange: vim.pack.lsp.Range,\n+  ---   children: vim.pack.lsp.Symbol[]?,\n+  --- }\n+\n+  --- @return vim.pack.lsp.Symbol?\n+  local new_symbol = function(name, start_line, end_line, kind)\n+    if name == nil then\n+      return nil\n+    end\n+    local range = {\n+      start = { line = start_line, character = 0 },\n+      ['end'] = { line = end_line, character = 0 },\n+    }\n+    return { name = name, kind = kind, range = range, selectionRange = range }\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+\n+  --- @return vim.pack.lsp.Symbol[]\n+  local parse_headers = function(pattern, start_line, end_line, kind)\n+    local res, cur_match, cur_start = {}, nil, nil\n+    for i = start_line, end_line do\n+      local m = lines[i + 1]:match(pattern)\n+      if m ~= nil and m ~= cur_match then\n+        table.insert(res, new_symbol(cur_match, cur_start, i, kind))\n+        cur_match, cur_start = m, i\n+      end\n+    end\n+    table.insert(res, new_symbol(cur_match, cur_start, end_line, kind))\n+    return res\n+  end\n+\n+  local group_kind = vim.lsp.protocol.SymbolKind.Namespace\n+  local symbols = parse_headers('^# (%S+)', 0, #lines - 1, group_kind)\n+\n+  local plug_kind = vim.lsp.protocol.SymbolKind.Module\n+  for _, group in ipairs(symbols) do\n+    local start_line, end_line = group.range.start.line, group.range['end'].line\n+    group.children = parse_headers('^## (.+)$', start_line, end_line, plug_kind)\n+  end\n+\n+  return callback(nil, symbols)\n+end\n+\n+--- @param callback function\n+methods['textDocument/codeAction'] = function(_, callback)\n+  -- TODO(echasnovski)\n+  -- Suggested actions for \"plugin under cursor\":\n+  -- - Delete plugin from disk.\n+  -- - Update only this plugin.\n+  -- - Exclude this plugin from update.\n+  return callback(_, {})\n+end\n+\n+--- @param params { textDocument: { uri: string }, position: { line: integer, character: integer } }\n+--- @param callback function\n+methods['textDocument/hover'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local lnum = params.position.line + 1\n+  local commit = lines[lnum]:match('^[<>] (%x+) │') or lines[lnum]:match('^State.*:%s+(%x+)')\n+  local tag = lines[lnum]:match('^• (.+)$')\n+  if commit == nil and tag == nil then\n+    return\n+  end\n+\n+  local path, path_lnum = nil, lnum - 1\n+  while path == nil and path_lnum >= 1 do\n+    path = lines[path_lnum]:match('^Path:%s+(.+)$')\n+    path_lnum = path_lnum - 1\n+  end\n+  if path == nil then\n+    return\n+  end\n+\n+  local cmd = { 'git', 'show', '--no-color', commit or tag }\n+  --- @param sys_out vim.SystemCompleted\n+  local on_exit = function(sys_out)\n+    local markdown = '```diff\\n' .. sys_out.stdout .. '\\n```'\n+    local res = { contents = { kind = vim.lsp.protocol.MarkupKind.Markdown, value = markdown } }\n+    callback(nil, res)\n+  end\n+  vim.system(cmd, { cwd = path }, vim.schedule_wrap(on_exit))\n+end\n+\n+local dispatchers = {}\n+\n+-- TODO: Simplify after `vim.lsp.server` is a thing\n+-- https://github.com/neovim/neovim/pull/24338\n+local cmd = function(disp)\n+  -- Store dispatchers to use for showing progress notifications\n+  dispatchers = disp\n+  local res, closing, request_id = {}, false, 0\n+\n+  function res.request(method, params, callback)\n+    local method_impl = methods[method]\n+    if method_impl ~= nil then\n+      method_impl(params, callback)\n+    end\n+    request_id = request_id + 1\n+    return true, request_id\n+  end\n+\n+  function res.notify(method, _)\n+    if method == 'exit' then\n+      dispatchers.on_exit(0, 15)\n+    end\n+    return false\n+  end\n+\n+  function res.is_closed()\n+    return closing\n+  end\n+\n+  function res.terminate()\n+    closing = true\n+  end\n+\n+  return res\n+end\n+\n+M.client_id = vim.lsp.start(\n+  { cmd = cmd, name = 'vim.pack', root_dir = vim.uv.cwd() },\n+  { attach = false }\n+)\n+\n+local progress_token_count = 0\n+\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+function M.new_progress_report(title)\n+  progress_token_count = progress_token_count + 1\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local value = { kind = kind, message = msg, percentage = percent }\n+    if kind == 'begin' then\n+      value.title = title\n+    elseif kind == 'end' then\n+      value.percentage = nil\n+    end\n+    dispatchers.notification('$/progress', { token = progress_token_count, value = value })",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132534911",
            "id": 2132534911,
            "in_reply_to_id": 2123790910,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_G-Z_",
            "original_commit_id": "8a829179c8e5839e35d0585250eed8d8d514148f",
            "original_line": 182,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack/_lsp.lua",
            "position": null,
            "pull_request_review_id": 2905495829,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132534911/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-06T16:51:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132534911",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2132567354"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132567354"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't quite understand. Merging them in a single function was possible even before there is `vim._async`.\r\n\r\nDo you suggest to go *now* with full refactor suggested [here](https://github.com/neovim/neovim/pull/34009#issuecomment-2940224254)? I.e. (if I understood correctly) remove the need of `prepare` / `process` in `PlugList:run()` and instead have something like `PlugList:run(f, progress_title)` that executes async `f` (with possibly several async-await consecutive steps) in parallel? If yes, this will take non-negligible amount of time. I don't say that this shouldn't be done at all, just that it won't gain much performance (only possibly better manageable code).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-06T17:11:37Z",
            "diff_hunk": "@@ -0,0 +1,1105 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- @package\n+--- @param names string[]?\n+--- @return vim.pack.PlugList\n+function PlugList.from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names, p_data.spec.name) then\n+      table.insert(plugs, { spec = p_data.spec, path = p_data.path })\n+    end\n+  end\n+\n+  return PlugList.new(plugs)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @async\n+--- @package\n+--- @param prepare? async fun(job: vim.pack.PlugJob): nil\n+--- @param process? async fun(job: vim.pack.PlugJob): nil\n+--- @param progress_title? string\n+function PlugList:run(prepare, process, progress_title)\n+  prepare = prepare or function(_) end\n+  process = process or function(_) end\n+  local report_progress = function(_, _, _) end\n+  if progress_title ~= nil then\n+    report_progress = require('vim.pack._lsp').new_progress_report(progress_title)\n+  end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_finished = #list_noerror, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(list_noerror) do\n+    --- @async\n+    funs[#funs + 1] = function()\n+      prepare(p)\n+      if #p.job.cmd == 0 or p.job.err ~= '' then\n+        register_finished()\n+        return\n+      end\n+\n+      local sys_opts = { cwd = p.job.cwd, text = true, clear_env = true }\n+      local sys_res = async.await(3, vim.system, p.job.cmd, sys_opts) --- @type vim.SystemCompleted\n+      async.await(1, vim.schedule)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+    end\n+  end\n+\n+  async.join(n_threads, funs)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd = {}\n+    p.job.cwd = p.plug.path\n+    p.job.out = ''\n+  end\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:install()\n+  -- Get user confirmation to install plugins\n+  --- @param p vim.pack.PlugJob\n+  local sources = vim.tbl_map(function(p)\n+    return p.plug.spec.source\n+  end, self.list)\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(self.list) do\n+      p.job.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  -- Trigger relevant event\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  self:run(prepare, nil, 'Installing plugins')\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.plug.spec.name), 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  self:run(prepare, nil, 'Downloading updates')\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:resolve_version()\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    if version == nil then\n+      p.info.version_str = git_get_default_branch(p.plug.path)\n+      p.info.version_ref = 'origin/' .. p.info.version_str\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    local branches = git_get_branches(p.plug.path)\n+    local tags = git_get_tags(p.plug.path)\n+    if type(version) == 'string' then\n+      local is_branch = vim.tbl_contains(branches, version)\n+      local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.plug.path)\n+      if not (is_branch or is_tag_or_hash) then\n+        p.job.err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+          .. list_in_line('Tags', tags)\n+          .. list_in_line('Branches', branches)\n+        return\n+      end\n+\n+      p.info.version_str = version\n+      p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag, semver_tags = nil, {}\n+    for _, tag in ipairs(tags) do\n+      local ver_tag = vim.version.parse(tag)\n+      table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+      local is_in_range = ver_tag and version:has(ver_tag)\n+      if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+        .. list_in_line('Versions', semver_tags)\n+        .. list_in_line('Branches', branches)\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @async\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from = p.info.sha_head\n+    local to = p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @async\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags pointing at target (there might be several)\n+    local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for tag in vim.gsplit(cur_tags, '\\n') do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @async\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name = p.plug.spec.name\n+    local warn = p.info.warn\n+    if warn ~= '' then\n+      notify(('Warnings in `%s` during %s:\\n%s'):format(name, action_name, warn), 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      error(('Error in `%s` during %s:\\n%s'):format(name, action_name, err))\n+    end\n+  end\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    --- @async\n+    local function do_install()\n+      pluglist_to_install:install()\n+    end\n+    async.run(do_install):wait()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.plug.spec.name, p.job.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.plug.path,\n+      'Source: ' .. p.plug.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.plug.path,\n+      'Source:       ' .. p.plug.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = ('========== Update %s =========='):format(get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun(bufnr: integer)\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'\n+\n+  -- Attach in-process LSP for more capabilities\n+  vim.lsp.buf_attach_client(bufnr, require('vim.pack._lsp').client_id)\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_confirm(plug_list)\n+  local function finish_update(_)\n+    -- TODO(echasnovski): Allow to not update all plugins via LSP code actions\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.job.err == ''\n+    end, plug_list.list)\n+\n+    --- @async\n+    async.run(function()\n+      plug_list:checkout({ skip_same_sha = true })\n+      feedback_log(plug_list)\n+    end)\n+  end\n+\n+  -- Show report in new buffer in separate tabpage\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = false })\n+  show_confirm_buf(lines, finish_update)\n+end\n+\n+--- @class vim.pack.keyset.update\n+--- @inlinedoc\n+--- @field force? boolean Whether to skip confirmation and make updates immediately. Default `false`.\n+\n+--- Update plugins\n+---\n+--- - Download new changes from source.\n+--- - Infer update info (current/target state, changelog, etc.).\n+--- - Depending on `force`:\n+---     - If `false`, show confirmation buffer. It lists data about all set to\n+---       update plugins. Pending changes starting with `>` will be applied while\n+---       the ones starting with `<` will be reverted.\n+---       It has special in-process LSP server attached to provide more interactive\n+---       features. Currently supported methods:\n+---         - 'textDocument/documentSymbol' (`gO` via |lsp-defaults|\n+---           or |vim.lsp.buf.document_symbol()|) - show structure of the buffer.\n+---         - 'textDocument/hover' (`K` via |lsp-defaults| or |vim.lsp.buf.hover()|) -\n+---           show more information at cursor. Like details of particular pending\n+---           change or newer tag.\n+---\n+---       Execute |:write| to confirm update, execute |:quit| to discard the update.\n+---     - If `true`, make updates right away.\n+---\n+--- Notes:\n+--- - Every actual update is logged in \"nvimpack.log\" file inside \"log\" |stdpath()|.\n+---\n+--- @param names? string[] List of plugin names to update. Must be managed\n+--- by |vim.pack|, not necessarily already added in current session.\n+--- Default: names of all plugins added to current session via |vim.pack.add()|.\n+--- @param opts? vim.pack.keyset.update\n+function M.update(names, opts)\n+  vim.validate('names', names, vim.islist, true, 'list')\n+  opts = vim.tbl_extend('force', { force = false }, opts or {})\n+\n+  local plug_list = PlugList.from_names(names)\n+  if #plug_list.list == 0 then\n+    notify('Nothing to update', 'WARN')\n+    return\n+  end\n+  git_ensure_exec()\n+\n+  --- @async\n+  local function do_update()\n+    -- Download new changes\n+    plug_list:download_updates()\n+\n+    -- Compute change info: changelog if any, new tags if nothing to update\n+    plug_list:infer_update_details()",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2132567354",
            "id": 2132567354,
            "in_reply_to_id": 2132093865,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_HGU6",
            "original_commit_id": "359f235d78f8ee552a7ae0d94f1d93d602db908e",
            "original_line": 1017,
            "original_position": 1017,
            "original_start_line": 1014,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2905547383,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132567354/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-06T17:11:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2132567354",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142634682"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142634682"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "You can just `vim.cmd.packadd(plug.spec.name .. \"/after\")` if it has one by the way, which I learned recently. No need to do this sourcing manually. And it will handle after/ftplugin that way as well (and others!)\r\n\r\nhttps://github.com/BirdeeHub/lzextras/blob/373ad5e3b223aad4eeee4376aa63b71466985da2/lua/lzextras/src/loaders.lua#L4-L7\r\n\r\nBeen using that for a while myself.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T12:38:34Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142634682",
            "id": 2142634682,
            "line": 625,
            "node_id": "PRRC_kwDOAPphoM5_tgK6",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 625,
            "original_position": 651,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 625,
            "pull_request_review_id": 2920979630,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142634682/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T12:50:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142634682",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142637867"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142637867"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "there should also be an `opt = true` to avoid calling packadd at all",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T12:40:15Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142637867",
            "id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_tg8r",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2920984460,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142637867/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T12:40:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142637867",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142642564"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142642564"
                }
            },
            "author_association": "MEMBER",
            "body": "This might be a topic for future discussions, not now.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T12:42:31Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142642564",
            "id": 2142642564,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_tiGE",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2920991720,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142642564/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T12:42:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142642564",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142649514"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142649514"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Im pretty sure that is like a 5 line change max? Plus some types? pack_add is called on line 710 it is easy to recieve and pass in the extra option there, and then in pack_add you just need to check and early return probably where you have the other early return? Or maybe right after the next block with the tracking stuff on line 640?\r\n\r\nOr you might even just be able to not call pack_add at all? unsure on that one, you have some tracking there before packadd, but you would either early return after that tracking block on line 640, or just not call it at all.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T12:46:07Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142649514",
            "id": 2142649514,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_tjyq",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2921003327,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142649514/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T13:00:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142649514",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142679495"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142679495"
                }
            },
            "author_association": "MEMBER",
            "body": "The focus here is to get a _minimal_ viable module merged so we can test and iterate on it during the 0.12 development cycle. Scope is determined by maintainers, not user requests.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T13:00:37Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142679495",
            "id": 2142679495,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_trHH",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2921049625,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142679495/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T13:00:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142679495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142692854"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142692854"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "When it merges people will start writing their configs to use it. I would argue that feature would be necessary in a minimal viable module. I suppose at the risk of being annoying I will PR it to echanovski later after I figure out what the implications of that tracking block on line 640 are for the change to figure out exactly where to skip from.\r\n\r\nI will also PR my other suggestion about using vim.cmd.packadd(plug.spec.name .. \"/after\") instead of the custom partial after directory sourcing happening in the current iteration",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T13:07:27Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142692854",
            "id": 2142692854,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_tuX2",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2921072127,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142692854/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T13:07:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142692854",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142742669"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142742669"
                }
            },
            "author_association": "MEMBER",
            "body": "> I suppose at the risk of being annoying I will PR it to echanovski later after I figure out what the implications of that tracking block on line 640 are for the change to figure out exactly where to skip from.\r\n> \r\n> I will also PR my other suggestion about using vim.cmd.packadd(plug.spec.name .. \"/after\") instead of the custom partial after directory sourcing happening in the current iteration\r\n\r\nI am sorry, but if up to me, I won't merge it now. The first one needs more discussions after this is merged (maybe there is a better more general flag/approach) and the second one doesn't look like an intended usage of `:packadd` (which seems to work by accident and not documented) and needs more Vim research.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T13:28:21Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142742669",
            "id": 2142742669,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_t6iN",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2921155457,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142742669/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T13:28:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142742669",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142743985"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142743985"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```lua\r\n  if vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins then\r\n    vim.cmd.packadd(plug.spec.name .. '/after')\r\n  end\r\n```\r\n\r\nShould I pass bang to the second packadd also, or should I keep the logic the same there? like this?\r\n\r\n```lua\r\n  if vim.v.vim_did_enter == 1 and vim.o.loadplugins then\r\n    vim.cmd.packadd({ plug.spec.name .. '/after', bang = bang })\r\n  end\r\n```\r\n\r\nI think I like the second one better actually, especially if we add an opt key to it, because then bang does bang, opt does opt\r\n\r\n~Also, should I check if it has an after directory first? I am not 100% sure if packadd still adds it to packpath even if the after directory wasnt found. Will check.~ Edit: no, it does not appear to do so, so no need to check if the after directory is even there.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T13:28:51Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142743985",
            "id": 2142743985,
            "in_reply_to_id": 2142634682,
            "line": 625,
            "node_id": "PRRC_kwDOAPphoM5_t62x",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 625,
            "original_position": 651,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 625,
            "pull_request_review_id": 2921157553,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142743985/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T13:43:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142743985",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2142873556"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142873556"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Ok, well, I opened a PR for you anyway so you can see exactly what I was talking about at least",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T14:09:05Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2142873556",
            "id": 2142873556,
            "in_reply_to_id": 2142637867,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_uafU",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 633,
            "original_position": 661,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2921381619,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142873556/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T14:09:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2142873556",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2143022433"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2143022433"
                }
            },
            "author_association": "MEMBER",
            "body": "Answered [here](https://github.com/echasnovski/neovim/pull/5#issuecomment-2967230385).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-06-12T15:10:38Z",
            "diff_hunk": "@@ -0,0 +1,1007 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd string\n+--- @return string\n+local function cli_async(cmd, cwd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  if out.stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(out.stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  --- @param timestamp string\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout'\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  get_default_origin_branch = function()\n+    return { 'rev-parse', '--abbrev-ref', 'origin/HEAD' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', '--abbrev-commit', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list', '--sort=-v:refname' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=-v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @async\n+local function git_get_default_branch(cwd)\n+  local res = cli_async(git_cmd('get_default_origin_branch'), cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout = cli_async(git_cmd('list_branches'), cwd)\n+  local res = {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_async(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field did_install? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path, info = { err = '' } }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    local p_data = plug_map[p.path]\n+    if p_data == nil then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+      p_data = plug_map[p.path]\n+    end\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {}\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (names == nil and p_data.was_added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      table.insert(plugs, new_plug(p_data.spec))\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', msg: string?, percent: integer?): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, msg, percent)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('%s: %s %s'):format(progress, title, msg))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug): nil\n+--- @param progress_title? string\n+local function run_list(plug_list, f, progress_title)\n+  local n_threads = 2 * #(uv.cpu_info() or { {} })\n+  local report_progress = progress_title ~= nil and new_progress_report(progress_title)\n+    or function(_, _, _) end\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p)\n+        if not ok then\n+          p.info.err = err --[[@as string]]\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        local msg = ('(%d/%d) - %s'):format(n_finished, #funs, p.spec.name)\n+        report_progress('report', msg, percent)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  local begin_msg = ('(0/%d)'):format(#funs)\n+  report_progress('begin', begin_msg, 0)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  local end_msg = ('(%d/%d)'):format(#funs, #funs)\n+  report_progress('end', end_msg, 100)\n+end\n+\n+--- @param msg string\n+local function confirm(msg)\n+  -- Work around confirmation message not showing during startup.\n+  -- This is a semi-regression of #31525: some redraw during startup makes\n+  -- confirmation message disappear.\n+  -- TODO: Remove when #34088 is resolved.\n+  if vim.v.vim_did_enter == 1 then\n+    return vim.fn.confirm(msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  end\n+\n+  msg = msg .. '\\nProceed? [Y]es, (N)o'\n+  vim.defer_fn(function()\n+    vim.print(msg)\n+  end, 100)\n+  local ok, char = pcall(vim.fn.getcharstr)\n+  local res = (ok and (char == 'y' or char == 'Y' or char == '\\r')) and 1 or 0\n+  vim.cmd.redraw()\n+  return res == 1\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function clone(p)\n+  cli_async(git_cmd('clone', p.spec.source, p.path), uv.cwd() or '')\n+  p.info.did_install = true\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str ~= nil then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if version == nil then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(cli_async, git_cmd('get_hash', version), p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag, semver_tags = nil, {}\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    table.insert(semver_tags, ver_tag ~= nil and tag or nil)\n+    local is_in_range = ver_tag and version:has(ver_tag)\n+    if is_in_range and (not last_ver_tag or ver_tag > last_ver_tag) then\n+      p.info.version_str, last_ver_tag = tag, ver_tag\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or cli_async(git_cmd('get_hash', 'HEAD'), p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or cli_async(git_cmd('get_hash', target_ref), p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param opts { timestamp: string, skip_same_sha: boolean, silent: boolean }\n+local function checkout(p, opts)\n+  infer_states(p)\n+  if opts.skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  cli_async(git_cmd('stash', opts.timestamp), p.path)\n+\n+  cli_async(git_cmd('checkout', p.info.sha_target), p.path)\n+  if not opts.silent then\n+    notify(('Updated state to `%s` in `%s`'):format(p.info.version_str, p.spec.name), 'INFO')\n+  end\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  local sources = {}\n+  for _, p in ipairs(plug_list) do\n+    table.insert(sources, p.spec.source)\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  if not confirm(confirm_msg) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local checkout_opts = { timestamp = get_timestamp(), skip_same_sha = false, silent = true }\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    clone(p)\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, checkout_opts)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+\n+  local from = p.info.sha_head\n+  local to = p.info.sha_target\n+  local cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  p.info.update_details = cli_async(cmd, p.path)\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = cli_async(git_cmd('list_cur_tags', p.info.sha_target), p.path)\n+  local cur_tags_arr = vim.split(cur_tags, '\\n')\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags_arr, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2143022433",
            "id": 2143022433,
            "in_reply_to_id": 2142634682,
            "line": 625,
            "node_id": "PRRC_kwDOAPphoM5_u-1h",
            "original_commit_id": "b6173d53f1843629b543b4334522d5e0fd9a03cd",
            "original_line": 625,
            "original_position": 651,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 625,
            "pull_request_review_id": 2921624736,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2143022433/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T15:10:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2143022433",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178192135"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178192135"
                }
            },
            "author_association": "MEMBER",
            "body": "should probably use a hyphen in our uri schemes. \r\n\r\n```suggestion\r\n  api.nvim_buf_set_name(bufnr, 'nvim-pack://' .. bufnr .. '/confirm-update')\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T17:40:00Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd? string\n+--- @return string\n+local function git_cmd(cmd, cwd)\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  cmd = vim.list_extend({ 'git', '-c', 'gc.auto=0' }, cmd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  local stdout, stderr = assert(out.stdout), assert(out.stderr)\n+  if stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @async\n+--- @param url string\n+--- @param path string\n+local function git_clone(url, path)\n+  local cmd = { 'clone', '--quiet', '--origin', 'origin' }\n+\n+  if vim.startswith(url, 'file://') then\n+    cmd[#cmd + 1] = '--no-hardlinks'\n+  else\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local filter_args = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    vim.list_extend(cmd, filter_args)\n+  end\n+\n+  vim.list_extend(cmd, { '--origin', 'origin', url, path })\n+  git_cmd(cmd, uv.cwd())\n+end\n+\n+--- @async\n+--- @param rev string\n+--- @param cwd string\n+--- @return string\n+local function git_get_hash(rev, cwd)\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  return git_cmd({ 'rev-list', '-1', '--abbrev-commit', rev }, cwd)\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string\n+local function git_get_default_branch(cwd)\n+  local res = git_cmd({ 'rev-parse', '--abbrev-ref', 'origin/HEAD' }, cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string[]\n+local function git_get_branches(cwd)\n+  local cmd = { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  local stdout = git_cmd(cmd, cwd)\n+  local res = {} --- @type string[]\n+  for l in vim.gsplit(stdout, '\\n') do\n+    res[#res + 1] = l:match('^origin/(.+)$')\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @param opts? { contains?: string, points_at?: string }\n+--- @return string[]\n+local function git_get_tags(cwd, opts)\n+  local cmd = { 'tag', '--list', '--sort=-v:refname' }\n+  if opts and opts.contains then\n+    vim.list_extend(cmd, { '--contains', opts.contains })\n+  end\n+  if opts and opts.points_at then\n+    vim.list_extend(cmd, { '--points-at', opts.points_at })\n+  end\n+  return vim.split(git_cmd(cmd, cwd), '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+\n+--- @return string\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+--- @param x string|vim.VersionRange\n+--- @return boolean\n+local function is_version(x)\n+  return type(x) == 'string' or (pcall(x.has, x, '1'))\n+end\n+\n+--- @return string\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field installed? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  local info = { err = '', installed = uv.fs_stat(path) ~= nil }\n+  return { spec = spec_resolved, path = path, info = info }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    if not plug_map[p.path] then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+    end\n+    local p_data = plug_map[p.path]\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  assert(#res == n)\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {} --- @type vim.pack.Plug[]\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (not names and p_data.added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      plugs[#plugs + 1] = new_plug(p_data.spec)\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', percent: integer, fmt: string, ...:any): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, percent, fmt, ...)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('(vim.pack) %s: %s %s'):format(progress, title, fmt:format(...)))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+local n_threads = 2 * #(uv.cpu_info() or { {} })\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug)\n+--- @param progress_title string\n+local function run_list(plug_list, f, progress_title)\n+  local report_progress = new_progress_report(progress_title)\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p) --[[@as string]]\n+        if not ok then\n+          p.info.err = err --- @as string\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        report_progress('report', percent, '(%d/%d) - %s', n_finished, #funs, p.spec.name)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  report_progress('begin', 0, '(0/%d)', #funs)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  report_progress('end', 100, '(%d/%d)', #funs, #funs)\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @return boolean\n+local function confirm_install(plug_list)\n+  local sources = {} --- @type string[]\n+  for _, p in ipairs(plug_list) do\n+    sources[#sources + 1] = p.spec.source\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  local res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  vim.cmd.redraw()\n+  return res\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if not version then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(git_get_hash, version, p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag --- @type vim.Version\n+  local semver_tags = {} --- @type string[]\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    if ver_tag then\n+      semver_tags[#semver_tags + 1] = tag\n+      if version:has(ver_tag) and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or git_get_hash('HEAD', p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or git_get_hash(target_ref, p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param timestamp string\n+--- @param skip_same_sha boolean\n+local function checkout(p, timestamp, skip_same_sha)\n+  infer_states(p)\n+  if skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  local msg = ('(vim.pack) %s Stash before checkout'):format(timestamp)\n+  git_cmd({ 'stash', '--quiet', '--message', msg }, p.path)\n+\n+  git_cmd({ 'checkout', '--quiet', p.info.sha_target }, p.path)\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  if not confirm_install(plug_list) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local timestamp = get_timestamp()\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    git_clone(p.spec.source, p.path)\n+    p.info.installed = true\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, timestamp, false)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+  local sha_head = assert(p.info.sha_head)\n+  local sha_target = assert(p.info.sha_target)\n+\n+  if sha_head ~= sha_target then\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    p.info.update_details = git_cmd({\n+      'log',\n+      '--pretty=format:%m %h │ %s%d',\n+      '--topo-order',\n+      '--decorate-refs=refs/tags',\n+      sha_head .. '...' .. sha_target,\n+    }, p.path)\n+  else\n+    p.info.update_details = table.concat(git_get_tags(p.path, { contains = sha_target }), '\\n')\n+  end\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = git_get_tags(p.path, { points_at = sha_target })\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }?>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang? boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return not p.info.installed\n+  end, plugs)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    install_list(plugs_to_install)\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if p.info.installed then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing all errors to have \"good\" plugins added first\n+  local errors = {} --- @type string[]\n+  for _, p in ipairs(plugs_to_install) do\n+    if p.info.err ~= '' then\n+      errors[#errors + 1] = ('`%s`:\\n%s'):format(p.spec.name, p.info.err)\n+    end\n+  end\n+  if #errors > 0 then\n+    local error_str = table.concat(errors, '\\n\\n')\n+    error(('Errors during installation:\\n\\n%s'):format(error_str))\n+  end\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.info.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.spec.name, p.info.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.path,\n+      'Source: ' .. p.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.path,\n+      'Source:       ' .. p.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @param skip_same_sha boolean\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, skip_same_sha)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list) do\n+    --- @type string[]\n+    local group_arr = p.info.err ~= '' and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    group_arr[#group_arr + 1] = compute_feedback_lines_single(p)\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function feedback_log(plug_list)\n+  local lines = { ('========== Update %s =========='):format(get_timestamp()) }\n+  vim.list_extend(lines, compute_feedback_lines(plug_list, true))\n+  lines[#lines + 1] = ''\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun()\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178192135",
            "id": 2178192135,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1JMH",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 780,
            "original_position": 780,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178192135/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178192135",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178272435"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178272435"
                }
            },
            "author_association": "MEMBER",
            "body": "AFAICT we dropped the `\"foo/bar\"` => `\"github.com/foo/bar/\"` feature, right? That's good, we don't need that. It's a questionable bit of \"magic\" for a minor UX benefit.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:14:51Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178272435",
            "id": 2178272435,
            "line": 24,
            "node_id": "PRRC_kwDOAPphoM6B1cyz",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 24,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178272435/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178272435",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178301261"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178301261"
                }
            },
            "author_association": "MEMBER",
            "body": "`src` or `url` \r\n\r\n```suggestion\r\n      { src = 'https://github.com/user/plugin1' },\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:31:18Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178301261",
            "id": 2178301261,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1j1N",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2551,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178301261/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178301261",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178303691"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178303691"
                }
            },
            "author_association": "MEMBER",
            "body": "if `'https://foo.com/user/plugin1'` is also specified, how does vim.pack handle the name conflict ? Docs may want to mention that.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:32:54Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178303691",
            "id": 2178303691,
            "line": 2550,
            "node_id": "PRRC_kwDOAPphoM6B1kbL",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2550,
            "original_position": 26,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 26,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178303691/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178303691",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178309011"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178309011"
                }
            },
            "author_association": "MEMBER",
            "body": "off-topic: we should probably introduce `pack.txt` helpfile (and also move the `:help packages` section in there)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:36:56Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178309011",
            "id": 2178309011,
            "line": 2529,
            "node_id": "PRRC_kwDOAPphoM6B1luT",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2529,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 5,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178309011/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178309011",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178316601"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178316601"
                }
            },
            "author_association": "MEMBER",
            "body": "👍 not suffixing `Post` is good. `TextYankPost` was a mistake 😅 ",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:42:18Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178316601",
            "id": 2178316601,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1nk5",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2608,
            "original_position": 86,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178316601/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178316601",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178320067"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178320067"
                }
            },
            "author_association": "MEMBER",
            "body": "This is essentially a key. I wonder if we should enforce this by structuring the Spec as `{ name = { src, version } }`. That would mean that users are required to name every plugin, but that's fine imo. If this was already discussed and rejected lmk.\r\n\r\nOtherwise, we need to mention here that the name must be unique?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:44:52Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178320067",
            "id": 2178320067,
            "line": 2624,
            "node_id": "PRRC_kwDOAPphoM6B1obD",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2624,
            "original_position": 99,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 100,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178320067/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178320067",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178326467"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178326467"
                }
            },
            "author_association": "MEMBER",
            "body": "can we think of a more semantic name, maybe `load` or `noload` ? or should this be a callback like `on_update` so users can do whatever if they [do or don't like :packadd](https://github.com/neovim/neovim/pull/34009#issuecomment-2966477907) ?\r\n\r\n```suggestion\r\n                 • {load}? (`boolean`, default `true`) Load plugin files and ftdetect scripts. If `false`, works like `:packadd!`.\r\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:49:42Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178326467",
            "id": 2178326467,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1p_D",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2655,
            "original_position": 133,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178326467/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:39:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178326467",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178329804"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178329804"
                }
            },
            "author_association": "MEMBER",
            "body": "`isnew` or `new` ?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T18:51:53Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178329804",
            "id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1qzM",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178329804/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:32:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178329804",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178345136"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178345136"
                }
            },
            "author_association": "MEMBER",
            "body": "(non-blocker) We could just claim the name `pack`, it doesn't seem to be claimed in `runtime/lua/vim/filetype/detect.lua`. We have also claimed other things like `query` , so I guess there isn't much concern about conflicts with filetypes \"in the wild\".\r\n\r\n~~Alternatively, is there precedent for dot-deliminated filetype names like `nvim.xx` ? (IIRC this is for \"sub types\" so maybe not.)~~",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T19:01:50Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd? string\n+--- @return string\n+local function git_cmd(cmd, cwd)\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  cmd = vim.list_extend({ 'git', '-c', 'gc.auto=0' }, cmd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  local stdout, stderr = assert(out.stdout), assert(out.stderr)\n+  if stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @async\n+--- @param url string\n+--- @param path string\n+local function git_clone(url, path)\n+  local cmd = { 'clone', '--quiet', '--origin', 'origin' }\n+\n+  if vim.startswith(url, 'file://') then\n+    cmd[#cmd + 1] = '--no-hardlinks'\n+  else\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local filter_args = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    vim.list_extend(cmd, filter_args)\n+  end\n+\n+  vim.list_extend(cmd, { '--origin', 'origin', url, path })\n+  git_cmd(cmd, uv.cwd())\n+end\n+\n+--- @async\n+--- @param rev string\n+--- @param cwd string\n+--- @return string\n+local function git_get_hash(rev, cwd)\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  return git_cmd({ 'rev-list', '-1', '--abbrev-commit', rev }, cwd)\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string\n+local function git_get_default_branch(cwd)\n+  local res = git_cmd({ 'rev-parse', '--abbrev-ref', 'origin/HEAD' }, cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string[]\n+local function git_get_branches(cwd)\n+  local cmd = { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  local stdout = git_cmd(cmd, cwd)\n+  local res = {} --- @type string[]\n+  for l in vim.gsplit(stdout, '\\n') do\n+    res[#res + 1] = l:match('^origin/(.+)$')\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @param opts? { contains?: string, points_at?: string }\n+--- @return string[]\n+local function git_get_tags(cwd, opts)\n+  local cmd = { 'tag', '--list', '--sort=-v:refname' }\n+  if opts and opts.contains then\n+    vim.list_extend(cmd, { '--contains', opts.contains })\n+  end\n+  if opts and opts.points_at then\n+    vim.list_extend(cmd, { '--points-at', opts.points_at })\n+  end\n+  return vim.split(git_cmd(cmd, cwd), '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+\n+--- @return string\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+--- @param x string|vim.VersionRange\n+--- @return boolean\n+local function is_version(x)\n+  return type(x) == 'string' or (pcall(x.has, x, '1'))\n+end\n+\n+--- @return string\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field installed? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  local info = { err = '', installed = uv.fs_stat(path) ~= nil }\n+  return { spec = spec_resolved, path = path, info = info }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    if not plug_map[p.path] then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+    end\n+    local p_data = plug_map[p.path]\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  assert(#res == n)\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {} --- @type vim.pack.Plug[]\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (not names and p_data.added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      plugs[#plugs + 1] = new_plug(p_data.spec)\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', percent: integer, fmt: string, ...:any): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, percent, fmt, ...)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('(vim.pack) %s: %s %s'):format(progress, title, fmt:format(...)))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+local n_threads = 2 * #(uv.cpu_info() or { {} })\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug)\n+--- @param progress_title string\n+local function run_list(plug_list, f, progress_title)\n+  local report_progress = new_progress_report(progress_title)\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p) --[[@as string]]\n+        if not ok then\n+          p.info.err = err --- @as string\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        report_progress('report', percent, '(%d/%d) - %s', n_finished, #funs, p.spec.name)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  report_progress('begin', 0, '(0/%d)', #funs)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  report_progress('end', 100, '(%d/%d)', #funs, #funs)\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @return boolean\n+local function confirm_install(plug_list)\n+  local sources = {} --- @type string[]\n+  for _, p in ipairs(plug_list) do\n+    sources[#sources + 1] = p.spec.source\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  local res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  vim.cmd.redraw()\n+  return res\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if not version then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(git_get_hash, version, p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag --- @type vim.Version\n+  local semver_tags = {} --- @type string[]\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    if ver_tag then\n+      semver_tags[#semver_tags + 1] = tag\n+      if version:has(ver_tag) and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or git_get_hash('HEAD', p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or git_get_hash(target_ref, p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param timestamp string\n+--- @param skip_same_sha boolean\n+local function checkout(p, timestamp, skip_same_sha)\n+  infer_states(p)\n+  if skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  local msg = ('(vim.pack) %s Stash before checkout'):format(timestamp)\n+  git_cmd({ 'stash', '--quiet', '--message', msg }, p.path)\n+\n+  git_cmd({ 'checkout', '--quiet', p.info.sha_target }, p.path)\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  if not confirm_install(plug_list) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local timestamp = get_timestamp()\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    git_clone(p.spec.source, p.path)\n+    p.info.installed = true\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, timestamp, false)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+  local sha_head = assert(p.info.sha_head)\n+  local sha_target = assert(p.info.sha_target)\n+\n+  if sha_head ~= sha_target then\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    p.info.update_details = git_cmd({\n+      'log',\n+      '--pretty=format:%m %h │ %s%d',\n+      '--topo-order',\n+      '--decorate-refs=refs/tags',\n+      sha_head .. '...' .. sha_target,\n+    }, p.path)\n+  else\n+    p.info.update_details = table.concat(git_get_tags(p.path, { contains = sha_target }), '\\n')\n+  end\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = git_get_tags(p.path, { points_at = sha_target })\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }?>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang? boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return not p.info.installed\n+  end, plugs)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    install_list(plugs_to_install)\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if p.info.installed then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing all errors to have \"good\" plugins added first\n+  local errors = {} --- @type string[]\n+  for _, p in ipairs(plugs_to_install) do\n+    if p.info.err ~= '' then\n+      errors[#errors + 1] = ('`%s`:\\n%s'):format(p.spec.name, p.info.err)\n+    end\n+  end\n+  if #errors > 0 then\n+    local error_str = table.concat(errors, '\\n\\n')\n+    error(('Errors during installation:\\n\\n%s'):format(error_str))\n+  end\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.info.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.spec.name, p.info.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.path,\n+      'Source: ' .. p.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.path,\n+      'Source:       ' .. p.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @param skip_same_sha boolean\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, skip_same_sha)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list) do\n+    --- @type string[]\n+    local group_arr = p.info.err ~= '' and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    group_arr[#group_arr + 1] = compute_feedback_lines_single(p)\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function feedback_log(plug_list)\n+  local lines = { ('========== Update %s =========='):format(get_timestamp()) }\n+  vim.list_extend(lines, compute_feedback_lines(plug_list, true))\n+  lines[#lines + 1] = ''\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun()\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish()\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178345136",
            "id": 2178345136,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B1uiw",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 816,
            "original_position": 816,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2976409008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178345136/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:59:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178345136",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178600385"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178600385"
                }
            },
            "author_association": "MEMBER",
            "body": "Do we actually need separate events? Every event is going to need the same kind of info, right? Seems like we only need `PackUpdate[Pre]`, and could pass an event arg (`data`) like `data.type: 'delete'|'install'|'update'`. \r\n",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T21:51:27Z",
            "diff_hunk": "@@ -87,6 +87,12 @@ return {\n     QuickFixCmdPost = false, -- after :make, :grep etc.\n     QuickFixCmdPre = false, -- before :make, :grep etc.\n     QuitPre = false, -- before :quit\n+    PackDeletePre = false, -- before removing `vim.pack` plugin from disk\n+    PackDelete = false, -- after removing `vim.pack` plugin from disk\n+    PackInstallPre = false, -- before installing `vim.pack` plugin\n+    PackInstall = false, -- after installing `vim.pack` plugin\n+    PackUpdatePre = false, -- before updating `vim.pack` plugin\n+    PackUpdate = false, -- after updating `vim.pack` plugin",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178600385",
            "id": 2178600385,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B2s3B",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 95,
            "original_position": 9,
            "original_start_line": null,
            "path": "src/nvim/auevents.lua",
            "position": null,
            "pull_request_review_id": 2977059931,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 6,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178600385/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:00:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178600385",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178603464"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178603464"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah, `foo.bar` is for running `ftplugin/foo.vim` then `ftplugin/bar.vim`.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T21:54:34Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd? string\n+--- @return string\n+local function git_cmd(cmd, cwd)\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  cmd = vim.list_extend({ 'git', '-c', 'gc.auto=0' }, cmd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  local stdout, stderr = assert(out.stdout), assert(out.stderr)\n+  if stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @async\n+--- @param url string\n+--- @param path string\n+local function git_clone(url, path)\n+  local cmd = { 'clone', '--quiet', '--origin', 'origin' }\n+\n+  if vim.startswith(url, 'file://') then\n+    cmd[#cmd + 1] = '--no-hardlinks'\n+  else\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local filter_args = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    vim.list_extend(cmd, filter_args)\n+  end\n+\n+  vim.list_extend(cmd, { '--origin', 'origin', url, path })\n+  git_cmd(cmd, uv.cwd())\n+end\n+\n+--- @async\n+--- @param rev string\n+--- @param cwd string\n+--- @return string\n+local function git_get_hash(rev, cwd)\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  return git_cmd({ 'rev-list', '-1', '--abbrev-commit', rev }, cwd)\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string\n+local function git_get_default_branch(cwd)\n+  local res = git_cmd({ 'rev-parse', '--abbrev-ref', 'origin/HEAD' }, cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string[]\n+local function git_get_branches(cwd)\n+  local cmd = { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  local stdout = git_cmd(cmd, cwd)\n+  local res = {} --- @type string[]\n+  for l in vim.gsplit(stdout, '\\n') do\n+    res[#res + 1] = l:match('^origin/(.+)$')\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @param opts? { contains?: string, points_at?: string }\n+--- @return string[]\n+local function git_get_tags(cwd, opts)\n+  local cmd = { 'tag', '--list', '--sort=-v:refname' }\n+  if opts and opts.contains then\n+    vim.list_extend(cmd, { '--contains', opts.contains })\n+  end\n+  if opts and opts.points_at then\n+    vim.list_extend(cmd, { '--points-at', opts.points_at })\n+  end\n+  return vim.split(git_cmd(cmd, cwd), '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+\n+--- @return string\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+--- @param x string|vim.VersionRange\n+--- @return boolean\n+local function is_version(x)\n+  return type(x) == 'string' or (pcall(x.has, x, '1'))\n+end\n+\n+--- @return string\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field installed? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  local info = { err = '', installed = uv.fs_stat(path) ~= nil }\n+  return { spec = spec_resolved, path = path, info = info }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    if not plug_map[p.path] then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+    end\n+    local p_data = plug_map[p.path]\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  assert(#res == n)\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {} --- @type vim.pack.Plug[]\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (not names and p_data.added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      plugs[#plugs + 1] = new_plug(p_data.spec)\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', percent: integer, fmt: string, ...:any): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, percent, fmt, ...)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('(vim.pack) %s: %s %s'):format(progress, title, fmt:format(...)))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+local n_threads = 2 * #(uv.cpu_info() or { {} })\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug)\n+--- @param progress_title string\n+local function run_list(plug_list, f, progress_title)\n+  local report_progress = new_progress_report(progress_title)\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p) --[[@as string]]\n+        if not ok then\n+          p.info.err = err --- @as string\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        report_progress('report', percent, '(%d/%d) - %s', n_finished, #funs, p.spec.name)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  report_progress('begin', 0, '(0/%d)', #funs)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  report_progress('end', 100, '(%d/%d)', #funs, #funs)\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @return boolean\n+local function confirm_install(plug_list)\n+  local sources = {} --- @type string[]\n+  for _, p in ipairs(plug_list) do\n+    sources[#sources + 1] = p.spec.source\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  local res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  vim.cmd.redraw()\n+  return res\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if not version then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(git_get_hash, version, p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag --- @type vim.Version\n+  local semver_tags = {} --- @type string[]\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    if ver_tag then\n+      semver_tags[#semver_tags + 1] = tag\n+      if version:has(ver_tag) and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or git_get_hash('HEAD', p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or git_get_hash(target_ref, p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param timestamp string\n+--- @param skip_same_sha boolean\n+local function checkout(p, timestamp, skip_same_sha)\n+  infer_states(p)\n+  if skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  local msg = ('(vim.pack) %s Stash before checkout'):format(timestamp)\n+  git_cmd({ 'stash', '--quiet', '--message', msg }, p.path)\n+\n+  git_cmd({ 'checkout', '--quiet', p.info.sha_target }, p.path)\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  if not confirm_install(plug_list) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local timestamp = get_timestamp()\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    git_clone(p.spec.source, p.path)\n+    p.info.installed = true\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, timestamp, false)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+  local sha_head = assert(p.info.sha_head)\n+  local sha_target = assert(p.info.sha_target)\n+\n+  if sha_head ~= sha_target then\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    p.info.update_details = git_cmd({\n+      'log',\n+      '--pretty=format:%m %h │ %s%d',\n+      '--topo-order',\n+      '--decorate-refs=refs/tags',\n+      sha_head .. '...' .. sha_target,\n+    }, p.path)\n+  else\n+    p.info.update_details = table.concat(git_get_tags(p.path, { contains = sha_target }), '\\n')\n+  end\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = git_get_tags(p.path, { points_at = sha_target })\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }?>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang? boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return not p.info.installed\n+  end, plugs)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    install_list(plugs_to_install)\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if p.info.installed then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing all errors to have \"good\" plugins added first\n+  local errors = {} --- @type string[]\n+  for _, p in ipairs(plugs_to_install) do\n+    if p.info.err ~= '' then\n+      errors[#errors + 1] = ('`%s`:\\n%s'):format(p.spec.name, p.info.err)\n+    end\n+  end\n+  if #errors > 0 then\n+    local error_str = table.concat(errors, '\\n\\n')\n+    error(('Errors during installation:\\n\\n%s'):format(error_str))\n+  end\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.info.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.spec.name, p.info.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.path,\n+      'Source: ' .. p.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.path,\n+      'Source:       ' .. p.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @param skip_same_sha boolean\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, skip_same_sha)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list) do\n+    --- @type string[]\n+    local group_arr = p.info.err ~= '' and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    group_arr[#group_arr + 1] = compute_feedback_lines_single(p)\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function feedback_log(plug_list)\n+  local lines = { ('========== Update %s =========='):format(get_timestamp()) }\n+  vim.list_extend(lines, compute_feedback_lines(plug_list, true))\n+  lines[#lines + 1] = ''\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun()\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish()\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178603464",
            "id": 2178603464,
            "in_reply_to_id": 2178345136,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B2tnI",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 816,
            "original_position": 816,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2977064301,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178603464/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T21:54:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178603464",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178605184"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178605184"
                }
            },
            "author_association": "MEMBER",
            "body": " I raised https://github.com/neovim/neovim/issues/32646 , and the reply was that `DiagnosticXX` already serve that purpose. So can we just use those directly (instead of linking `PackMsgBreaking`)? \r\n\r\n`PackTitle*` also seems over-specific. Defining multiple highlight groups for a \"title\" in a specific filetype doesn't seem like something that should be a builtin hl group.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T21:55:57Z",
            "diff_hunk": "@@ -224,6 +224,16 @@ static const char *highlight_init_both[] = {\n   \"default link LspSignatureActiveParameter Visual\",\n   \"default link SnippetTabstop              Visual\",\n \n+  // vim.pack\n+  \"default link PackChangeAdded   Added\",\n+  \"default link PackChangeRemoved Removed\",\n+  \"default link PackHint          DiagnosticHint\",\n+  \"default link PackInfo          DiagnosticInfo\",\n+  \"default link PackMsgBreaking   DiagnosticWarn\",\n+  \"default link PackTitleError    DiffDelete\",\n+  \"default link PackTitleSame     DiffText\",\n+  \"default link PackTitleUpdate   DiffAdd\",",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178605184",
            "id": 2178605184,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B2uCA",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 235,
            "original_position": 12,
            "original_start_line": 232,
            "path": "src/nvim/highlight_group.c",
            "position": null,
            "pull_request_review_id": 2977066590,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178605184/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-01T22:01:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178605184",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178629520"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178629520"
                }
            },
            "author_association": "MEMBER",
            "body": "+1 `url`",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:19:39Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178629520",
            "id": 2178629520,
            "in_reply_to_id": 2178301261,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B2z-Q",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2551,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2977103211,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178629520/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:19:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178629520",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178630582"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178630582"
                }
            },
            "author_association": "MEMBER",
            "body": "I suggest we just error on such conflicts until someone actually wants this to be resolved.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:20:51Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178630582",
            "id": 2178630582,
            "in_reply_to_id": 2178303691,
            "line": 2550,
            "node_id": "PRRC_kwDOAPphoM6B20O2",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2550,
            "original_position": 26,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 26,
            "pull_request_review_id": 2977104650,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178630582/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:20:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178630582",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178636927"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178636927"
                }
            },
            "author_association": "MEMBER",
            "body": "I feel like this should be consistent with the uri protocol (`nvim-pack` or `nvimpack`)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:25:02Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd? string\n+--- @return string\n+local function git_cmd(cmd, cwd)\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  cmd = vim.list_extend({ 'git', '-c', 'gc.auto=0' }, cmd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  local stdout, stderr = assert(out.stdout), assert(out.stderr)\n+  if stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @async\n+--- @param url string\n+--- @param path string\n+local function git_clone(url, path)\n+  local cmd = { 'clone', '--quiet', '--origin', 'origin' }\n+\n+  if vim.startswith(url, 'file://') then\n+    cmd[#cmd + 1] = '--no-hardlinks'\n+  else\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local filter_args = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    vim.list_extend(cmd, filter_args)\n+  end\n+\n+  vim.list_extend(cmd, { '--origin', 'origin', url, path })\n+  git_cmd(cmd, uv.cwd())\n+end\n+\n+--- @async\n+--- @param rev string\n+--- @param cwd string\n+--- @return string\n+local function git_get_hash(rev, cwd)\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  return git_cmd({ 'rev-list', '-1', '--abbrev-commit', rev }, cwd)\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string\n+local function git_get_default_branch(cwd)\n+  local res = git_cmd({ 'rev-parse', '--abbrev-ref', 'origin/HEAD' }, cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string[]\n+local function git_get_branches(cwd)\n+  local cmd = { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  local stdout = git_cmd(cmd, cwd)\n+  local res = {} --- @type string[]\n+  for l in vim.gsplit(stdout, '\\n') do\n+    res[#res + 1] = l:match('^origin/(.+)$')\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @param opts? { contains?: string, points_at?: string }\n+--- @return string[]\n+local function git_get_tags(cwd, opts)\n+  local cmd = { 'tag', '--list', '--sort=-v:refname' }\n+  if opts and opts.contains then\n+    vim.list_extend(cmd, { '--contains', opts.contains })\n+  end\n+  if opts and opts.points_at then\n+    vim.list_extend(cmd, { '--points-at', opts.points_at })\n+  end\n+  return vim.split(git_cmd(cmd, cwd), '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+\n+--- @return string\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+--- @param x string|vim.VersionRange\n+--- @return boolean\n+local function is_version(x)\n+  return type(x) == 'string' or (pcall(x.has, x, '1'))\n+end\n+\n+--- @return string\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field installed? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  local info = { err = '', installed = uv.fs_stat(path) ~= nil }\n+  return { spec = spec_resolved, path = path, info = info }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    if not plug_map[p.path] then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+    end\n+    local p_data = plug_map[p.path]\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  assert(#res == n)\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {} --- @type vim.pack.Plug[]\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (not names and p_data.added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      plugs[#plugs + 1] = new_plug(p_data.spec)\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', percent: integer, fmt: string, ...:any): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, percent, fmt, ...)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('(vim.pack) %s: %s %s'):format(progress, title, fmt:format(...)))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+local n_threads = 2 * #(uv.cpu_info() or { {} })\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug)\n+--- @param progress_title string\n+local function run_list(plug_list, f, progress_title)\n+  local report_progress = new_progress_report(progress_title)\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p) --[[@as string]]\n+        if not ok then\n+          p.info.err = err --- @as string\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        report_progress('report', percent, '(%d/%d) - %s', n_finished, #funs, p.spec.name)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  report_progress('begin', 0, '(0/%d)', #funs)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  report_progress('end', 100, '(%d/%d)', #funs, #funs)\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @return boolean\n+local function confirm_install(plug_list)\n+  local sources = {} --- @type string[]\n+  for _, p in ipairs(plug_list) do\n+    sources[#sources + 1] = p.spec.source\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  local res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  vim.cmd.redraw()\n+  return res\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if not version then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(git_get_hash, version, p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag --- @type vim.Version\n+  local semver_tags = {} --- @type string[]\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    if ver_tag then\n+      semver_tags[#semver_tags + 1] = tag\n+      if version:has(ver_tag) and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or git_get_hash('HEAD', p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or git_get_hash(target_ref, p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param timestamp string\n+--- @param skip_same_sha boolean\n+local function checkout(p, timestamp, skip_same_sha)\n+  infer_states(p)\n+  if skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  local msg = ('(vim.pack) %s Stash before checkout'):format(timestamp)\n+  git_cmd({ 'stash', '--quiet', '--message', msg }, p.path)\n+\n+  git_cmd({ 'checkout', '--quiet', p.info.sha_target }, p.path)\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  if not confirm_install(plug_list) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local timestamp = get_timestamp()\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    git_clone(p.spec.source, p.path)\n+    p.info.installed = true\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, timestamp, false)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+  local sha_head = assert(p.info.sha_head)\n+  local sha_target = assert(p.info.sha_target)\n+\n+  if sha_head ~= sha_target then\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    p.info.update_details = git_cmd({\n+      'log',\n+      '--pretty=format:%m %h │ %s%d',\n+      '--topo-order',\n+      '--decorate-refs=refs/tags',\n+      sha_head .. '...' .. sha_target,\n+    }, p.path)\n+  else\n+    p.info.update_details = table.concat(git_get_tags(p.path, { contains = sha_target }), '\\n')\n+  end\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = git_get_tags(p.path, { points_at = sha_target })\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }?>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang? boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return not p.info.installed\n+  end, plugs)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    install_list(plugs_to_install)\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if p.info.installed then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing all errors to have \"good\" plugins added first\n+  local errors = {} --- @type string[]\n+  for _, p in ipairs(plugs_to_install) do\n+    if p.info.err ~= '' then\n+      errors[#errors + 1] = ('`%s`:\\n%s'):format(p.spec.name, p.info.err)\n+    end\n+  end\n+  if #errors > 0 then\n+    local error_str = table.concat(errors, '\\n\\n')\n+    error(('Errors during installation:\\n\\n%s'):format(error_str))\n+  end\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.info.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.spec.name, p.info.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.path,\n+      'Source: ' .. p.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.path,\n+      'Source:       ' .. p.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @param skip_same_sha boolean\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, skip_same_sha)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list) do\n+    --- @type string[]\n+    local group_arr = p.info.err ~= '' and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    group_arr[#group_arr + 1] = compute_feedback_lines_single(p)\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function feedback_log(plug_list)\n+  local lines = { ('========== Update %s =========='):format(get_timestamp()) }\n+  vim.list_extend(lines, compute_feedback_lines(plug_list, true))\n+  lines[#lines + 1] = ''\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun()\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish()\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178636927",
            "id": 2178636927,
            "in_reply_to_id": 2178345136,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B21x_",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 816,
            "original_position": 816,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2977112963,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178636927/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:25:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178636927",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178654803"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178654803"
                }
            },
            "author_association": "MEMBER",
            "body": "I predict most users will wrap/augment `vim.pack.add()` to add this kind of magic (and other stuff). Someone will likely then distribute this as a plugin:\n\n```lua\nvim.pack.add('https://github.com/eklof/better-nvimpack\")\nrequire('better-nvimpack')\n\nvim.pack.add('lewis6991/gitsigns.nvim')\n```",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:33:43Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178654803",
            "id": 2178654803,
            "in_reply_to_id": 2178272435,
            "line": 24,
            "node_id": "PRRC_kwDOAPphoM6B26JT",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 24,
            "pull_request_review_id": 2977134847,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 1,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178654803/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:33:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178654803",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178657568"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178657568"
                }
            },
            "author_association": "MEMBER",
            "body": "I agree this is a lot of events. Maybe we should reduce these initially and add them as we need.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:35:09Z",
            "diff_hunk": "@@ -87,6 +87,12 @@ return {\n     QuickFixCmdPost = false, -- after :make, :grep etc.\n     QuickFixCmdPre = false, -- before :make, :grep etc.\n     QuitPre = false, -- before :quit\n+    PackDeletePre = false, -- before removing `vim.pack` plugin from disk\n+    PackDelete = false, -- after removing `vim.pack` plugin from disk\n+    PackInstallPre = false, -- before installing `vim.pack` plugin\n+    PackInstall = false, -- after installing `vim.pack` plugin\n+    PackUpdatePre = false, -- before updating `vim.pack` plugin\n+    PackUpdate = false, -- after updating `vim.pack` plugin",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178657568",
            "id": 2178657568,
            "in_reply_to_id": 2178600385,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B260g",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 95,
            "original_position": 9,
            "original_start_line": null,
            "path": "src/nvim/auevents.lua",
            "position": null,
            "pull_request_review_id": 2977138465,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178657568/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:35:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178657568",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178666762"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178666762"
                }
            },
            "author_association": "MEMBER",
            "body": "That's not what this means. `added` means the plugin was added with `vim.pack.add()` and thus in their Lua config somewhere. If `false` it means the plugin could have been installed manually or by some other manager.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:38:26Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178666762",
            "id": 2178666762,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B29EK",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2977149299,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178666762/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T22:38:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178666762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178689989"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178689989"
                }
            },
            "author_association": "MEMBER",
            "body": "seems kind of strange, but hopefully can think of a better name later. not a blocker for now\r\n\r\nmaybe `own` ? (to indicate that vim.pack owns this plugin)",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T22:48:54Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178689989",
            "id": 2178689989,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B3CvF",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2977175928,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178689989/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-02T10:17:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178689989",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178703987"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178703987"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd suggest not as it's important to this design that the spec maintains ordering. If you make `name` a key then you won't be able to process plugins in the order they are defined.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T23:07:50Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178703987",
            "id": 2178703987,
            "in_reply_to_id": 2178320067,
            "line": 2624,
            "node_id": "PRRC_kwDOAPphoM6B3GJz",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2624,
            "original_position": 99,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 100,
            "pull_request_review_id": 2977196601,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178703987/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T23:07:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178703987",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2178718440"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178718440"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "might want to clarify that we mean `plugin/*` files, which is meaningfully different from 'plugin files'. Maybe 'Load files under `plugin/` and `ftdetect/` directories'? ",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-01T23:28:15Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2178718440",
            "id": 2178718440,
            "in_reply_to_id": 2178326467,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B3Jro",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2655,
            "original_position": 133,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2977217071,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178718440/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-01T23:28:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2178718440",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7416158?v=4",
                "events_url": "https://api.github.com/users/craigmac/events{/privacy}",
                "followers_url": "https://api.github.com/users/craigmac/followers",
                "following_url": "https://api.github.com/users/craigmac/following{/other_user}",
                "gists_url": "https://api.github.com/users/craigmac/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/craigmac",
                "id": 7416158,
                "login": "craigmac",
                "node_id": "MDQ6VXNlcjc0MTYxNTg=",
                "organizations_url": "https://api.github.com/users/craigmac/orgs",
                "received_events_url": "https://api.github.com/users/craigmac/received_events",
                "repos_url": "https://api.github.com/users/craigmac/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/craigmac/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/craigmac/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/craigmac",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2179680270"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2179680270"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't care much about the filetype name but am pretty sure that hyphen is the long-term right choice for the URI scheme.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-02T10:16:04Z",
            "diff_hunk": "@@ -0,0 +1,998 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated [vim.pack-directory]() (see |packages|):\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`.\n+---Plugin's subdirectory name matches plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+---   'https://github.com/user/plugin1',\n+---\n+---   -- Same as above, but using a table (allows setting other options)\n+---   { source = 'https://github.com/user/plugin1' },\n+---\n+---   -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+---   -- instead of \"generic-name\")\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin3',\n+---     -- Version constraint, see |vim.version.range()|\n+---     version = vim.version.range('1.0'),\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     -- Git branch, tag, or commit hash\n+---     version = 'main',\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+---installed will be available on disk in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed to `vim.version.range('*')`.\n+---- |:restart|. The plugin's actual state on disk is not yet changed.\n+---- Execute `vim.pack.update({ 'plugin1' })`.\n+---- Review changes and either confirm or discard them. If discarded, revert\n+---any changes in 'init.lua' as well or you will be prompted again next time\n+---you run |vim.pack.update()|.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version` set to current commit hash.\n+---You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+---the word describing current state (looks like `abc12345`).\n+---- |:restart|.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- |:restart|.\n+---\n+---Remove plugins from disk:\n+---- Use |vim.pack.del()| with a list of plugin names to remove. Make sure their specs\n+---are not included in |vim.pack.add()| call in 'init.lua' or they will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+---- [PackDeletePre]() - before removing plugin from disk.\n+---- [PackDelete]() - after removing plugin from disk.\n+\n+local api = vim.api\n+local uv = vim.uv\n+local async = require('vim._async')\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+\n+--- @async\n+--- @param cmd string[]\n+--- @param cwd? string\n+--- @return string\n+local function git_cmd(cmd, cwd)\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  cmd = vim.list_extend({ 'git', '-c', 'gc.auto=0' }, cmd)\n+  local sys_opts = { cwd = cwd, text = true, clear_env = true }\n+  local out = async.await(3, vim.system, cmd, sys_opts) --- @type vim.SystemCompleted\n+  async.await(1, vim.schedule)\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  local stdout, stderr = assert(out.stdout), assert(out.stderr)\n+  if stderr ~= '' then\n+    vim.schedule(function()\n+      vim.notify(stderr:gsub('\\n+$', ''), vim.log.levels.WARN)\n+    end)\n+  end\n+  return (stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @async\n+--- @param url string\n+--- @param path string\n+local function git_clone(url, path)\n+  local cmd = { 'clone', '--quiet', '--origin', 'origin' }\n+\n+  if vim.startswith(url, 'file://') then\n+    cmd[#cmd + 1] = '--no-hardlinks'\n+  else\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local filter_args = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    vim.list_extend(cmd, filter_args)\n+  end\n+\n+  vim.list_extend(cmd, { '--origin', 'origin', url, path })\n+  git_cmd(cmd, uv.cwd())\n+end\n+\n+--- @async\n+--- @param rev string\n+--- @param cwd string\n+--- @return string\n+local function git_get_hash(rev, cwd)\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  return git_cmd({ 'rev-list', '-1', '--abbrev-commit', rev }, cwd)\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string\n+local function git_get_default_branch(cwd)\n+  local res = git_cmd({ 'rev-parse', '--abbrev-ref', 'origin/HEAD' }, cwd)\n+  return (res:gsub('^origin/', ''))\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @return string[]\n+local function git_get_branches(cwd)\n+  local cmd = { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  local stdout = git_cmd(cmd, cwd)\n+  local res = {} --- @type string[]\n+  for l in vim.gsplit(stdout, '\\n') do\n+    res[#res + 1] = l:match('^origin/(.+)$')\n+  end\n+  return res\n+end\n+\n+--- @async\n+--- @param cwd string\n+--- @param opts? { contains?: string, points_at?: string }\n+--- @return string[]\n+local function git_get_tags(cwd, opts)\n+  local cmd = { 'tag', '--list', '--sort=-v:refname' }\n+  if opts and opts.contains then\n+    vim.list_extend(cmd, { '--contains', opts.contains })\n+  end\n+  if opts and opts.points_at then\n+    vim.list_extend(cmd, { '--points-at', opts.points_at })\n+  end\n+  return vim.split(git_cmd(cmd, cwd), '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+\n+--- @return string\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+--- @param x string|vim.VersionRange\n+--- @return boolean\n+local function is_version(x)\n+  return type(x) == 'string' or (pcall(x.has, x, '1'))\n+end\n+\n+--- @return string\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: `source` repository name.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. Can be:\n+--- - `nil` (no value, default) to use repository's default branch (usually `main` or `master`).\n+--- - String to use specific branch, tag, or commit hash.\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the version constraint.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: nil|string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source:gsub('%.git$', '')):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  vim.validate('spec.version', spec.version, is_version, true, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = spec.version }\n+end\n+\n+--- @class (private) vim.pack.PlugInfo\n+--- @field err string The latest error when working on plugin. If non-empty,\n+---   all further actions should not be done (including triggering events).\n+--- @field installed? boolean Whether plugin was successfully installed.\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+--- @field info vim.pack.PlugInfo Gathered information about plugin.\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  local info = { err = '', installed = uv.fs_stat(path) ~= nil }\n+  return { spec = spec_resolved, path = path, info = info }\n+end\n+\n+--- Normalize plug array: gather non-conflicting data from duplicated entries.\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.Plug[]\n+local function normalize_plugs(plugs)\n+  --- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+  local plug_map = {}\n+  local n = 0\n+  for _, p in ipairs(plugs) do\n+    -- Collect\n+    if not plug_map[p.path] then\n+      n = n + 1\n+      plug_map[p.path] = { plug = p, id = n }\n+    end\n+    local p_data = plug_map[p.path]\n+    -- TODO(echasnovski): if both versions are `vim.VersionRange`, collect as\n+    -- their intersection. Needs `vim.version.intersect`.\n+    p_data.plug.spec.version = vim.F.if_nil(p_data.plug.spec.version, p.spec.version)\n+\n+    -- Ensure no conflicts\n+    local spec_ref = p_data.plug.spec\n+    local spec = p.spec\n+    if spec_ref.source ~= spec.source then\n+      local src_1 = tostring(spec_ref.source)\n+      local src_2 = tostring(spec.source)\n+      error(('Conflicting `source` for `%s`:\\n%s\\n%s'):format(spec.name, src_1, src_2))\n+    end\n+    if spec_ref.version ~= spec.version then\n+      local ver_1 = tostring(spec_ref.version)\n+      local ver_2 = tostring(spec.version)\n+      error(('Conflicting `version` for `%s`:\\n%s\\n%s'):format(spec.name, ver_1, ver_2))\n+    end\n+  end\n+\n+  --- @type vim.pack.Plug[]\n+  local res = {}\n+  for _, p_data in pairs(plug_map) do\n+    res[p_data.id] = p_data.plug\n+  end\n+  assert(#res == n)\n+  return res\n+end\n+\n+--- @param names string[]?\n+--- @return vim.pack.Plug[]\n+local function plug_list_from_names(names)\n+  local all_plugins = M.get()\n+  local plugs = {} --- @type vim.pack.Plug[]\n+  -- Preserve plugin order; might be important during checkout or event trigger\n+  for _, p_data in ipairs(all_plugins) do\n+    -- NOTE: By default include only added plugins (and not all on disk). Using\n+    -- not added plugins might lead to a confusion as default `version` and\n+    -- user's desired one might mismatch.\n+    -- TODO(echasnovski): Consider changing this if/when there is lockfile.\n+    --- @cast names string[]\n+    if (not names and p_data.added) or vim.tbl_contains(names or {}, p_data.spec.name) then\n+      plugs[#plugs + 1] = new_plug(p_data.spec)\n+    end\n+  end\n+\n+  return plugs\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'|'PackDeletePre'|'PackDelete'\n+local function trigger_event(p, event_name)\n+  local data = { spec = vim.deepcopy(p.spec), path = p.path }\n+  vim.api.nvim_exec_autocmds(event_name, { pattern = p.path, data = data })\n+end\n+\n+--- @param title string\n+--- @return fun(kind: 'begin'|'report'|'end', percent: integer, fmt: string, ...:any): nil\n+local function new_progress_report(title)\n+  -- TODO(echasnovski): currently print directly in command line because\n+  -- there is no robust built-in way of showing progress:\n+  -- - `vim.ui.progress()` is planned and is a good candidate to use here.\n+  -- - Use `'$/progress'` implementation in 'vim.pack._lsp' if there is\n+  --   a working built-in '$/progress' handler. Something like this:\n+  --   ```lua\n+  --   local progress_token_count = 0\n+  --   function M.new_progress_report(title)\n+  --     progress_token_count = progress_token_count + 1\n+  --     return vim.schedule_wrap(function(kind, msg, percent)\n+  --       local value = { kind = kind, message = msg, percentage = percent }\n+  --       dispatchers.notification(\n+  --         '$/progress',\n+  --         { token = progress_token_count, value = value }\n+  --       )\n+  --     end\n+  --   end\n+  --   ```\n+  -- Any of these choices is better as users can tweak how progress is shown.\n+\n+  return vim.schedule_wrap(function(kind, percent, fmt, ...)\n+    local progress = kind == 'end' and 'done' or ('%3d%%'):format(percent)\n+    print(('(vim.pack) %s: %s %s'):format(progress, title, fmt:format(...)))\n+    -- Force redraw to show installation progress during startup\n+    vim.cmd.redraw({ bang = true })\n+  end)\n+end\n+\n+local n_threads = 2 * #(uv.cpu_info() or { {} })\n+\n+--- Execute function in parallel for each non-errored plugin in the list\n+--- @param plug_list vim.pack.Plug[]\n+--- @param f async fun(p: vim.pack.Plug)\n+--- @param progress_title string\n+local function run_list(plug_list, f, progress_title)\n+  local report_progress = new_progress_report(progress_title)\n+\n+  -- Construct array of functions to execute in parallel\n+  local n_finished = 0\n+  local funs = {} --- @type (async fun())[]\n+  for _, p in ipairs(plug_list) do\n+    -- Run only for plugins which didn't error before\n+    if p.info.err == '' then\n+      --- @async\n+      funs[#funs + 1] = function()\n+        local ok, err = pcall(f, p) --[[@as string]]\n+        if not ok then\n+          p.info.err = err --- @as string\n+        end\n+\n+        -- Show progress\n+        n_finished = n_finished + 1\n+        local percent = math.floor(100 * n_finished / #funs)\n+        report_progress('report', percent, '(%d/%d) - %s', n_finished, #funs, p.spec.name)\n+      end\n+    end\n+  end\n+\n+  if #funs == 0 then\n+    return\n+  end\n+\n+  -- Run async in parallel but wait for all to finish/timeout\n+  report_progress('begin', 0, '(0/%d)', #funs)\n+\n+  --- @async\n+  local function joined_f()\n+    async.join(n_threads, funs)\n+  end\n+  async.run(joined_f):wait()\n+\n+  report_progress('end', 100, '(%d/%d)', #funs, #funs)\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @return boolean\n+local function confirm_install(plug_list)\n+  local sources = {} --- @type string[]\n+  for _, p in ipairs(plug_list) do\n+    sources[#sources + 1] = p.spec.source\n+  end\n+  local sources_str = table.concat(sources, '\\n')\n+  local confirm_msg = ('These plugins will be installed:\\n\\n%s\\n'):format(sources_str)\n+  local res = vim.fn.confirm(confirm_msg, 'Proceed? &Yes\\n&No', 1, 'Question') == 1\n+  vim.cmd.redraw()\n+  return res\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function resolve_version(p)\n+  local function list_in_line(name, list)\n+    return #list == 0 and '' or ('\\n' .. name .. ': ' .. table.concat(list, ', '))\n+  end\n+\n+  -- Resolve only once\n+  if p.info.version_str then\n+    return\n+  end\n+  local version = p.spec.version\n+\n+  -- Default branch\n+  if not version then\n+    p.info.version_str = git_get_default_branch(p.path)\n+    p.info.version_ref = 'origin/' .. p.info.version_str\n+    return\n+  end\n+\n+  -- Non-version-range like version: branch, tag, or commit hash\n+  local branches = git_get_branches(p.path)\n+  local tags = git_get_tags(p.path)\n+  if type(version) == 'string' then\n+    local is_branch = vim.tbl_contains(branches, version)\n+    local is_tag_or_hash = pcall(git_get_hash, version, p.path)\n+    if not (is_branch or is_tag_or_hash) then\n+      local err = ('`%s` is not a branch/tag/commit. Available:'):format(version)\n+        .. list_in_line('Tags', tags)\n+        .. list_in_line('Branches', branches)\n+      error(err)\n+    end\n+\n+    p.info.version_str = version\n+    p.info.version_ref = (is_branch and 'origin/' or '') .. version\n+    return\n+  end\n+  --- @cast version vim.VersionRange\n+\n+  -- Choose the greatest/last version among all matching semver tags\n+  local last_ver_tag --- @type vim.Version\n+  local semver_tags = {} --- @type string[]\n+  for _, tag in ipairs(tags) do\n+    local ver_tag = vim.version.parse(tag)\n+    if ver_tag then\n+      semver_tags[#semver_tags + 1] = tag\n+      if version:has(ver_tag) and (not last_ver_tag or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+  end\n+\n+  if p.info.version_str == nil then\n+    local err = 'No versions fit constraint. Relax it or switch to branch. Available:'\n+      .. list_in_line('Versions', semver_tags)\n+      .. list_in_line('Branches', branches)\n+    error(err)\n+  end\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_states(p)\n+  p.info.sha_head = p.info.sha_head or git_get_hash('HEAD', p.path)\n+\n+  resolve_version(p)\n+  local target_ref = p.info.version_ref or p.info.version_str --[[@as string]]\n+  p.info.sha_target = p.info.sha_target or git_get_hash(target_ref, p.path)\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @async\n+--- @param p vim.pack.Plug\n+--- @param timestamp string\n+--- @param skip_same_sha boolean\n+local function checkout(p, timestamp, skip_same_sha)\n+  infer_states(p)\n+  if skip_same_sha and p.info.sha_head == p.info.sha_target then\n+    return\n+  end\n+\n+  trigger_event(p, 'PackUpdatePre')\n+\n+  local msg = ('(vim.pack) %s Stash before checkout'):format(timestamp)\n+  git_cmd({ 'stash', '--quiet', '--message', msg }, p.path)\n+\n+  git_cmd({ 'checkout', '--quiet', p.info.sha_target }, p.path)\n+\n+  trigger_event(p, 'PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files.\n+  -- Also use `pcall()` because `:helptags` errors if there is no 'doc/'\n+  -- directory or if it is empty.\n+  local doc_dir = vim.fs.joinpath(p.path, 'doc')\n+  vim.fn.delete(vim.fs.joinpath(doc_dir, 'tags'))\n+  pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function install_list(plug_list)\n+  -- Get user confirmation to install plugins\n+  if not confirm_install(plug_list) then\n+    for _, p in ipairs(plug_list) do\n+      p.info.err = 'Installation was not confirmed'\n+    end\n+    return\n+  end\n+\n+  local timestamp = get_timestamp()\n+  --- @async\n+  --- @param p vim.pack.Plug\n+  local function do_install(p)\n+    trigger_event(p, 'PackInstallPre')\n+\n+    git_clone(p.spec.source, p.path)\n+    p.info.installed = true\n+\n+    -- Do not skip checkout even if HEAD and target have same commit hash to\n+    -- have new repo in expected detached HEAD state and generated help files.\n+    checkout(p, timestamp, false)\n+\n+    -- 'PackInstall' is triggered after 'PackUpdate' intentionally to have it\n+    -- indicate \"plugin is installed in its correct initial version\"\n+    trigger_event(p, 'PackInstall')\n+  end\n+  run_list(plug_list, do_install, 'Installing plugins')\n+end\n+\n+--- @async\n+--- @param p vim.pack.Plug\n+local function infer_update_details(p)\n+  infer_states(p)\n+  local sha_head = assert(p.info.sha_head)\n+  local sha_target = assert(p.info.sha_target)\n+\n+  if sha_head ~= sha_target then\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    p.info.update_details = git_cmd({\n+      'log',\n+      '--pretty=format:%m %h │ %s%d',\n+      '--topo-order',\n+      '--decorate-refs=refs/tags',\n+      sha_head .. '...' .. sha_target,\n+    }, p.path)\n+  else\n+    p.info.update_details = table.concat(git_get_tags(p.path, { contains = sha_target }), '\\n')\n+  end\n+\n+  if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+    return\n+  end\n+\n+  -- Remove tags pointing at target (there might be several)\n+  local cur_tags = git_get_tags(p.path, { points_at = sha_target })\n+  local new_tags_arr = vim.split(p.info.update_details, '\\n')\n+  local function is_not_cur_tag(s)\n+    return not vim.tbl_contains(cur_tags, s)\n+  end\n+  p.info.update_details = table.concat(vim.tbl_filter(is_not_cur_tag, new_tags_arr), '\\n')\n+end\n+\n+--- Map from plugin path to its data.\n+--- Use map and not array to avoid linear lookup during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }?>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang? boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory (via `git clone`) and update state to match `version` (via `git checkout`).\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  plugs = normalize_plugs(plugs)\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return not p.info.installed\n+  end, plugs)\n+\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    install_list(plugs_to_install)\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if p.info.installed then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing all errors to have \"good\" plugins added first\n+  local errors = {} --- @type string[]\n+  for _, p in ipairs(plugs_to_install) do\n+    if p.info.err ~= '' then\n+      errors[#errors + 1] = ('`%s`:\\n%s'):format(p.spec.name, p.info.err)\n+    end\n+  end\n+  if #errors > 0 then\n+    local error_str = table.concat(errors, '\\n\\n')\n+    error(('Errors during installation:\\n\\n%s'):format(error_str))\n+  end\n+end\n+\n+--- @param p vim.pack.Plug\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.info.err ~= '' then\n+    return ('## %s\\n\\n %s'):format(p.spec.name, p.info.err:gsub('\\n', '\\n  '))\n+  end\n+\n+  local parts = { '## ' .. p.spec.name .. '\\n' }\n+  local version_suffix = p.info.version_str == '' and '' or (' (%s)'):format(p.info.version_str)\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    parts[#parts + 1] = table.concat({\n+      'Path:   ' .. p.path,\n+      'Source: ' .. p.spec.source,\n+      'State:  ' .. p.info.sha_target .. version_suffix,\n+    }, '\\n')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      parts[#parts + 1] = '\\n\\nAvailable newer tags:\\n• ' .. details\n+    end\n+  else\n+    parts[#parts + 1] = table.concat({\n+      'Path:         ' .. p.path,\n+      'Source:       ' .. p.spec.source,\n+      'State before: ' .. p.info.sha_head,\n+      'State after:  ' .. p.info.sha_target .. version_suffix,\n+      '',\n+      'Pending updates:',\n+      p.info.update_details,\n+    }, '\\n')\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+--- @param skip_same_sha boolean\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, skip_same_sha)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list) do\n+    --- @type string[]\n+    local group_arr = p.info.err ~= '' and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    group_arr[#group_arr + 1] = compute_feedback_lines_single(p)\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.Plug[]\n+local function feedback_log(plug_list)\n+  local lines = { ('========== Update %s =========='):format(get_timestamp()) }\n+  vim.list_extend(lines, compute_feedback_lines(plug_list, true))\n+  lines[#lines + 1] = ''\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+--- @param lines string[]\n+--- @param on_finish fun()\n+local function show_confirm_buf(lines, on_finish)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num = api.nvim_tabpage_get_number(0)\n+  local win_id = api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    on_finish()\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified = false\n+  vim.bo[bufnr].modifiable = false\n+  vim.bo[bufnr].buftype = 'acwrite'\n+  vim.bo[bufnr].filetype = 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2179680270",
            "id": 2179680270,
            "in_reply_to_id": 2178345136,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B60gO",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 816,
            "original_position": 816,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2978581363,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2179680270/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-02T10:16:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2179680270",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2180591174"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2180591174"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Suggestion: `managed`",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-02T17:18:35Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2180591174",
            "id": 2180591174,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6B-S5G",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2980019219,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2180591174/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-02T17:18:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2180591174",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/151598?v=4",
                "events_url": "https://api.github.com/users/noahfrederick/events{/privacy}",
                "followers_url": "https://api.github.com/users/noahfrederick/followers",
                "following_url": "https://api.github.com/users/noahfrederick/following{/other_user}",
                "gists_url": "https://api.github.com/users/noahfrederick/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/noahfrederick",
                "id": 151598,
                "login": "noahfrederick",
                "node_id": "MDQ6VXNlcjE1MTU5OA==",
                "organizations_url": "https://api.github.com/users/noahfrederick/orgs",
                "received_events_url": "https://api.github.com/users/noahfrederick/received_events",
                "repos_url": "https://api.github.com/users/noahfrederick/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/noahfrederick/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/noahfrederick/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/noahfrederick",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182142682"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182142682"
                }
            },
            "author_association": "MEMBER",
            "body": "> can we think of a more semantic name, maybe `load` or `noload` ? or should this be a callback like `on_update` so users can do whatever if they [do or don't like :packadd](https://github.com/neovim/neovim/pull/34009#issuecomment-2966477907) ?\r\n\r\nI like the idea of callable way to do whatever users want here. The best approach seems to me like:\r\n- Rename `bang` to `load` with default value of `true`.\r\n- In follow up allow it to be `@param load? boolean|fun` after discussing use cases and function signature? Like, should it be called on an array of specifications or a single specification, etc.\r\n- In possible `vim.pack.config()` allow it to be globally configurable, so it persists across `vim.pack.add()` calls without custom wrappers.\r\n\r\nDoes that sound good?",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T08:07:30Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182142682",
            "id": 2182142682,
            "in_reply_to_id": 2178326467,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CENra",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2655,
            "original_position": 133,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2982171798,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182142682/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T08:07:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182142682",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182172610"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182172610"
                }
            },
            "author_association": "MEMBER",
            "body": "> seems kind of strange, but hopefully can think of a better name later. not a blocker for now\r\n> \r\n> maybe `own` ? (to indicate that vim.pack owns this plugin)\r\n\r\nHere is the meaning of the flag:\r\n- Let's say there are calls `vim.pack.add('.../plugin1')` and `vim.pack.add('.../plugin2')`. It installs both plugins in '~/.local/share/nvim/site/pack/core/opt/', i.e. there are 'plugin1' and 'plugin2' subdirectories. `vim.pack` is now assumed to *manage* (i.e. *own*) both 'plugin1' and 'plugin2'.\r\n- Restart Nvim and call only `vim.pack.add('.../plugin1')`. The 'plugin1' is now *added* to the current session, while 'plugin2' is not yet added (maybe it is lazy loaded, or something else).\r\n\r\nThe `vim.pack.get()` lists all plugins that are managed/owned by `vim.pack` and indicates which ones of them are currently added to the current session: `true` means added, `false` mean not (yet) added. So I think `added` is a natural name here.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T08:22:12Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182172610",
            "id": 2182172610,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CEU_C",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2982216064,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182172610/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T08:22:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182172610",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182194236"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182194236"
                }
            },
            "author_association": "MEMBER",
            "body": "When adding this to 'highlight_group.c' I mostly followed the path of [`vimdoc` specific highlight groups](https://github.com/neovim/neovim/blob/fc1be07d28ac423d1f8356460a6da45d801c0789/src/nvim/highlight_group.c#L315-L318) and the advice \"if highlight groups is for something that is owned by Neovim, it should be in 'highlight_group.c'\" (can't find the source now).\r\n\r\nUsing `DiagnosticXxx` for title is fine, but I just wanted for them to be different from the actual text. But we can work something out here.\r\n\r\nI can also remove dedicated highlight groups and use their default links directly, but I think allowing color schemes to customize that is important. This can be done in a follow up after discussing the scope and the best place to define them.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T08:32:37Z",
            "diff_hunk": "@@ -224,6 +224,16 @@ static const char *highlight_init_both[] = {\n   \"default link LspSignatureActiveParameter Visual\",\n   \"default link SnippetTabstop              Visual\",\n \n+  // vim.pack\n+  \"default link PackChangeAdded   Added\",\n+  \"default link PackChangeRemoved Removed\",\n+  \"default link PackHint          DiagnosticHint\",\n+  \"default link PackInfo          DiagnosticInfo\",\n+  \"default link PackMsgBreaking   DiagnosticWarn\",\n+  \"default link PackTitleError    DiffDelete\",\n+  \"default link PackTitleSame     DiffText\",\n+  \"default link PackTitleUpdate   DiffAdd\",",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182194236",
            "id": 2182194236,
            "in_reply_to_id": 2178605184,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CEaQ8",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 235,
            "original_position": 12,
            "original_start_line": 232,
            "path": "src/nvim/highlight_group.c",
            "position": null,
            "pull_request_review_id": 2982248813,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182194236/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-03T08:32:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182194236",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182198609"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182198609"
                }
            },
            "author_association": "MEMBER",
            "body": "I've added this to the list of future work.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T08:34:39Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182198609",
            "id": 2182198609,
            "in_reply_to_id": 2178309011,
            "line": 2529,
            "node_id": "PRRC_kwDOAPphoM6CEbVR",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2529,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 5,
            "pull_request_review_id": 2982255569,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182198609/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T08:34:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182198609",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182216779"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182216779"
                }
            },
            "author_association": "MEMBER",
            "body": "> if `'https://foo.com/user/plugin1'` is also specified, how does vim.pack handle the name conflict ? Docs may want to mention that.\r\n\r\nRight now it [normalizes all specs](https://github.com/neovim/neovim/blob/44b11296513974b1ddf7ef7629644be4e2f6be03/runtime/lua/vim/pack.lua#L274-L314) and throws error if there are actual conflicts in `src` or `version`. It will probably also be a good place to use `vim.version.intersect()` to gather several semver ranges as their intersection, which will be important after dependencies are handled somehow.\r\n\r\nOne thing to note is that it is done only inside a single `vim.pack.add()` call, not across different calls. In that case it silently assumes that 'plugin1' is already loaded and does nothing. There is room for improvement here, but it needs a broader discussion about what to do on such conflicts (allow overriding parts of specs or not, etc.).",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T08:43:27Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182216779",
            "id": 2182216779,
            "in_reply_to_id": 2178303691,
            "line": 2550,
            "node_id": "PRRC_kwDOAPphoM6CEfxL",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2550,
            "original_position": 26,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 26,
            "pull_request_review_id": 2982285736,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182216779/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T08:43:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182216779",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182439667"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182439667"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes, at least not excluding the easy possibility to account for order is important. It is less used now after \"more `vim.async`\" changes, but I'd like to get back to it.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T10:30:02Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182439667",
            "id": 2182439667,
            "in_reply_to_id": 2178320067,
            "line": 2624,
            "node_id": "PRRC_kwDOAPphoM6CFWLz",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2624,
            "original_position": 99,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 100,
            "pull_request_review_id": 2982641006,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182439667/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T10:30:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182439667",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182532541"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182532541"
                }
            },
            "author_association": "MEMBER",
            "body": "sounds like `loaded` or `active` would fit. `added` is over-specific and unintuitive, we need to find a more conventional name.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T11:20:41Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182532541",
            "id": 2182532541,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CFs29",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2982786918,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182532541/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T11:21:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182532541",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182540320"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182540320"
                }
            },
            "author_association": "MEMBER",
            "body": "> I mostly followed the path of [`vimdoc` specific highlight groups](https://github.com/neovim/neovim/blob/fc1be07d28ac423d1f8356460a6da45d801c0789/src/nvim/highlight_group.c#L315-L318)\r\n\r\nbut the vimdoc-specific hl groups are not introducing new top-level names. If you want to name these `@standardThing.standardSubThing....pack`, that could make sense.\r\n\r\n\r\n\r\n> Using `DiagnosticXxx` for title is fine, but I just wanted for them to be different from the actual text.\r\n\r\nevery feature thinks it's the most important feature and needs its own special highlights :P\r\n\r\n> but I think allowing color schemes to customize that is important. \r\n\r\nthey can do that already via DiagnosticXX. Just not at hyper-granularity. \r\n\r\n> This can be done in a follow up after discussing the scope and the best place to define them.\r\n\r\nthat unblocks this PR at least 👍 ",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T11:25:07Z",
            "diff_hunk": "@@ -224,6 +224,16 @@ static const char *highlight_init_both[] = {\n   \"default link LspSignatureActiveParameter Visual\",\n   \"default link SnippetTabstop              Visual\",\n \n+  // vim.pack\n+  \"default link PackChangeAdded   Added\",\n+  \"default link PackChangeRemoved Removed\",\n+  \"default link PackHint          DiagnosticHint\",\n+  \"default link PackInfo          DiagnosticInfo\",\n+  \"default link PackMsgBreaking   DiagnosticWarn\",\n+  \"default link PackTitleError    DiffDelete\",\n+  \"default link PackTitleSame     DiffText\",\n+  \"default link PackTitleUpdate   DiffAdd\",",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182540320",
            "id": 2182540320,
            "in_reply_to_id": 2178605184,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CFuwg",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 235,
            "original_position": 12,
            "original_start_line": 232,
            "path": "src/nvim/highlight_group.c",
            "position": null,
            "pull_request_review_id": 2982798636,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182540320/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-03T11:25:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182540320",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182929439"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182929439"
                }
            },
            "author_association": "MEMBER",
            "body": "After a discussion on Matrix, we ended up with `src`. One of the reasons is that `url` might not fit for all allowed values. For example, 'file://...' is an URI and in future there might be support for local plugin (so the value is just path).\r\n\r\nChanged it in recent push.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T14:23:34Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182929439",
            "id": 2182929439,
            "in_reply_to_id": 2178301261,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CHNwf",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2551,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2983400464,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182929439/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T14:23:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182929439",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182932253"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182932253"
                }
            },
            "author_association": "MEMBER",
            "body": "I like `active` and changed to it in latest push.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T14:24:37Z",
            "diff_hunk": "@@ -2523,6 +2523,190 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated *vim.pack-directory* (see |packages|):\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install \"plugin1\" and use default branch (usually `main` or `master`)\n+      'https://github.com/user/plugin1',\n+\n+      -- Same as above, but using a table (allows setting other options)\n+      { source = 'https://github.com/user/plugin1' },\n+\n+      -- Specify plugin's name (here the plugin will be called \"plugin2\"\n+      -- instead of \"generic-name\")\n+      { source = 'https://github.com/user/generic-name', name = 'plugin2' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin3',\n+        -- Version constraint, see |vim.version.range()|\n+        version = vim.version.range('1.0'),\n+      },\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        -- Git branch, tag, or commit hash\n+        version = 'main',\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim (for example, with |:restart|). Plugins that were not yet\n+  installed will be available on disk in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed to `vim.version.range('*')`.\n+• |:restart|. The plugin's actual state on disk is not yet changed.\n+• Execute `vim.pack.update({ 'plugin1' })`.\n+• Review changes and either confirm or discard them. If discarded, revert any\n+  changes in 'init.lua' as well or you will be prompted again next time you\n+  run |vim.pack.update()|.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version` set to current commit hash.\n+  You can get it by running `vim.pack.update({ 'plugin-name' })` and yanking\n+  the word describing current state (looks like `abc12345`).\n+• |:restart|.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• |:restart|.\n+\n+Remove plugins from disk:\n+• Use |vim.pack.del()| with a list of plugin names to remove. Make sure their\n+  specs are not included in |vim.pack.add()| call in 'init.lua' or they will\n+  be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+• *PackDeletePre* - before removing plugin from disk.\n+• *PackDelete* - after removing plugin from disk.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: `source` repository name.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. Can be:\n+                    • `nil` (no value, default) to use repository's default\n+                      branch (usually `main` or `master`).\n+                    • String to use specific branch, tag, or commit hash.\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the version constraint.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.del({names})                                         *vim.pack.del()*\n+    Remove plugins from disk\n+\n+    Parameters: ~\n+      • {names}  (`string[]`) List of plugin names to remove from disk. Must\n+                 be managed by |vim.pack|, not necessarily already added in\n+                 current session.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {added} (`boolean`) Whether plugin was added via |vim.pack.add()| in",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182932253",
            "id": 2182932253,
            "in_reply_to_id": 2178329804,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CHOcd",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 2674,
            "original_position": 152,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2983404788,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182932253/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T14:24:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182932253",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182936989"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182936989"
                }
            },
            "author_association": "MEMBER",
            "body": "After discussing on Matrix, we did go for `PackChanged` and `PackChangedPre`. Mostly because `XxxChanged` is a more established pattern in event name than `XxxUpdate`. Plus it might be a bit confusing to use `PackUpdate` name for \"on delete/install\" hooks, given there is a `vim.pack.update()` already.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T14:26:34Z",
            "diff_hunk": "@@ -87,6 +87,12 @@ return {\n     QuickFixCmdPost = false, -- after :make, :grep etc.\n     QuickFixCmdPre = false, -- before :make, :grep etc.\n     QuitPre = false, -- before :quit\n+    PackDeletePre = false, -- before removing `vim.pack` plugin from disk\n+    PackDelete = false, -- after removing `vim.pack` plugin from disk\n+    PackInstallPre = false, -- before installing `vim.pack` plugin\n+    PackInstall = false, -- after installing `vim.pack` plugin\n+    PackUpdatePre = false, -- before updating `vim.pack` plugin\n+    PackUpdate = false, -- after updating `vim.pack` plugin",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182936989",
            "id": 2182936989,
            "in_reply_to_id": 2178600385,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CHPmd",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 95,
            "original_position": 9,
            "original_start_line": null,
            "path": "src/nvim/auevents.lua",
            "position": null,
            "pull_request_review_id": 2983412073,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182936989/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-03T14:26:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182936989",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2182944735"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182944735"
                }
            },
            "author_association": "MEMBER",
            "body": "I've reverted to use already available highlight groups: mostly `DiagnosticXxx` plus `Added` / `Removed` for changelog.\r\n\r\nAlso added \"discuss adding dedicated highlight groups\" for future work.",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-03T14:29:44Z",
            "diff_hunk": "@@ -224,6 +224,16 @@ static const char *highlight_init_both[] = {\n   \"default link LspSignatureActiveParameter Visual\",\n   \"default link SnippetTabstop              Visual\",\n \n+  // vim.pack\n+  \"default link PackChangeAdded   Added\",\n+  \"default link PackChangeRemoved Removed\",\n+  \"default link PackHint          DiagnosticHint\",\n+  \"default link PackInfo          DiagnosticInfo\",\n+  \"default link PackMsgBreaking   DiagnosticWarn\",\n+  \"default link PackTitleError    DiffDelete\",\n+  \"default link PackTitleSame     DiffText\",\n+  \"default link PackTitleUpdate   DiffAdd\",",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2182944735",
            "id": 2182944735,
            "in_reply_to_id": 2178605184,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CHRff",
            "original_commit_id": "44b11296513974b1ddf7ef7629644be4e2f6be03",
            "original_line": 235,
            "original_position": 12,
            "original_start_line": 232,
            "path": "src/nvim/highlight_group.c",
            "position": null,
            "pull_request_review_id": 2983425120,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182944735/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-03T14:29:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2182944735",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2184215377"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2184215377"
                }
            },
            "author_association": "NONE",
            "body": "`is_closed` > `is_closing`\r\n\r\n`vim.lsp.rpc.PublicClient` doesn't have an `is_closed` field.\r\n",
            "commit_id": "d21b8c949ad7213b372486b45225f691934d6a6d",
            "created_at": "2025-07-04T03:17:25Z",
            "diff_hunk": "@@ -0,0 +1,168 @@\n+local M = {}\n+\n+local capabilities = {\n+  codeActionProvider = true,\n+  documentSymbolProvider = true,\n+  hoverProvider = true,\n+}\n+--- @type table<string,function>\n+local methods = {}\n+\n+--- @param callback function\n+function methods.initialize(_, callback)\n+  return callback(nil, { capabilities = capabilities })\n+end\n+\n+--- @param callback function\n+function methods.shutdown(_, callback)\n+  return callback(nil, nil)\n+end\n+\n+local get_confirm_bufnr = function(uri)\n+  return tonumber(uri:match('^nvim%-pack://(%d+)/confirm%-update$'))\n+end\n+\n+--- @param params { textDocument: { uri: string } }\n+--- @param callback function\n+methods['textDocument/documentSymbol'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return callback(nil, {})\n+  end\n+\n+  --- @alias vim.pack.lsp.Position { line: integer, character: integer }\n+  --- @alias vim.pack.lsp.Range { start: vim.pack.lsp.Position, end: vim.pack.lsp.Position }\n+  --- @alias vim.pack.lsp.Symbol {\n+  ---   name: string,\n+  ---   kind: number,\n+  ---   range: vim.pack.lsp.Range,\n+  ---   selectionRange: vim.pack.lsp.Range,\n+  ---   children: vim.pack.lsp.Symbol[]?,\n+  --- }\n+\n+  --- @return vim.pack.lsp.Symbol?\n+  local new_symbol = function(name, start_line, end_line, kind)\n+    if name == nil then\n+      return nil\n+    end\n+    local range = {\n+      start = { line = start_line, character = 0 },\n+      ['end'] = { line = end_line, character = 0 },\n+    }\n+    return { name = name, kind = kind, range = range, selectionRange = range }\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+\n+  --- @return vim.pack.lsp.Symbol[]\n+  local parse_headers = function(pattern, start_line, end_line, kind)\n+    local res, cur_match, cur_start = {}, nil, nil\n+    for i = start_line, end_line do\n+      local m = lines[i + 1]:match(pattern)\n+      if m ~= nil and m ~= cur_match then\n+        table.insert(res, new_symbol(cur_match, cur_start, i, kind))\n+        cur_match, cur_start = m, i\n+      end\n+    end\n+    table.insert(res, new_symbol(cur_match, cur_start, end_line, kind))\n+    return res\n+  end\n+\n+  local group_kind = vim.lsp.protocol.SymbolKind.Namespace\n+  local symbols = parse_headers('^# (%S+)', 0, #lines - 1, group_kind)\n+\n+  local plug_kind = vim.lsp.protocol.SymbolKind.Module\n+  for _, group in ipairs(symbols) do\n+    local start_line, end_line = group.range.start.line, group.range['end'].line\n+    group.children = parse_headers('^## (.+)$', start_line, end_line, plug_kind)\n+  end\n+\n+  return callback(nil, symbols)\n+end\n+\n+--- @param callback function\n+methods['textDocument/codeAction'] = function(_, callback)\n+  -- TODO(echasnovski)\n+  -- Suggested actions for \"plugin under cursor\":\n+  -- - Delete plugin from disk.\n+  -- - Update only this plugin.\n+  -- - Exclude this plugin from update.\n+  return callback(_, {})\n+end\n+\n+--- @param params { textDocument: { uri: string }, position: { line: integer, character: integer } }\n+--- @param callback function\n+methods['textDocument/hover'] = function(params, callback)\n+  local bufnr = get_confirm_bufnr(params.textDocument.uri)\n+  if bufnr == nil then\n+    return\n+  end\n+\n+  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n+  local lnum = params.position.line + 1\n+  local commit = lines[lnum]:match('^[<>] (%x+) │') or lines[lnum]:match('^State.*:%s+(%x+)')\n+  local tag = lines[lnum]:match('^• (.+)$')\n+  if commit == nil and tag == nil then\n+    return\n+  end\n+\n+  local path, path_lnum = nil, lnum - 1\n+  while path == nil and path_lnum >= 1 do\n+    path = lines[path_lnum]:match('^Path:%s+(.+)$')\n+    path_lnum = path_lnum - 1\n+  end\n+  if path == nil then\n+    return\n+  end\n+\n+  local cmd = { 'git', 'show', '--no-color', commit or tag }\n+  --- @param sys_out vim.SystemCompleted\n+  local on_exit = function(sys_out)\n+    local markdown = '```diff\\n' .. sys_out.stdout .. '\\n```'\n+    local res = { contents = { kind = vim.lsp.protocol.MarkupKind.Markdown, value = markdown } }\n+    callback(nil, res)\n+  end\n+  vim.system(cmd, { cwd = path }, vim.schedule_wrap(on_exit))\n+end\n+\n+local dispatchers = {}\n+\n+-- TODO: Simplify after `vim.lsp.server` is a thing\n+-- https://github.com/neovim/neovim/pull/24338\n+local cmd = function(disp)\n+  -- Store dispatchers to use for showing progress notifications\n+  dispatchers = disp\n+  local res, closing, request_id = {}, false, 0\n+\n+  function res.request(method, params, callback)\n+    local method_impl = methods[method]\n+    if method_impl ~= nil then\n+      method_impl(params, callback)\n+    end\n+    request_id = request_id + 1\n+    return true, request_id\n+  end\n+\n+  function res.notify(method, _)\n+    if method == 'exit' then\n+      dispatchers.on_exit(0, 15)\n+    end\n+    return false\n+  end\n+\n+  function res.is_closed()",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2184215377",
            "id": 2184215377,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6CMHtR",
            "original_commit_id": "73b9281b41db39adacb2c2b91bc526d5e1754315",
            "original_line": 153,
            "original_position": 153,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack/_lsp.lua",
            "position": null,
            "pull_request_review_id": 2985288948,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2184215377/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-04T03:17:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2184215377",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/90168447?v=4",
                "events_url": "https://api.github.com/users/luozhiya/events{/privacy}",
                "followers_url": "https://api.github.com/users/luozhiya/followers",
                "following_url": "https://api.github.com/users/luozhiya/following{/other_user}",
                "gists_url": "https://api.github.com/users/luozhiya/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/luozhiya",
                "id": 90168447,
                "login": "luozhiya",
                "node_id": "MDQ6VXNlcjkwMTY4NDQ3",
                "organizations_url": "https://api.github.com/users/luozhiya/orgs",
                "received_events_url": "https://api.github.com/users/luozhiya/received_events",
                "repos_url": "https://api.github.com/users/luozhiya/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/luozhiya/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/luozhiya/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/luozhiya",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "NONE",
            "body": "What about url schemas, like Nix has with its `fetchTree` (and, by extension, flakes): \"gitlab:some-fella/plug.nvim\" for \"https://gitlab.com/some-fella/plug.nvim.git\"? Or will that be too much for this?",
            "created_at": "2025-05-13T19:40:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2877746784",
            "id": 2877746784,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rhu5g",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 3,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877746784/reactions"
            },
            "updated_at": "2025-05-15T12:39:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877746784",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/94849097?v=4",
                "events_url": "https://api.github.com/users/acid-bong/events{/privacy}",
                "followers_url": "https://api.github.com/users/acid-bong/followers",
                "following_url": "https://api.github.com/users/acid-bong/following{/other_user}",
                "gists_url": "https://api.github.com/users/acid-bong/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/acid-bong",
                "id": 94849097,
                "login": "acid-bong",
                "node_id": "U_kgDOBadISQ",
                "organizations_url": "https://api.github.com/users/acid-bong/orgs",
                "received_events_url": "https://api.github.com/users/acid-bong/received_events",
                "repos_url": "https://api.github.com/users/acid-bong/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/acid-bong/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/acid-bong/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/acid-bong",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> What about url schemas, like Nix has with its `fetchTree` (and, by extension, flakes): \"gitlab:some-fella/plug.nvim\" for \"https://gitlab.com/some-fella/plug.nvim.git\"? Or will that be too much for this?\r\n\r\nThe actual flexibility that is welcomed here will be a topic of discussion. Right now the most established pattern among plugin managers is to only allow \"user/plugin\" as a stand-in for \"https://github.com/user/plugin\". If even this kind of \"magic\" is welcome needs discussion with core team. There is [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2087294117) that brings up this and similar issues.\r\n\r\n---\r\n\r\nI'd also like to take an opportunity and kindly ask for people outside of Neovim team to deeply consider if adding a comment will help the discussion. There will probably be a lot of comments as is and navigating a PR with lots of comments becomes problematic very quickly. Thanks for understanding!",
            "created_at": "2025-05-13T20:04:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2877808718",
            "id": 2877808718,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rh-BO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877808718/reactions"
            },
            "updated_at": "2025-05-13T20:04:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877808718",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Can I ask about the choice never to use the `start/` directory? More generally, I'm wondering why `vim.pack.add` always calls `:packadd` behind the scenes. Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes. (I have several plugins that fall into that category for me.) It seems better to me to use `start/` and `opt/` as designed, so that items in `start/` are always sourced and items in `opt/` are left to be manually sourced by the user. But you may have reasons I haven't thought of. Anyhow, I'd be curious to hear your rationale for this part of the design.",
            "created_at": "2025-05-13T22:52:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2878132814",
            "id": 2878132814,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rjNJO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878132814/reactions"
            },
            "updated_at": "2025-05-13T22:52:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878132814",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Can I ask about the choice never to use the start/ directory?\r\n\r\nThen if you want to disable plugins, you have to manually move them to `opt`. That is bad UX.\r\n\r\nI remember @justinmk once said the Nvim team generally think `pack/*/start` is unnecessary",
            "created_at": "2025-05-14T01:24:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2878364447",
            "id": 2878364447,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rkFsf",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 6,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878364447/reactions"
            },
            "updated_at": "2025-05-14T01:28:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878364447",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Can I ask about the choice never to use the start/ directory?\r\n> \r\n> Then if you want to disable plugins, you have to manually move them to `opt`.\r\n\r\nNo, that doesn't follow. The plugin manager can move plugins between `start/` and `opt/` as necessary so that the user does not have to do anything manually. (It shouldn't take much extra code: plugin configurations can have a boolean field for `opt` that defaults to false.)\r\n\r\n> That is bad UX.\r\n>\r\n> I remember justinmk once said the Nvim team generally think pack/*/start is unnecessary\r\n\r\nI think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system. It's true that `pack/*/start` is not absolutely necessary, but the system of `start/` versus `opt/` makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nIf the core team is against it, I doubt I will convince them, but here's my final argument. It's better to support both `start/` and `opt/` because that allows more people to use the built-in plugin manager. People who prefer `opt/` for everything can put all their plugins in `opt/` and `:packadd` them all at startup. Other people can put most things in `start/` and a few things in `opt/` (and `:packadd` those when they want). But if the plugin manager ignores `start/`, then only users who prefer everything in `opt/` are supported. I think that a built-in tool should support as many users as possible rather than be overly opinionated. ",
            "created_at": "2025-05-14T11:42:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2879870302",
            "id": 2879870302,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rp1Ve",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879870302/reactions"
            },
            "updated_at": "2025-05-14T12:00:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879870302",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The plugin manager can move plugins between start/ and opt/ as necessary so that the user does not have to do anything manually. (It shouldn't take much extra code: plugin configurations can have a boolean field for opt that defaults to false.)\r\n\r\nIt does make the code more complicated than just\r\n```lua\r\n-- pseudo code\r\nif not pack.opt then\r\n    vim.cmd('packadd! ' .. pack.name)\r\nend\r\n```\r\nNot to say checking if a plugin is in `start/` directory and then moving it could be slow.\r\n\r\n> I think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system.\r\n\r\nIt seems you misunderstood what \"UX\" means.\r\n\r\n> It's true that pack/*/start is not absolutely necessary, but the system of start/ versus opt/ makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nI already answered that, and Chasnovski has also answered that right in the description of this PR.\r\n\r\n> People who prefer opt/ for everything can put all their plugins in opt/ and :packadd them all at startup. Other people can put most things in start/ and a few things in opt/ (and :packadd those when they want). But if the plugin manager ignores start/, then only users who prefer everything in opt/ are supported.\r\n\r\nWhy would people care if the plugin manager use `start/` or not?",
            "created_at": "2025-05-14T11:58:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2879930418",
            "id": 2879930418,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqEAy",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879930418/reactions"
            },
            "updated_at": "2025-05-14T15:45:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879930418",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes.\r\n\r\nYes, it is possible. Call `vim.pack.add()` with plugin spec only when you want to use the plugin. If plugin is absent it will be automatically installed.\r\nWithout plugin manager it is two step: 1) manually put plugin in pack/*/opt; 2) call `:packadd` when you want to use it.\r\n\r\n> I think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system. It's true that `pack/*/start` is not absolutely necessary, but the system of `start/` versus `opt/` makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nThe fact that there is choice to make doesn't mean every choice fits every situation. Nothing here \"undermines the system\".\r\n\r\n> People who prefer `opt/` for everything can put all their plugins in `opt/` and `:packadd` them all at startup. Other people can put most things in `start/` and a few things in `opt/` (and `:packadd` those when they want). ... I think that a built-in tool should support as many users as possible rather than be overly opinionated.\r\n\r\nBoth \"put all in 'opt/' and `:packadd` all of them\" and \"put most in 'start/' and some in 'opt/'\" is supported with `vim.pack`. \r\n\r\nPutting a plugin in 'start/' is (in aspects that usually matter, not like 'rtp' order, etc.) the same as putting a `vim.pack.add()` line in an 'init.lua' that is executed on every startup.\r\n\r\nPutting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.",
            "created_at": "2025-05-14T12:17:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880003283",
            "id": 2880003283,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqVzT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880003283/reactions"
            },
            "updated_at": "2025-05-14T12:17:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880003283",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes.\r\n> \r\n> Yes, it is possible. Call `vim.pack.add()` with plugin spec only when you want to use the plugin. If plugin is absent it will be automatically installed. Without plugin manager it is two step: 1) manually put plugin in pack/*/opt; 2) call `:packadd` when you want to use it.\r\n>...\r\n> Putting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.\r\n\r\nMaybe this is where I am confused. Will vim.pack uninstall packages that are present in `opt/` but no longer in a user's start-up files? If not, then I think I see what you're saying. I was worried that plugins not currently in use would be uninstalled—and then need to be reinstalled later.\r\n\r\n",
            "created_at": "2025-05-14T12:41:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880072549",
            "id": 2880072549,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqmtl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880072549/reactions"
            },
            "updated_at": "2025-07-01T17:44:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880072549",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Putting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.\r\n\r\nI am currently using mini.deps, which implements the behavior proposed here, and I have a couple of plugins that I load on demand by calling `add()` when I need to as suggested here.\r\n\r\nThis has two side effects that I don't think are desirable: if the plugin is not loaded when `vim.pack.update()` is called the plugin will not be updated and it will be removed when `vim.pack.clean()` is run.\r\n\r\nI think a way to separately indicate \"this is a plugin I want installed\" and \"this is a plugin I want loaded\" is useful.\r\n\r\nWhether this results in putting the files in start/opt or just a flag to call or skip packadd I have no opinion on.",
            "created_at": "2025-05-14T13:00:31Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880163546",
            "id": 2880163546,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rq87a",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 7,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 7,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880163546/reactions"
            },
            "updated_at": "2025-07-01T17:44:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880163546",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/15096481?v=4",
                "events_url": "https://api.github.com/users/micampe/events{/privacy}",
                "followers_url": "https://api.github.com/users/micampe/followers",
                "following_url": "https://api.github.com/users/micampe/following{/other_user}",
                "gists_url": "https://api.github.com/users/micampe/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/micampe",
                "id": 15096481,
                "login": "micampe",
                "node_id": "MDQ6VXNlcjE1MDk2NDgx",
                "organizations_url": "https://api.github.com/users/micampe/orgs",
                "received_events_url": "https://api.github.com/users/micampe/received_events",
                "repos_url": "https://api.github.com/users/micampe/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/micampe/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/micampe/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/micampe",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Maybe this is where I am confused. Will vim.pack uninstall packages that are present in `opt/` but no longer in a user's start-up files? If not, then I think I see what you're saying. I was worried that plugins not currently in use would be uninstalled—and then need to be reinstalled later.\r\n\r\nNo, `vim.pack` doesn't remove those plugins from disk. They are there just waiting to be loaded. They can even be updated when not loaded (just not with default `:lua vim.pack.update()` at the moment), but that is problematic currently because `vim.pack` doesn't know about which `version` to use. That would require some version of lockfile (which is planned).\r\n\r\nIn fact, there is currently no functionality of removing plugins from disk at all. I do want to have an \"interactive way\" to do that inside confirmation buffer, but not sure if the whole design is still acceptable. And the \"scripting way\" is also planned (see \"Planned future work\" in first comment).\r\n\r\n---\r\n\r\n> This has two side effects that I don't think are desirable: if the plugin is not loaded when `vim.pack.update()` is called the plugin will not be updated and it will be removed when `vim.pack.clean()` is run.\r\n\r\nThe plugin not being updated during `vim.pack.update()` is addressed couple of paragraphs above (i.e. \"it requires some sort of lockfile\"). The \"will be removed after `clean()`\" is intentional: \"clean\" means remove all plugins that are not used. And 'mini.deps' allows you to interactively adjust which plugins to not remove (by deleting lines), which can be done in `vim.pack` also.",
            "created_at": "2025-05-14T13:02:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880170352",
            "id": 2880170352,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rq-lw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880170352/reactions"
            },
            "updated_at": "2025-05-14T13:07:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880170352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The \"will be removed after clean()\" is intentional: \"clean\" means remove all plugins that are not used.\r\n\r\nBut \"are not used\" is now ambiguous. Some plugins \"are not used (at startup)\"—meaning plugins that are wanted but which users will only sometimes call on with a manual `vim.pack.add`.  But it also can mean \"are not used (at all)\"—meaning plugins that the user wants removed from disk.\r\n\r\nI agree with micampe that \"a way to separately indicate 'this is a plugin I want installed' and 'this is a plugin I want loaded\"' is useful.\" As he says, one way to do this is with `start/` and `opt/`, but you can also do it other ways.\r\n",
            "created_at": "2025-05-14T13:17:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880216947",
            "id": 2880216947,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rrJ9z",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880216947/reactions"
            },
            "updated_at": "2025-05-14T13:18:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880216947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> But \"are not used\" is now ambiguous. Some plugins \"are not used (at startup)\"—meaning plugins that are wanted but which users will only sometimes call on with a manual `vim.pack.add`. But it also can mean \"are not used (at all)\"—meaning plugins that the user wants removed from disk.\r\n\r\nIf anything, this is a point towards not having automated \"cleaning\" in favor of manually selected one (which I'd suggest having in `vim.pack`).\r\n\r\n> I agree with micampe that \"a way to separately indicate 'this is a plugin I want installed' and 'this is a plugin I want loaded\"' is useful.\" As he says, one way to do this is with `start/` and `opt/`, but you can also do it other ways.\r\n\r\nHaving 'start/' and 'opt/' causes more troubles than brings good. Yes, having an extra `load` flag in `vim.pack.Spec` is possible. At the moment I personally lean towards implementing lockfile (to be able to properly update \"plugins that are not yet loaded\") plus only manual plugin removal (inside confirmation buffer or `vim.pack.remove()`). Mostly because this both solves actual problems without introducing new fields in spec (which is usually better for usability and maintainability).\r\n\r\n---\r\n\r\nYou (collective) were heard on this topic. Please, let's not continue this discussion here and wait for reviews and (hopefully) merge. After that, these separate subjects can be discussed in a more structured fashion inside separate issues. It is clearly stated as yet work in progress.",
            "created_at": "2025-05-14T14:00:47Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306",
            "id": 2880367306,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rrurK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 6,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880367306/reactions"
            },
            "updated_at": "2025-05-14T14:00:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880367306",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I realized that original demo didn't showcase the \"in-process LSP\" part of the PR. So I decided to add 'textDocument/hover' support (as it is pretty straightforward) and here is the result:\r\n\r\nhttps://github.com/user-attachments/assets/230a056f-12b9-40e6-861e-76fa136fd1e1\r\n\r\nThis is how a clean install looks, but in combination with \"pretty LSP\" plugins it can be customized without any burden on `vim.pack` itself.",
            "created_at": "2025-05-15T13:10:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2883761573",
            "id": 2883761573,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6r4rWl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2883761573/reactions"
            },
            "updated_at": "2025-05-15T13:10:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2883761573",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There were visible changes in workflow:\r\n\r\n- The `version = nil` case is now the same as \"use default branch\" (usually `main` or `master`). The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2091371243).\r\n- Any plugin installation now requires an explicit user confirmation. The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094169684).\r\n- There is now `vim.pack.del()` to remove installed plugins from disk. The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094172936).",
            "created_at": "2025-05-19T16:58:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2891698715",
            "id": 2891698715,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6sW9Ib",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2891698715/reactions"
            },
            "updated_at": "2025-05-19T16:59:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2891698715",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Can you add an example of how to install a plugin (eg. [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)) with `vim.pack` to [runtime/example_init.lua](https://github.com/neovim/neovim/blob/master/runtime/example_init.lua), when the API is done?",
            "created_at": "2025-05-22T00:29:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2899572293",
            "id": 2899572293,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6s0_ZF",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2899572293/reactions"
            },
            "updated_at": "2025-05-22T05:48:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2899572293",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "The `vim.pack.update()` now doesn't have `offline` option. The decision of whether it is needed is postponed until after there is lockfile support. This also means that (temporarily) changing `version` for already installed plugin requires internet connection. The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094170341).",
            "created_at": "2025-05-23T12:16:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2904232370",
            "id": 2904232370,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6tGxGy",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2904232370/reactions"
            },
            "updated_at": "2025-05-23T12:16:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2904232370",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There's an issue if the spec list contains duplicate url's:\r\n\r\n```lua\r\nlocal pack = require('vim.pack')\r\npack.add {\r\n  'https://github.com/hrsh7th/nvim-cmp',\r\n  'https://github.com/hrsh7th/nvim-cmp',\r\n}\r\n```\r\n\r\ncauses error:\r\n\r\n```\r\nError in /Users/lewis/projects/neovim/plugs.lua:\r\nE5113: Lua chunk: /Users/lewis/projects/neovim/runtime/lua/vim/pack.lua:665: Error in `nvim-cmp` during installation:\r\nError code 128\r\nfatal: could not create work tree dir '/Users/lewis/.data/nvim/site/pack/core/opt/nvim-cmp': File exists\r\nstack traceback:\r\n        [C]: in function 'error'\r\n        /Users/lewis/projects/neovim/runtime/lua/vim/pack.lua:665: in function 'show_notifications'\r\n        /Users/lewis/projects/neovim/runtime/lua/vim/pack.lua:758: in function 'add'\r\n        /Users/lewis/projects/neovim/plugs.lua:2: in main chunk\r\n```",
            "created_at": "2025-05-31T14:56:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2925297258",
            "id": 2925297258,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6uXH5q",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925297258/reactions"
            },
            "updated_at": "2025-05-31T14:56:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925297258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "When installing plugins for the first time, nvim appears to hang for some time and there isn't any messages until all plugins have been installed\r\n\r\n\r\n\r\nhttps://github.com/user-attachments/assets/2199da3b-c45a-42f4-9eb4-a7d51727cd2c\r\n\r\nCan this be improved?",
            "created_at": "2025-05-31T15:02:25Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2925307322",
            "id": 2925307322,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6uXKW6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925307322/reactions"
            },
            "updated_at": "2025-05-31T15:02:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925307322",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> There's an issue if the spec list contains duplicate url's:\r\n\r\nYeah, I was aware of that (it is actually if there are duplicated `name` fields), but figured it could wait until there is a need for a proper spec list normalization. Can do it now also.\r\n\r\n> there isn't any messages until all plugins have been installed\r\n> ...\r\n> Can this be improved?\r\n\r\nThere are messages shown via [LSP progress](https://github.com/neovim/neovim/blob/ab420f1a8869cf14e5bb5cffebeb9834f316754d/runtime/lua/vim/pack.lua#L454). They are visible in top right in the [initial demo](https://github.com/neovim/neovim/pull/34009#issue-3060712969) when there is a proper `'$/progress'` handler defined.\r\n\r\nShould also be seen with something like `vim.cmd(\"autocmd LspProgress * lua print(vim.lsp.status()); vim.cmd('redraw!')\")` before `vim.pack.add()`.\r\n\r\nAs there are (actually progressing) plans to show LSP progress in default statusline (#28809) I've figured using it should be fine. If not, I'd say using `vim.ui.progress` from #32537 when it comes to life is also possible (should not be too long, as it is GSOC project). Reimplementing something custom seems to be over-the-top as proper showing progress (LSP or not) is worth having in core and is planned.",
            "created_at": "2025-05-31T15:45:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2925351442",
            "id": 2925351442,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6uXVIS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925351442/reactions"
            },
            "updated_at": "2025-05-31T15:51:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2925351442",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Rebased on `master` to [mention `:restart`](https://github.com/neovim/neovim/pull/34009/commits/060fbadf0219e6d34eabe705c763fd53582789ac).\r\n\r\nAlso added [whole array normalization in `add()`](https://github.com/neovim/neovim/pull/34009/commits/8a829179c8e5839e35d0585250eed8d8d514148f): it collects non-duplicating specs and errors if there are conflicts in `source` or `version`. So [this](https://github.com/neovim/neovim/pull/34009#issuecomment-2925297258) now works without errors.",
            "created_at": "2025-06-03T13:12:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2935169380",
            "id": 2935169380,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6u8yFk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2935169380/reactions"
            },
            "updated_at": "2025-06-03T13:12:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2935169380",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "So I've had a good study of the implementation and I'm not super comfortable with how it's structured. It is all centred around being able to call `vim.system()` with a list of plugins and can only run 1 kind of operation in parallel at once. I think this makes the code quite awkward and unintuitive and not as efficient as it could be. I especially don't like having to set `p.info.cmd` and `p.info.cwd` in a callback before calling `:run`. This can be improved.\r\n\r\nI'm going to try to push a PR to your fork which adds a very small async lib (~100 LOC) along with the necessary changes to use it. This isn't the final solution, but does put the implementation into a form so it can be refactored and simplified, and more importantly allows many more things to be run asynchronously.\r\n\r\nWhen I did the initial prototype of adding an async lib, after applying the revealed opportunities to refactor, I ended up touching most lines in the module, so for now I've just done the basics to enable better async support. Normally I make such changes in a follow-up PR, but because adding async support results in so much changing, I think it's probably best to get this in first.\r\n\r\nHope this is ok.\r\n\r\nOther than that, I'm pretty happy with this, and hope we can get this merged soon.\r\n\r\nEDIT: PR here: https://github.com/echasnovski/neovim/pull/2",
            "created_at": "2025-06-04T14:18:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2940224254",
            "id": 2940224254,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vQEL-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940224254/reactions"
            },
            "updated_at": "2025-06-04T14:18:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940224254",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> It is all centred around being able to call `vim.system()` with a list of plugins and can only run 1 kind of operation in parallel at once.\r\n\r\nYeah, this is usually \"fast enough\" without adding complexity (and lines of code) of a separate `async`. If temporarily inlining the future `vim.async` is okay and won't harm the goal of \"minimal single file plugin manager\", then it is totally okay (as long as the overall design of having `add()` wait for all install jobs to finish stays).\r\n\r\n> I especially don't like having to set `p.info.cmd` and `p.info.cwd` in a callback before calling `:run`.\r\n\r\nSetting `cwd` is only needed one time to `clone`, other times it is set to  plugin's directory. Also, the overall idea of having `cmd` set inside `prepare` callback looks better if formatting allows single-line functions (like `local function prepare(p) p.job.cmd = stash_cmd end`) which is the case in 'mini.nvim' but not here. I agree that with multiline formatting it is a bit off.\r\n\r\n> Other than that, I'm pretty happy with this, and hope we can get this merged soon.\r\n\r\nThat's great! I do would like to here thoughts on my not-yet-resolved comments. They are mostly about fundamental naming that is better get right from the start.\r\n\r\n> EDIT: PR here: [echasnovski#2](https://github.com/echasnovski/neovim/pull/2)\r\n\r\nThanks, I'll take a close look (hopefully) tomorrow.\r\n\r\n\r\n\r\n",
            "created_at": "2025-06-04T15:08:44Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2940404288",
            "id": 2940404288,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vQwJA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940404288/reactions"
            },
            "updated_at": "2025-06-04T15:08:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940404288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Yeah, this is usually \"fast enough\" without adding complexity (and lines of code) of a separate async. If temporarily inlining the future vim.async is okay \r\n\r\nIn my prototype the final LOC was around the same if not less. If you prefer you can pull it out into a `_async.lua` file which can serve as the initial beginning of `vim.async`.",
            "created_at": "2025-06-04T15:45:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2940531976",
            "id": 2940531976,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vRPUI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 3,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940531976/reactions"
            },
            "updated_at": "2025-06-04T15:45:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2940531976",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I've pushed async stuff (with a separate commit introducing dedicated `vim._async` that will be kept for future). @lewis6991, enabling `await` in '.luarc.json' results in failing linting in unrelated code parts. What would you suggest here to do: disable it for the time being or to wait until those are resolved (I'd like to not touch them on my own)? All fails are `Async function can only be called in async function. (await-in-sync)`, so does it mean adding `--- @async` in all the right places?\r\n\r\nAlso pushed pure refactor changes, without functionality changes or fixes. That'll be (hopefully) tomorrow.",
            "created_at": "2025-06-05T17:19:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2945352755",
            "id": 2945352755,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vjoQz",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2945352755/reactions"
            },
            "updated_at": "2025-06-05T17:19:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2945352755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Remove the `.luarc.json` change for now. I just added it to make sure I added `@async` in all the right places.",
            "created_at": "2025-06-05T18:08:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2945546753",
            "id": 2945546753,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vkXoB",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2945546753/reactions"
            },
            "updated_at": "2025-06-05T18:08:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2945546753",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm testing this implementation and I have some questions:\r\n1. Is it intended behaviour that all the messages telling me that a package has been installed appear all at the end? I would expect to informing me while I wait.\r\n\r\n<details><summary>Current Behaviour</summary>\r\n<p>\r\n\r\nhttps://github.com/user-attachments/assets/f915e10b-545a-4546-9464-61c23fadd191\r\n\r\n</p>\r\n</details> \r\n\r\n<details><summary>Expected Behaviour</summary>\r\n<p>\r\n\r\nhttps://github.com/user-attachments/assets/66e4ae20-8005-4f90-a7be-4486c0283e8a\r\n\r\n</p>\r\n</details> \r\n\r\n2. Do you really need to block the user input when downloading the plugins after the confirmation prompt? I'm asking because I read some of the source code but maybe I don't get the reason.  \r\n\r\n3. Currently you have to specify the entire url to register a plugin, can be annoying especially because I use different methods depending on the machine, ssh at work and https at home, in my implementation you can configure how the source is normalized. For example I can just say \"tpope/vim-fugitive\" and then it will be converted using `Config.url_format` that contains a formatted lua string (the default is `https://github.com/%s.git`). \\\r\n \\\r\nIt is pretty simple to check if a source is a full url or not, I do something like:\r\n```lua\r\nlocal url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\r\n  or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\r\n```\r\n\r\n  Also if in the future you want to add a command to add quickly a plugin I think having something like this is can be very ergonomic.\r\n\r\nIs it something you want to address later or at all when you introduce `pack.config()` or something?\r\n\r\n4. This is pedantic but it would be really nice if I can just define a plugin with some option using a sintax like `{ <plugin-name>, opts }` instead of having to spell out `{ source = <plugin-name>, opts }`. It's not really a deal breaker but I don't think is difficult to normalized.\r\n\r\n```lua\r\nif pkg[1] then\r\n  pkg.source = pkg[1]\r\n  pkg[1] = nil\r\nend\r\n```",
            "created_at": "2025-06-06T11:00:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2948890775",
            "id": 2948890775,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxICX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948890775/reactions"
            },
            "updated_at": "2025-06-06T11:08:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948890775",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> 1. Is it intended behaviour that all the messages telling me that a package has been installed appear all at the end?\r\n\r\nThis is because there is no LSP progress handler enabled by default. Discussed [here](https://github.com/neovim/neovim/pull/34009#discussion_r2123790910) and [here](https://github.com/neovim/neovim/pull/34009#issuecomment-2925351442).\r\n\r\n> 2\\. Do you really need to block the user input when downloading the plugins after the confirmation prompt? I'm asking because I read some of the source code but maybe I don't get the reason.\r\n\r\nYes, this is the a core design of `vim.pack.add()`: after it is finished, the target plugins should be already present on disk so that the config code afterwards can assume that plugin is present and use something like `require('my-plugin').setup()`.\r\n\r\n> 3\\. Currently you have to specify the entire url to register a plugin, ...\r\n> ...\r\n> > 4\\. This is pedantic but it would be really nice if I can just define a plugin with some option using a sintax like `{ <plugin-name>, opts }` instead of having to spell out `{ source = <plugin-name>, opts }`. ...\r\n\r\nBoth of these were discussed [here](https://github.com/neovim/neovim/pull/34009#discussion_r2087294117). At least for initial PR having full URL and explicit source is fine. I am not particularly opposed to changing any of these per se:\r\n- The URL formats might be configured as `vim.pack.config({ format_source = function(source) ... end })`. I'd personally like that.\r\n- Allowing `[1] = 'https:...'` is just a matter of design decision. I'd personally would not like that. It is not big of a deal to prepend with the explicit field. Maybe making it shorter (like `url` or `src`) would be a better direction here.",
            "created_at": "2025-06-06T11:30:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2948960726",
            "id": 2948960726,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxZHW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948960726/reactions"
            },
            "updated_at": "2025-06-06T11:30:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948960726",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> 1. Is it intended behaviour that all the messages telling me that a package has been installed appear all at the end? I would expect to informing me while I wait.\r\n\r\nI've noticed that too. Now that this has better async support, I think that can be improved more easily.\r\n\r\n> 2. Do you really need to block the user input when downloading the plugins after the confirmation prompt? I'm asking because I read some of the source code but maybe I don't get the reason.\r\n\r\nThat is one of @echasnovski main requirements that `vim.pack.add()` is fully synchronous and the plugin is guaranteed to be loaded after this call. For now, I think this is fine, but I would like to add in an opt-in way of making this asynchronous in the future, perhaps adding an optional callback argument to `vim.pack.add()` to activate async.\r\n\r\n> 3. Currently you have to specify the entire url to register a plugin, can be annoying especially because I use different methods depending on the machine, ssh at work and https at home, in my implementation you can configure how the source is normalized. For example I can just say \"tpope/vim-fugitive\" and then it will be converted using Config.url_format that contains a formatted lua string (the default is https://github.com/%s.git). \r\n\r\nFor now I think specifying the url is fine. You can easily wrap `vim.pack.add` to augment how the url is passed. This is exactly what I've done in my config so I can quickly switch between `vim.pack` and pckr.nvim without having to change my config.\r\n\r\nFWIW I do think in the future we should support something like `github:tpope/vim-fugitive` and allow some way to configure how `gtihub:` is treated: `ssh`, `https` or `gh`.\r\n\r\n> 4. This is pedantic but it would be really nice if I can just define a plugin with some option using a sintax like { <plugin-name>, opts } instead of having to spell out { source = <plugin-name>, opts }. It's not really a deal breaker but I don't think is difficult to normalized.\r\n\r\nAgain you can create trivial wrappers to do this. For reference here are the wrappers I'm using:\r\n\r\nvim.pack:\r\n```lua\r\n  function M.setup()\r\n    vim.pack.add(init)\r\n    for _, spec in ipairs(init) do\r\n      local config = spec.config\r\n      if type(config) == 'function' then\r\n        config()\r\n      elseif type(config) == 'string' then\r\n        require(config)\r\n      end\r\n    end\r\n    init = {}\r\n  end\r\n\r\n  --- @param name string\r\n  --- @param spec? Pckr.UserSpec\r\n  function M.add(name, spec)\r\n    spec = spec or {}\r\n    local requires = spec.requires\r\n    if type(requires) == 'table' then\r\n      for _, req in ipairs(requires) do\r\n        if type(req) == 'table' then\r\n          M.add(req[1], req[2])\r\n        else\r\n          M.add(req)\r\n        end\r\n      end\r\n    elseif type(requires) == 'string' then\r\n      M.add(requires)\r\n    end\r\n    spec.source = 'https://github.com/' .. name\r\n    init[#init + 1] = spec\r\n  end\r\n```\r\n\r\npckr.nvim:\r\n```lua\r\n  function M.setup()\r\n    local pckr = require('pckr')\r\n\r\n    pckr.setup({\r\n      git = { default_url_format = 'git@github.com:/%s' },\r\n      max_jobs = 30,\r\n    }, init)\r\n\r\n    init = {}\r\n  end\r\n\r\n  --- @param name string\r\n  --- @param spec? Pckr.UserSpec\r\n  function M.add(name, spec)\r\n    spec = spec or {}\r\n    spec[1] = name\r\n    init[#init + 1] = spec\r\n  end\r\n```\r\n\r\nExample usage:\r\n\r\n```lua\r\nM.add('lewis6991/gitsigns.nvim', { config = 'lewis6991.gitsigns' })\r\nM.add('nvim-treesitter/nvim-treesitter-context', {\r\n  requires = 'nvim-treesitter/nvim-treesitter',\r\n  config = function()\r\n    require('treesitter-context').setup({\r\n      max_lines = 5,\r\n      trim_scope = 'outer',\r\n      multiwindow = true,\r\n    })\r\n  end,\r\n})\r\nM.add('tpope/vim-unimpaired')\r\nM.add('tpope/vim-repeat')\r\nM.add('tpope/vim-eunuch')\r\nM.add('tpope/vim-surround')\r\nM.add('tpope/vim-fugitive')\r\nM.add('tpope/vim-sleuth')\r\nM.setup()\r\n```",
            "created_at": "2025-06-06T11:32:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2948964825",
            "id": 2948964825,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxaHZ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948964825/reactions"
            },
            "updated_at": "2025-06-06T11:36:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948964825",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Again you can create trivial wrappers to do this. For reference here are the wrappers I'm using:\r\n\r\nYes, yes I was just wondering if it is in the scope of the current PR or if it is a next step kind of thing. I don't have really an issue **for now** to have a wrapper in my config.\r\n\r\n> This is because there is no LSP progress handler enabled by default. Discussed https://github.com/neovim/neovim/pull/34009#discussion_r2123790910 and https://github.com/neovim/neovim/pull/34009#issuecomment-2925351442.\r\n\r\nOk, I've tested this using:\r\n\r\n```lua\r\nvim.api.nvim_create_autocmd(\"LspProgress\", {\r\n    pattern = \"*\",\r\n    group = vim.api.nvim_create_augroup(\"progress\", {}),\r\n    callback = function(_)\r\n        vim.notify(vim.lsp.status())\r\n        vim.cmd.redraw()\r\n    end,\r\n})\r\n```\r\n\r\nThis works but I have to redraw the screen every time to see the changes ",
            "created_at": "2025-06-06T11:46:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2948998953",
            "id": 2948998953,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxicp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948998953/reactions"
            },
            "updated_at": "2025-06-06T11:46:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2948998953",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I found and issue were if I had `.git` at the end it will treat it as a separate plugin.\r\n\r\n```lua\r\n\"tpope/vim-fugitive\" ~= \"tpope/vim-fugitive.git\"\r\n```\r\n\r\n![image](https://github.com/user-attachments/assets/2cf13eef-4147-405f-b83a-058c2cf9e94b)\r\n",
            "created_at": "2025-06-06T11:57:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949025550",
            "id": 2949025550,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxo8O",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949025550/reactions"
            },
            "updated_at": "2025-06-06T11:57:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949025550",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I found and issue were if I had `.git` at the end it will treat it as a separate plugin.\r\n\r\nThis was also discussed [here](https://github.com/neovim/neovim/pull/34009#discussion_r2087294117) and can also be subject to something like `vim.pack.config({ infer_name = function(source) end })`. Although removing '.git' suffixmight be worth doing by default, the current initial implementation is \"as less magic as possible\" here. The default value is documented to be \"basename of `source`.\", which also includes \".git\" suffix.",
            "created_at": "2025-06-06T12:09:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949054333",
            "id": 2949054333,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vxv99",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949054333/reactions"
            },
            "updated_at": "2025-06-06T12:09:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949054333",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Although removing '.git' suffixmight be worth doing by default, the current initial implementation is \"as less magic as possible\" here. The default value is documented to be \"basename of source.\", which also includes \".git\" suffix.\r\n\r\nIdk I would expect to behave more like git clone, witch removes the `.git` postfix from the directory name, but I don't really care that strongly about this.",
            "created_at": "2025-06-06T12:16:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949074700",
            "id": 2949074700,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vx08M",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949074700/reactions"
            },
            "updated_at": "2025-06-06T12:16:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949074700",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Are repo names allowed to end with `.git` e.g. would `https://github.com/user/proj.git.git` be valid?",
            "created_at": "2025-06-06T12:17:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949077181",
            "id": 2949077181,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vx1i9",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949077181/reactions"
            },
            "updated_at": "2025-06-06T12:17:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949077181",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Are repo names allowed to end with .git e.g. would https://github.com/user/proj.git.git be valid?\r\n\r\nAs far as I know and tested with git clone only a single `.git` postfix is allow. If you try something like `git clone https://github.com/b3nj5m1n/xdg-ninja.git.git` it will simply fail to locate it because it thinks that the first `.git` is part of the name",
            "created_at": "2025-06-06T12:20:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949084444",
            "id": 2949084444,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vx3Uc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949084444/reactions"
            },
            "updated_at": "2025-06-06T12:25:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949084444",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Are repo names allowed to end with `.git` e.g. would `https://github.com/user/proj.git.git` be valid?\r\n\r\nThe Git repos in general are allowed to end with `.git`. For example, this works:\r\n\r\n```bash\r\n> mkdir my.git.git.git\r\n> cd my.git.git.git\r\n> git init\r\n> cd -\r\n> git clone my.git.git.git my-git\r\n```\r\n\r\nRepo names on Github are not allowed to end with `.git` (I know because [only 'mini-git' was allowed](https://github.com/echasnovski/mini-git/)).\r\n\r\nSo *in theory* plugin's `source` *might* end with a `.git` that is intended to be the part of the name, while most common cases of hosts (at least GitHub) would not allow it. In fact, it will not allow `.git` suffix in any form (initial or sanitized) : trying to create repo `hello.git.git.git` says that it will create repo named `hello`'.",
            "created_at": "2025-06-06T12:32:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949127067",
            "id": 2949127067,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vyBub",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949127067/reactions"
            },
            "updated_at": "2025-06-06T12:32:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949127067",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> So in theory plugin's source might end with a .git that is intended to be the part of the name, while most common cases of hosts (at least GitHub) would not allow it. In fact, it will not allow .git suffix in any form (initial or sanitized) : trying to create repo hello.git.git.git says that it will create repo named hello'.\r\n\r\nYes apparently is not a thing that git by itself enforce (at least reading the official [git-url format](https://git-scm.com/docs/http-protocol#_url_format)) but it seems that any forge I've tried doesn't let you create a repository using `.git` at the end (I've tried on github, gitlab and codeberg witch also exclude forjeo and gitea).\r\n\r\nSo I think is safe to remove the `.git` at the end by default and then when if the user uses for some reasons repo names with `.git` they can configure it themself.\r\n\r\nOther sources I've found:\r\n- https://github.com/orgs/community/discussions/22859\r\n- https://stackoverflow.com/questions/65043372/is-git-at-end-of-repository-name-important-in-local-git-repository-remote-re\r\n- https://stackoverflow.com/questions/11947587/is-there-a-naming-convention-for-git-repositories",
            "created_at": "2025-06-06T12:43:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949154589",
            "id": 2949154589,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6vyIcd",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949154589/reactions"
            },
            "updated_at": "2025-06-06T12:44:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949154589",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Pushed fixes/improvements based on recent feedback:\r\n- Instead of providing progress updates via LSP progress (which is better for user customization), it is now hard-coded with custom `print()` of progress info. This provides better out of the box experience, but I'd like to eventually go the more user-customizable route (be it LSP `$/progress` when there is good built-in handler or `vim.ui.progress`). Using `vim.notify()` instead of `print()` *is* user-customizable, but it results into a separate message for each progress update (I'm personally fine with it, but it *is* a bit too much with something like 'mini.notify' or 'nvim-notify'). Relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2123790910).\r\n- Default number of threads is increased from 80% of available hardware logical threads to 200%. Relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2126941070).\r\n- Default `name` now doesn't include possible '.git' suffix of `source`. The `source` itself is not adjusted though (`https://some-site.com/neovim/nvim-lspconfig` and `https://some-site.com/neovim/nvim-lspconfig.git` are not treated as the same source). Relevant discussion starts [here](https://github.com/neovim/neovim/pull/34009#issuecomment-2949025550).\r\n\r\nHere is how the fresh install and update process of 43 plugins looks now:\r\n\r\nhttps://github.com/user-attachments/assets/7eff3e2c-0f45-46e1-ba5f-e8fe7e6d3205\r\n",
            "created_at": "2025-06-06T17:01:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2949889365",
            "id": 2949889365,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6v071V",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 4,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949889365/reactions"
            },
            "updated_at": "2025-06-06T17:01:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2949889365",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Pushed updates after following reviews from @lewis6991. The code now more uses `vim._async` (a bit cleaner and overall faster), but doesn't enforce order in several places:\r\n- `Pack{Install,Update}{Pre,}` events are triggered in not guaranteed order. Previously they always were triggered in order plugins were supplied to `vim.pack.add()`. This allowed to treat order of `vim.pack.add()` input as a manual dependency resolution proxy, but that came at a cost of extra async breakpoints (where all async tasks are waited to finish). How to deal with that is left as future discussions and work. The relevant discussion starts [here](https://github.com/echasnovski/neovim/pull/3#discussion_r2135577470).\r\n- During installation of several plugins, progress updates and \"Updated state\" notifications are intertwined, because checkout is now part of the installation. Previously there was a breakpoint between installing all plugins and checking them out, so those messages were separated. This currently results in a flicker (demo of which I'll post after `confirm()` issues are resolved, see #34414). On practical level there are several solutions here:\r\n    - Do nothing. The progress update is shown with `print()` and is planned to be shown with customizable `vim.ui.progress()`, while notifications use `vim.notify()`. The latter is already customizable and likely that users will have it different from `print()`. Maybe after extui is more polished, this will even come out of the box. I'd prefer this approach.\r\n    - Stop showing \"Updated state\" during initial installation. I personally don't like this approach, as having at least *some* confirmation that plugin is installed in correct state improves confidence that everything is as expected. This might not matter much with default branch case, but in case when `version` is `vim.version.range` it will show the resolved version.\r\n    - Somehow delay notifications during installation to be shown all at once. Seems complicated and unnecessary.",
            "created_at": "2025-06-10T13:25:06Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959258852",
            "id": 2959258852,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wYrTk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959258852/reactions"
            },
            "updated_at": "2025-06-10T13:25:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959258852",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "If a third-party plugin calls `vim.pack.add`, will the plugin be downloaded?\r\nThis may be a topic that needs careful consideration, even if a confirmation dialog is shown.\r\n\r\nI think it's ok if plugins that the user lists in the config file are downloaded.",
            "created_at": "2025-06-10T13:36:41Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959296916",
            "id": 2959296916,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wY0mU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959296916/reactions"
            },
            "updated_at": "2025-06-10T15:23:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959296916",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> If a third-party plugin calls `vim.pack.add`, will the plugin be downloaded?\r\n> This may be a topic that needs careful consideration, even if a confirmation dialog is shown.\r\n\r\nThe main idea of `vim.pack.add()` is a \"smarter `:packadd`\". I.e. ensure that plugin is present on disk (i.e. downloaded) and then `:packadd`ed. If \"main\" plugin doesn't want other to be downloaded, let it do `:packadd`. I am not opposed to adding something like `opts.skip_install` flag to `vim.pack.add()`, but the general idea of \"ensure plugins are present on disk and available in current session\" is too useful for user configs.\r\n\r\nHowever, I don't think `vim.pack.add()` (and plugin manager in general) is designed to be used by third-party plugins (that don't want to build a more capable plugin manager on top of it). If the goal of calling `vim.pack.add()` is to declare other plugin as a dependency, then it is planned to be possible via a separate manifest-like file ('pkg.json').",
            "created_at": "2025-06-10T13:49:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959340099",
            "id": 2959340099,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wY_JD",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959340099/reactions"
            },
            "updated_at": "2025-06-10T15:23:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959340099",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "If a malicious plugin is installed, it can perform more dangerous operations than installing other plugins (such as executing os commands).\r\nSo while it may not be a big problem, it's still worth considering.",
            "created_at": "2025-06-10T15:17:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959669035",
            "id": 2959669035,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6waPcr",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959669035/reactions"
            },
            "updated_at": "2025-06-10T15:23:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959669035",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> If a third-party plugin calls vim.pack.add, will the plugin be downloaded?\n\nI think it doesn't need `vim.pack.add`, it could just clone to `pack/*/start/` directory",
            "created_at": "2025-06-10T15:20:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959689743",
            "id": 2959689743,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6waUgP",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959689743/reactions"
            },
            "updated_at": "2025-06-10T15:23:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959689743",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> If a malicious plugin is installed, it can perform more dangerous operations than installing other plugins (such as executing os commands).\r\nSo while it may not be a big problem, it's still worth considering.\r\n\r\nA malicious plugin can already call `vim.system()`/`vim.fn.system()`/`vim.fn.jobstart()` and do anything it wants. That is 100x worse than installing random plugins with `vim.pack.add()`.",
            "created_at": "2025-06-10T15:22:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2959694997",
            "id": 2959694997,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6waVyV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959694997/reactions"
            },
            "updated_at": "2025-06-10T15:23:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2959694997",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> During installation of several plugins, progress updates and \"Updated state\" notifications are intertwined\r\n\r\nIs it necessary to notify the user of state changes like: `(vim.pack) Updated state to master in vim-fugitive`? I would argue that it would be better to just log it somewhere or simply don't show it. If the plugin manager is working correctly the state is the one in the config, so it is a bit redundant I feel like. Also this prevent the problem of interpolation of messages all together.",
            "created_at": "2025-06-11T10:48:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2962193093",
            "id": 2962193093,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wj3rF",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962193093/reactions"
            },
            "updated_at": "2025-06-11T10:50:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962193093",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Is it necessary to notify the user of state changes like: `(vim.pack) Updated state to master in vim-fugitive`? I would argue that it would be better to just log it somewhere or simply don't show it.\r\n\r\nMy thought process is already described in [this comment](https://github.com/neovim/neovim/pull/34009#issuecomment-2959258852). Here is the relevant part:\r\n\r\n> Stop showing \"Updated state\" during initial installation. I personally don't like this approach, as having at least some confirmation that plugin is installed in correct state improves confidence that everything is as expected. This might not matter much with default branch case, but in case when `version` is `vim.version.range` it will show the resolved version.\r\n\r\nHaving *something* shown as a result of `vim.pack.update()` is absolutely crucial, though. Otherwise there is no feedback that changes were actually made after `:write` in confirmation buffer or `vim.pack.update(nil, { force = true })`. ",
            "created_at": "2025-06-11T11:26:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2962314255",
            "id": 2962314255,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wkVQP",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962314255/reactions"
            },
            "updated_at": "2025-06-11T11:26:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962314255",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Both `vim.pack.add()` and `vim.pack.update()` need to have a result shown for each plugin. However, `vim.pack.add()` currently shows 2 results for each plugin, I think this should be reduced to one.",
            "created_at": "2025-06-11T11:36:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2962343658",
            "id": 2962343658,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wkcbq",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962343658/reactions"
            },
            "updated_at": "2025-06-11T11:36:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962343658",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Both `vim.pack.add()` and `vim.pack.update()` need to have a result shown for each plugin. However, `vim.pack.add()` currently shows 2 results for each plugin, I think this should be reduced to one.\r\n\r\nThis feels like 2 results only because they use the same way to display things with current bare bones Nvim. But the one is an entry in overall progress update while the other is the notification about an actually performed action. Those are meant to be displayed without overlapping (either with the future `vim.ui.progress` and/or with customized `vim.notify`), so flickering will not be an issue.\r\n\r\nFor the time being (at least while progress update is shown with `print`), I'll push (probably tomorrow) silencing notifications while there is a progress update: i.e. both during install in `vim.pack.add()` and `vim.pack.update(nil, { force = true })`. The `:write` in confirmation buffer will still show those notifications.\r\n\r\nI think also the possible future `vim.pack.add()` functionality (after there is a private lockfile) of ensuring proper `version` and `source` should also come with a notification if plugin is already present on disk.",
            "created_at": "2025-06-11T11:53:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2962388079",
            "id": 2962388079,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wknRv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962388079/reactions"
            },
            "updated_at": "2025-06-11T11:53:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2962388079",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Pushed the change that doesn't show \"Updated state\" notifications if there is active progress report (currently during install and force update). Also made progress titles different for forced (\"Updating\") and not forced (\"Downloading updates\") cases, as they do perform slightly different things.\r\n\r\nI'll wait for #34414 to merge before rebasing, squashing, resolving news conflicts, and posting new demo (it is mostly similar to [this one](https://github.com/neovim/neovim/pull/34009#issuecomment-2949889365), though, with some cosmetic changes).",
            "created_at": "2025-06-12T09:09:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2965770170",
            "id": 2965770170,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6wxg-6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965770170/reactions"
            },
            "updated_at": "2025-06-12T09:09:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965770170",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Combination of question from the other PR which was more relevant to this one:\r\n\r\n- part 1:\r\n---\r\n\r\nIs it possible with this implementation to download a plugin WITHOUT calling `packadd` on it (at all)? Im having issues figuring it out. It seems to me like I can only choose between `packadd` and `packadd!`. I want to just download the thing. I don't want my downloading of stuff complected in with how I load it or I get randomly blindsided by stuff that I haven't downloaded, usually the moment I don't have wifi.\r\n\r\nIf I can easily download all my plugins up front without calling packadd on them, I am happy.\r\n\r\n---\r\n- part 2:\r\n---\r\n\r\ncalling `packadd!` is meaningfully different than not calling `packadd!` or `packadd` at all.\r\n\r\nIt would allow you to call require on the plugin without any of the plugins `plugin/*` or `ftplugin/*` scripts being loaded ever, which may lead to unintended effects, and confusion, and it doesnt seem to offer an alternative to that.\r\n\r\nIt would interfere with anything designed to load if something could not be found via require as well, such as in lze if you use the on_require handler, the config in your spec would not trigger and the plugin and ftplugin scripts would not be ran, as it was already present when it tried to require it.\r\n\r\nAs the implementation does not create ways to lazily load plugins more easily than using packadd itself, only downloading the things when you do it, [lze](https://github.com/BirdeeHub/lze) and [lz.n](https://github.com/nvim-neorocks/lz.n) will be very relevant to how people manage lazy loading going forwards, as they solve the \"multiple triggers, 1 plugin\" problem, and not being able to have full control over whether the plugin is available or not is bad for both of these solutions, and probably others.\r\n\r\nNow, of course, in both lze and lz.n you can change the load function used. You could change the load function to be a call to vim.pack.add() with the info. Both can be extended to handle this, its not ultimately the biggest issue for either plugin, but it still has the issue of things not being downloaded until they are loaded, which many users might not like, myself included.\r\n\r\nBasically, 1 extra option should be added to allow it to not call `packadd` or `packadd!` if you dont want that to happen. Because it is a lot easier and faster to never add something to the `rtp` than it is to add it then remove it.\r\n\r\nThere is already `bang = true`, it can probably also afford an `opt = true`",
            "created_at": "2025-06-12T12:19:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2966477907",
            "id": 2966477907,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6w0NxT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966477907/reactions"
            },
            "updated_at": "2025-06-12T12:29:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966477907",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Pushed rebased on `master` code and squashed all previous commits (as there started to be plenty already). It also includes massive polishing from @lewis6991 (echasnovski/neovim#4).\r\n\r\nAs there is now a mandatory progress update for any parallel action (including when doing local checkout), I completely removed \"Updated state\" notifications for now (as it falls under \"no notifications if there is progress update\" rule from earlier). Maybe this can be revisited after progress is shown not via `print()` by default (because I still think that showing it separately with a resolved version is still worth it).\r\n\r\nAs #34414 is merged, there is now no hack for confirming during startup. Plain `vim.fn.confirm()` is used (mostly comes down to different color in confirmation message and no 100ms delay during start).\r\n\r\nHere is the demo of the current first install and update:\r\n\r\nhttps://github.com/user-attachments/assets/d688a4cb-8b27-4b0b-a424-a364673f1fb5\r\n\r\n",
            "created_at": "2025-06-12T14:43:41Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2967131799",
            "id": 2967131799,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6w2taX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 4,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967131799/reactions"
            },
            "updated_at": "2025-06-12T14:43:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967131799",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Just to be clear, I'd still like to add at least basic end-to-end tests in initial PR. This will make future changes/discussions much easier. But I'll wait for @justinmk review first.",
            "created_at": "2025-06-12T16:59:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2967589211",
            "id": 2967589211,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6w4dFb",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967589211/reactions"
            },
            "updated_at": "2025-06-12T16:59:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967589211",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "What if I put the opt setting into the plugin spec? would that be better than including it alongside bang? Should bang also be moved into the plugin spec?\r\n\r\nIf so I am happy to work on that now and PR it before it gets merged. I really dont think it should be merged in any capacity without this. Anything would be ok with me. As long as I can tell it not to packadd.",
            "created_at": "2025-06-12T18:01:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2967752404",
            "id": 2967752404,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6w5E7U",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967752404/reactions"
            },
            "updated_at": "2025-06-12T22:42:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967752404",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> What if I put the opt setting into the plugin spec? would that be better than including it alongside bang? Should bang also be moved into the plugin spec?\r\n\r\nThere will be a separate dedicated discussion after this is merged (it is listed in the future work, so it shouldn't be forgotten). As already was the answer [here](https://github.com/neovim/neovim/pull/34009#discussion_r2142637867).",
            "created_at": "2025-06-12T18:07:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2967765418",
            "id": 2967765418,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6w5IGq",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967765418/reactions"
            },
            "updated_at": "2025-06-14T11:02:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967765418",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Is there already an option to disable confirmation? I would like to replace lazy.nvim with it while preserving the modular config structure it encourages. This would mean having multiple files with around 40 `vim.pack.add` calls instead of shoving all plugin installations into a single one. I’m afraid the first init would require me to press confirm 40 times, so there should definitely be an option to disable this invasive behavior (globally)",
            "created_at": "2025-07-03T08:06:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3031294915",
            "id": 3031294915,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60rePD",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3031294915/reactions"
            },
            "updated_at": "2025-07-03T08:08:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3031294915",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/80050619?v=4",
                "events_url": "https://api.github.com/users/miroshQa/events{/privacy}",
                "followers_url": "https://api.github.com/users/miroshQa/followers",
                "following_url": "https://api.github.com/users/miroshQa/following{/other_user}",
                "gists_url": "https://api.github.com/users/miroshQa/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/miroshQa",
                "id": 80050619,
                "login": "miroshQa",
                "node_id": "MDQ6VXNlcjgwMDUwNjE5",
                "organizations_url": "https://api.github.com/users/miroshQa/orgs",
                "received_events_url": "https://api.github.com/users/miroshQa/received_events",
                "repos_url": "https://api.github.com/users/miroshQa/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/miroshQa/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/miroshQa/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/miroshQa",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I’m afraid the first init would require me to press confirm 40 times, so there should definitely be an option to disable this invasive behavior (globally)\r\n\r\nOn one hand, it is a problem only for the first install, which is not a huge deal. On the other hand, I've added this to the follow up work as part of \"Consider making `vim.pack.add()` more flexible\".",
            "created_at": "2025-07-03T08:26:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3031354558",
            "id": 3031354558,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60rsy-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 1,
                "confused": 1,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3031354558/reactions"
            },
            "updated_at": "2025-07-03T08:26:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3031354558",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > I’m afraid the first init would require me to press confirm 40 times, so there should definitely be an option to disable this invasive behavior (globally)\r\n> \r\n> On one hand, it is a problem only for the first install, which is not a huge deal. On the other hand, I've added this to the follow up work as part of \"Consider making `vim.pack.add()` more flexible\".\r\n\r\n\r\nIt is bold to state it is not a huge deal to press confirm 40 times!!! It definitely is for me. Some people may generally not like any confirmation prompts and would like to disable them even if they have to press it just once. Allowing this is basically like 5 additional lines of code (assuming there is some API for configuring it, like vim.pack.config), so I don’t see any reason to postpone it, it’s an absolute basic feature.\r\n\r\nBesides that, the inability to disable confirmation prevents users from making wrappers over vim.pack.add (for example, a custom confirmation prompt or whatever...) because there is no way to programmatically prevent it. vim.pack.add seems to take too much responsibility on itself, in my opinion. I would say the confirmation prompt should be provided by some other plugin that wraps vim.pack.add, or if it stays as it is now, then vim.pack.add should at least accept some value in the opts table to disable it locally.",
            "created_at": "2025-07-03T14:02:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032399701",
            "id": 3032399701,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60vr9V",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032399701/reactions"
            },
            "updated_at": "2025-07-03T17:09:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032399701",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/80050619?v=4",
                "events_url": "https://api.github.com/users/miroshQa/events{/privacy}",
                "followers_url": "https://api.github.com/users/miroshQa/followers",
                "following_url": "https://api.github.com/users/miroshQa/following{/other_user}",
                "gists_url": "https://api.github.com/users/miroshQa/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/miroshQa",
                "id": 80050619,
                "login": "miroshQa",
                "node_id": "MDQ6VXNlcjgwMDUwNjE5",
                "organizations_url": "https://api.github.com/users/miroshQa/orgs",
                "received_events_url": "https://api.github.com/users/miroshQa/received_events",
                "repos_url": "https://api.github.com/users/miroshQa/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/miroshQa/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/miroshQa/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/miroshQa",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Note that the \"40 confirmations\" is predicated on \r\n\r\n>  I would like to replace lazy.nvim with it while preserving the modular config structure it encourages.\r\n\r\nThere is absolutely no _requirement_ for `vim.pack` to support niceties from other, much more complex, plugin managers. So this is indeed out of scope for the MVP (at least).\r\n\r\nIf the builtin `vim.pack` meets your needs, great! Otherwise you are more than welcome to keep using other plugins that fit your preferences better.",
            "created_at": "2025-07-03T14:07:04Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032416504",
            "id": 3032416504,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60vwD4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032416504/reactions"
            },
            "updated_at": "2025-07-03T17:10:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032416504",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> There is absolutely no _requirement_ for `vim.pack` to support niceties from other, much more complex, plugin managers. So this is indeed out of scope for the MVP (at least).\r\n> \r\nI don't understand what **niceties** you mean. The issue has nothing to do with lazy.nvim actually. I just described one of the cases where a confirmation prompt prevents me from using `vim.pack` as I want. The inability to make a custom confirmation prompt was the second example. This isn't about features actually, I'd even say it's more about **decreasing** \"features\" of `vim.pack.add`. It imposes a confirmation prompt on users who may not want it and gives no way to disable it, reducing extensibility and possible use cases.\r\n\r\nThe main point: it's just **5 lines of code** to add an option in the `opts` table for `vim.pack.add` to disable this locally. Global configuration could indeed be considered later.\r\n\r\n\r\n",
            "created_at": "2025-07-03T14:29:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032490241",
            "id": 3032490241,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60wCEB",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032490241/reactions"
            },
            "updated_at": "2025-07-03T17:10:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032490241",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/80050619?v=4",
                "events_url": "https://api.github.com/users/miroshQa/events{/privacy}",
                "followers_url": "https://api.github.com/users/miroshQa/followers",
                "following_url": "https://api.github.com/users/miroshQa/following{/other_user}",
                "gists_url": "https://api.github.com/users/miroshQa/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/miroshQa",
                "id": 80050619,
                "login": "miroshQa",
                "node_id": "MDQ6VXNlcjgwMDUwNjE5",
                "organizations_url": "https://api.github.com/users/miroshQa/orgs",
                "received_events_url": "https://api.github.com/users/miroshQa/received_events",
                "repos_url": "https://api.github.com/users/miroshQa/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/miroshQa/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/miroshQa/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/miroshQa",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> . I just described one of the cases where a confirmation prompt prevents me from using vim.pack as I want.\r\n\r\nAnd I just said \"thanks, duly noted, but the final decision is the maintainers'.\" Input is welcome; arguing is not. (This PR already has over 200 comments, and every single one adds friction.)",
            "created_at": "2025-07-03T14:33:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032500919",
            "id": 3032500919,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60wEq3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032500919/reactions"
            },
            "updated_at": "2025-07-03T14:33:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032500919",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Pushed the changes based on the recent round of review:\r\n- Several renames:\r\n    - `nvimpack` filetype and URI prefix is `nvim-pack`. I do like the idea of using just `pack`, but it feels a bit too much. Plus there is something in C# that uses `pack://application/...` URI scheme (not sure how much this matters).\r\n    - `source` in plugin spec is now `src`.\r\n    - `bang` in `vim.pack.add()` is now a more descriptive `load`. It is boolean for now, but might be extended to be function to take care of plugin loading in the future.\r\n    - `added` in `vim.pack.get()` output is now `active`. Relevant discussion starts [here](https://github.com/neovim/neovim/pull/34009#discussion_r2178329804).\r\n- Instead of two dedicated events for each action, there is now only `PackChangedPre` and `PackChanged` with populated `data.kind` (\"install\", \"update\", \"delete\"). Relevant discussion starts [here](https://github.com/neovim/neovim/pull/34009#discussion_r2178600385).\r\n- There is no dedicated highlight groups for confirmation report. It uses directly already present built-in groups, mostly `DiagnosticXxx` plus `Added` / `Removed`. Titles also use diagnostic groups for consistency and based on #32646. Relevant discussion starts [here](https://github.com/neovim/neovim/pull/34009#discussion_r2178605184).\r\n\r\nHere is the demo of the current state:\r\n\r\nhttps://github.com/user-attachments/assets/9b6c52ed-f8c4-4a2f-8656-6c9eddd338f2",
            "created_at": "2025-07-03T14:39:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032521412",
            "id": 3032521412,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60wJrE",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 5,
                "total_count": 5,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032521412/reactions"
            },
            "updated_at": "2025-07-03T14:39:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032521412",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> It is bold to state it is not a huge deal to press confirm 40 times!!!\r\n\r\nThis is Phase 1. We will think about next steps after this. Please, leave the off-topic remarks out of this PR.",
            "created_at": "2025-07-03T17:09:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3032980985",
            "id": 3032980985,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60x535",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032980985/reactions"
            },
            "updated_at": "2025-07-03T17:09:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3032980985",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Added [basic mention](https://github.com/neovim/neovim/pull/34009/commits/e85c3ea54c92289e7413ad52f4244339b9fa4f18) of external plugins and `vim.pack.add()` to the 'example_init.lua'. After `vim.pack` API matures, maybe it can also have basic description of common workflows, but it is a bit early right now.",
            "created_at": "2025-07-04T07:18:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3034793776",
            "id": 3034793776,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6040cw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3034793776/reactions"
            },
            "updated_at": "2025-07-04T07:18:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3034793776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Discuss followup work and feedback in the sub-issues of https://github.com/neovim/neovim/issues/34763",
            "created_at": "2025-07-04T13:51:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-3036347856",
            "id": 3036347856,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM60-v3Q",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3036347856/reactions"
            },
            "updated_at": "2025-07-04T13:51:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3036347856",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/34009/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/34009/commits",
    "created_at": "2025-05-13T17:07:47Z",
    "diff_url": "https://github.com/neovim/neovim/pull/34009.diff",
    "draft": false,
    "head": {
        "label": "echasnovski:vim-pack",
        "ref": "vim-pack",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/echasnovski/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/echasnovski/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/echasnovski/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/echasnovski/neovim/branches{/branch}",
            "clone_url": "https://github.com/echasnovski/neovim.git",
            "collaborators_url": "https://api.github.com/repos/echasnovski/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/echasnovski/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/echasnovski/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/echasnovski/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/echasnovski/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/echasnovski/neovim/contributors",
            "created_at": "2021-12-02T09:43:59Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/echasnovski/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/echasnovski/neovim/downloads",
            "events_url": "https://api.github.com/repos/echasnovski/neovim/events",
            "fork": true,
            "forks": 1,
            "forks_count": 1,
            "forks_url": "https://api.github.com/repos/echasnovski/neovim/forks",
            "full_name": "echasnovski/neovim",
            "git_commits_url": "https://api.github.com/repos/echasnovski/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/echasnovski/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/echasnovski/neovim/git/tags{/sha}",
            "git_url": "git://github.com/echasnovski/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/echasnovski/neovim/hooks",
            "html_url": "https://github.com/echasnovski/neovim",
            "id": 434162461,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/echasnovski/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/echasnovski/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/echasnovski/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/echasnovski/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/echasnovski/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/echasnovski/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/echasnovski/neovim/merges",
            "milestones_url": "https://api.github.com/repos/echasnovski/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGeDLHQ",
            "notifications_url": "https://api.github.com/repos/echasnovski/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/echasnovski/neovim/pulls{/number}",
            "pushed_at": "2025-07-07T16:49:51Z",
            "releases_url": "https://api.github.com/repos/echasnovski/neovim/releases{/id}",
            "size": 324007,
            "ssh_url": "git@github.com:echasnovski/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/echasnovski/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/echasnovski/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/echasnovski/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/echasnovski/neovim/subscription",
            "svn_url": "https://github.com/echasnovski/neovim",
            "tags_url": "https://api.github.com/repos/echasnovski/neovim/tags",
            "teams_url": "https://api.github.com/repos/echasnovski/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/echasnovski/neovim/git/trees{/sha}",
            "updated_at": "2025-07-07T13:55:07Z",
            "url": "https://api.github.com/repos/echasnovski/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "d21b8c949ad7213b372486b45225f691934d6a6d",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
            "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
            "followers_url": "https://api.github.com/users/echasnovski/followers",
            "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
            "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/echasnovski",
            "id": 24854248,
            "login": "echasnovski",
            "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
            "organizations_url": "https://api.github.com/users/echasnovski/orgs",
            "received_events_url": "https://api.github.com/users/echasnovski/received_events",
            "repos_url": "https://api.github.com/users/echasnovski/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/echasnovski",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/34009",
    "id": 2517199651,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
    "labels": [
        {
            "color": "bfd4f2",
            "default": false,
            "description": "vim.pack, start/opt packages, 'packpath'",
            "id": 8889050758,
            "name": "packages",
            "node_id": "LA_kwDOAPphoM8AAAACEdQmhg",
            "url": "https://api.github.com/repos/neovim/neovim/labels/packages"
        }
    ],
    "locked": true,
    "merge_commit_sha": "cbfc3d1cdc199ce65368a2f40dc4b1ddc4331714",
    "merged_at": "2025-07-04T13:32:55Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6WCWsj",
    "number": 34009,
    "patch_url": "https://github.com/neovim/neovim/pull/34009.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/34009/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/d21b8c949ad7213b372486b45225f691934d6a6d",
    "title": "feat(pack): add built-in plugin manager `vim.pack`",
    "updated_at": "2025-07-04T13:51:21Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
        "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
        "followers_url": "https://api.github.com/users/echasnovski/followers",
        "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
        "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/echasnovski",
        "id": 24854248,
        "login": "echasnovski",
        "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
        "organizations_url": "https://api.github.com/users/echasnovski/orgs",
        "received_events_url": "https://api.github.com/users/echasnovski/received_events",
        "repos_url": "https://api.github.com/users/echasnovski/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/echasnovski",
        "user_view_type": "public"
    }
}