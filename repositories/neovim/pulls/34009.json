{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34009/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/34009"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34009"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/6646c0368e8d8e872b033c311107be80f231cf2e"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6092,
            "forks_count": 6092,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1968,
            "open_issues_count": 1968,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-05-20T02:44:26Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 323650,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 89644,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-05-20T02:49:00Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 89644,
            "watchers_count": 89644,
            "web_commit_signoff_required": false
        },
        "sha": "dfad6138131f86a229d6fb9fb21742a8b979ede7",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "This PR adds a minimal built-in plugin manager `vim.pack`. This is a first step towards resolving #20893. A general design is a minimized (496 LOC for core functionality when PR is opened) and reworked ['mini.deps'](https://github.com/echasnovski/mini.nvim/blob/main/readmes/mini-deps.md) plugin. There is a first-pass documentation mostly aimed for reviewers and no tests yet (as it is an open question about how to do that reasonably).\r\n\r\nHere is a demo of common workflows (I'll also mention here that top right window comes from 'mini.notify' plugin; that is not part of `vim.pack`):\r\n\r\nhttps://github.com/user-attachments/assets/f99c8adf-c01d-4dfe-86a5-95d8e4cbc1b4\r\n\r\nTimestamps:\r\n- 00:00 - initial \"clean\" run (i.e. just like after installing Neovim and adding 'init.lua' that is shown in demo).\r\n- 00:10 - install new plugin (add line and restart).\r\n- 00:28 - updating existing plugins (simulate new upstream changes, run `vim.pack.update()`, review, confirm).\r\n- 01:10 - change version of existing plugin (update 'init.lua', restart, run `vim.pack.update()` with `{ offline = true }` to skip downloading new changes, review, confirm).\r\n\r\n---\r\n\r\nGeneral notes about design decisions:\r\n\r\n<details><summary>Design decisions notes</summary>\r\n\r\n- Plugin spec is designed to be minimal yet versatile with an eye for future automated packspec support, i.e. plugins themselves containing a special 'pkg.json' file which should contain at least the following information:\r\n    - Dependencies: repo urls and versions. If plugin doesn't support packspec, user can register dependencies manually by explicitly adding them to `vim.pack.add()`.\r\n    - Hooks: paths to scripts to be executed before/after install/update. Without them user can register hooks by creating autocommand for dedicated events. Note: custom events are generally better than hooks because they can be used by plugins to tweak install/update behavior of *other* plugins. Plus smaller `vim.pack.Spec`.\r\n\r\n- Showing \"interactive\" confirmation buffer might be considered too much, but being able to review updates before approving them is a huge QoL improvement. Right now it also includes in-process LSP server to show structure via `vim.lsp.buf.document_symbol()` (or with default `gO`). The whole LSP approach might be an overkill, but:\r\n    - It works nicely with plugin ecosystem around LSP lifting the burden of having to create dedicated conventions for `vim.pack`. Most useful mappings are already built-in.\r\n    - Can serve as a reference implementation of an in-process LSP server (which is a decided way forward for several built-in things, like custom `vim.lsp.completion` sources and code actions).\r\n    - It reinforces the \"LSP out of the box\" approach.\r\n\r\n  There are more LSP-based interactive features planned (see next section).\r\n\r\n</details>\r\n\r\n---\r\n\r\nLeft out from this PR but planned after discussions and executive decisions:\r\n\r\n<details><summary>Planned future work</summary>\r\n\r\n- ~~**\"Scripting way\" to remove installed plugins from disk**. I do have plans to support \"delete plugin\" code action from inside confirmation buffer, but it needs green light. The \"scripting way\" can be designed in several ways:~~\r\n    - ~~A `vim.pack.remove()` - simple wrapper around `vim.fn.delete()`. Might also trigger dedicated events.~~\r\n    - ~~A `vim.pack.clean()` - delete plugins that are not added to current session. Without interactive confirmation, this can become tricky for configs which will lazy load plugins on events/ModeChanged/etc.~~\r\n    - ~~Do nothing and suggest using `vim.fn.delete()` directly with (possibly exported) path to a special plugin's directory. This is meant as minimal plugin manager, after all.~~\r\n\r\n    After relevant discussions ([this](https://github.com/neovim/neovim/pull/34009#discussion_r2094172936) and [this](https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306)), there is a `vim.pack.del()` present in this PR.\r\n\r\n- **User commands**. Like `:Pack add` or `:PackAdd`. The latter is more natural when it comes to `!` and easier to implement completion.\r\n- **Allowing \"local plugins\"** (as \"unmanaged plugins\" in 'vim-plug'). This can be skipped entirely in favor of suggesting putting those plugins in custom 'pack/mine/opt' package and use `:packadd`. But initial Matrix discussions showed interest in having this supported.\r\n\r\n    As far as I can tell, they don't quite fit into the current design: they usually don't require automated installation or update. They require manual handling during `add` (explicit source of 'plugin/' and 'after/plugin/') and book keeping to ignore it during `update()`. Doable, but requires executive decision and extra effort/code.\r\n- **More interactive update features**:\r\n    - Code lenses/actions \"update this plugin\", \"skip updating this plugin\", maybe \"delete\" this plugin.\r\n- **Lockfile support**. Basically, store state/commit per source and prefer it *only during initial install* over resolving `version`. Will help with reproducible setups.\r\n\r\n    It (or its \"private\" alternative) can also contain an information about `version` to be used during `update()` if the plugin was not (yet) added to current session. In theory, this can also be used to detect if the user has changed plugin's `version` in an attempt to switch version/branch and automatically do so during startup (without having to do an extra `vim.pack.update()` call). One thing why this might not be good is that it breaks the separation of \"`add()` is for installing and loading plugins\" and \"`update()` is for updating already installed plugins\".\r\n\r\n- **More straightforward plugin freeze/pin/lock**. Originally this PR proposed a special value of `version` (`'HEAD'` string or `false` boolean) to be treated as \"freeze the installed plugin from updates\". It was decided to postpone the decision about the better \"freeze\" approach until there is a lockfile support. See [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2096143432) for details.\r\n\r\n- **`:checkhealth` support**. It can include suggestions like \"the latest tag of this plugin is very far behind default branch; consider setting version = 'master'\".\r\n\r\n- **Packspec support**. It is rather big and needs discussions about the degree of support vs complexity.\r\n\r\n</details>\r\n\r\n---\r\n\r\nNot planned as `vim.pack` functionality:\r\n\r\n<details><summary>Not planned</summary>\r\n\r\n- Manage plugins from 'start/' directory. As `vim.pack.add()` only installs in 'opt/' directory (as it is all that is needed), it seems unnecessary to also manage 'start/' from the same package path. Plus it is known to cause confusion about how to not load its plugins.\r\n- Lazy loading out of the box. This can be done like in 'mini.deps': via `now()` and `later()` functions. They *safely* execute its input function immediately and \"soon\" while reporting errors only after all those functions are finished. These are general enough to live outside of `vim.pack` and should be useful to have in `vim.func`.\r\n\r\n</details>",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087290998"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998"
                }
            },
            "author_association": "MEMBER",
            "body": "Notes about spec:\r\n- Maybe naming of both `source` and `version` might be improved. Maybe `url`/`uri` and `follow`/`target`/`checkout`? The current ones are general enough for possible leeway in the future.\r\n- ~~Is using \"FREEZE\" instead of \"HEAD\" a better choice (as it is less Git-specific; suggested [here](https://github.com/neovim/neovim/pull/34009#discussion_r20876143530))? If `version->checkout` is renamed, then using \"HEAD\" should be fine.~~ ~~After [this discussion](https://github.com/neovim/neovim/pull/34009#discussion_r2094172722), `version = false` now means freezing from updates.~~ The decision about better approach to freezing plugin is postponed until after lockfile support (see [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2096143432) for details).\r\n- Allowing version to be explicit `vim.VersionRange` is needed to avoid conflicts with branch names that look similar to version range (\"1.0\", \"v1.0.0\", \"0-x\", \"tmux 3.2a\", etc.). If that is not a concern, then only allowing string `version` with trying to parsing it as version range is doable.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:11:27Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087290998",
            "id": 2087290998,
            "line": 221,
            "node_id": "PRRC_kwDOAPphoM58aYh2",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 197,
            "original_position": 197,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 221,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-19T17:01:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087290998",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294117"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117"
                }
            },
            "author_association": "MEMBER",
            "body": "How much \"magic\" for inferring `source` and `name` should be allowed? Right now `source` should be set explicitly as URI. Possible improvements:\r\n- Allow setting source as `[1]` key to avoid explicitly setting `source` as key?\r\n- Allow `string|vim.pack.Spec` directly and not inside list?\r\n- Allow setting source (wherever it is possible) as \"user/repo\" and infer it as \"https://github.com/user/repo\". Can be behind `vim.pack.config()` as `format_source`?\r\n\r\nAlso, should `name` be cleaned as well? Like stripping '.git' suffix, etc.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:13:34Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294117",
            "id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58aZSl",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294117",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294852"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852"
                }
            },
            "author_association": "MEMBER",
            "body": "Consider making it configurable, like via `vim.pack.config()`?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:14:06Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087294852",
            "id": 2087294852,
            "line": 336,
            "node_id": "PRRC_kwDOAPphoM58aZeE",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 293,
            "original_position": 293,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 336,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087294852",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087296122"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122"
                }
            },
            "author_association": "MEMBER",
            "body": "Showing progress report might wait for `vim.ui.progress()`, but as this can already be done with in-process LSP server (which is useful for interactive confirm), seems okay to add. Even if later during 0.12 cycle replaced with `vim.ui.progress`.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:14:59Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087296122",
            "id": 2087296122,
            "line": 455,
            "node_id": "PRRC_kwDOAPphoM58aZx6",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 380,
            "original_position": 380,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 455,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087296122",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087298163"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163"
                }
            },
            "author_association": "MEMBER",
            "body": "This will only not add plugins that did not install to disk. Plugin can still be installed but not in correct version after installation (like if target doesn't exist), which will be shown as error during initial install and error during update.\r\n\r\nThis decision is mostly due to the fact that this plugin would still load after restart (as there is no check if the version is correct; for performance).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:15:57Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    -- Allow 'HEAD' to mean 'HEAD' (freeze current state from updates)\n+    if version == 'HEAD' then\n+      p.info.version_str = 'HEAD'\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    if not is_version_range(version) then\n+      --- @cast version string\n+      local branches = git_get_branches(p.plug.path)\n+      p.info.version_str = version\n+      p.info.version_ref = (vim.tbl_contains(branches, version) and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag = nil\n+    for _, tag in ipairs(git_get_tags(p.plug.path)) do\n+      local ver_tag = vim.version.parse(tag)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No tags matching version range. Consider increasing it or switch to branch.'\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      notify(msg, 'ERROR')\n+    end\n+  end\n+end\n+\n+--- Keep this as map and not array for faster checks during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory and update state to match `version`.\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| (possibly with `{ offline = true }`) to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  -- TODO(echasnovski): Normalize all plugins as a whole, mostly process\n+  -- duplicates. This has little benefit now, but will be more sore after\n+  -- packspec processing (as it might introduce conflicting dependencies).\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087298163",
            "id": 2087298163,
            "line": 753,
            "node_id": "PRRC_kwDOAPphoM58aaRz",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 663,
            "original_position": 663,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 753,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087298163",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087299188"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188"
                }
            },
            "author_association": "MEMBER",
            "body": "Module name is `vim.pack`, but using 'vimpack' as file/filetype name feels wrong (as it doesn't use 'nvim'). So it is 'nvimpack' for now.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:16:27Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')\n+  local name = (spec.name or spec.source):match('[^/]+$')\n+  vim.validate('spec.name', name, 'string')\n+  local version = spec.version or vim.version.range('*')\n+  local function is_version(x)\n+    return type(x) == 'string' or is_version_range(x)\n+  end\n+  vim.validate('spec.version', version, is_version, false, 'string or vim.VersionRange')\n+  return { source = spec.source, name = name, version = version }\n+end\n+\n+--- @class (private) vim.pack.Plug\n+--- @field spec vim.pack.SpecResolved\n+--- @field path string\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.Plug\n+local function new_plug(spec)\n+  local spec_resolved = normalize_spec(spec)\n+  local path = vim.fs.joinpath(get_plug_dir(), spec_resolved.name)\n+  return { spec = spec_resolved, path = path }\n+end\n+\n+--- @alias vim.pack.Job { cmd: string[], cwd: string, out: string, err: string }\n+\n+--- @class (private) vim.pack.PlugJobInfo\n+--- @field warn? string Concatenated job warnings\n+--- @field version_str? string `spec.version` with resolved version range.\n+--- @field version_ref? string Resolved version as Git reference (if different\n+---   from `version_str`).\n+--- @field sha_head? string Git hash of HEAD.\n+--- @field sha_target? string Git hash of `version_ref`.\n+--- @field update_details? string Details about the update:: changelog if HEAD\n+---   and target are different, available newer tags otherwise.\n+\n+--- @class (private) vim.pack.PlugJob\n+--- @field plug vim.pack.Plug\n+--- @field job { cmd: string[], cwd: string, out: string, err: string }\n+--- @field info vim.pack.PlugJobInfo\n+\n+--- @class (private) vim.pack.PlugList List of plugin along with job and info\n+--- @field list vim.pack.PlugJob[]\n+local PlugList = {}\n+PlugList.__index = PlugList\n+\n+--- @package\n+--- @param plugs vim.pack.Plug[]\n+--- @return vim.pack.PlugList\n+function PlugList.new(plugs)\n+  --- @type vim.pack.PlugJob[]\n+  local list = {}\n+  for i, p in ipairs(plugs) do\n+    local job = { cmd = {}, cwd = p.path, out = '', err = '' }\n+    list[i] = { plug = p, job = job, info = { warn = '' } }\n+  end\n+  return setmetatable({ list = list }, PlugList)\n+end\n+\n+--- Run jobs from plugin list in parallel\n+---\n+--- For each plugin that hasn't errored yet:\n+--- - Execute `prepare`: do side effects and set `job.cmd`.\n+--- - If set, execute `job.cmd` asynchronously.\n+--- - After done, preprocess job's `code`/`stdout`/`stderr`, run `process` to gather\n+---   useful info, and start next job.\n+---\n+--- @package\n+--- @param prepare? fun(vim.pack.PlugExtra): nil\n+--- @param process? fun(vim.pack.PlugExtra): nil\n+--- @param report_progress? fun(kind: 'report'|'end', msg: string, percent: integer): nil\n+function PlugList:run(prepare, process, report_progress)\n+  prepare, process = prepare or function(_) end, process or function(_) end\n+  report_progress = report_progress or function(_, _, _) end\n+\n+  local n_threads = math.max(math.floor(0.8 * #(uv.cpu_info() or {})), 1)\n+  local timeout = 30000\n+\n+  -- Use only plugs which didn't error before\n+  --- @param p vim.pack.PlugJob\n+  local list_noerror = vim.tbl_filter(function(p)\n+    return p.job.err == ''\n+  end, self.list)\n+  if #list_noerror == 0 then\n+    return\n+  end\n+\n+  -- Prepare for job execution\n+  local n_total, n_started, n_finished = #list_noerror, 0, 0\n+  local function register_finished()\n+    n_finished = n_finished + 1\n+    local percent = math.floor(100 * n_finished / n_total)\n+    report_progress('report', n_finished .. '/' .. n_total, percent)\n+  end\n+\n+  local function run_next()\n+    if n_started >= n_total then\n+      return\n+    end\n+    n_started = n_started + 1\n+\n+    local p = list_noerror[n_started]\n+\n+    local function on_exit(sys_res)\n+      register_finished()\n+\n+      --- @type string\n+      local stderr = sys_res.stderr:gsub('\\n+$', '')\n+      -- If error, skip custom processing\n+      if sys_res.code ~= 0 then\n+        p.job.err = 'Error code ' .. sys_res.code .. '\\n' .. stderr\n+        return run_next()\n+      end\n+\n+      -- Process command results. Treat exit code 0 with `stderr` as warning.\n+      p.job.out = sys_res.stdout:gsub('\\n+$', '')\n+      p.info.warn = p.info.warn .. (stderr == '' and '' or ('\\n\\n' .. stderr))\n+      process(p)\n+      run_next()\n+    end\n+\n+    prepare(p)\n+    if #p.job.cmd == 0 or p.job.err ~= '' then\n+      register_finished()\n+      return run_next()\n+    end\n+    local system_opts = { cwd = p.job.cwd, text = true, timeout = timeout, clear_env = true }\n+    -- NOTE: `schedule_wrap(on_exit)` avoids \"is not allowed in fast context\"\n+    vim.system(p.job.cmd, system_opts, vim.schedule_wrap(on_exit))\n+  end\n+\n+  -- Run jobs async in parallel but wait for all to finish/timeout\n+  report_progress('begin', '0/' .. n_total)\n+\n+  for _ = 1, n_threads do\n+    run_next()\n+  end\n+\n+  local total_wait = timeout * math.ceil(n_total / n_threads)\n+  vim.wait(total_wait, function()\n+    return n_finished >= n_total\n+  end, 1)\n+\n+  report_progress('end', n_total .. '/' .. n_total)\n+\n+  -- Clean up. Preserve errors to stop processing plugin after the first one.\n+  for _, p in ipairs(list_noerror) do\n+    p.job.cmd, p.job.cwd, p.job.out = {}, p.plug.path, ''\n+  end\n+end\n+\n+--- @package\n+function PlugList:install()\n+  self:trigger_event('PackInstallPre')\n+\n+  -- Clone\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    -- Temporarily change job's cwd because target path doesn't exist yet\n+    p.job.cwd = uv.cwd() --[[@as string]]\n+    p.job.cmd = git_cmd('clone', p.plug.spec.source, p.plug.path)\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Installing plugins')\n+  self:run(prepare, nil, report_progress)\n+\n+  -- Checkout to target version. Do not skip checkout even if HEAD and target\n+  -- have same commit hash to have installed repo in expected detached HEAD\n+  -- state and generated help files.\n+  self:checkout({ skip_same_sha = false })\n+\n+  -- NOTE: 'PackInstall' is triggered after 'PackUpdate' intentionally to have\n+  -- it indicate \"plugin is installed in its correct initial version\"\n+  self:trigger_event('PackInstall')\n+end\n+\n+--- Keep repos in detached HEAD state. Infer commit from resolved version.\n+--- No local branches are created, branches from \"origin\" remote are used directly.\n+--- @package\n+--- @param opts { skip_same_sha: boolean }\n+function PlugList:checkout(opts)\n+  opts = vim.tbl_deep_extend('force', { skip_same_sha = true }, opts or {})\n+\n+  self:infer_head()\n+  self:infer_target()\n+\n+  local plug_list = vim.deepcopy(self)\n+  if opts.skip_same_sha then\n+    --- @param p vim.pack.PlugJob\n+    plug_list.list = vim.tbl_filter(function(p)\n+      return p.info.sha_head ~= p.info.sha_target\n+    end, plug_list.list)\n+  end\n+\n+  -- Stash changes\n+  local stash_cmd = git_cmd('stash', get_timestamp())\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = stash_cmd\n+  end\n+  plug_list:run(prepare, nil)\n+\n+  plug_list:trigger_event('PackUpdatePre')\n+\n+  -- Checkout\n+  prepare = function(p)\n+    p.job.cmd = git_cmd('checkout', p.info.sha_target)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    local msg = string.format('Updated state to `%s` in `%s`', p.info.version_str, p.plug.spec.name)\n+    notify(msg, 'INFO')\n+  end\n+  plug_list:run(prepare, process)\n+\n+  plug_list:trigger_event('PackUpdate')\n+\n+  -- (Re)Generate help tags according to the current help files\n+  for _, p in ipairs(plug_list.list) do\n+    -- Completely redo tags\n+    local doc_dir = p.plug.path .. '/doc'\n+    vim.fn.delete(doc_dir .. '/tags')\n+    -- Use `pcall()` because `:helptags` errors if there is no 'doc/' directory\n+    -- or if it is empty\n+    pcall(vim.cmd.helptags, vim.fn.fnameescape(doc_dir))\n+  end\n+end\n+\n+--- @package\n+function PlugList:download_updates()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = git_cmd('fetch')\n+  end\n+  local report_progress = require('vim.pack.lsp').new_progress_report('Downloading updates')\n+  self:run(prepare, nil, report_progress)\n+end\n+\n+--- @package\n+function PlugList:resolve_version()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    if p.info.version_str ~= nil then\n+      return\n+    end\n+    local version = p.plug.spec.version\n+\n+    -- Allow 'HEAD' to mean 'HEAD' (freeze current state from updates)\n+    if version == 'HEAD' then\n+      p.info.version_str = 'HEAD'\n+      return\n+    end\n+\n+    -- Allow specifying non-version-range like version: branch or commit.\n+    if not is_version_range(version) then\n+      --- @cast version string\n+      local branches = git_get_branches(p.plug.path)\n+      p.info.version_str = version\n+      p.info.version_ref = (vim.tbl_contains(branches, version) and 'origin/' or '') .. version\n+      return\n+    end\n+    --- @cast version vim.VersionRange\n+\n+    -- Choose the greatest/last version among all matching semver tags\n+    local last_ver_tag = nil\n+    for _, tag in ipairs(git_get_tags(p.plug.path)) do\n+      local ver_tag = vim.version.parse(tag)\n+      local is_in_range = ver_tag ~= nil and version:has(ver_tag)\n+      if is_in_range and (last_ver_tag == nil or ver_tag > last_ver_tag) then\n+        p.info.version_str, last_ver_tag = tag, ver_tag\n+      end\n+    end\n+\n+    if p.info.version_str == nil then\n+      p.job.err = 'No tags matching version range. Consider increasing it or switch to branch.'\n+    end\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+function PlugList:infer_head()\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    p.job.cmd = p.info.sha_head == nil and git_cmd('get_hash', 'HEAD') or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_head = p.info.sha_head or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_target()\n+  self:resolve_version()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local target_ref = p.info.version_ref or p.info.version_str\n+    p.job.cmd = p.info.sha_target == nil and git_cmd('get_hash', target_ref) or {}\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.sha_target = p.info.sha_target or p.job.out\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- @package\n+function PlugList:infer_update_details()\n+  self:infer_head()\n+  self:infer_target()\n+\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    local from, to = p.info.sha_head, p.info.sha_target\n+    p.job.cmd = from ~= to and git_cmd('log', from, to) or git_cmd('list_new_tags', to)\n+  end\n+  --- @param p vim.pack.PlugJob\n+  local function process(p)\n+    p.info.update_details = p.job.out\n+    if p.info.sha_head ~= p.info.sha_target or p.info.update_details == '' then\n+      return\n+    end\n+\n+    -- Remove tags points at target (there might be several)\n+    local cur_tags = cli_sync(git_cmd('list_cur_tags', p.info.sha_target), p.plug.path)\n+    for _, tag in ipairs(vim.split(cur_tags, '\\n')) do\n+      p.info.update_details = p.info.update_details:gsub(vim.pesc(tag) .. '\\n?', '')\n+    end\n+  end\n+  self:run(prepare, process)\n+end\n+\n+--- Trigger event for not yet errored plugin jobs\n+--- Do so as `PlugList` method to preserve order, which might be important when\n+--- dealing with dependencies.\n+--- @package\n+--- @param event_name 'PackInstallPre'|'PackInstall'|'PackUpdatePre'|'PackUpdate'\n+function PlugList:trigger_event(event_name)\n+  --- @param p vim.pack.PlugJob\n+  local function prepare(p)\n+    vim.api.nvim_exec_autocmds(event_name, { pattern = p.plug.path, data = vim.deepcopy(p.plug) })\n+  end\n+  self:run(prepare, nil)\n+end\n+\n+--- @package\n+--- @param action_name string\n+function PlugList:show_notifications(action_name)\n+  for _, p in ipairs(self.list) do\n+    local name, warn = p.plug.spec.name, p.info.warn\n+    if warn ~= '' then\n+      local msg = string.format('Warnings in `%s` during %s:\\n%s', name, action_name, warn)\n+      notify(msg, 'WARN')\n+    end\n+    local err = p.job.err\n+    if err ~= '' then\n+      local msg = string.format('Error in `%s` during %s:\\n%s', name, action_name, err)\n+      notify(msg, 'ERROR')\n+    end\n+  end\n+end\n+\n+--- Keep this as map and not array for faster checks during startup.\n+--- @type table<string, { plug: vim.pack.Plug, id: integer }>\n+local added_plugins = {}\n+local n_added_plugins = 0\n+\n+--- @param plug vim.pack.Plug\n+--- @param bang boolean\n+local function pack_add(plug, bang)\n+  -- Add plugin only once, i.e. no overriding of spec. This allows users to put\n+  -- plugin first to fully control its spec.\n+  if added_plugins[plug.path] ~= nil then\n+    return\n+  end\n+\n+  n_added_plugins = n_added_plugins + 1\n+  added_plugins[plug.path] = { plug = plug, id = n_added_plugins }\n+\n+  vim.cmd.packadd({ plug.spec.name, bang = bang })\n+\n+  -- Execute 'after/' scripts if not during startup (when they will be sourced\n+  -- automatically), as `:packadd` only sources plain 'plugin/' files.\n+  -- See https://github.com/vim/vim/issues/15584\n+  -- Deliberately do so after executing all currently known 'plugin/' files.\n+  local should_load_after_dir = vim.v.vim_did_enter == 1 and not bang and vim.o.loadplugins\n+  if should_load_after_dir then\n+    local after_paths = vim.fn.glob(plug.path .. '/after/plugin/**/*.{vim,lua}', false, true)\n+    --- @param path string\n+    vim.tbl_map(function(path)\n+      pcall(vim.cmd.source, vim.fn.fnameescape(path))\n+    end, after_paths)\n+  end\n+end\n+\n+--- @class vim.pack.keyset.add\n+--- @inlinedoc\n+--- @field bang? boolean Whether to execute `:packadd!` instead of |:packadd|. Default `false`.\n+\n+--- Add plugin to current session\n+---\n+--- - For each specification check that plugin exists on disk in |vim.pack-directory|:\n+---     - If exists, do nothin in this step.\n+---     - If doesn't exist, install it by downloading from `source` into `name`\n+---       subdirectory and update state to match `version`.\n+--- - For each plugin execute |:packadd| making them reachable by Nvim.\n+---\n+--- Notes:\n+--- - Installation is done in parallel, but waits for all to finish before\n+---   continuing next code execution.\n+--- - If plugin is already present on disk, there are no checks about its present state.\n+---   The specified `version` can be not the one actually present on disk.\n+---   Execute |vim.pack.update()| (possibly with `{ offline = true }`) to synchronize.\n+--- - Adding plugin second and more times during single session does nothing:\n+---   only the data from the first adding is registered.\n+---\n+--- @param specs (string|vim.pack.Spec)[] List of plugin specifications. String item\n+--- is treated as `source`.\n+--- @param opts? vim.pack.keyset.add\n+function M.add(specs, opts)\n+  vim.validate('specs', specs, vim.islist, false, 'list')\n+  opts = vim.tbl_extend('force', { bang = false }, opts or {})\n+  vim.validate('opts', opts, 'table')\n+\n+  --- @type vim.pack.Plug[]\n+  local plugs = vim.tbl_map(new_plug, specs)\n+  -- TODO(echasnovski): Normalize all plugins as a whole, mostly process\n+  -- duplicates. This has little benefit now, but will be more sore after\n+  -- packspec processing (as it might introduce conflicting dependencies).\n+\n+  -- Install\n+  --- @param p vim.pack.Plug\n+  local plugs_to_install = vim.tbl_filter(function(p)\n+    return uv.fs_stat(p.path) == nil\n+  end, plugs)\n+  local pluglist_to_install = PlugList.new(plugs_to_install)\n+  if #plugs_to_install > 0 then\n+    git_ensure_exec()\n+    pluglist_to_install:install()\n+  end\n+\n+  -- Register and `:packadd` those actually on disk\n+  for _, p in ipairs(plugs) do\n+    if uv.fs_stat(p.path) ~= nil then\n+      pack_add(p, opts.bang)\n+    end\n+  end\n+\n+  -- Delay showing warnings/errors to first have \"good\" plugins added\n+  pluglist_to_install:show_notifications('installation')\n+end\n+\n+--- @param p vim.pack.PlugJob\n+--- @return string\n+local function compute_feedback_lines_single(p)\n+  if p.job.err ~= '' then\n+    return '## ' .. p.plug.spec.name .. '\\n\\n  ' .. p.job.err:gsub('\\n', '\\n  ')\n+  end\n+\n+  local parts = { '## ' .. p.plug.spec.name .. '\\n' }\n+\n+  if p.info.sha_head == p.info.sha_target then\n+    table.insert(parts, 'Path:   ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source: ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State:  ' .. p.info.sha_target .. ' (' .. p.info.version_str .. ')')\n+\n+    if p.info.update_details ~= '' then\n+      local details = p.info.update_details:gsub('\\n', '\\n• ')\n+      table.insert(parts, '\\n\\nAvailable newer tags:\\n• ' .. details)\n+    end\n+  else\n+    table.insert(parts, 'Path:         ' .. p.plug.path .. '\\n')\n+    table.insert(parts, 'Source:       ' .. p.plug.spec.source .. '\\n')\n+    table.insert(parts, 'State before: ' .. p.info.sha_head .. '\\n')\n+    table.insert(parts, 'State after:  ' .. p.info.sha_target .. ' (' .. p.info.version_str .. ')')\n+\n+    table.insert(parts, '\\n\\nPending updates:\\n' .. p.info.update_details)\n+  end\n+\n+  return table.concat(parts, '')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+--- @param opts { skip_same_sha: boolean }\n+--- @return string[]\n+local function compute_feedback_lines(plug_list, opts)\n+  -- Construct plugin line groups for better report\n+  local report_err, report_update, report_same = {}, {}, {}\n+  for _, p in ipairs(plug_list.list) do\n+    local group_arr = #p.job.err > 0 and report_err\n+      or (p.info.sha_head ~= p.info.sha_target and report_update or report_same)\n+    table.insert(group_arr, compute_feedback_lines_single(p))\n+  end\n+\n+  local lines = {}\n+  --- @param header string\n+  --- @param arr string[]\n+  local function append_report(header, arr)\n+    if #arr == 0 then\n+      return\n+    end\n+    header = header .. ' ' .. string.rep('─', 79 - header:len())\n+    table.insert(lines, header)\n+    vim.list_extend(lines, arr)\n+  end\n+  append_report('# Error', report_err)\n+  append_report('# Update', report_update)\n+  if not opts.skip_same_sha then\n+    append_report('# Same', report_same)\n+  end\n+\n+  return vim.split(table.concat(lines, '\\n\\n'), '\\n')\n+end\n+\n+--- @param plug_list vim.pack.PlugList\n+local function feedback_log(plug_list)\n+  local lines = compute_feedback_lines(plug_list, { skip_same_sha = true })\n+  local title = string.format('========== Update %s ==========', get_timestamp())\n+  table.insert(lines, 1, title)\n+  table.insert(lines, '')\n+\n+  local log_path = vim.fn.stdpath('log') .. '/nvimpack.log'\n+  vim.fn.mkdir(vim.fs.dirname(log_path), 'p')\n+  vim.fn.writefile(lines, log_path, 'a')\n+end\n+\n+local function show_confirm_buf(lines, opts)\n+  -- Show buffer in a separate tabpage\n+  local bufnr = api.nvim_create_buf(true, true)\n+  api.nvim_buf_set_name(bufnr, 'nvimpack://' .. bufnr .. '/confirm-update')\n+  api.nvim_buf_set_lines(bufnr, 0, -1, false, lines)\n+  vim.cmd.sbuffer({ bufnr, mods = { tab = vim.fn.tabpagenr('#') } })\n+  local tab_num, win_id = api.nvim_tabpage_get_number(0), api.nvim_get_current_win()\n+\n+  local delete_buffer = vim.schedule_wrap(function()\n+    pcall(api.nvim_buf_delete, bufnr, { force = true })\n+    pcall(vim.cmd.tabclose, tab_num)\n+    vim.cmd.redraw()\n+  end)\n+\n+  -- Define action on accepting confirm\n+  local function finish()\n+    opts.exec_on_write(bufnr)\n+    delete_buffer()\n+  end\n+  -- - Use `nested` to allow other events (useful for statuslines)\n+  api.nvim_create_autocmd('BufWriteCmd', { buffer = bufnr, nested = true, callback = finish })\n+\n+  -- Define action to cancel confirm\n+  --- @type integer\n+  local cancel_au_id\n+  local function on_cancel(data)\n+    if tonumber(data.match) ~= win_id then\n+      return\n+    end\n+    pcall(api.nvim_del_autocmd, cancel_au_id)\n+    delete_buffer()\n+  end\n+  cancel_au_id = api.nvim_create_autocmd('WinClosed', { nested = true, callback = on_cancel })\n+\n+  -- Set buffer-local options last (so that user autocmmands could override)\n+  vim.bo[bufnr].modified, vim.bo[bufnr].modifiable = false, false\n+  vim.bo[bufnr].buftype, vim.bo[bufnr].filetype = 'acwrite', 'nvimpack'",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087299188",
            "id": 2087299188,
            "line": 874,
            "node_id": "PRRC_kwDOAPphoM58aah0",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 782,
            "original_position": 782,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 874,
            "pull_request_review_id": 2837550908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:17:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087299188",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087330410"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410"
                }
            },
            "author_association": "MEMBER",
            "body": "This should be added to checkhealth then (same as `rg`).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T17:31:13Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087330410",
            "id": 2087330410,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aiJq",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2522,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2837613109,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:31:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087330410",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087579420"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> as \"user/repo\" and infer it as \"https://github.com/user/repo\"\r\n\r\nMy two cents on this: While the vast majority of plugins are on github, I'm not so much a fan of the current convention of github favouritism without providing shorthands for other hosts.\r\nI'd personally prefer `<host>:<owner>/<repo>`, which would result in shorthands like `github:user/repo`, `gitlab:user/repo`, `sourcehut:user/repo`, `codeberg:user/repo`, and so on.\r\nWith support for some other hosts, having `user/repo` default to github for user convenience doesn't feel quite as \"evil\" :sweat_smile:\r\nIf shorthand support for multiple hosts is \"too much magic\", then my vote would be for no shorthand support at all.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T20:26:52Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087579420",
            "id": 2087579420,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58be8c",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 14,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 14,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087579420",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087585745"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "question: This has to be a git source URL, right?\r\nIf so, I'd suggest to clarify that in the docs, so people know they can't specify things like source archive URLs.\r\nPerhaps it would also be good to document (un)supported formats (`ssh://`, `https://` `git+ssh://` `git+https://`, `git+file://`, `.git` suffix, ...), if there are any limitations due to plugin name inferring.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T20:31:16Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087585745",
            "id": 2087585745,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58bgfR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 198,
            "original_position": 198,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087585745",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087614353"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "question: Lockfile support isn't implemented yet. What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\nThis isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nquibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\nFor consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-13T20:51:26Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087614353",
            "id": 2087614353,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58bneR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2575,
            "original_position": 63,
            "original_start_line": 2573,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2838039353,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-13T21:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087614353",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2087933137"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Or can also use Golang-like format \"github.com/user/repo\" (`https://` is ommitted)",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-14T02:49:14Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2087933137",
            "id": 2087933137,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58c1TR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2838571319,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-14T05:15:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087933137",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2090889590"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I strongly agree with @mrcjkb.\r\n\r\nI think it would be most flexible if all specifications were unified to `provider:identifier`.\r\n\r\nThis is what the internal implementation looks like.\r\n\r\n```lua\r\nvim.pack.providers:add('github', {\r\n  fetch = function(ctx, callback)\r\n    vim.system({\r\n      'git',\r\n      'clone',\r\n      ('https://github.com/%s'):format(ctx.identifier),\r\n      ctx.dist_path\r\n    }, {\r\n      on_exit = function(output)\r\n        callback(output.code == 0)\r\n      end\r\n    })\r\n  end\r\n})\r\n```\r\n_It's just a example_",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T10:49:51Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2090889590",
            "id": 2090889590,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58oHF2",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843224811,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T10:49:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2090889590",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091036566"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566"
                }
            },
            "author_association": "MEMBER",
            "body": "I am completely open to adding `<host>:<owner>/<repo>` support (was not aware of this convention, by the way, it's nice). It is better to wait for an \"executive decision\" on this, though. Plus can always be added in a follow up PR.\r\n\r\n> This is what the internal implementation looks like.\r\n\r\n*This* level of flexibility is definitely too much. Not only because making everything as flexible as possible is probably not the best goal here, but mostly because `vim.pack` makes assumptions about how `git clone` is done (like explicitly set \"origin\" as remote's name, extra useful arguments `--filter=blob:none`, etc.).\r\n\r\nIf any customization here is deemed to be acceptable, I am leaning towards creating a separate `vim.pack.config()` (like `vim.diagnostic.config()`) which can have `format_source` callable. By default it can transform 'domain:user/repo' into 'https://domain.com/user/repo.git' and users can adjust to their liking (like allowing 'user/repo' to mean 'github:user/repo').",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:15:09Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091036566",
            "id": 2091036566,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58oq-W",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843470729,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:15:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091036566",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091049777"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777"
                }
            },
            "author_association": "MEMBER",
            "body": "Just make users specify the full URL to a git repo; no point in being clever for the sake of it (and very minor convenience). The built-in manager needs to be minimal (but functional), nothing more.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:22:31Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091049777",
            "id": 2091049777,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58ouMx",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843492390,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 6,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:22:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091049777",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091066897"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This example is not intended to expose an API for customization for users. It's just an idea of ​​how to handle user-specified \"identifiers\".\r\n\r\nMy concern was the fact that deno/node eventually introduced `node:`, `npm:`, etc.\r\n\r\nI'm not against the introduction of a minimal manager, I just suggested it now to pave the way for the future.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:32:11Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091066897",
            "id": 2091066897,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58oyYR",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843520661,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:32:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091066897",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091077947"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947"
                }
            },
            "author_association": "MEMBER",
            "body": "We are more interested in future maintainability in this regard; any future extensibility will be controlled through options. The string is either a full URL or a full local path, nothing \"magic\"; this is a hard line.\r\n\r\nSo the blunt answer to the initial question is \"**zero** magic\" (which has the benefit of supporting _any_ git hoster as long as `git clone <url>` works as expected). Non-git version control is completely out of scope for core (sorry not sorry).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:38:22Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091077947",
            "id": 2091077947,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58o1E7",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843539089,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:42:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091077947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091094199"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "From the viewpoint of maintainability, wouldn't it be easier to maintain if it was clear whether the specified thing was a URL or a local path?\r\n\r\nIs it possible to distinguish between them using prefixes such as `~/`, `./`, `$HOME/`, `https://github.com`, and `git@`? (Sorry, I can't think of any concrete examples.)\r\n\r\nThat's my opinion, but I support the official position.\r\nI wanted to make a suggestion as a community member.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:47:01Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091094199",
            "id": 2091094199,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58o5C3",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843565110,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:47:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091094199",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091104201"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe we can special case missing protocol (which a full URL always requires!) as a local path (since at least in my opinion that is an important enough usecase); but that is still TBD since local plugins are not part of this PR. Having to explicitly specify `local = true` (or variants thereof) is acceptable as long as the functionality is there.\r\n\r\nWe want to remove friction for users, but we are _not_ interested in maximizing convenience at the cost of maintenance (which includes sufficiently clear documentation for \"magic\" behavior).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T12:52:18Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.\n+--- @field name? string Name of plugin. Will be used as directory name. Default: basename of `source`.\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.\n+--- @field version? string|vim.VersionRange\n+\n+--- @alias vim.pack.SpecResolved { source: string, name: string, version: string|vim.VersionRange }\n+\n+--- @param spec string|vim.pack.Spec\n+--- @return vim.pack.SpecResolved\n+local function normalize_spec(spec)\n+  spec = type(spec) == 'string' and { source = spec } or spec\n+  vim.validate('spec', spec, 'table')\n+  vim.validate('spec.source', spec.source, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091104201",
            "id": 2091104201,
            "in_reply_to_id": 2087294117,
            "line": 243,
            "node_id": "PRRC_kwDOAPphoM58o7fJ",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": 243,
            "pull_request_review_id": 2843581513,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T12:53:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091104201",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091158037"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037"
                }
            },
            "author_association": "MEMBER",
            "body": "I've added the \"Any format supported by `git clone` is allowed.\" (which *should* be technically true, I hope). At least for now, until there is a local plugin support or an explicitly limited support of formats.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T13:19:21Z",
            "diff_hunk": "@@ -0,0 +1,911 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Requires present `git` executable of at least version 2.36.\n+---\n+--- `vim.pack` manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+--- `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+--- plugin's name in specification.\n+--- It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+--- @field source string URI from which to install and pull updates.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091158037",
            "id": 2091158037,
            "in_reply_to_id": 2087585745,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pIoV",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 198,
            "original_position": 198,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2843670856,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T13:19:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091158037",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091167529"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529"
                }
            },
            "author_association": "MEMBER",
            "body": "> What's the current behaviour for a plugin that hasn't been installed yet, if its version is set to `HEAD`?\r\n> This isn't clear to me from the docs alone - perhaps it needs clarification?\r\n\r\nTechnically - whichever is after `git clone`. On paper - added that \"HEAD\" is \"... for already installed plugin\" only. At least indeed until there is a lockfile support.\r\n\r\n> quibble: The field name `version` suggests a semantic abstraction, while `HEAD` is git-specific.\r\n> For consistency, I'd suggest either using a semantic term like `FREEZE`, or renaming the field to be explicitly git-specific.\r\n\r\nI am also not 100% happy with either \"version\" or \"HEAD\". Using \"FREEZE\" indeed might be a good idea, although I personally would prefer using \"checkout\" instead of \"version\". But that seems too Git-specific and needs a review.\r\n\r\nI've updated [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2087290998) to keep these kind of suggestions in one place.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T13:23:54Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.\n+\n+`vim.pack` manages plugins only in a dedicated |packages|\n+*vim.pack-directory*: `$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's\n+subdirectory name matches plugin's name in specification. It is assumed that\n+all plugins in the directory are managed exclusively by `vim.pack`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091167529",
            "id": 2091167529,
            "in_reply_to_id": 2087614353,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pK8p",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2575,
            "original_position": 63,
            "original_start_line": 2573,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2843686203,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T13:23:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091167529",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091170938"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938"
                }
            },
            "author_association": "MEMBER",
            "body": "Done.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T13:25:32Z",
            "diff_hunk": "@@ -2513,6 +2513,167 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Requires present `git` executable of at least version 2.36.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091170938",
            "id": 2091170938,
            "in_reply_to_id": 2087330410,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58pLx6",
            "original_commit_id": "343baab15155797d9993e84149939868e44a3be7",
            "original_line": 2522,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2843691917,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T13:25:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091170938",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2091371243"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243"
                }
            },
            "author_association": "MEMBER",
            "body": "Although the strict \"try to use greatest available version\" should be a good approach for most \"popular\"/\"serious\" plugins, many smaller ones would probably not have semver tags at all. The current logic is for those users to set an explicit `version = 'master'` or `version = 'main'` (which one - should be specified in the plugin's help or just by two trials and one error). This sounds okay to me.\r\n\r\nPlus, some older (i.e. Vimscript) plugins might also have very old semver tag compared to the progress on default branch (like 'tpope/vim-fugitive').\r\n\r\nOne possible solution for both of this might be the following compromise:\r\n\r\n- Have default that *tries* to use latest semver tag. If there is no semver tags at all - fall back to default branch. This is more magic than requiring to explicitly set `version = 'main'/'master'`, but should reduce friction for such cases.\r\n- Add 'pack/health.lua' with checks like \"the latest tag of this plugin is very far behind of default branch; consider setting `version = 'master'`\". This can also be done inside confirmation buffer in the same fashion as there are currently \"Available newer tags\" suggestions.\r\n\r\nBoth of these can be done in a follow up PR.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-15T14:48:02Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2091371243",
            "id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58p8rr",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2844024077,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-15T14:50:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091371243",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2092749902"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902"
                }
            },
            "author_association": "MEMBER",
            "body": "Another approach for solving both of these is, of course, to use default branch (`main` / `master` / etc.) by default. The rationale for using `vim.version.range('*')` as default was to nudge plugins towards adopting semver tags versions. The cons of this are:\r\n- Adds friction for developing \"small\" plugins, i.e. which don't plan to become state-of-the-art implementations with large code bases. Those usually tend to be developed inside a single default branch. This can be resolved by providing installation instructions that use `version = 'main'`, yet it is still friction.\r\n- Adds friction for users when using outdated releases for old Vimscript plugins. It can be mitigated by adding checkhealth entry mentioned above.\r\n- Not all plugins might be suitable for semver release model. A collection of runtime files (like 'nvim-lspconfig', 'nvim-treesitter') might be better managed with \"calendar versioning\" (like a once a month release instead of following semver major-minor-patch convention).\r\n- Most currently popular plugin managers seem to have default branch as default version. Not following that might be going too much against user expectations.\r\n\r\nI personally would always use default branch, but having built-in plugin manager use versions by default seemed like a \"good kind of friction\" in a long term. I just need a decision to which kind of default is best here.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-16T10:01:28Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2092749902",
            "id": 2092749902,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58vNRO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2846163099,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T10:03:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092749902",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2093496585"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585"
                }
            },
            "author_association": "MEMBER",
            "body": "My vote is to use the default branch. The versioning scheme needs to be specified by the plugin for us to automatically select tags.\n\nOther package managers allow setting something like `version = \"v*\"` to pick the latest tag beginning with `v`. Some versioning schemes omit the leading `v`.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-16T18:16:49Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2093496585",
            "id": 2093496585,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58yDkJ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2847339802,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T18:16:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093496585",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2093533944"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944"
                }
            },
            "author_association": "MEMBER",
            "body": "> Other package managers allow setting something like `version = \"v*\"` to pick the latest tag beginning with `v`. Some versioning schemes omit the leading `v`.\r\n\r\nFor semantic versioning there is no such need for `vim.pack`, as `vim.version.parse` is smart enough (with `strict = false`) to [extract version number](https://github.com/neovim/neovim/blob/3659058e80485c64cdd8a980337058ca0e40555d/runtime/lua/vim/version.lua#L174). Yes, there might be false positives if there are numbers in tags, but it should be good enough if it is known that tags have semantic versioning.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-16T18:50:22Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2093533944",
            "id": 2093533944,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58yMr4",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2847399048,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-16T18:50:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093533944",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169208"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208"
                }
            },
            "author_association": "MEMBER",
            "body": "Will this work outside of init.lua, for those of us who still use init.vim? For example, can I use `plugin/pack.lua` or even `lua/pack.lua` (and execute manually with `:lua require('pack')` when I want to modify my plugins)?\r\n\r\nOne reason I like using `start/` is that I don't have to dedicate any source code to loading plugins. I literally just `git clone` them to the right location and let Nvim handle the rest. Since it sounds like `vim.pack` puts everything in `opt`, I'm assuming that is not a use case that will be supported and I will have to use `vim.pack.add` to load plugins out of `opt`? ",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:09:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169208",
            "id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580nx4",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2564,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848354438,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:09:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169208",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169684"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684"
                }
            },
            "author_association": "MEMBER",
            "body": "Does this download happen automatically? So if a user has `vim.pack.add` in their init.lua, as soon as they start Nvim it will automatically start downloading things?\r\n\r\nI wonder if this should be a more explicit action. Nvim automatically downloading things without any user action feels a bit iffy (I don't think there's any precedent for that?)",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:11:51Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169684",
            "id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580n5U",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848355087,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:11:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169684",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169923"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923"
                }
            },
            "author_association": "MEMBER",
            "body": "Spell files? I would consider a `vim.pack.add` line as \"explicitly opting in\" here.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:13:08Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094169923",
            "id": 2094169923,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580n9D",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848355360,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:13:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094169923",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094170341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure I understand what this does if `offline` is false?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:16:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094170341",
            "id": 2094170341,
            "line": 2671,
            "node_id": "PRRC_kwDOAPphoM580oDl",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 159,
            "pull_request_review_id": 2848355887,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:16:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094170341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171165"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165"
                }
            },
            "author_association": "MEMBER",
            "body": "This comment and the way these two lines are grouped together is confusing (I had to read this 3 times and I'm still not 100% confident I'm understanding it correctly).\r\n\r\nIIUC, this installs two different plugins, `github.com/user/plugin1` and `github.com/user/plugin2`. The 1st example is demonstrating the \"shortcut\" method of installing a plugin and the 2nd example is showing the more verbose version.\r\n\r\nThe single comment and grouping of these lines makes it seem like this is installing a single plugin under a directory `plugin1/plugin2`.\r\n\r\nIf my understanding is correct, I think formatting it like this would make it clearer:\r\n\r\n```\r\n-- Install \"plugin1\" and use greatest available version.\r\n'https://github.com/user/plugin1',\r\n\r\n-- Same as above, but using a full table, which allows setting other options.\r\n{ source = 'https://github.com/user/plugin1' },\r\n```",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:20:40Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171165",
            "id": 2094171165,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oQd",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2539,
            "original_position": 27,
            "original_start_line": 2537,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848356705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:20:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171165",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171449"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe clarify here that if `name` is omitted it's inferred from the URL?\r\n\r\n```suggestion\r\n      -- Specify plugin's name (here the plugin will be called \"plugin3\"\r\n      -- instead of \"generic-name\")\r\n      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\r\n```",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:22:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094171449",
            "id": 2094171449,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oU5",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2542,
            "original_position": 30,
            "original_start_line": 2541,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848356964,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:22:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094171449",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172111"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure what \"Greatest version matching range\" means. Maybe call this the \"version constraint\" instead (with a link to the docs).\r\n\r\nI had to read the `vim.version.range` docs to understand exactly what `vim.version.range('1.0')` means. This matches `1.0.0` and `1.0.1`, but not `1.1`, for example.\r\n\r\n```suggestion\r\n        version = vim.version.range('1.0'), -- Version constraint. See |vim.version.range()|\r\n```",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:25:40Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172111",
            "id": 2094172111,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ofP",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2547,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357554,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:25:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172111",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172321"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n• Restart Nvim. The plugin's actual state on disk is not yet changed.\r\n```",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:26:37Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172321",
            "id": 2094172321,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580oih",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2569,
            "original_position": 57,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357717,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:26:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172321",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172538"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n• Review changes and either confirm or discard them. If discarded, revert any changes in 'init.lua' as well or you will be prompted again next time you run |vim.pack.update()|.\r\n```",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:28:04Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172538",
            "id": 2094172538,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ol6",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2573,
            "original_position": 61,
            "original_start_line": 2572,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848357948,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:28:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172538",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172722"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722"
                }
            },
            "author_association": "MEMBER",
            "body": "I find it pretty counter-intuitive that `HEAD` implies freezing the plugin. In Git parlance, `HEAD` is the current tip, which is always changing.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:29:17Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172722",
            "id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ooy",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358116,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:29:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172722",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172936"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936"
                }
            },
            "author_association": "MEMBER",
            "body": "No API to delete plugins? Having to manually run `rm -rf ~/.local/share/nvim/site/pack/core/plugin-name` is a bit tedious. Not to mention it leaks an abstraction (the installation directory of plugins).\r\n\r\nWhy not provide `vim.pack.del(\"plugin-name\")`?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:30:38Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094172936",
            "id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580osI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358433,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:30:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094172936",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094173407"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407"
                }
            },
            "author_association": "MEMBER",
            "body": "I think the plan is to\r\n1. remove/comment out `vim.pack.add()`\r\n2. call `vim.clean()`\r\n\r\n(Agreed that we absolutely need a way to clean up what we put in.)",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:32:44Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094173407",
            "id": 2094173407,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580ozf",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848358945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:32:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094173407",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174058"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058"
                }
            },
            "author_association": "MEMBER",
            "body": "> that I don't have to dedicate any source code to loading plugins\n\nIf you use `vim.pack` wouldn't you then have source code for loading plugins regardless of whether it uses `opt` or `start` internally?\n\nAnd if you are thinking from a perf pov, using a plugin manager with `opt` will be more efficient than using `start` since you can avoid an unnecessary directory path scan as the package manager knows where to look for plugins.\n\n`start` really only makes sense if you do not want any plugin knowledge in your `init.lua`, and manage them externally, in which case a built-in package manager has no place. Unless I'm missing something?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:36:18Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174058",
            "id": 2094174058,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580o9q",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2564,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:36:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174058",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174061"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061"
                }
            },
            "author_association": "MEMBER",
            "body": "I've never downloaded a spell file in Vim, but reading the docs briefly it says \r\n\r\n>But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nIn this case it's still requiring an explicit action (confirmation) from the user, not just immediately downloading.\r\n\r\n>I would consider a vim.pack.add line as \"explicitly opting in\" here.\r\n\r\nUsers are required to have `vim.pack.add` in their init file to even load/enable the plugin. So I don't think it's acceptable to treat that as tacit approval of \"yes please download things automatically\".\r\n\r\nIt's not difficult to show a single confirmation dialog that says \"Install the following plugins? [Y/n]\"",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:36:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174061",
            "id": 2094174061,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580o9t",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848360004,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:36:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174061",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174802"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802"
                }
            },
            "author_association": "MEMBER",
            "body": "No, I mean adding `vim.pack.add('thisplugin')` _is_ giving confirmation to \"yes, please download _this plugin_\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\n> But if the \"spellfile.vim\" plugin is active it will offer you to download the spell file\r\n\r\nWhich it is by default, in Nvim (not Vim IIRC). You're right that this shows a prompt (correctly in this case, because the action is not directly tied to what triggers it, unlike here).\r\n",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:40:28Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094174802",
            "id": 2094174802,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580pJS",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848360776,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:45:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094174802",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175054"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054"
                }
            },
            "author_association": "MEMBER",
            "body": "I was a bit careless with my words/phrasing. Yes there will of course always be some code to specify the list of plugins which should be installed (even in the `start` world). I was referring to requiring code to just enable/load the plugin.\r\n\r\nBut I'm also speaking more from personal preference here. I think in regard to the builtin plugin manager, this design is perfectly fine. And the small minority of users still using init.vim instead of init.lua can use a Lua heredoc or something.\r\n\r\nSo consider this comment resolved.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:41:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175054",
            "id": 2094175054,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pNO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2564,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848360945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:41:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175054",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175776"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776"
                }
            },
            "author_association": "MEMBER",
            "body": ">Which it is by default, in Nvim (not Vim IIRC).\r\n\r\nThe plugin is enabled, but still \"offers to download the spell file\" (implying there is a prompt).\r\n\r\n>No, I mean adding vim.pack.add('thisplugin') is giving confirmation to \"yes, please download this plugin\". I don't want to have to deal with a second prompt for this. (Otherwise bootstrapping will be painful.)\r\n\r\nThe bootstrapping situation is exactly the one I'm thinking of where I would want a prompt. If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBut if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:45:25Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175776",
            "id": 2094175776,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580pYg",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848361660,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:45:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175991"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991"
                }
            },
            "author_association": "MEMBER",
            "body": ">If I'm on an existing machine and I want to add a new plugin, I agree that I should be able to run some command/call some function and add/install the new plugin all at once (that is my explicit opt-in).\r\n\r\nBeing able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:46:49Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094175991",
            "id": 2094175991,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580pb3",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848361902,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:46:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094175991",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094176570"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570"
                }
            },
            "author_association": "MEMBER",
            "body": "> Will this work outside of init.lua, for those of us who still use init.vim? For example, can I use `plugin/pack.lua` or even `lua/pack.lua` (and execute manually with `:lua require('pack')` when I want to modify my plugins)?\r\n\r\nThis should work as any \"regular\" `vim.xxx()` function, even via `:lua vim.pack.add(...)`.\r\n\r\nAnd yes, 'start/' vs 'opt/' shouldn't make a difference here if they both are required to be listed in the config somewhere.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:49:57Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094176570",
            "id": 2094176570,
            "in_reply_to_id": 2094169208,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580pk6",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2564,
            "original_position": 52,
            "original_start_line": 2533,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848362436,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T17:49:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094176570",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094177352"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352"
                }
            },
            "author_association": "MEMBER",
            "body": "Everything that is listed afterwards: infer the matching states from `version` field of plugins and either update (`force = true`) or show confirmation buffer (`force = false`, default). This is useful for changing the version of plugin on disk, as it doesn't require internet connection. Strictly speaking, having `offline` field is not needed if checking for upstream changes is considered a \"cheap\" enough operation.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:53:37Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094177352",
            "id": 2094177352,
            "in_reply_to_id": 2094170341,
            "line": 2671,
            "node_id": "PRRC_kwDOAPphoM580pxI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 159,
            "pull_request_review_id": 2848363083,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:53:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094177352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094178068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068"
                }
            },
            "author_association": "MEMBER",
            "body": "> I'm not sure what \"Greatest version matching range\" means. Maybe call this the \"version constraint\" instead (with a link to the docs).\r\n\r\nIn `vim.version` terminology it is \"last\", which I don't find correct/intuitive. It is the largest/biggest/greatest available version that matches any constraint specified via `vim.version.range()`. In this particular case it is indeed larger than or equal `1.0.0` but strictly less than `1.1.0`.\r\n\r\nYes, linking to `vim.version.range()` makes sense.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T17:56:49Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094178068",
            "id": 2094178068,
            "in_reply_to_id": 2094172111,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580p8U",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2547,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848363681,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-17T17:56:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094178068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134"
                }
            },
            "author_association": "MEMBER",
            "body": "The logic is as follows. The `version` describes what target state to use when updating plugin. If target state is always \"HEAD\" (i.e. current), it means that updating will always \"update\" to the current state. I.e. no new changes.\r\n\r\nI think this name best works if `version` is named `checkout`.\r\n\r\nNaming \"FREEZE\" instead of \"HEAD\" is possible, but it makes it a \"reserved\" word which would make it impossible to use branch named \"FREEZE\". A *very* unlikely scenario which might be worth the risk, of course.\r\n\r\nOther plugin managers use a separate spec field for that, but I really don't think it is needed here.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:02:04Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179134",
            "id": 2094179134,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qM-",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848364934,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:02:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179150"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150"
                }
            },
            "author_association": "MEMBER",
            "body": "Pretty sure there is a prompt for spell files, and I also agree plugin installs should require a prompt.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:02:11Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094179150",
            "id": 2094179150,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580qNO",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848364959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:02:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094179150",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180255"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255"
                }
            },
            "author_association": "MEMBER",
            "body": "> Why not provide `vim.pack.del(\"plugin-name\")`?\r\n\r\nIt is one of the possibility (listed in \"Planned future work\" of the first comment), which I am not against. There are/were others:\r\n\r\n1. Provide a `vim.pack.clean()` to clean not used plugins. This might get tricky if there is no way to cherry-pick plugins, because there is no good way to see which plugins are intended to be removed and which are just not (yet) loaded. See [this comment](https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306) and what it responds to. So I think it is only a good option if it provides an *interactive* confirmation buffer allowing to filter out plugins that don't need to be removed. This is what 'mini.deps' does, but I think it is too much for `vim.pack.add`.\r\n1. Export a way to get plugin's path based on the name and suggest to use `vim.fn.delete()`. So it might be something like `vim.fn.delete(vim.pack.get('plugin-name').path)`.\r\n1. Indeed provide `vim.pack.del('plugin-name')`. This can also trigger dedicated events (`PackDelPre` and `PackDel`) which can be used by plugins to do some kind of \"cleanup\".\r\n\r\nAt the moment, I think either option 2. or 3. are fine. They 3. indeed might be a bit cleaner.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:09:36Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180255",
            "id": 2094180255,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qef",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848366306,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:09:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180255",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180525"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525"
                }
            },
            "author_association": "MEMBER",
            "body": "At best `HEAD` is ambiguous here.\n\nI think a separate field is warranted. Adding special keywords that can conflict in a namespace is a worse way of solving this and a separate field is much more intuitive and easier to understand.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:11:10Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094180525",
            "id": 2094180525,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qit",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848366589,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:11:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094180525",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181422"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422"
                }
            },
            "author_association": "MEMBER",
            "body": "> because there is no good way to see which plugins are intended to be removed and which are just not (yet) loaded\n\nThis is exactly why I added a `cond = function(load) end` spec field in pckr.nvim to defer loading a plugin. In order for a package manager to manage plugins, it needs to know what plugins it is managing. There isn't really a way around this.\n\nSince you have the constraint that `vim.pack.add` _must_ load the plugin, I don't think we'll ever be able to robustly manage the removal of unused plugins. That will just need to be an accepted limitation.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:18:14Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181422",
            "id": 2094181422,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580qwu",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848367702,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:18:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181422",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181976"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976"
                }
            },
            "author_association": "MEMBER",
            "body": "> vim.fn.delete()\n\nOr `vim.fs.rm()`",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:20:58Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094181976",
            "id": 2094181976,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580q5Y",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848368123,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:20:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094181976",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094183625"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625"
                }
            },
            "author_association": "MEMBER",
            "body": "My thinking is what @clason described: putting explicit `vim.pack.add()` in the config should be enough of a confirmation already. \r\n\r\n> Being able to add a `vim.pack.add()` and then immediately call `:lua vim.pack.update()` to install the plugin that I've just added seems like it should satisfy this use case. Instead of having to add `vim.pack.add()` and then restart Nvim.\r\n\r\nPlugin will be installed already after `vim.pack.add()`, no need to either restart Nvim or `vim.pack.update()`. So I don't really understand what this is about.\r\n\r\n> But if I'm on a new machine, or perhaps reproducing a user's bug report which installs a bunch of arbitrary plugins, and I start Nvim for the first time, I absolutely want to explicitly say \"yes go ahead and install the plugins after I see what you're going to install\". The difference is that when you're starting Nvim for the first time on a new machine or reproducing some bug, you don't necessarily already know exactly what plugins are going to be downloaded.\r\n\r\nWell, right now it is known (all plugins are listed), but if/when there is packspec support, this indeed won't be known 100% in advance.\r\n\r\nI am open to adding some confirmation before installing. Some questions:\r\n- Is something like `vim.fn.confirm('These plugins will be installed:\\n...')` enough or should be more interactive (like allowing to specify which plugins to install)? I'd guess it should be enough.\r\n- Should it be one confirmation per install (i.e. several times pressing `y`) or one confirm for all installs? I'd guess one for all plugins should be enough, otherwise it is a tedious amount of \"y\" during bootstrap.\r\n- Should it be run only during startup (i.e. `vim.v.vim_did_enter == 0`) or for every install? I'd go with only during startup, because otherwise it should be a conscious decision (i.e. enough of confirmation already).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:28:46Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094183625",
            "id": 2094183625,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580rTJ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848369343,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:28:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094183625",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184571"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571"
                }
            },
            "author_association": "MEMBER",
            "body": "> ... it needs to know what plugins it is managing. There isn't really a way around this.\r\n\r\nRight now it is \"all plugins inside '~/.local/share/nvim/site/pack/core/opt'\". All of them can be updated, i.e. \"managed\".\r\n\r\n> I don't think we'll ever be able to robustly manage the removal of unused plugins. That will just need to be an accepted limitation.\r\n\r\nYes, I did come to that conclusion also (as a result of comments in this PR). And I think this limitation is worthwhile as the idea of \"just add `vim.pack.add()` line to config and assume plugin is present afterwards\" is very convenient when used inside config.\r\n\r\nHence why I think providing only a manual way of `vim.pack.del()` is good enough. It is explicit and atomic operation, which can be more than just deleting a directory.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:35:29Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184571",
            "id": 2094184571,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rh7",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848370378,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:35:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184571",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184911"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911"
                }
            },
            "author_association": "MEMBER",
            "body": "> I think a separate field is warranted. Adding special keywords that can conflict in a namespace is a worse way of solving this and a separate field is much more intuitive and easier to understand.\r\n\r\nSure, sounds good. My objective here is to have as simple spec as possible. There are precedents of having too fields in plugin spec bring more confusion than good.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:37:45Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094184911",
            "id": 2094184911,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580rnP",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848370934,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:37:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094184911",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094185053"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053"
                }
            },
            "author_association": "MEMBER",
            "body": "I think a single prompt for a list of plugins and done any time a plugin is installed.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T18:38:41Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094185053",
            "id": 2094185053,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580rpd",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848371086,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T18:39:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094185053",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094194341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341"
                }
            },
            "author_association": "MEMBER",
            "body": ">Is something like vim.fn.confirm('These plugins will be installed:\\n...') enough or should be more interactive \r\n\r\nYes I think that's fine\r\n\r\n>Should it be one confirmation per install (i.e. several times pressing y) or one confirm for all installs\r\n\r\nOne for all, just list all of the ones that are going to be installed (this can be done in a floating window or something if there are a lot)\r\n\r\n>putting explicit vim.pack.add() in the config should be enough of a confirmation already.\r\n\r\nThere are cases where you DIDN'T put `vim.pack.add` in the config though (you are using a config that somebody else provided to reproduce a bug), or when you did the context/situation was different (maybe I put `vim.pack.add` in my config several months ago, but now I'm cloning onto a new machine and I want to review what's going to be downloaded before Nvim starts cloning a bunch of repos automatically).\r\n\r\n> Plugin will be installed already after vim.pack.add(), no need to either restart Nvim or vim.pack.update(). So I don't really understand what this is about.\r\n\r\nAs a general design rule Nvim shouldn't be downloading things from the internet without some explicit consent/action from the user. If the user runs `vim.pack.add()` interactively then I agree that is sufficiently explicit. But if it's run programmatically (as part of startup in init.lua) I don't think it is, at least not as a default.\r\n\r\nIn Emacs, `use-package` has an `ensure` option that users can set to have the plugin automatically downloaded. That is another option we could explore (set either per-plugin as part of `vim.pack.add()` or globally as part of `vim.pack.config()`). But as a **default**, we should err on the side of requiring user action.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T19:30:19Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094194341",
            "id": 2094194341,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM580t6l",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2848381093,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T19:30:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094194341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094197044"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044"
                }
            },
            "author_association": "MEMBER",
            "body": "Another idea would be to use another type like `version=false`? Isn't as easy to understand as a separate field but avoids the name clashing problem.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-17T19:47:12Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094197044",
            "id": 2094197044,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM580uk0",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2848383792,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 2,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-17T19:47:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094197044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094484236"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, sorry, I misunderstood the question (thought it was about `offline = true`) :facepalm:\r\nIf `offline` is `false` (which is default), it downloads new changes from the source. Under the hood it is `git fetch` with some set of useful flags, which makes local copy of `origin` remote have the same state as on remote. After that, it proceeds with next steps.\r\n\r\n---\r\n\r\nA note. If/when there is a lockfile capability which would allow to track data (like `version`) between Nvim sessions, the `offline = true` use case might be replaced with making `vim.pack.add()` always ensure that plugin is at correct target state. Without lockfile it is not quite performant to do so (as \"happy path\" of being in the proper target version is much more common and explicitly checking takes non-trivial-during-startup amount of time). Whether this is a good behavior or it is better to require an explicit `vim.pack.update()` to actually see which changes are being applied is a topic of another discussion.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T10:54:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094484236",
            "id": 2094484236,
            "in_reply_to_id": 2094170341,
            "line": 2671,
            "node_id": "PRRC_kwDOAPphoM5810sM",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 159,
            "pull_request_review_id": 2848892677,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-18T11:03:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094484236",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094507024"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024"
                }
            },
            "author_association": "MEMBER",
            "body": "> Oh, sorry, I misunderstood the question (thought it was about offline = true)\r\n\r\nHa that is actually what I meant, so you understood my question even though I asked it incorrectly. ",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T12:17:39Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).\n+    • For each plugin execute |:packadd| making them reachable by Nvim.\n+\n+    Notes:\n+    • Installation is done in parallel, but waits for all to finish before\n+      continuing next code execution.\n+    • If plugin is already present on disk, there are no checks about its\n+      present state. The specified `version` can be not the one actually\n+      present on disk. Execute |vim.pack.update()| (possibly with\n+      `{ offline = true }`) to synchronize.\n+    • Adding plugin second and more times during single session does nothing:\n+      only the data from the first adding is registered.\n+\n+    Parameters: ~\n+      • {specs}  (`(string|vim.pack.Spec)[]`) List of plugin specifications.\n+                 String item is treated as `source`.\n+      • {opts}   (`table?`) A table with the following fields:\n+                 • {bang}? (`boolean`) Whether to execute `:packadd!` instead\n+                   of |:packadd|. Default `false`.\n+\n+vim.pack.get()                                                *vim.pack.get()*\n+    Get data about all plugins managed by |vim.pack|\n+\n+    Return: ~\n+        (`table[]`) A list of objects with the following fields:\n+        • {spec} (`vim.pack.SpecResolved`) A |vim.pack.Spec| with defaults\n+          made explicit.\n+        • {path} (`string`) Plugin's path on disk.\n+        • {was_added} (`boolean`) Whether plugin was added via\n+          |vim.pack.add()| in current session.\n+\n+vim.pack.update({names}, {opts})                           *vim.pack.update()*\n+    Update plugins\n+    • If not `offline`, download new changes from source.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094507024",
            "id": 2094507024,
            "in_reply_to_id": 2094170341,
            "line": 2671,
            "node_id": "PRRC_kwDOAPphoM5816QQ",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2657,
            "original_position": 145,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 159,
            "pull_request_review_id": 2848921755,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-18T12:17:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094507024",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571350"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350"
                }
            },
            "author_association": "MEMBER",
            "body": "I did go with `version = false` to freeze plugins. Is it enough to resolve this?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T16:28:10Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571350",
            "id": 2094571350,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582J9W",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849037248,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:28:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571350",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592"
                }
            },
            "author_association": "MEMBER",
            "body": "There is now `vim.pack.del()` in this PR. It accepts array of names and removes those plugins from disk. Along with triggering dedicated events and some proper bookkeeping.\r\nIs it enough to resolve this conversation?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T16:29:21Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094571592",
            "id": 2094571592,
            "in_reply_to_id": 2094172936,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582KBI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2586,
            "original_position": 74,
            "original_start_line": 2585,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849037477,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:29:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094571592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094575524"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524"
                }
            },
            "author_association": "MEMBER",
            "body": "If someone wants to freeze/pin a plugin to an exact version can’t they just set the tag/commit hash? Do we need this extra field/value at all?",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T16:49:08Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094575524",
            "id": 2094575524,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582K-k",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849041508,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T16:49:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094575524",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2094598936"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes, that's a fair point. The special case of \"freezing\" a plugin is mostly due to:\r\n- Having a recipe of \"Just set `version = false` to prevent updates\" is more straightforward than \"Run `vim.pack.update({ 'plugin-name' }, { offline = true })`, yank the hash for current state, and set `version` to it\".\r\n- There is a similar functionality in other plugin managers (although with a separate field). So this concept should be familiar to users of other plugin managers.\r\n\r\nAs \"freezing\" the plugin from updates is more or less common operation, I decided to have this to reduce friction.\r\n\r\nIf both of the above points are not important enough for the added complexity, it can indeed be removed. I also \"prepared\" for it just now by having shorter hashes (`--abbrev-commit`) be reported as state in the `vim.pack.update()` output. Another reason for removing it might be that it is possible to add later, while removing this capability is less easy.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-18T18:45:33Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2094598936",
            "id": 2094598936,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM582QsY",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2849063536,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-18T18:45:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2094598936",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096135993"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993"
                }
            },
            "author_association": "MEMBER",
            "body": "There is now a confirm before any plugin(s) install. It uses `vim.fn.confirm()`, but during startup it is drawing issues (see #34088), so for now it is a bit hacky workaround with delayed `vim.print()` and manual processing of the key asked via `vim.fn.getcharstr()`. After #34088 is solved (or 'extui' becomes default, whichever is sooner), the `vim.fn.confirm()` can be used universally.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-19T16:47:06Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.\n+\n+Unfreeze plugin to start receiving updates:\n+• Update 'init.lua' for plugin to have `version` set to whichever version you\n+  want it to be updated.\n+• Restart Nvim.\n+\n+Remove plugin from disk:\n+• Delete plugin's directory manually. Make sure its spec is not included in\n+  |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+\n+Available events to hook into ~\n+• *PackInstallPre* - before trying to install plugin on disk.\n+• *PackInstall* - after installing plugin on disk in proper state. After\n+  |PackUpdatePre| and |PackUpdate|.\n+• *PackUpdatePre* - before trying to update plugin's state.\n+• *PackUpdate* - after plugin's state is updated.\n+\n+\n+*vim.pack.Spec*\n+\n+    Fields: ~\n+      • {source}    (`string`) URI from which to install and pull updates. Any\n+                    format supported by `git clone` is allowed.\n+      • {name}?     (`string`) Name of plugin. Will be used as directory name.\n+                    Default: basename of `source`.\n+      • {version}?  (`string|vim.VersionRange`) Version to use for install and\n+                    updates. One of:\n+                    • Output of |vim.version.range()| to install the\n+                      greatest/last semver tag inside the range.\n+                    • Tag name.\n+                    • Branch name.\n+                    • \"HEAD\" to freeze current state from updates for already\n+                      installed plugin.\n+                    • Explicit commit hash.\n+\n+                    Default is `vim.version.range('*')`, i.e. install the\n+                    greatest available version.\n+\n+\n+vim.pack.add({specs}, {opts})                                 *vim.pack.add()*\n+    Add plugin to current session\n+    • For each specification check that plugin exists on disk in\n+      |vim.pack-directory|:\n+      • If exists, do nothin in this step.\n+      • If doesn't exist, install it by downloading from `source` into `name`\n+        subdirectory (via `git clone`) and update state to match `version`\n+        (via `git checkout`).",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096135993",
            "id": 2096135993,
            "in_reply_to_id": 2094169684,
            "line": 2630,
            "node_id": "PRRC_kwDOAPphoM588H85",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2624,
            "original_position": 112,
            "original_start_line": 2622,
            "path": "runtime/doc/lua.txt",
            "position": 118,
            "pull_request_review_id": 2851436368,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993/reactions"
            },
            "side": "RIGHT",
            "start_line": 2628,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-19T16:47:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096135993",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096138197"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197"
                }
            },
            "author_association": "MEMBER",
            "body": "The default `version` is now default branch, which is computed automatically (i.e. doesn't hard code `main` or `master`).",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-19T16:48:36Z",
            "diff_hunk": "@@ -0,0 +1,925 @@\n+--- @brief\n+---\n+---WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+---is appreciated, but expect breaking changes without notice.\n+---\n+---Manages plugins only in a dedicated |packages| [vim.pack-directory]():\n+---`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+---plugin's name in specification.\n+---It is assumed that all plugins in the directory are managed exclusively by `vim.pack`.\n+---\n+---Uses Git to manage plugins and requires present `git` executable of at\n+---least version 2.36. Target plugins should be Git repositories with versions\n+---as named tags following semver convention `v<major>.<minor>.<patch>`.\n+---\n+---Example workflows ~\n+---\n+---Basic install and management:\n+---\n+---- Add |vim.pack.add()| call(s) to 'init.lua':\n+---```lua\n+---\n+---vim.pack.add({\n+---   -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+---   'https://github.com/user/plugin1',\n+---   { source = 'https://github.com/user/plugin2' },\n+---\n+---   -- Specify plugin's name\n+---   { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+---\n+---   -- Specify version to follow during install and update\n+---   {\n+---     source = 'https://github.com/user/plugin4',\n+---     version = vim.version.range('1.0'), -- Greatest version matching range\n+---   },\n+---   {\n+---     source = 'https://github.com/user/plugin5',\n+---     version = 'main', -- Git branch, tag, or commit hash\n+---   },\n+---})\n+---\n+----- Plugin's code can be used directly after `add()`\n+---plugin1 = require('plugin1')\n+---```\n+---\n+---- Restart Nvim. Plugins that were not yet installed will be available on disk\n+---in target state after `add()` call.\n+---\n+---- To update all plugins with new changes:\n+---    - Execute |vim.pack.update()|. This will download updates from source and\n+---      show confirmation buffer in a separate tabpage.\n+---    - Review changes. To confirm all updates execute |:write|.\n+---      To discard updates execute |:quit|.\n+---\n+---Switch plugin's version:\n+---- Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+---named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+---- Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+---- Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using `offline`\n+---is optional to not download updates from source.\n+---- Review changes and either confirm or discard them. If discard, make sure\n+---to revert changes in 'init.lua' also.\n+---\n+---Freeze plugin from being updated:\n+---- Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+---- Restart Nvim.\n+---\n+---Unfreeze plugin to start receiving updates:\n+---- Update 'init.lua' for plugin to have `version` set to whichever version\n+---you want it to be updated.\n+---- Restart Nvim.\n+---\n+---Remove plugin from disk:\n+---- Delete plugin's directory manually. Make sure its spec is not included\n+---in |vim.pack.add()| call in 'init.lua' or it will be reinstalled.\n+---\n+--- Available events to hook into ~\n+---\n+---- [PackInstallPre]() - before trying to install plugin on disk.\n+---- [PackInstall]() - after installing plugin on disk in proper state.\n+---After |PackUpdatePre| and |PackUpdate|.\n+---- [PackUpdatePre]() - before trying to update plugin's state.\n+---- [PackUpdate]() - after plugin's state is updated.\n+\n+local api = vim.api\n+local uv = vim.uv\n+\n+local M = {}\n+\n+-- Git ------------------------------------------------------------------------\n+--- @param cmd string[]\n+--- @param cwd string\n+local function cli_sync(cmd, cwd)\n+  local out = vim.system(cmd, { cwd = cwd, text = true, clear_env = true }):wait()\n+  if out.code ~= 0 then\n+    error(out.stderr)\n+  end\n+  return (out.stdout:gsub('\\n+$', ''))\n+end\n+\n+local function git_ensure_exec()\n+  if vim.fn.executable('git') == 0 then\n+    error('No `git` executable')\n+  end\n+end\n+\n+--- @type table<string,fun(...): string[]>\n+local git_args = {\n+  clone = function(source, path)\n+    -- NOTE: '--also-filter-submodules' requires Git>=2.36\n+    local opts = { '--filter=blob:none', '--recurse-submodules', '--also-filter-submodules' }\n+    if vim.startswith(source, 'file://') then\n+      opts = { '--no-hardlinks' }\n+    end\n+    return { 'clone', '--quiet', unpack(opts), '--origin', 'origin', source, path }\n+  end,\n+  stash = function(timestamp)\n+    local msg = '(vim.pack) ' .. timestamp .. ' Stash before checkout' --[[@as string]]\n+    return { 'stash', '--quiet', '--message', msg }\n+  end,\n+  checkout = function(target)\n+    return { 'checkout', '--quiet', target }\n+  end,\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  fetch = function()\n+    return { 'fetch', '--quiet', '--tags', '--force', '--recurse-submodules=yes', 'origin' }\n+  end,\n+  get_origin = function()\n+    return { 'remote', 'get-url', 'origin' }\n+  end,\n+  -- Using `rev-list -1` shows a commit of revision, while `rev-parse` shows\n+  -- hash of revision. Those are different for annotated tags.\n+  get_hash = function(rev)\n+    return { 'rev-list', '-1', rev }\n+  end,\n+  log = function(from, to)\n+    local pretty = '--pretty=format:%m %h │ %s%d'\n+    -- `--topo-order` makes showing divergent branches nicer\n+    -- `--decorate-refs` shows only tags near commits (not `origin/main`, etc.)\n+    return { 'log', pretty, '--topo-order', '--decorate-refs=refs/tags', from .. '...' .. to }\n+  end,\n+  list_branches = function()\n+    return { 'branch', '--remote', '--list', '--format=%(refname:short)', '--', 'origin/**' }\n+  end,\n+  list_tags = function()\n+    return { 'tag', '--list' }\n+  end,\n+  list_new_tags = function(from)\n+    return { 'tag', '--list', '--sort=v:refname', '--contains', from }\n+  end,\n+  list_cur_tags = function(at)\n+    return { 'tag', '--list', '--points-at', at }\n+  end,\n+}\n+\n+local function git_cmd(cmd_name, ...)\n+  local args = git_args[cmd_name](...)\n+  if args == nil then\n+    return {}\n+  end\n+\n+  -- Use '-c gc.auto=0' to disable `stderr` \"Auto packing...\" messages\n+  return { 'git', '-c', 'gc.auto=0', unpack(args) }\n+end\n+\n+--- @param cwd string\n+local function git_get_branches(cwd)\n+  local stdout, res = cli_sync(git_cmd('list_branches'), cwd), {}\n+  for _, l in ipairs(vim.split(stdout, '\\n')) do\n+    table.insert(res, l:match('^origin/(.+)$'))\n+  end\n+  return res\n+end\n+\n+--- @param cwd string\n+local function git_get_tags(cwd)\n+  local stdout = cli_sync(git_cmd('list_tags'), cwd)\n+  return vim.split(stdout, '\\n')\n+end\n+\n+-- Plugin operations ----------------------------------------------------------\n+local function get_plug_dir()\n+  return vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'core', 'opt')\n+end\n+\n+--- @param msg string|string[]\n+--- @param level ('DEBUG'|'TRACE'|'INFO'|'WARN'|'ERROR')?\n+local function notify(msg, level)\n+  msg = type(msg) == 'table' and table.concat(msg, '\\n') or msg\n+  vim.notify('(vim.pack) ' .. msg, vim.log.levels[level or 'INFO'])\n+  vim.cmd.redraw()\n+end\n+\n+local function is_version_range(x)\n+  return (pcall(function()\n+    x:has('1')\n+  end))\n+end\n+\n+local function get_timestamp()\n+  return vim.fn.strftime('%Y-%m-%d %H:%M:%S')\n+end\n+\n+--- @class vim.pack.Spec\n+---\n+--- URI from which to install and pull updates. Any format supported by `git clone` is allowed.\n+--- @field source string\n+---\n+--- Name of plugin. Will be used as directory name. Default: basename of `source`.\n+--- @field name? string\n+---\n+--- Version to use for install and updates. One of:\n+--- - Output of |vim.version.range()| to install the greatest/last semver tag\n+---   inside the range.\n+--- - Tag name.\n+--- - Branch name.\n+--- - \"HEAD\" to freeze current state from updates for already installed plugin.\n+--- - Explicit commit hash.\n+---\n+--- Default is `vim.version.range('*')`, i.e. install the greatest available version.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096138197",
            "id": 2096138197,
            "in_reply_to_id": 2091371243,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM588IfV",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 219,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2851439498,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-19T16:48:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096138197",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34009#discussion_r2096143432"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34009"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432"
                }
            },
            "author_association": "MEMBER",
            "body": "After further discussion on Matrix, it seemed best to postpone the support for `version = false` for freezing plugin in favor of suggesting to use explicit commit hash. At least until there is a lockfile support, because:\r\n- It will provide a more proper initial install of plugin (and not only checkout the default branch) if there is a decision to have `version = false` support.\r\n- It will make easier to get the commit hash of current state if there will be no `version = false` (or separate `pin = true`) support.",
            "commit_id": "6646c0368e8d8e872b033c311107be80f231cf2e",
            "created_at": "2025-05-19T16:52:13Z",
            "diff_hunk": "@@ -2513,6 +2513,180 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+WORK IN PROGRESS built-in plugin manager! Early testing of existing features\n+is appreciated, but expect breaking changes without notice.\n+\n+Manages plugins only in a dedicated |packages| *vim.pack-directory*:\n+`$XDG_DATA_HOME/nvim/site/pack/core/opt`. Plugin's subdirectory name matches\n+plugin's name in specification. It is assumed that all plugins in the\n+directory are managed exclusively by `vim.pack`.\n+\n+Uses Git to manage plugins and requires present `git` executable of at least\n+version 2.36. Target plugins should be Git repositories with versions as named\n+tags following semver convention `v<major>.<minor>.<patch>`.\n+\n+Example workflows ~\n+\n+Basic install and management:\n+• Add |vim.pack.add()| call(s) to 'init.lua': >lua\n+\n+    vim.pack.add({\n+      -- Install as \"plugin1\"/\"plugin2\" and use greatest available version\n+      'https://github.com/user/plugin1',\n+      { source = 'https://github.com/user/plugin2' },\n+\n+      -- Specify plugin's name\n+      { source = 'https://github.com/user/generic-name', name = 'plugin3' },\n+\n+      -- Specify version to follow during install and update\n+      {\n+        source = 'https://github.com/user/plugin4',\n+        version = vim.version.range('1.0'), -- Greatest version matching range\n+      },\n+      {\n+        source = 'https://github.com/user/plugin5',\n+        version = 'main', -- Git branch, tag, or commit hash\n+      },\n+    })\n+\n+    -- Plugin's code can be used directly after `add()`\n+    plugin1 = require('plugin1')\n+<\n+• Restart Nvim. Plugins that were not yet installed will be available on disk\n+  in target state after `add()` call.\n+• To update all plugins with new changes:\n+  • Execute |vim.pack.update()|. This will download updates from source and\n+    show confirmation buffer in a separate tabpage.\n+  • Review changes. To confirm all updates execute |:write|. To discard\n+    updates execute |:quit|.\n+\n+Switch plugin's version:\n+• Update 'init.lua' for plugin to have desired `version`. Let's say, plugin\n+  named 'plugin1' has changed from default `vim.version.range('*')` to `main`.\n+• Restartn Nvim. This has not yet changed plugin's actual state on disk.\n+• Execute `vim.pack.update({ 'plugin1' }, { offline = true })`. Using\n+  `offline` is optional to not download updates from source.\n+• Review changes and either confirm or discard them. If discard, make sure to\n+  revert changes in 'init.lua' also.\n+\n+Freeze plugin from being updated:\n+• Update 'init.lua' for plugin to have `version = 'HEAD'`.\n+• Restart Nvim.",
            "html_url": "https://github.com/neovim/neovim/pull/34009#discussion_r2096143432",
            "id": 2096143432,
            "in_reply_to_id": 2094172722,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM588JxI",
            "original_commit_id": "49547ad2be01efdcb6f7ae99a431c74e03f7f05c",
            "original_line": 2577,
            "original_position": 65,
            "original_start_line": 2575,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2851447354,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-19T16:52:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2096143432",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "NONE",
            "body": "What about url schemas, like Nix has with its `fetchTree` (and, by extension, flakes): \"gitlab:some-fella/plug.nvim\" for \"https://gitlab.com/some-fella/plug.nvim.git\"? Or will that be too much for this?",
            "created_at": "2025-05-13T19:40:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2877746784",
            "id": 2877746784,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rhu5g",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 3,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877746784/reactions"
            },
            "updated_at": "2025-05-15T12:39:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877746784",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/94849097?v=4",
                "events_url": "https://api.github.com/users/acid-bong/events{/privacy}",
                "followers_url": "https://api.github.com/users/acid-bong/followers",
                "following_url": "https://api.github.com/users/acid-bong/following{/other_user}",
                "gists_url": "https://api.github.com/users/acid-bong/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/acid-bong",
                "id": 94849097,
                "login": "acid-bong",
                "node_id": "U_kgDOBadISQ",
                "organizations_url": "https://api.github.com/users/acid-bong/orgs",
                "received_events_url": "https://api.github.com/users/acid-bong/received_events",
                "repos_url": "https://api.github.com/users/acid-bong/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/acid-bong/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/acid-bong/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/acid-bong",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> What about url schemas, like Nix has with its `fetchTree` (and, by extension, flakes): \"gitlab:some-fella/plug.nvim\" for \"https://gitlab.com/some-fella/plug.nvim.git\"? Or will that be too much for this?\r\n\r\nThe actual flexibility that is welcomed here will be a topic of discussion. Right now the most established pattern among plugin managers is to only allow \"user/plugin\" as a stand-in for \"https://github.com/user/plugin\". If even this kind of \"magic\" is welcome needs discussion with core team. There is [this comment](https://github.com/neovim/neovim/pull/34009#discussion_r2087294117) that brings up this and similar issues.\r\n\r\n---\r\n\r\nI'd also like to take an opportunity and kindly ask for people outside of Neovim team to deeply consider if adding a comment will help the discussion. There will probably be a lot of comments as is and navigating a PR with lots of comments becomes problematic very quickly. Thanks for understanding!",
            "created_at": "2025-05-13T20:04:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2877808718",
            "id": 2877808718,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rh-BO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877808718/reactions"
            },
            "updated_at": "2025-05-13T20:04:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877808718",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Can I ask about the choice never to use the `start/` directory? More generally, I'm wondering why `vim.pack.add` always calls `:packadd` behind the scenes. Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes. (I have several plugins that fall into that category for me.) It seems better to me to use `start/` and `opt/` as designed, so that items in `start/` are always sourced and items in `opt/` are left to be manually sourced by the user. But you may have reasons I haven't thought of. Anyhow, I'd be curious to hear your rationale for this part of the design.",
            "created_at": "2025-05-13T22:52:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2878132814",
            "id": 2878132814,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rjNJO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878132814/reactions"
            },
            "updated_at": "2025-05-13T22:52:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878132814",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Can I ask about the choice never to use the start/ directory?\r\n\r\nThen if you want to disable plugins, you have to manually move them to `opt`. That is bad UX.\r\n\r\nI remember @justinmk once said the Nvim team generally think `pack/*/start` is unnecessary",
            "created_at": "2025-05-14T01:24:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2878364447",
            "id": 2878364447,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rkFsf",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878364447/reactions"
            },
            "updated_at": "2025-05-14T01:28:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878364447",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Can I ask about the choice never to use the start/ directory?\r\n> \r\n> Then if you want to disable plugins, you have to manually move them to `opt`.\r\n\r\nNo, that doesn't follow. The plugin manager can move plugins between `start/` and `opt/` as necessary so that the user does not have to do anything manually. (It shouldn't take much extra code: plugin configurations can have a boolean field for `opt` that defaults to false.)\r\n\r\n> That is bad UX.\r\n>\r\n> I remember justinmk once said the Nvim team generally think pack/*/start is unnecessary\r\n\r\nI think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system. It's true that `pack/*/start` is not absolutely necessary, but the system of `start/` versus `opt/` makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nIf the core team is against it, I doubt I will convince them, but here's my final argument. It's better to support both `start/` and `opt/` because that allows more people to use the built-in plugin manager. People who prefer `opt/` for everything can put all their plugins in `opt/` and `:packadd` them all at startup. Other people can put most things in `start/` and a few things in `opt/` (and `:packadd` those when they want). But if the plugin manager ignores `start/`, then only users who prefer everything in `opt/` are supported. I think that a built-in tool should support as many users as possible rather than be overly opinionated. ",
            "created_at": "2025-05-14T11:42:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2879870302",
            "id": 2879870302,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rp1Ve",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879870302/reactions"
            },
            "updated_at": "2025-05-14T12:00:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879870302",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The plugin manager can move plugins between start/ and opt/ as necessary so that the user does not have to do anything manually. (It shouldn't take much extra code: plugin configurations can have a boolean field for opt that defaults to false.)\r\n\r\nIt does make the code more complicated than just\r\n```lua\r\n-- pseudo code\r\nif not pack.opt then\r\n    vim.cmd('packadd! ' .. pack.name)\r\nend\r\n```\r\nNot to say checking if a plugin is in `start/` directory and then moving it could be slow.\r\n\r\n> I think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system.\r\n\r\nIt seems you misunderstood what \"UX\" means.\r\n\r\n> It's true that pack/*/start is not absolutely necessary, but the system of start/ versus opt/ makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nI already answered that, and Chasnovski has also answered that right in the description of this PR.\r\n\r\n> People who prefer opt/ for everything can put all their plugins in opt/ and :packadd them all at startup. Other people can put most things in start/ and a few things in opt/ (and :packadd those when they want). But if the plugin manager ignores start/, then only users who prefer everything in opt/ are supported.\r\n\r\nWhy would people care if the plugin manager use `start/` or not?",
            "created_at": "2025-05-14T11:58:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2879930418",
            "id": 2879930418,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqEAy",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879930418/reactions"
            },
            "updated_at": "2025-05-14T15:45:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2879930418",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes.\r\n\r\nYes, it is possible. Call `vim.pack.add()` with plugin spec only when you want to use the plugin. If plugin is absent it will be automatically installed.\r\nWithout plugin manager it is two step: 1) manually put plugin in pack/*/opt; 2) call `:packadd` when you want to use it.\r\n\r\n> I think it's poor UX for neovim's built-in manager to work directly against the underlying vim/neovim package system. It's true that `pack/*/start` is not absolutely necessary, but the system of `start/` versus `opt/` makes good sense and works well. Why design a plugin manager that undermines that system?\r\n\r\nThe fact that there is choice to make doesn't mean every choice fits every situation. Nothing here \"undermines the system\".\r\n\r\n> People who prefer `opt/` for everything can put all their plugins in `opt/` and `:packadd` them all at startup. Other people can put most things in `start/` and a few things in `opt/` (and `:packadd` those when they want). ... I think that a built-in tool should support as many users as possible rather than be overly opinionated.\r\n\r\nBoth \"put all in 'opt/' and `:packadd` all of them\" and \"put most in 'start/' and some in 'opt/'\" is supported with `vim.pack`. \r\n\r\nPutting a plugin in 'start/' is (in aspects that usually matter, not like 'rtp' order, etc.) the same as putting a `vim.pack.add()` line in an 'init.lua' that is executed on every startup.\r\n\r\nPutting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.",
            "created_at": "2025-05-14T12:17:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880003283",
            "id": 2880003283,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqVzT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880003283/reactions"
            },
            "updated_at": "2025-05-14T12:17:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880003283",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Unless I'm confused, that makes it impossible to use `vim.pack` to install something that a user prefers to load only sometimes.\r\n> \r\n> Yes, it is possible. Call `vim.pack.add()` with plugin spec only when you want to use the plugin. If plugin is absent it will be automatically installed. Without plugin manager it is two step: 1) manually put plugin in pack/*/opt; 2) call `:packadd` when you want to use it.\r\n>...\r\n> Putting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.\r\n\r\nMaybe this is where I am confused. Will vim.pack uninstall packages that are present in `opt/` but no longer in a user's start-up files? If not, then I think I see what you're saying. I was worried that plugins not currently in use would be uninstalled—and then need to be reinstalled later.\r\n\r\n",
            "created_at": "2025-05-14T12:41:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880072549",
            "id": 2880072549,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rqmtl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880072549/reactions"
            },
            "updated_at": "2025-05-14T12:41:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880072549",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Putting a plugin in 'opt/' and load when needed is the same as executing `vim.pack.add()` only when needed. With future user commands that will also be easier to do from command line.\r\n\r\nI am currently using mini.deps, which implements the behavior proposed here, and I have a couple of plugins that I load on demand by calling `add()` when I need to as suggested here.\r\n\r\nThis has two side effects that I don't think are desirable: if the plugin is not loaded when `vim.pack.update()` is called the plugin will not be updated and it will be removed when `vim.pack.clean()` is run.\r\n\r\nI think a way to separately indicate \"this is a plugin I want installed\" and \"this is a plugin I want loaded\" is useful.\r\n\r\nWhether this results in putting the files in start/opt or just a flag to call or skip packadd I have no opinion on.",
            "created_at": "2025-05-14T13:00:31Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880163546",
            "id": 2880163546,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rq87a",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880163546/reactions"
            },
            "updated_at": "2025-05-14T13:00:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880163546",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/15096481?v=4",
                "events_url": "https://api.github.com/users/micampe/events{/privacy}",
                "followers_url": "https://api.github.com/users/micampe/followers",
                "following_url": "https://api.github.com/users/micampe/following{/other_user}",
                "gists_url": "https://api.github.com/users/micampe/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/micampe",
                "id": 15096481,
                "login": "micampe",
                "node_id": "MDQ6VXNlcjE1MDk2NDgx",
                "organizations_url": "https://api.github.com/users/micampe/orgs",
                "received_events_url": "https://api.github.com/users/micampe/received_events",
                "repos_url": "https://api.github.com/users/micampe/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/micampe/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/micampe/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/micampe",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Maybe this is where I am confused. Will vim.pack uninstall packages that are present in `opt/` but no longer in a user's start-up files? If not, then I think I see what you're saying. I was worried that plugins not currently in use would be uninstalled—and then need to be reinstalled later.\r\n\r\nNo, `vim.pack` doesn't remove those plugins from disk. They are there just waiting to be loaded. They can even be updated when not loaded (just not with default `:lua vim.pack.update()` at the moment), but that is problematic currently because `vim.pack` doesn't know about which `version` to use. That would require some version of lockfile (which is planned).\r\n\r\nIn fact, there is currently no functionality of removing plugins from disk at all. I do want to have an \"interactive way\" to do that inside confirmation buffer, but not sure if the whole design is still acceptable. And the \"scripting way\" is also planned (see \"Planned future work\" in first comment).\r\n\r\n---\r\n\r\n> This has two side effects that I don't think are desirable: if the plugin is not loaded when `vim.pack.update()` is called the plugin will not be updated and it will be removed when `vim.pack.clean()` is run.\r\n\r\nThe plugin not being updated during `vim.pack.update()` is addressed couple of paragraphs above (i.e. \"it requires some sort of lockfile\"). The \"will be removed after `clean()`\" is intentional: \"clean\" means remove all plugins that are not used. And 'mini.deps' allows you to interactively adjust which plugins to not remove (by deleting lines), which can be done in `vim.pack` also.",
            "created_at": "2025-05-14T13:02:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880170352",
            "id": 2880170352,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rq-lw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880170352/reactions"
            },
            "updated_at": "2025-05-14T13:07:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880170352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The \"will be removed after clean()\" is intentional: \"clean\" means remove all plugins that are not used.\r\n\r\nBut \"are not used\" is now ambiguous. Some plugins \"are not used (at startup)\"—meaning plugins that are wanted but which users will only sometimes call on with a manual `vim.pack.add`.  But it also can mean \"are not used (at all)\"—meaning plugins that the user wants removed from disk.\r\n\r\nI agree with micampe that \"a way to separately indicate 'this is a plugin I want installed' and 'this is a plugin I want loaded\"' is useful.\" As he says, one way to do this is with `start/` and `opt/`, but you can also do it other ways.\r\n",
            "created_at": "2025-05-14T13:17:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880216947",
            "id": 2880216947,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rrJ9z",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880216947/reactions"
            },
            "updated_at": "2025-05-14T13:18:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880216947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62958?v=4",
                "events_url": "https://api.github.com/users/telemachus/events{/privacy}",
                "followers_url": "https://api.github.com/users/telemachus/followers",
                "following_url": "https://api.github.com/users/telemachus/following{/other_user}",
                "gists_url": "https://api.github.com/users/telemachus/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/telemachus",
                "id": 62958,
                "login": "telemachus",
                "node_id": "MDQ6VXNlcjYyOTU4",
                "organizations_url": "https://api.github.com/users/telemachus/orgs",
                "received_events_url": "https://api.github.com/users/telemachus/received_events",
                "repos_url": "https://api.github.com/users/telemachus/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/telemachus/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/telemachus/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/telemachus",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> But \"are not used\" is now ambiguous. Some plugins \"are not used (at startup)\"—meaning plugins that are wanted but which users will only sometimes call on with a manual `vim.pack.add`. But it also can mean \"are not used (at all)\"—meaning plugins that the user wants removed from disk.\r\n\r\nIf anything, this is a point towards not having automated \"cleaning\" in favor of manually selected one (which I'd suggest having in `vim.pack`).\r\n\r\n> I agree with micampe that \"a way to separately indicate 'this is a plugin I want installed' and 'this is a plugin I want loaded\"' is useful.\" As he says, one way to do this is with `start/` and `opt/`, but you can also do it other ways.\r\n\r\nHaving 'start/' and 'opt/' causes more troubles than brings good. Yes, having an extra `load` flag in `vim.pack.Spec` is possible. At the moment I personally lean towards implementing lockfile (to be able to properly update \"plugins that are not yet loaded\") plus only manual plugin removal (inside confirmation buffer or `vim.pack.remove()`). Mostly because this both solves actual problems without introducing new fields in spec (which is usually better for usability and maintainability).\r\n\r\n---\r\n\r\nYou (collective) were heard on this topic. Please, let's not continue this discussion here and wait for reviews and (hopefully) merge. After that, these separate subjects can be discussed in a more structured fashion inside separate issues. It is clearly stated as yet work in progress.",
            "created_at": "2025-05-14T14:00:47Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2880367306",
            "id": 2880367306,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6rrurK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880367306/reactions"
            },
            "updated_at": "2025-05-14T14:00:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2880367306",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I realized that original demo didn't showcase the \"in-process LSP\" part of the PR. So I decided to add 'textDocument/hover' support (as it is pretty straightforward) and here is the result:\r\n\r\nhttps://github.com/user-attachments/assets/230a056f-12b9-40e6-861e-76fa136fd1e1\r\n\r\nThis is how a clean install looks, but in combination with \"pretty LSP\" plugins it can be customized without any burden on `vim.pack` itself.",
            "created_at": "2025-05-15T13:10:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2883761573",
            "id": 2883761573,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6r4rWl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2883761573/reactions"
            },
            "updated_at": "2025-05-15T13:10:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2883761573",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There were visible changes in workflow:\r\n\r\n- The `version = nil` case is now the same as \"use default branch\" (usually `main` or `master`). The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2091371243).\r\n- Any plugin installation now requires an explicit user confirmation. The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094169684).\r\n- There is now `vim.pack.del()` to remove installed plugins from disk. The relevant discussion is [here](https://github.com/neovim/neovim/pull/34009#discussion_r2094172936).",
            "created_at": "2025-05-19T16:58:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/34009#issuecomment-2891698715",
            "id": 2891698715,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
            "node_id": "IC_kwDOAPphoM6sW9Ib",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2891698715/reactions"
            },
            "updated_at": "2025-05-19T16:59:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2891698715",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/34009/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/34009/commits",
    "created_at": "2025-05-13T17:07:47Z",
    "diff_url": "https://github.com/neovim/neovim/pull/34009.diff",
    "draft": false,
    "head": {
        "label": "echasnovski:vim-pack",
        "ref": "vim-pack",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/echasnovski/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/echasnovski/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/echasnovski/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/echasnovski/neovim/branches{/branch}",
            "clone_url": "https://github.com/echasnovski/neovim.git",
            "collaborators_url": "https://api.github.com/repos/echasnovski/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/echasnovski/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/echasnovski/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/echasnovski/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/echasnovski/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/echasnovski/neovim/contributors",
            "created_at": "2021-12-02T09:43:59Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/echasnovski/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/echasnovski/neovim/downloads",
            "events_url": "https://api.github.com/repos/echasnovski/neovim/events",
            "fork": true,
            "forks": 1,
            "forks_count": 1,
            "forks_url": "https://api.github.com/repos/echasnovski/neovim/forks",
            "full_name": "echasnovski/neovim",
            "git_commits_url": "https://api.github.com/repos/echasnovski/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/echasnovski/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/echasnovski/neovim/git/tags{/sha}",
            "git_url": "git://github.com/echasnovski/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/echasnovski/neovim/hooks",
            "html_url": "https://github.com/echasnovski/neovim",
            "id": 434162461,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/echasnovski/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/echasnovski/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/echasnovski/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/echasnovski/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/echasnovski/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/echasnovski/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/echasnovski/neovim/merges",
            "milestones_url": "https://api.github.com/repos/echasnovski/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGeDLHQ",
            "notifications_url": "https://api.github.com/repos/echasnovski/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/echasnovski/neovim/pulls{/number}",
            "pushed_at": "2025-05-19T16:54:51Z",
            "releases_url": "https://api.github.com/repos/echasnovski/neovim/releases{/id}",
            "size": 316042,
            "ssh_url": "git@github.com:echasnovski/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/echasnovski/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/echasnovski/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/echasnovski/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/echasnovski/neovim/subscription",
            "svn_url": "https://github.com/echasnovski/neovim",
            "tags_url": "https://api.github.com/repos/echasnovski/neovim/tags",
            "teams_url": "https://api.github.com/repos/echasnovski/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/echasnovski/neovim/git/trees{/sha}",
            "updated_at": "2025-05-19T12:49:22Z",
            "url": "https://api.github.com/repos/echasnovski/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "6646c0368e8d8e872b033c311107be80f231cf2e",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
            "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
            "followers_url": "https://api.github.com/users/echasnovski/followers",
            "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
            "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/echasnovski",
            "id": 24854248,
            "login": "echasnovski",
            "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
            "organizations_url": "https://api.github.com/users/echasnovski/orgs",
            "received_events_url": "https://api.github.com/users/echasnovski/received_events",
            "repos_url": "https://api.github.com/users/echasnovski/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/echasnovski",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/34009",
    "id": 2517199651,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34009",
    "labels": [],
    "locked": false,
    "merge_commit_sha": "e2a6c7fd6a0bad9526d80274feba3f97b2a20649",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6WCWsj",
    "number": 34009,
    "patch_url": "https://github.com/neovim/neovim/pull/34009.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
            "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
            "followers_url": "https://api.github.com/users/justinmk/followers",
            "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
            "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/justinmk",
            "id": 1359421,
            "login": "justinmk",
            "node_id": "MDQ6VXNlcjEzNTk0MjE=",
            "organizations_url": "https://api.github.com/users/justinmk/orgs",
            "received_events_url": "https://api.github.com/users/justinmk/received_events",
            "repos_url": "https://api.github.com/users/justinmk/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/justinmk",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/34009/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/6646c0368e8d8e872b033c311107be80f231cf2e",
    "title": "feat(pack): add built-in plugin manager `vim.pack`",
    "updated_at": "2025-05-19T17:00:00Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/34009",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
        "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
        "followers_url": "https://api.github.com/users/echasnovski/followers",
        "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
        "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/echasnovski",
        "id": 24854248,
        "login": "echasnovski",
        "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
        "organizations_url": "https://api.github.com/users/echasnovski/orgs",
        "received_events_url": "https://api.github.com/users/echasnovski/received_events",
        "repos_url": "https://api.github.com/users/echasnovski/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/echasnovski",
        "user_view_type": "public"
    }
}