{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31399/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31399/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/31399"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31399"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31399/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/a719c674a90c3d053d79cb1b20c9df657e2a4d98"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "FIRST_TIME_CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6102,
            "forks_count": 6102,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1963,
            "open_issues_count": 1963,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-05-27T01:16:46Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 324248,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 89828,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-05-27T01:20:04Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 89828,
            "watchers_count": 89828,
            "web_commit_signoff_required": false
        },
        "sha": "a96665cf4867c82f5bbcae5a1c01542c0d15859e",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "# Status\r\n\r\nThis PR serves as a nice feasibility study but has grown too large to consider merging. So it is temporarily parked while a suitable API is being discussed.\r\n\r\n----\r\n\r\n# Feature & Implementation Breakdown\r\n\r\nThe following is both a tracker and detailing of the features supported by this PR, what they look like, and a visual of each implementation (provider) in order to support as many terminals as possible, including on Windows. Monitor this top-level comment for the current API structure and visual examples of the PR in action.\r\n\r\n## Core API Structure\r\n\r\nThe API follows a simplistic, object-oriented design similar to `vim.system()`. You specify an image, optionally eagerly loading its data, and then display it within neovim. The information about where and how it is displayed is provided through a single table.\r\n\r\nEach image, once shown, returns a placement, which represents the specific instance of the image on screen. This is to support the separation of an image and its data from the details and management of displaying it.\r\n\r\nThe image API makes use of an internal `Promise<T>` class in order to support both synchronous and asynchronous operation, meaning that images can be loaded, shown, hidden, and updated asynchronously in order to be efficient, but also can manually be waited upon at any stage.\r\n\r\n- [x] A static image you can place within neovim\r\n    ```lua\r\n    -- Supports loading PNG images into memory\r\n    local img = assert(vim.ui.img.load(\"/path/to/img.png\"):wait())\r\n\r\n    -- Supports lazy-loading image, deferring to a provider\r\n    local img = vim.ui.img.new(\"/path/to/img.png\")\r\n\r\n    -- Supports specifying an image and explicitly providing the data\r\n    local img = vim.ui.img.new({ bytes = \"...\", filename = \"/path/to/img.png\" })\r\n\r\n    -- Once created, can be shown, returning an object representing the instance\r\n    local placement = img:show():wait() -- Places in top-left of editor with default size\r\n    local placement = img:show({ pos = { x = 4, y = 8, unit = 'cell' }):wait()\r\n    local placement = img:show({ relative = \"cursor\" }):wait()\r\n    ```\r\n- [x] Support deleting the image placed within neovim\r\n    ```lua\r\n    local img = vim.ui.img.new({ filename = \"/path/to/img.png\" })\r\n    local placement = assert(img:show():wait())\r\n\r\n    -- Supports hiding the specific instance of the image\r\n    placement:hide()\r\n    ```\r\n- [x] Dynamically resize/move an image\r\n    ```lua\r\n    local img = vim.ui.img.new({ filename = \"/path/to/img.png\" })\r\n    local placement = assert(img:show({ pos = { x = 1, y = 2, unit = \"cell\" } }):wait())\r\n\r\n    -- Supports updating a displayed image with a new position\r\n    placement:update({ pos = { x = 5, y = 6, unit = \"cell\" } }):wait()\r\n\r\n    -- Supports resizing a displayed image\r\n    placement:update({ size = { width = 10, height = 5, unit = \"cell\" } }):wait()\r\n    ```\r\n- [x] Asynchronous support for image operations\r\n    ```lua\r\n    img:show({ ... })\r\n        :on_ok(function(placement)\r\n            -- Use the placement once it has been confirmed as shown\r\n        end)\r\n        :on_fail(function(err)\r\n            -- Do something with the error that occurred\r\n        end)\r\n        :on_done(function(err, placement)\r\n            -- When either ok or fail happens\r\n        end)\r\n\r\n    -- The same applies for all APIs:\r\n    --\r\n    --    img.load() -> returns Promise<Image>\r\n    --    img:show() -> returns Promise<Placement>\r\n    --    placement:show() -> returns Promise<true>\r\n    --    placement:hide() -> returns Promise<true>\r\n    --    placement:update() -> returns Promise<true>\r\n    --\r\n    -- Each Promise<T> supports chaining callbacks for individual\r\n    -- conditions of success or failure as well as combining the two\r\n    -- together.\r\n    --\r\n    -- The on_* methods can be called multiple times and each\r\n    -- callback will be invoked when finished.\r\n    --\r\n    -- You can also still choose to wait in a synchronous fashion\r\n    -- using `:wait()` which supports supplying a specific timeout\r\n    -- in milliseconds.\r\n    ```\r\n\r\n## Image Manipulation & Inspection\r\n\r\nLeveraging *ImageMagick* for the functionality, this section describes features needed to manipulate and inspect images. This is particularly needed for sixel, which would normally require advanced image decoding to convert to an RGB format and then packaged in sixel's format. ImageMagick supports features like cropping and resizing, which we expose through the `convert` method.\r\n\r\nAdditionally, provides a retrieval API called `identify` (modeled after `magick identify`) to inspect images without needing advanced header parsing per image format in order to learn details like the true image format (not just reading the file extension) and pixel dimensions of the image.\r\n\r\n- [x] Manipulation an image\r\n    ```lua\r\n    -- Making use of ImageMagick, you can convert an image\r\n    -- to different formats, resize it, crop it, and more\r\n    --\r\n    -- And like all other APIs, this returns a promise\r\n    img:convert({ \r\n        format = 'jpeg', -- Supports a variety of formats, including sixel!\r\n        size = { width = 50, height = 30, unit = 'pixel' },\r\n    }):on_done(function(err, data)\r\n        -- By default, this returns the data of the image\r\n        -- instead of updating the instance or saving it\r\n        -- to disk\r\n        --\r\n        -- Use img:convert({ out = '/path/to/img.jpeg' })\r\n        -- to write to disk instead\r\n    end)\r\n    ```\r\n- [x] Retrieve information about an image\r\n    ```lua\r\n    -- Retrieving information also makes use of ImageMagick\r\n    -- to learn things like image dimensions and format\r\n    img:identify({ format = true, size = true }):on_done(function(err, info)\r\n        -- Info is a table containing the information requested by each\r\n        -- field marked true\r\n        --\r\n        -- In this case, info.format == \"PNG\" and\r\n        -- info.size == vim.ui.img.utils.Size { width = 50, height = 30, unit = 'pixel' }\r\n    end)\r\n    ```\r\n\r\n## Kitty Provider\r\n\r\nThe 1st protocol supported is [kitty graphics protocol](https://sw.kovidgoyal.net/kitty/graphics-protocol/). Aside from the obvious kitty, other graphics-accelerated terminals like Ghostty make use of this protocol to display images. This protocol only requires `magick` when attempting to load an image other than PNG, which will be converted to PNG and placed in `~/.cache/nvim/imgs/{sha256(filename)}.png`.\r\n\r\n- [x] Integration of kitty as a provider\r\n    ```lua\r\n    vim.o.imgprovider = 'sixel'\r\n    ```\r\n\r\n    https://github.com/user-attachments/assets/1f956e34-a84c-421a-a421-88040a059a03\r\n\r\n## Sixel Provider\r\n\r\nThe 2nd protocol supported is [sixel image protocol](https://en.wikipedia.org/wiki/Sixel). Windows Terminal, in particular, makes use of this protocol to display images. This protocol requires `magick` in order to convert images into the sixel format, as well as all operations like resizing and cropping.\r\n\r\n- [x] Integration of sixel as a provider\r\n    ```lua\r\n    vim.o.imgprovider = 'sixel'\r\n    ```\r\n\r\n    https://github.com/user-attachments/assets/7b592468-919c-4282-99d6-273f4e006578\r\n\r\n## iterm2 Provider\r\n\r\nThe 3rd protocol supported is [iterm2 image protocol](https://iterm2.com/documentation-images.html). WezTerm provides a GPU-accelerated implementation of this protocol. This protocol only requires `magick` in order to crop images. Resizing images does not require `magick`, and iterm2 supports multiple image formats.\r\n\r\n- [x] Integration of iterm2 as a provider\r\n    ```lua\r\n    vim.o.imgprovider = 'iterm2'\r\n    ```\r\n\r\n    https://github.com/user-attachments/assets/0ea6a248-72a8-441f-868a-4b68fc0b5b85\r\n## 3rd Party Providers\r\n\r\nTo enable GUIs and other image protocols to easily slide into neovim's API abstraction, a singular API is exposed through `vim.ui.img.providers.new`, which implementers will use to specify `show` and `hide` functions at a minimum. Each provider supports operations when `load`ing, `unload`ing, checking `supported` to see if the provider can operate in the current environment, and (if possible) specifying a more efficient `update` method.\r\n\r\nThe methods `supported`, `show`, `hide`, and `update` take a callback to support asynchronous operation, and must use it to communicate when the operation is finished. The methods `load` and `unload` are considered synchronous and should be fast to operate.\r\n\r\n- [x] Abstraction for 3rd parties to support images in neovim\r\n    ```lua\r\n    -- Providers implement a small API to support showing and hiding images\r\n    vim.ui.img.providers['neovide'] = vim.ui.img.providers.new({\r\n        ---(Optional) Called to initialize the provider.\r\n        ---@param ... any arguments for the specific provider upon loading\r\n        load = function(...)\r\n          -- Implement here\r\n        end,\r\n\r\n        ---(Optional) Called to cleanup the provider.\r\n        unload = function()\r\n          -- Implement here\r\n        end,\r\n\r\n        ---(Optional) Reports whether this provider is supported in the current environment.\r\n        ---@param on_supported? fun(supported:boolean) callback when finished checking\r\n        supported = function(on_supported)\r\n            -- Implement here\r\n        end,\r\n\r\n        ---Displays an image, returning (through callback) an id tied to the instance.\r\n        ---@param img vim.ui.Image image data container to display\r\n        ---@param opts vim.ui.img.Opts specification of how to display the image\r\n        ---@param on_shown? fun(err:string|nil, id:integer|nil) callback when finished showing\r\n        ---@return integer id unique identifier connected to the displayed image (not vim.ui.Image)\r\n        show = function(img, opts, on_shown)\r\n            -- Implement here\r\n        end,\r\n\r\n        ---Hides one or more displayed images.\r\n        ---@param ids integer[] list of displayed image ids to hide\r\n        ---@param on_hidden fun(err:string|nil, ids:integer[]|nil) callback when finished hiding\r\n        hide = function(ids, on_hidden)\r\n            -- Implement here\r\n        end,\r\n\r\n        ---(Optional) Updates an image, returning (through callback) a refreshed id tied to the instance.\r\n        ---If not specified, neovim will invoke `hide(id)` followed by `show(img, opts, on_updated)`.\r\n        ---@param id integer id of the displayed image to update\r\n        ---@param opts vim.ui.img.Opts specification of how to display the image\r\n        ---@param on_updated? fun(err:string|nil, id:integer|nil) callback when finished updating\r\n        ---@return integer id unique identifier connected to the displayed image (not vim.ui.Image)\r\n        update = function(id, opts, on_updated)\r\n            -- Implement here\r\n        end,\r\n    })\r\n    ```\r\n- Example of using the neovide 3rd party once specified above\r\n    ```lua\r\n    -- Load an image to display, nothing different here\r\n    local img = assert(vim.ui.img.load(\"/path/to/img.png\"):wait())\r\n\r\n    -- Set the global provider, which will be used for all image operations by default\r\n    vim.o.imgprovider = 'neovide'\r\n\r\n    -- Display the image, which will use the neovim provider\r\n    local placement = assert(img:show():wait())\r\n\r\n    -- Alternatively, you can manually create a placement and specify the provider\r\n    -- This will not be shown yet until specifically invoked\r\n    local placement = img:new_placement({ provider = 'neovide' })\r\n    placement:show({ size = { ... } }):wait()\r\n    ```\r\n\r\n## Maybe in scope for this PR\r\n\r\n- Injection of an image into a buffer within neovim (tracking its movement properly, possibly through the use of extmarks)\r\n    1. Support raw placement of an image on top of text in a buffer, but have the image scroll with the buffer\r\n    2. Support injecting an image into the buffer and reflowing text around it\r\n\r\n## Out of Scope for this PR\r\n\r\n- Video/gif support (there are reasons why this would be neat, but not a dealbreaker if we want to exclude this from neovim core)",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1864093226"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864093226"
                }
            },
            "author_association": "MEMBER",
            "body": "Imo it would also be nice to be able to do something like this:\r\n\r\n```lua\r\nlocal image = vim.img.load({\r\n    filename = \"/Users/senkwich/Pictures/org-roam-logo.png\",\r\n})\r\n\r\nimage:show({\r\n    pos = { row = 8, col = 8 }, \r\n    backend = \"iterm2\",\r\n})\r\n```\r\n\r\nwhat do you think?",
            "commit_id": "33ee5810ddf72d6cb9ec0497af01e3d7003c9963",
            "created_at": "2024-11-30T05:26:53Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1864093226",
            "id": 1864093226,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vG84q",
            "original_commit_id": "33ee5810ddf72d6cb9ec0497af01e3d7003c9963",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": 1,
            "pull_request_review_id": 2470715000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864093226/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-30T05:26:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864093226",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1864321758"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864321758"
                }
            },
            "author_association": "NONE",
            "body": "> Imo it would also be nice to be able to do something like this:\n> \n> ```lua\n> local image = vim.img.load({\n>     filename = \"/Users/senkwich/Pictures/org-roam-logo.png\",\n> })\n> \n> image:show({\n>     pos = { row = 8, col = 8 }, \n>     backend = \"iterm2\",\n> })\n> ```\n> \n> what do you think?\n\nSure, seems fine to me. It'd defer to `vim.img.show` underneath. Or we move the logic of show to it and call out to it within show. ",
            "commit_id": "33ee5810ddf72d6cb9ec0497af01e3d7003c9963",
            "created_at": "2024-11-30T16:43:48Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1864321758",
            "id": 1864321758,
            "in_reply_to_id": 1864093226,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vH0re",
            "original_commit_id": "33ee5810ddf72d6cb9ec0497af01e3d7003c9963",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": 1,
            "pull_request_review_id": 2470949395,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864321758/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-30T16:43:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864321758",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1864375317"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864375317"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  local handle = assert(io.open(M.tty_name(), \"w\"))\r\n```\r\n\r\nDoes the same since the return type on error is `{ nil, \"%s: No such file or directory\", 2 }`.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-11-30T17:43:50Z",
            "diff_hunk": "@@ -0,0 +1,133 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = \"\\x07\", -- aka ^G\n+  ESC = \"\\x1B\", -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has(\"win32\") == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return \"\\\\\\\\.\\\\CON\"\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen(\"tty 2>/dev/null\")\n+    if not handle then return nil end\n+    local result = handle:read(\"*a\")\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == \"\" then return nil end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), \"failed to read editor tty name\")\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = io.open(M.tty_name(), \"w\")\n+  if not handle then\n+    error(\"failed to open \" .. M.tty_name())\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1864375317",
            "id": 1864375317,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vIBwV",
            "original_commit_id": "33ee5810ddf72d6cb9ec0497af01e3d7003c9963",
            "original_line": 47,
            "original_position": 47,
            "original_start_line": 44,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2470994902,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864375317/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-30T17:44:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1864375317",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865785053"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865785053"
                }
            },
            "author_association": "MEMBER",
            "body": "`vim.ui.img` seems like the right place for this (else why do we have `vim.ui`? :)",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T12:44:17Z",
            "diff_hunk": "@@ -31,6 +31,7 @@ for k, v in pairs({\n   loader = true,\n   func = true,\n   F = true,\n+  img = true,",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865785053",
            "id": 1865785053,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNZ7d",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 34,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/lua/vim/_editor.lua",
            "position": null,
            "pull_request_review_id": 2472597418,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865785053/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T12:44:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865785053",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865788219"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865788219"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there a need for this to be defined on `vim`? usually code should just `require()` stuff, just-in-time if it wants \"lazy\" behavior.\r\n\r\n `vim._defer_require` is for things that we actually need on `vim.*`.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T12:46:42Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+local img = vim._defer_require('vim.img', {\n+  _backend = ..., --- @module 'vim.img._backend'\n+  _detect = ..., --- @module 'vim.img._detect'\n+  _image = ..., --- @module 'vim.img._image'\n+  _terminal = ..., --- @module 'vim.img._terminal'",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865788219",
            "id": 1865788219,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNas7",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 5,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/lua/vim/img.lua",
            "position": null,
            "pull_request_review_id": 2472602585,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865788219/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T12:46:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865788219",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865791901"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865791901"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's try to orient around \"UI\", not \"terminal\", where possible. This might only support terminals for now. But there is really no need to mention \"neovim\" etc here anyway.\r\n\r\n```suggestion\r\n--- Displays an image. Currently only supports the |TUI|.\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T12:49:23Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+local img = vim._defer_require('vim.img', {\n+  _backend = ..., --- @module 'vim.img._backend'\n+  _detect = ..., --- @module 'vim.img._detect'\n+  _image = ..., --- @module 'vim.img._image'\n+  _terminal = ..., --- @module 'vim.img._terminal'\n+})\n+\n+---Loads an image into memory, returning a wrapper around the image.\n+---\n+---Accepts `data` as base64-encoded bytes, or a `filename` that will be loaded.\n+---@param opts {data?:string, filename?:string}\n+---@return vim.img.Image\n+function img.load(opts)\n+  return img._image:new(opts)\n+end\n+\n+img.protocol = (function()\n+  ---@class vim.img.Protocol 'iterm2'|'kitty'|'sixel'\n+\n+  ---@type vim.img.Protocol|nil\n+  local protocol = nil\n+\n+  local loaded = false\n+\n+  ---Determines the preferred graphics protocol to use by default.\n+  ---\n+  ---@return vim.img.Protocol|nil\n+  return function()\n+    if not loaded then\n+      local graphics = img._detect().graphics\n+\n+      ---@diagnostic disable-next-line:cast-type-mismatch\n+      ---@cast graphics vim.img.Protocol|nil\n+      protocol = graphics\n+\n+      loaded = true\n+    end\n+\n+    return protocol\n+  end\n+end)()\n+\n+---@class vim.img.Opts: vim.img.Backend.RenderOpts\n+---@field backend? vim.img.Protocol|vim.img.Backend\n+\n+---Displays the image within the terminal used by neovim.",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865791901",
            "id": 1865791901,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNbmd",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 46,
            "original_position": 46,
            "original_start_line": null,
            "path": "runtime/lua/vim/img.lua",
            "position": null,
            "pull_request_review_id": 2472608213,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865791901/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T12:50:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865791901",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865796429"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865796429"
                }
            },
            "author_association": "MEMBER",
            "body": "would \"provider\" fit here? that aligns with our existing vocabulary. or \"strategy\", I guess.\r\n```suggestion\r\n---@class vim.img.Provider\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T12:52:55Z",
            "diff_hunk": "@@ -0,0 +1,12 @@\n+---@class vim.img.Backend",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865796429",
            "id": 1865796429,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNctN",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_backend.lua",
            "position": null,
            "pull_request_review_id": 2472615517,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865796429/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T12:52:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865796429",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865801668"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865801668"
                }
            },
            "author_association": "MEMBER",
            "body": "should this live in `runtime/lua/vim/termcap.lua` ? cc @gpanders ",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-02T12:56:29Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865801668",
            "id": 1865801668,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vNd_E",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": 1,
            "pull_request_review_id": 2472623185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865801668/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-02T12:56:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865801668",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865804083"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865804083"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there a `on_xx` name that makes sense here, instead of `cb` / `callback` (which are discouraged)\r\n\r\n```suggestion\r\nfunction M:load_from_file(filename, on_load)\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T12:58:09Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local data = self.data\n+  if not data then\n+    return\n+  end\n+\n+  local pos = 1\n+  local len = string.len(data)\n+  while pos <= len do\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = data:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, invoke our callback\n+    if string.len(chunk) > 0 then\n+      local has_more = end_pos + 1 <= len\n+      pcall(f, chunk, pos, has_more)\n+    end\n+\n+    pos = end_pos + 1\n+  end\n+end\n+\n+---Displays the image within the terminal used by neovim.\n+---@param opts? vim.img.Opts\n+function M:show(opts)\n+  vim.img.show(self, opts)\n+end\n+\n+---Loads data for an image from a file, replacing any existing data.\n+---If a callback provided, will load asynchronously; otherwise, is blocking.\n+---@param filename string\n+---@param cb fun(err:string|nil, image:vim.img.Image|nil)\n+---@overload fun(filename:string):vim.img.Image\n+function M:load_from_file(filename, cb)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865804083",
            "id": 1865804083,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNekz",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 78,
            "original_position": 78,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2472626732,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865804083/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T12:58:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865804083",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865806661"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865806661"
                }
            },
            "author_association": "MEMBER",
            "body": "why is this code not in `runtime/lua/vim/img.lua` ?",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-02T12:59:57Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865806661",
            "id": 1865806661,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vNfNF",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": 1,
            "pull_request_review_id": 2472630752,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865806661/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-02T12:59:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865806661",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1865811123"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865811123"
                }
            },
            "author_association": "MEMBER",
            "body": "RFC: should we use pixels consistently, and maybe provide a `pixels_to_cells` util function (and `cells_to_pixels`)?\r\n\r\nAfter all, even for `crop` I would guess it will be very common to want to decide the crop dimensions based on cells. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T13:03:07Z",
            "diff_hunk": "@@ -0,0 +1,12 @@\n+---@class vim.img.Backend\n+---@field render fun(image:vim.img.Image, opts?:vim.img.Backend.RenderOpts)\n+\n+---@class vim.img.Backend.RenderOpts\n+---@field crop? {x:integer, y:integer, width:integer, height:integer} units are pixels\n+---@field pos? {row:integer, col:integer} units are cells\n+---@field size? {width:integer, height:integer} units are cells",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1865811123",
            "id": 1865811123,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vNgSz",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 5,
            "path": "runtime/lua/vim/img/_backend.lua",
            "position": null,
            "pull_request_review_id": 2472637581,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865811123/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-02T13:03:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1865811123",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866064296"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866064296"
                }
            },
            "author_association": "MEMBER",
            "body": "`:help dev-patterns`\r\n\r\n```suggestion\r\nfunction M:for_each_chunk(opts, f)\r\n```\r\n\r\nIf you want to support optional `opts`, make it an \"overload\".",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:32:12Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866064296",
            "id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOeGo",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2473041675,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866064296/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:33:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866064296",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866073747"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866073747"
                }
            },
            "author_association": "MEMBER",
            "body": "normally new() would not be an instance/self method, see e.g. `Iter.new` https://github.com/neovim/neovim/blob/c7ec010ade0832e43c7a319ea69fae642771479d/runtime/lua/vim/iter.lua#L1018",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:37:55Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866073747",
            "id": 1866073747,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOgaT",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2473057382,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866073747/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:37:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866073747",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866076814"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866076814"
                }
            },
            "author_association": "MEMBER",
            "body": "nit: probably should be an error? or this should force it to load?\r\n\r\nor alternatively, this could check `size() == 0`, then we don't need `is_loaded()` (until proven otherwise)",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:39:06Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence\n+  terminal.write(data) -- Primary data\n+  terminal.write(terminal.code.ESC .. '\\\\') -- End sequence\n+end\n+\n+---Builds a header table of key value pairs.\n+---@param opts vim.img.Backend.RenderOpts\n+---@return table<string, string>\n+local function make_header(opts)\n+  ---@type table<string, string>\n+  local header = {}\n+\n+  header['a'] = 'T'\n+  header['f'] = '100'\n+\n+  local crop = opts.crop\n+  local size = opts.size\n+\n+  if crop then\n+    header['x'] = tostring(crop.x)\n+    header['y'] = tostring(crop.y)\n+    header['w'] = tostring(crop.width)\n+    header['h'] = tostring(crop.height)\n+  end\n+\n+  if size then\n+    header['c'] = tostring(size.width)\n+    header['r'] = tostring(size.height)\n+  end\n+\n+  return header\n+end\n+\n+---@param image vim.img.Image\n+---@param opts vim.img.Backend.RenderOpts\n+local function write_multipart_image(image, opts)\n+  image:for_each_chunk(function(chunk, pos, has_more)\n+    local data = {}\n+\n+    -- If at the beginning of our image, mark as a PNG to be\n+    -- transmitted and displayed immediately\n+    if pos == 1 then\n+      -- Add an entry in our data to write out to the terminal\n+      -- that is \"k=v,\" for the key-value entries from the header\n+      for key, value in pairs(make_header(opts)) do\n+        table.insert(data, key .. '=' .. value .. ',')\n+      end\n+    end\n+\n+    -- If we are still sending chunks and not at the end\n+    if has_more then\n+      table.insert(data, 'm=1')\n+    else\n+      table.insert(data, 'm=0')\n+    end\n+\n+    -- If we have a chunk available, write it\n+    if string.len(chunk) > 0 then\n+      table.insert(data, ';')\n+      table.insert(data, chunk)\n+    end\n+\n+    write_seq(table.concat(data))\n+  end)\n+end\n+\n+---@param image vim.img.Image\n+---@param opts? vim.img.Backend.RenderOpts\n+function M.render(image, opts)\n+  local terminal = require('vim.img._terminal')\n+\n+  if not image:is_loaded() then\n+    return",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866076814",
            "id": 1866076814,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOhKO",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 93,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2473061654,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866076814/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:41:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866076814",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866083848"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866083848"
                }
            },
            "author_association": "MEMBER",
            "body": "Can we return an iterator instead (`:help iterator`)? That is more idiomatic, and composes with `vim.iter`, `ipairs()`, etc.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:42:49Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866083848",
            "id": 1866083848,
            "in_reply_to_id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOi4I",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2473072508,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866083848/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:43:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866083848",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866086124"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866086124"
                }
            },
            "author_association": "NONE",
            "body": "> RFC: should we use pixels consistently, and maybe provide a pixels_to_cells util function (and cells_to_pixels)?\r\n\r\nI saw something like that in `image.nvim`, so it'd be a good idea. I wasn't happy that the units were different between crop and the others. For me personally, I don't know how I'd think of crop in cells, though, as it's in relation to the raw image file whereas `pos` and `size` are in relation to placement on top of neovim.\r\n\r\nSo two different coordinate spaces; however, happy to switch `crop` to be the same units",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:44:10Z",
            "diff_hunk": "@@ -0,0 +1,12 @@\n+---@class vim.img.Backend\n+---@field render fun(image:vim.img.Image, opts?:vim.img.Backend.RenderOpts)\n+\n+---@class vim.img.Backend.RenderOpts\n+---@field crop? {x:integer, y:integer, width:integer, height:integer} units are pixels\n+---@field pos? {row:integer, col:integer} units are cells\n+---@field size? {width:integer, height:integer} units are cells",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866086124",
            "id": 1866086124,
            "in_reply_to_id": 1865811123,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOjbs",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 5,
            "path": "runtime/lua/vim/img/_backend.lua",
            "position": null,
            "pull_request_review_id": 2473075922,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866086124/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-02T15:44:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866086124",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866099662"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866099662"
                }
            },
            "author_association": "NONE",
            "body": "Just a separation of responsibilities to different files. Can merge it into `img.lua` if that's a better practice.",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-02T15:51:46Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866099662",
            "id": 1866099662,
            "in_reply_to_id": 1865806661,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vOmvO",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": 1,
            "pull_request_review_id": 2473095971,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866099662/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-02T15:51:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866099662",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866104355"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866104355"
                }
            },
            "author_association": "NONE",
            "body": "Happy for it to live wherever you'd like. It felt odd to have this live under `img`, and I was unaware of `termcap.lua`. Let me know what you'd like to do.\r\n\r\nAlso happy to break out this logic to a separate PR if we want to review and merge this logic separately. It'd need to be handled prior to the image work, though. Or it can live in this PR.",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-02T15:54:29Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866104355",
            "id": 1866104355,
            "in_reply_to_id": 1865801668,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5vOn4j",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": 1,
            "pull_request_review_id": 2473102898,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866104355/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-02T15:54:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866104355",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866112258"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866112258"
                }
            },
            "author_association": "NONE",
            "body": "@justinmk sure, happy to put it there. Would you like me to refactor this PR to have it placed under the namespace?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:59:10Z",
            "diff_hunk": "@@ -31,6 +31,7 @@ for k, v in pairs({\n   loader = true,\n   func = true,\n   F = true,\n+  img = true,",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866112258",
            "id": 1866112258,
            "in_reply_to_id": 1865785053,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOp0C",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 34,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/lua/vim/_editor.lua",
            "position": null,
            "pull_request_review_id": 2473115154,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866112258/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:59:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866112258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866113370"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866113370"
                }
            },
            "author_association": "NONE",
            "body": "Cool, I wasn't sure the best practice here. I just looked at how `vim.lsp` was done and copied it. So I can switch to regular `require` instead.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T15:59:48Z",
            "diff_hunk": "@@ -0,0 +1,78 @@\n+local img = vim._defer_require('vim.img', {\n+  _backend = ..., --- @module 'vim.img._backend'\n+  _detect = ..., --- @module 'vim.img._detect'\n+  _image = ..., --- @module 'vim.img._image'\n+  _terminal = ..., --- @module 'vim.img._terminal'",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866113370",
            "id": 1866113370,
            "in_reply_to_id": 1865788219,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOqFa",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 5,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/lua/vim/img.lua",
            "position": null,
            "pull_request_review_id": 2473116850,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866113370/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T15:59:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866113370",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866116472"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866116472"
                }
            },
            "author_association": "NONE",
            "body": "@justinmk yeah, I can do that. Was unaware of neovim having an iterator, so it'll be nice to get a feel for how that works.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T16:01:46Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866116472",
            "id": 1866116472,
            "in_reply_to_id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOq14",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2473121745,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866116472/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-02T16:01:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866116472",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1866124325"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866124325"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe we can punt on this for now, because these fields are dict-like. But there is still some ambiguity with the current key names (`crop.width` is pixels, but `size.width` is cells).\r\n\r\nInstead, we could future-proof this by requiring an explicit `unit` field (note: below is pseudocode, I didn't check LuaLS syntax):\r\n\r\n```\r\n---@class img.Pos\r\n---@field unit:string\r\n---@field x:integer\r\n---@field y:integer\r\n\r\n---@class img.Region\r\n---@field pos1: img.Pos\r\n---@field pos2: img.Pos\r\n\r\n---@field crop? img.Region\r\n---@field pos?  img.Pos\r\n---@field size? {unit:string, width:integer, height:integer}\r\n```\r\n\r\nNote: the above is flirting with https://github.com/neovim/neovim/issues/25509 territory, and I don't want to encumber this PR with that scope. But it'll help to at least reference it and see if it makes sense to stub a similar skeleton here.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-02T16:06:19Z",
            "diff_hunk": "@@ -0,0 +1,12 @@\n+---@class vim.img.Backend\n+---@field render fun(image:vim.img.Image, opts?:vim.img.Backend.RenderOpts)\n+\n+---@class vim.img.Backend.RenderOpts\n+---@field crop? {x:integer, y:integer, width:integer, height:integer} units are pixels\n+---@field pos? {row:integer, col:integer} units are cells\n+---@field size? {width:integer, height:integer} units are cells",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1866124325",
            "id": 1866124325,
            "in_reply_to_id": 1865811123,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vOswl",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 5,
            "path": "runtime/lua/vim/img/_backend.lua",
            "position": null,
            "pull_request_review_id": 2473135788,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866124325/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-02T16:06:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1866124325",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1880102148"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102148"
                }
            },
            "author_association": "MEMBER",
            "body": "yes",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-11T12:21:44Z",
            "diff_hunk": "@@ -31,6 +31,7 @@ for k, v in pairs({\n   loader = true,\n   func = true,\n   F = true,\n+  img = true,",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1880102148",
            "id": 1880102148,
            "in_reply_to_id": 1865785053,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wEBUE",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 34,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/lua/vim/_editor.lua",
            "position": null,
            "pull_request_review_id": 2495513063,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102148/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-11T12:21:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102148",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1880102866"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102866"
                }
            },
            "author_association": "MEMBER",
            "body": "in favor merging them",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-11T12:22:17Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1880102866",
            "id": 1880102866,
            "in_reply_to_id": 1865806661,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5wEBfS",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": 1,
            "pull_request_review_id": 2495514190,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102866/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-11T12:22:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880102866",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1880104108"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880104108"
                }
            },
            "author_association": "MEMBER",
            "body": "iterators are a Lua concept, and can be as simple as returning a function (closure) which, when called, returns the next item.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-11T12:23:12Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1880104108",
            "id": 1880104108,
            "in_reply_to_id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wEBys",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2495516549,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880104108/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-11T12:23:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1880104108",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882587144"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882587144"
                }
            },
            "author_association": "MEMBER",
            "body": "`:h for-in`",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:22:42Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882587144",
            "id": 1882587144,
            "in_reply_to_id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNgAI",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2500334750,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882587144/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T17:22:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882587144",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882595338"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882595338"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think we need a special constant for `ESC`. We can just write `\\027_G` here. That's what we already do everywhere else and it's fine.\r\n\r\nIf we were going to make anything into a constant, it should be the entire APC prefix (`ESC _`) and likewise for ST (`ESC \\`), CSI, OSC, etc.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:28:11Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882595338",
            "id": 1882595338,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNiAK",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 21,
            "original_position": 21,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2500346730,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882595338/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T17:28:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882595338",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882598297"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882598297"
                }
            },
            "author_association": "MEMBER",
            "body": "`termcap` probably isn't the right name since that is specifically for terminal capabilities. But we can (and probably should) rename `termcap` to `term` or `tty` or something, and then we can move all of this there. The existing `vim.termcap.query` would become `vim.tty.query`, which still makes sense (we will need to keep the old `termcap` file around as a BWC stub for a bit).",
            "commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "created_at": "2024-12-12T17:30:17Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882598297",
            "id": 1882598297,
            "in_reply_to_id": 1865801668,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5wNiuZ",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": 1,
            "pull_request_review_id": 2500351029,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882598297/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-12-12T17:30:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882598297",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882599415"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882599415"
                }
            },
            "author_association": "MEMBER",
            "body": "The `\\x` prefix is a LuaJIT extension and won't work in PUC Lua. You need to use decimal notation, i.e. `\\007` for BEL and `\\027` for ESC.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:30:57Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882599415",
            "id": 1882599415,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNi_3",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 6,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500352731,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882599415/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T17:30:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882599415",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882604756"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882604756"
                }
            },
            "author_association": "MEMBER",
            "body": "~~I see we are caching the result of `get_tty_name`, but if different TUIs are attached (e.g. with `--remote`) this won't work, since they will use different TTYs.~~\r\n\r\nIt's a moot point, we shouldn't be using the TTY name directly anyway I don't think. See other comments.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:34:45Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882604756",
            "id": 1882604756,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNkTU",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 43,
            "original_position": 43,
            "original_start_line": 37,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500360470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882604756/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T17:57:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882604756",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882607052"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882607052"
                }
            },
            "author_association": "MEMBER",
            "body": "Three separate writes means we are opening the TTY device, writing the data, and closing it three different times. We should be batching these writes as much as possible.\r\n\r\n**EDIT:** We shouldn't be using this special `terminal.write` function anyway. `io.stdout:write` will suffice (we should still batch the write calls though).",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:36:30Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence\n+  terminal.write(data) -- Primary data\n+  terminal.write(terminal.code.ESC .. '\\\\') -- End sequence\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882607052",
            "id": 1882607052,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNk3M",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": 21,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2500363913,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882607052/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T18:27:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882607052",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882609596"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882609596"
                }
            },
            "author_association": "MEMBER",
            "body": "Please DO NOT hard code `$TERM` values here. We can query for kitty graphics support and that is what we will do.\r\n\r\nNeovim will not hard code `$TERM` values on my watch unless absolutely necessary :triumph: ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:38:04Z",
            "diff_hunk": "@@ -0,0 +1,88 @@\n+local terminal = require('vim.img._terminal')\n+\n+local TERM_QUERY = {\n+  -- Request device attributes (DA2).\n+  --\n+  -- It typically returns information about the terminal type and supported features.\n+  --\n+  -- Response format is typically something like '\\033[>...;...;...c'\n+  DEVICE_ATTRIBUTES = terminal.code.ESC .. '[>q',\n+\n+  -- Request device status report (DSR), checking if terminal is okay.\n+  --\n+  -- Response indicates its current state.\n+  DEVICE_STATUS_REPORT = terminal.code.ESC .. '[5n',\n+}\n+\n+local TERM_RESPONSE = {\n+  -- Indicates that the terminal is functioning normally (no error).\n+  --\n+  -- 0 means 'OK'; other values indicate different states or errors.\n+  OK = terminal.code.ESC .. '[0n',\n+}\n+\n+---Detects supported graphics of the terminal.\n+---@return {graphics:'iterm2'|'kitty'|'sixel'|nil, tmux:boolean, broken_sixel_cursor_placement:boolean}\n+return function()\n+  local results = { graphics = nil, tmux = false, broken_sixel_cursor_placement = false }\n+\n+  local term = os.getenv('TERM')\n+  if term == 'xterm-kitty' or term == 'xterm-ghostty' or term == 'ghostty' then\n+    results.graphics = 'kitty'\n+  end\n+",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882609596",
            "id": 1882609596,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNle8",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 33,
            "original_position": 33,
            "original_start_line": 29,
            "path": "runtime/lua/vim/img/_detect.lua",
            "position": null,
            "pull_request_review_id": 2500367192,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 2,
                "heart": 0,
                "hooray": 0,
                "laugh": 2,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882609596/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T17:38:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882609596",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882613095"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882613095"
                }
            },
            "author_association": "MEMBER",
            "body": "This seems unnecessary. Why do we need to get the TTY name and open a file descriptor to the device directly? If we are running in the TUI, then the TTY is already stdout.\r\n\r\nWe already make extensive use of terminal queries in Neovim by using `io.stdout:write` (see `_defaults.lua` and `termcap.lua`).",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:40:38Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)\n+end\n+\n+function M.cursor.save()\n+  M.write(TERM_CODE.ESC .. '[s')\n+end\n+\n+function M.cursor.restore()\n+  M.write(TERM_CODE.ESC .. '[u')\n+end\n+\n+---Terminal escape codes.\n+M.code = TERM_CODE\n+\n+---@param opts {query:string, handler:(fun(buffer:string):string|nil), timeout?:integer}\n+---@return string|nil result, string|nil err\n+function M.query(opts)\n+  local uv = vim.uv\n+\n+  opts = opts or {}\n+  local query = opts.query\n+  local handler = opts.handler\n+  local timeout = opts.timeout or 250\n+\n+  local tty_fd, err\n+  local function cleanup()\n+    if tty_fd then\n+      uv.fs_close(tty_fd)\n+      tty_fd = nil\n+    end\n+  end\n+\n+  -- Identify the path to the editor's tty\n+  -- NOTE: This only works on Unix-like systems!\n+  local ok, tty_path = pcall(M.tty_name)\n+  if not ok then\n+    return nil, tty_path\n+  end\n+\n+  -- Open the tty so we can write our query\n+  tty_fd, err = uv.fs_open(tty_path, 'r+', 438)\n+  if not tty_fd then\n+    return nil, err\n+  end\n+\n+  -- Write query to terminal.\n+  local success, write_err = uv.fs_write(tty_fd, query, -1)\n+  if not success then\n+    cleanup()\n+    return nil, write_err\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882613095",
            "id": 1882613095,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNmVn",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 114,
            "original_position": 114,
            "original_start_line": 98,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500372003,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882613095/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T17:40:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882613095",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882614507"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882614507"
                }
            },
            "author_association": "MEMBER",
            "body": "We don't need a blocking read for terminal queries. Use a timer and callbacks instead (again see `termcap.lua` for an example).",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:41:24Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)\n+end\n+\n+function M.cursor.save()\n+  M.write(TERM_CODE.ESC .. '[s')\n+end\n+\n+function M.cursor.restore()\n+  M.write(TERM_CODE.ESC .. '[u')\n+end\n+\n+---Terminal escape codes.\n+M.code = TERM_CODE\n+\n+---@param opts {query:string, handler:(fun(buffer:string):string|nil), timeout?:integer}\n+---@return string|nil result, string|nil err\n+function M.query(opts)\n+  local uv = vim.uv\n+\n+  opts = opts or {}\n+  local query = opts.query\n+  local handler = opts.handler\n+  local timeout = opts.timeout or 250\n+\n+  local tty_fd, err\n+  local function cleanup()\n+    if tty_fd then\n+      uv.fs_close(tty_fd)\n+      tty_fd = nil\n+    end\n+  end\n+\n+  -- Identify the path to the editor's tty\n+  -- NOTE: This only works on Unix-like systems!\n+  local ok, tty_path = pcall(M.tty_name)\n+  if not ok then\n+    return nil, tty_path\n+  end\n+\n+  -- Open the tty so we can write our query\n+  tty_fd, err = uv.fs_open(tty_path, 'r+', 438)\n+  if not tty_fd then\n+    return nil, err\n+  end\n+\n+  -- Write query to terminal.\n+  local success, write_err = uv.fs_write(tty_fd, query, -1)\n+  if not success then\n+    cleanup()\n+    return nil, write_err\n+  end\n+\n+  -- Read response with timeout.\n+  local buffer = ''\n+  local start_time = uv.now()\n+\n+  while uv.now() - start_time < timeout do\n+    local data, read_err = uv.fs_read(tty_fd, 512, -1)\n+    if data then\n+      buffer = buffer .. data\n+      local result = handler(buffer)\n+      if result then\n+        cleanup()\n+        return result\n+      end\n+    elseif read_err ~= 'EAGAIN' then\n+      cleanup()\n+      return nil, read_err\n+    end\n+    uv.sleep(1)\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882614507",
            "id": 1882614507,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNmrr",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 134,
            "original_position": 134,
            "original_start_line": 120,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500374278,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882614507/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-12-12T17:41:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882614507",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882616636"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882616636"
                }
            },
            "author_association": "MEMBER",
            "body": "We already have a function for querying the terminal using XTGETTCAP with `vim.termcap.query`. It doesn't need to happen in this PR (and probably shouldn't) but we should combine all of our \"query the terminal\" functions under one roof (I'll take the action to do that myself).",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:42:43Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)\n+end\n+\n+function M.cursor.save()\n+  M.write(TERM_CODE.ESC .. '[s')\n+end\n+\n+function M.cursor.restore()\n+  M.write(TERM_CODE.ESC .. '[u')\n+end\n+\n+---Terminal escape codes.\n+M.code = TERM_CODE\n+\n+---@param opts {query:string, handler:(fun(buffer:string):string|nil), timeout?:integer}\n+---@return string|nil result, string|nil err\n+function M.query(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882616636",
            "id": 1882616636,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNnM8",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 80,
            "original_position": 80,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500378166,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882616636/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T17:42:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882616636",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882622325"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882622325"
                }
            },
            "author_association": "MEMBER",
            "body": "Actually on further thought, it looks like this is only being used for querying device attributes and device status report. We should probably just update our `TermResponse` autocommand to include those sequences. Then this just becomes a single `io.stdout:write` along with a `TermResponse` autocommand. We don't need this function at all.\r\n\r\n**EDIT:** The `XTVERSION` query already works, since the response is a DCS:\r\n\r\n```lua\r\nvim.api.nvim_create_autocmd('TermResponse', {\r\n  callback = function(args)\r\n    local xtversion = args.data:match('^\\027P>|(.+)$')\r\n    if xtversion then\r\n      print(xtversion)\r\n    end\r\n  end,\r\n})\r\n\r\nio.stdout:write('\\027[>q')\r\n```\r\n\r\nI'm not sure we need to change anything then. This should be sufficient for this feature.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:46:33Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)\n+end\n+\n+function M.cursor.save()\n+  M.write(TERM_CODE.ESC .. '[s')\n+end\n+\n+function M.cursor.restore()\n+  M.write(TERM_CODE.ESC .. '[u')\n+end\n+\n+---Terminal escape codes.\n+M.code = TERM_CODE\n+\n+---@param opts {query:string, handler:(fun(buffer:string):string|nil), timeout?:integer}\n+---@return string|nil result, string|nil err\n+function M.query(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882622325",
            "id": 1882622325,
            "in_reply_to_id": 1882616636,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNol1",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 80,
            "original_position": 80,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500386690,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882622325/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T18:01:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882622325",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882631381"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882631381"
                }
            },
            "author_association": "MEMBER",
            "body": "According to https://invisible-island.net/xterm/ctlseqs/ctlseqs.html this is called `XTVERSION`. The Device Attributes is `CSI c`\r\n\r\n```suggestion\r\n  XTVERSION = terminal.code.ESC .. '[>q',\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T17:52:48Z",
            "diff_hunk": "@@ -0,0 +1,88 @@\n+local terminal = require('vim.img._terminal')\n+\n+local TERM_QUERY = {\n+  -- Request device attributes (DA2).\n+  --\n+  -- It typically returns information about the terminal type and supported features.\n+  --\n+  -- Response format is typically something like '\\033[>...;...;...c'\n+  DEVICE_ATTRIBUTES = terminal.code.ESC .. '[>q',",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882631381",
            "id": 1882631381,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNqzV",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 9,
            "original_position": 9,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_detect.lua",
            "position": null,
            "pull_request_review_id": 2500400132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882631381/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T17:52:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882631381",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882650624"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882650624"
                }
            },
            "author_association": "MEMBER",
            "body": "Why are we sleeping here?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T18:02:10Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882650624",
            "id": 1882650624,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wNvgA",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 64,
            "original_position": 64,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500431320,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882650624/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T18:02:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882650624",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r1882690288"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882690288"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure how widely supported the SC and RC sequences are. The Xterm [ctlseqs](https://invisible-island.net/xterm/ctlseqs/ctlseqs.html) page has a bunch of caveats and disclaimers (search for SCORC).\r\n\r\nIn contrast, `ESC 7` and `ESC 8` are VT100 sequences and will be supported by everything. \r\n\r\nDo we even need to save and restore the cursor position? The Kitty graphics protocol has a `C=1` parameter to preserve cursor position https://sw.kovidgoyal.net/kitty/graphics-protocol/#controlling-displayed-image-layout",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2024-12-12T18:30:39Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033\n+}\n+\n+---Retrieve the tty name used by the editor.\n+---\n+---E.g. /dev/ttys008\n+---@return string|nil\n+local function get_tty_name()\n+  if vim.fn.has('win32') == 1 then\n+    -- On windows, we use \\\\.\\CON for reading and writing\n+    return '\\\\\\\\.\\\\CON'\n+  else\n+    -- Linux/Mac: Use `tty` command, which reads the terminal name\n+    --            in the form of something like /dev/ttys008\n+    local handle = io.popen('tty 2>/dev/null')\n+    if not handle then\n+      return nil\n+    end\n+    local result = handle:read('*a')\n+    handle:close()\n+    result = vim.fn.trim(result)\n+    if result == '' then\n+      return nil\n+    end\n+    return result\n+  end\n+end\n+\n+---Returns the name of the tty associated with the terminal.\n+---@return string\n+function M.tty_name()\n+  if not M.__tty_name then\n+    M.__tty_name = assert(get_tty_name(), 'failed to read editor tty name')\n+  end\n+\n+  return M.__tty_name\n+end\n+\n+---Writes data to the editor tty.\n+---@param ... string|number\n+function M.write(...)\n+  local handle = assert(io.open(M.tty_name(), 'w'))\n+  handle:write(...)\n+  handle:close()\n+end\n+\n+---@class vim.img.terminal.cursor\n+M.cursor = {}\n+\n+---@param x integer\n+---@param y integer\n+---@param save? boolean\n+function M.cursor.move(x, y, save)\n+  if save then\n+    M.cursor.save()\n+  end\n+  M.write(TERM_CODE.ESC .. '[' .. y .. ';' .. x .. 'H')\n+  vim.uv.sleep(1)\n+end\n+\n+function M.cursor.save()\n+  M.write(TERM_CODE.ESC .. '[s')\n+end\n+\n+function M.cursor.restore()\n+  M.write(TERM_CODE.ESC .. '[u')",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r1882690288",
            "id": 1882690288,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5wN5Lw",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2500487455,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882690288/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-12-12T18:30:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1882690288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2067258667"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067258667"
                }
            },
            "author_association": "NONE",
            "body": "@justinmk took a stab at this for the time being. Created three new methods:\r\n\r\n1. `vim.ui.img.new_size()`\r\n2. `vim.ui.img.new_region()`\r\n3. `vim.ui.img.new_position()`\r\n\r\nEach of them supports converting between pixel and cell units.\r\n\r\nIt's untested for now, but wanted to sneak this in while I'm in the airport.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-29T19:50:38Z",
            "diff_hunk": "@@ -0,0 +1,12 @@\n+---@class vim.img.Backend\n+---@field render fun(image:vim.img.Image, opts?:vim.img.Backend.RenderOpts)\n+\n+---@class vim.img.Backend.RenderOpts\n+---@field crop? {x:integer, y:integer, width:integer, height:integer} units are pixels\n+---@field pos? {row:integer, col:integer} units are cells\n+---@field size? {width:integer, height:integer} units are cells",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2067258667",
            "id": 2067258667,
            "in_reply_to_id": 1865811123,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57N90r",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 5,
            "path": "runtime/lua/vim/img/_backend.lua",
            "position": null,
            "pull_request_review_id": 2804836338,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067258667/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-29T19:50:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067258667",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2067439368"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067439368"
                }
            },
            "author_association": "NONE",
            "body": "@gpanders  when I switch from my terminal.write to io.stdout:write, nothing happens. This was an issue I was facing earlier, and I'm not sure why. Any thoughts?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-29T21:13:59Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence\n+  terminal.write(data) -- Primary data\n+  terminal.write(terminal.code.ESC .. '\\\\') -- End sequence\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2067439368",
            "id": 2067439368,
            "in_reply_to_id": 1882607052,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57Op8I",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": 21,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2805101070,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067439368/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-29T21:14:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067439368",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2067441109"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067441109"
                }
            },
            "author_association": "NONE",
            "body": "@gpanders is it `\\027` or `\\033` for escape? I feel like I tried this awhile back switching to `\\027` and the image no longer showed with kitty, but I'll need to check again.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-29T21:15:28Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2067441109",
            "id": 2067441109,
            "in_reply_to_id": 1882599415,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57OqXV",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 6,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2805103706,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067441109/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-29T21:15:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2067441109",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2069099215"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069099215"
                }
            },
            "author_association": "NONE",
            "body": "Updated to be `Image:chunks()` which returns the result of `vim.iter()` on a function iterator. Assuming that should be good enough?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-30T16:51:45Z",
            "diff_hunk": "@@ -0,0 +1,144 @@\n+---@class vim.img.Image\n+---@field name string|nil name of the image if loaded from disk\n+---@field data string|nil base64 encoded data\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image instance.\n+---@param opts? {data?:string, filename?:string}\n+---@return vim.img.Image\n+function M:new(opts)\n+  opts = opts or {}\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.data = opts.data\n+  if not instance.data and opts.filename then\n+    instance:load_from_file(opts.filename)\n+  end\n+\n+  return instance\n+end\n+\n+---Returns true if the image is loaded into memory.\n+---@return boolean\n+function M:is_loaded()\n+  return self.data ~= nil\n+end\n+\n+---Returns the size of the base64 encoded image.\n+---@return integer\n+function M:size()\n+  return string.len(self.data or '')\n+end\n+\n+---Iterates over the chunks of the image, invoking `f` per chunk.\n+---@param f fun(chunk:string, pos:integer, has_more:boolean)\n+---@param opts? {size?:integer}\n+function M:for_each_chunk(f, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2069099215",
            "id": 2069099215,
            "in_reply_to_id": 1866064296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57U_LP",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 39,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/lua/vim/img/_image.lua",
            "position": null,
            "pull_request_review_id": 2807776189,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069099215/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-04-30T16:51:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069099215",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2069100473"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069100473"
                }
            },
            "author_association": "NONE",
            "body": "Okay, confirmed that `\\027` is the right one. Was some other issue when I was testing and trying to use `io.stdout:write()`.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-30T16:52:25Z",
            "diff_hunk": "@@ -0,0 +1,140 @@\n+---@class vim.img.terminal\n+---@field private __tty_name string\n+local M = {}\n+\n+local TERM_CODE = {\n+  BEL = '\\x07', -- aka ^G\n+  ESC = '\\x1B', -- aka ^[ aka \\033",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2069100473",
            "id": 2069100473,
            "in_reply_to_id": 1882599415,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57U_e5",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": 6,
            "path": "runtime/lua/vim/img/_terminal.lua",
            "position": null,
            "pull_request_review_id": 2807778959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069100473/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-30T16:52:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069100473",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2069117066"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069117066"
                }
            },
            "author_association": "MEMBER",
            "body": "Did you figure this out? `io.stdout:write` should work, we use that [elsewhere already](https://github.com/gpanders/neovim/blob/496c82ba41142b8756d03bee55bf64e8b439167f/runtime/lua/vim/termcap.lua#L74).",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-30T17:02:20Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence\n+  terminal.write(data) -- Primary data\n+  terminal.write(terminal.code.ESC .. '\\\\') -- End sequence\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2069117066",
            "id": 2069117066,
            "in_reply_to_id": 1882607052,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57VDiK",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": 21,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2807817142,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069117066/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-30T17:02:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069117066",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2069210656"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069210656"
                }
            },
            "author_association": "NONE",
            "body": "Not yet. If I change the implementation of `terminal.write` to use `io.stdout:write` instead of opening and writing to the tty, the image doesn't show up.\n\nAdding `io.stdout:flush` has no effect. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-04-30T18:09:11Z",
            "diff_hunk": "@@ -0,0 +1,108 @@\n+---@class vim.img.KittyBackend: vim.img.Backend\n+local M = {}\n+\n+---For kitty, we need to write an image in chunks\n+---\n+---Graphics codes are in this form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---To stream data for a PNG, we specify the format `f=100`.\n+---\n+---To simultaneously transmit and display an image, we use `a=T`.\n+---\n+---Chunking data (such as from over a network) requires the\n+---specification of `m=0|1`, where all chunks must have a\n+---value of `1` except the very last chunk.\n+---@param data string\n+local function write_seq(data)\n+  local terminal = require('vim.img._terminal')\n+\n+  terminal.write(terminal.code.ESC .. '_G') -- Begin sequence\n+  terminal.write(data) -- Primary data\n+  terminal.write(terminal.code.ESC .. '\\\\') -- End sequence\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2069210656",
            "id": 2069210656,
            "in_reply_to_id": 1882607052,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM57VaYg",
            "original_commit_id": "ce818a9a914b3c8ddd0cf747238ae5a4d0a18671",
            "original_line": 24,
            "original_position": 24,
            "original_start_line": 21,
            "path": "runtime/lua/vim/img/_backend/kitty.lua",
            "position": null,
            "pull_request_review_id": 2808007095,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069210656/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-04-30T18:10:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2069210656",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2083159782"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083159782"
                }
            },
            "author_association": "NONE",
            "body": "These values are meaningless. On Windows Terminal and the Windows console the cell size is unrelated to the font - it always emulates a VT340 cell size of 10x20. Other terminals running on Windows will typically have a variable cell size, but the values reported here would not reflect the font that the terminal is actually using. The only way to determine the real cell size is with an escape sequence.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-10T13:35:39Z",
            "diff_hunk": "@@ -0,0 +1,275 @@\n+---@class vim.ui.img.screen.Size\n+---@field width integer in pixels\n+---@field height integer in pixels\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.screen.Size|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.screen.Size\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__windows_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for Windows systems with pixel accuracy.\n+---@return vim.ui.img.screen.Size|nil\n+function M.__windows_size()\n+  -- For neovim spawned from within Windows Terminal, this should be set to\n+  -- some GUID; so, leverage CSI escape codes to query, which are supported\n+  -- by modern Windows Terminal instances\n+  if vim.env.WT_SESSION then\n+    return M.__csi_size()\n+  end\n+\n+  local ffi = require('ffi')\n+\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef unsigned long DWORD;\n+      typedef unsigned short WORD;\n+      typedef int BOOL;\n+      typedef void* HANDLE;\n+      typedef short SHORT;\n+\n+      typedef struct _COORD {\n+        SHORT X;\n+        SHORT Y;\n+      } COORD;\n+\n+      typedef struct _SMALL_RECT {\n+        SHORT Left;\n+        SHORT Top;\n+        SHORT Right;\n+        SHORT Bottom;\n+      } SMALL_RECT;\n+\n+      typedef struct _CONSOLE_SCREEN_BUFFER_INFO {\n+        COORD dwSize;\n+        COORD dwCursorPosition;\n+        WORD wAttributes;\n+        SMALL_RECT srWindow;\n+        COORD dwMaximumWindowSize;\n+      } CONSOLE_SCREEN_BUFFER_INFO;\n+\n+      typedef struct _CONSOLE_FONT_INFO {\n+        DWORD nFont;\n+        COORD dwFontSize;\n+      } CONSOLE_FONT_INFO;\n+\n+      HANDLE GetStdHandle(DWORD nStdHandle);\n+      BOOL GetConsoleScreenBufferInfo(\n+        HANDLE hConsoleOutput,\n+        CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo\n+      );\n+      BOOL GetCurrentConsoleFont(\n+        HANDLE hConsoleOutput,\n+        BOOL bMaximumWindow,\n+        CONSOLE_FONT_INFO* lpConsoleFontInfo\n+      );\n+    ]])\n+    M.__def = true\n+  end\n+\n+  ---@type vim.ui.img.screen.Size|nil\n+  local size\n+\n+  ---Retrieve the screen buffer info and font size to determine the cell width and height.\n+  ---NOTE: This does not work on Windows Terminal! We will fall back to CSI escape codes.\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    -- Using -11 should retrieve STD_OUTPUT_HANDLE, which initially is the\n+    -- active console screen buffer (CONOUT$)\n+    ---@type ffi.cdata*\n+    local hStdOut = ffi.C.GetStdHandle(-11)\n+\n+    -- If our handle is INVALID_HANDLE_VALUE (-1)\n+    if hStdOut == ffi.cast('HANDLE', -1) then\n+      error('failed to get STD_OUTPUT_HANDLE')\n+    end\n+\n+    ---@type { srWindow: { Left:integer, Top:integer, Right:integer, Bottom:integer } }\n+    local csbi = ffi.new('CONSOLE_SCREEN_BUFFER_INFO')\n+    if ffi.C.GetConsoleScreenBufferInfo(hStdOut, csbi) == 0 then\n+      error('failed to retrieve screen buffer info')\n+    end\n+\n+    ---@type { nFont:integer, dwFontSize: { X:integer, Y:integer } }\n+    local fontInfo = ffi.new('CONSOLE_FONT_INFO')\n+    if ffi.C.GetCurrentConsoleFont(hStdOut, false, fontInfo) == 0 then\n+      error('failed to retrieve current console font')\n+    end\n+\n+    -- Use the visible window (srWindow) to figure out the rows and columns shown\n+    local cols = csbi.srWindow.Right - csbi.srWindow.Left + 1\n+    local rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1\n+\n+    -- Use our font size as an approximation of the cell size\n+    local cell_width = fontInfo.dwFontSize.X\n+    local cell_height = fontInfo.dwFontSize.Y",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2083159782",
            "id": 2083159782,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58Kn7m",
            "original_commit_id": "385e2c7e82eb71691c608ce4b1c32c2827ac5eaa",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": 139,
            "path": "runtime/lua/vim/ui/img/screen.lua",
            "position": null,
            "pull_request_review_id": 2830807142,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083159782/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-10T13:35:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083159782",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2083222284"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083222284"
                }
            },
            "author_association": "NONE",
            "body": "Got it, thanks for the clarification on this one. I was hoping @gpanders might see the conversation since he was the one providing insight on neovim's `TermResponse` and general query API. From what I can see, neovim consumes any CSI responses from the terminal, which is why I haven't implemented `CSI 14 t` or `CSI 16 t`.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-10T15:34:01Z",
            "diff_hunk": "@@ -0,0 +1,275 @@\n+---@class vim.ui.img.screen.Size\n+---@field width integer in pixels\n+---@field height integer in pixels\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.screen.Size|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.screen.Size\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__windows_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for Windows systems with pixel accuracy.\n+---@return vim.ui.img.screen.Size|nil\n+function M.__windows_size()\n+  -- For neovim spawned from within Windows Terminal, this should be set to\n+  -- some GUID; so, leverage CSI escape codes to query, which are supported\n+  -- by modern Windows Terminal instances\n+  if vim.env.WT_SESSION then\n+    return M.__csi_size()\n+  end\n+\n+  local ffi = require('ffi')\n+\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef unsigned long DWORD;\n+      typedef unsigned short WORD;\n+      typedef int BOOL;\n+      typedef void* HANDLE;\n+      typedef short SHORT;\n+\n+      typedef struct _COORD {\n+        SHORT X;\n+        SHORT Y;\n+      } COORD;\n+\n+      typedef struct _SMALL_RECT {\n+        SHORT Left;\n+        SHORT Top;\n+        SHORT Right;\n+        SHORT Bottom;\n+      } SMALL_RECT;\n+\n+      typedef struct _CONSOLE_SCREEN_BUFFER_INFO {\n+        COORD dwSize;\n+        COORD dwCursorPosition;\n+        WORD wAttributes;\n+        SMALL_RECT srWindow;\n+        COORD dwMaximumWindowSize;\n+      } CONSOLE_SCREEN_BUFFER_INFO;\n+\n+      typedef struct _CONSOLE_FONT_INFO {\n+        DWORD nFont;\n+        COORD dwFontSize;\n+      } CONSOLE_FONT_INFO;\n+\n+      HANDLE GetStdHandle(DWORD nStdHandle);\n+      BOOL GetConsoleScreenBufferInfo(\n+        HANDLE hConsoleOutput,\n+        CONSOLE_SCREEN_BUFFER_INFO* lpConsoleScreenBufferInfo\n+      );\n+      BOOL GetCurrentConsoleFont(\n+        HANDLE hConsoleOutput,\n+        BOOL bMaximumWindow,\n+        CONSOLE_FONT_INFO* lpConsoleFontInfo\n+      );\n+    ]])\n+    M.__def = true\n+  end\n+\n+  ---@type vim.ui.img.screen.Size|nil\n+  local size\n+\n+  ---Retrieve the screen buffer info and font size to determine the cell width and height.\n+  ---NOTE: This does not work on Windows Terminal! We will fall back to CSI escape codes.\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    -- Using -11 should retrieve STD_OUTPUT_HANDLE, which initially is the\n+    -- active console screen buffer (CONOUT$)\n+    ---@type ffi.cdata*\n+    local hStdOut = ffi.C.GetStdHandle(-11)\n+\n+    -- If our handle is INVALID_HANDLE_VALUE (-1)\n+    if hStdOut == ffi.cast('HANDLE', -1) then\n+      error('failed to get STD_OUTPUT_HANDLE')\n+    end\n+\n+    ---@type { srWindow: { Left:integer, Top:integer, Right:integer, Bottom:integer } }\n+    local csbi = ffi.new('CONSOLE_SCREEN_BUFFER_INFO')\n+    if ffi.C.GetConsoleScreenBufferInfo(hStdOut, csbi) == 0 then\n+      error('failed to retrieve screen buffer info')\n+    end\n+\n+    ---@type { nFont:integer, dwFontSize: { X:integer, Y:integer } }\n+    local fontInfo = ffi.new('CONSOLE_FONT_INFO')\n+    if ffi.C.GetCurrentConsoleFont(hStdOut, false, fontInfo) == 0 then\n+      error('failed to retrieve current console font')\n+    end\n+\n+    -- Use the visible window (srWindow) to figure out the rows and columns shown\n+    local cols = csbi.srWindow.Right - csbi.srWindow.Left + 1\n+    local rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1\n+\n+    -- Use our font size as an approximation of the cell size\n+    local cell_width = fontInfo.dwFontSize.X\n+    local cell_height = fontInfo.dwFontSize.Y",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2083222284",
            "id": 2083222284,
            "in_reply_to_id": 2083159782,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58K3MM",
            "original_commit_id": "385e2c7e82eb71691c608ce4b1c32c2827ac5eaa",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": 139,
            "path": "runtime/lua/vim/ui/img/screen.lua",
            "position": null,
            "pull_request_review_id": 2830907774,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083222284/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-10T15:34:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2083222284",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2087295339"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087295339"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I'm not sure about terminal emulators, but in order to round to perfect cell positions without gaps when displaying in Neovide, the formula for calculating the width needs to be the following. Where \r\n`cells_to_pixels` rounds instead of flooring\r\n\r\n```lua\r\nx1, y1 = screen.cells_to_pixels(self.x, self.y)\r\nx2, y2 = screen.cells_to_pixels(self.x + self.width, self.y + self.height)\r\nwidth = x2 - x1\r\nheight = y2 - y1\r\n```\r\n\r\nThis also means that the image can be one pixel smaller or larger depending on where it's displayed on the screen.\r\n\r\nNeovide can't easily be changed to do something else, since the coordinates has to match with how the GPU draws anti-aliased lines.\r\n\r\nThe other option is to use fractional coordinates all the way and draw the image at fractional coordinates with a fractional width. But that won't align nicely with our box-drawing characters.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-13T17:14:29Z",
            "diff_hunk": "@@ -0,0 +1,95 @@\n+---@class vim.ui.img.utils.Region\n+---@field x integer\n+---@field y integer\n+---@field width integer\n+---@field height integer\n+---@field unit vim.ui.img.utils.Unit\n+local M = {}\n+M.__index = M\n+\n+---Creates a new instance of a region corresponding to an image.\n+---@param x integer\n+---@param y integer\n+---@param width integer\n+---@param height integer\n+---@param unit vim.ui.img.utils.Unit\n+---@return vim.ui.img.utils.Region\n+---@overload fun(opts:{x:integer, y:integer, width:integer, height:integer, unit:vim.ui.img.utils.Unit}):vim.ui.img.utils.Region\n+function M.new(x, y, width, height, unit)\n+  local instance = {}\n+\n+  -- For overloaded function, options table provided\n+  if type(x) == 'table' and y == nil and width == nil and height == nil and unit == nil then\n+    instance = x\n+  else\n+    instance.x = x\n+    instance.y = y\n+    instance.width = width\n+    instance.height = height\n+    instance.unit = unit\n+  end\n+\n+  vim.validate('region.x', instance.x, 'number')\n+  vim.validate('region.y', instance.y, 'number')\n+  vim.validate('region.width', instance.width, 'number')\n+  vim.validate('region.height', instance.height, 'number')\n+  vim.validate('region.unit', instance.unit, 'string')\n+\n+  setmetatable(instance, M)\n+  return instance\n+end\n+\n+---Creates a new region from two positions.\n+---@param pos1 vim.ui.img.utils.Position\n+---@param pos2 vim.ui.img.utils.Position\n+---@return vim.ui.img.utils.Region\n+function M.from_positions(pos1, pos2)\n+  assert(pos1.unit == pos2.unit, 'positions must have same unit')\n+  local x, y = math.min(pos1.x, pos2.x), math.min(pos1.y, pos2.y)\n+  local w, h = math.max(pos1.x, pos2.x) - x, math.max(pos1.y, pos2.y) - y\n+  return M.new(x, y, w, h, pos1.unit)\n+end\n+\n+---Convert unit of region to cells, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_cells()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'pixel' then\n+    local cell_x, cell_y = screen.pixels_to_cells(self.x, self.y)\n+    local cell_width, cell_height = screen.pixels_to_cells(self.width, self.height)\n+    return M.new(cell_x, cell_y, cell_width, cell_height, 'cell')\n+  end\n+\n+  return self\n+end\n+\n+---Convert unit of region to pixels, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_pixels()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'cell' then\n+    local px_x, px_y = screen.cells_to_pixels(self.x, self.y)\n+    local px_width, px_height = screen.cells_to_pixels(self.width, self.height)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2087295339",
            "id": 2087295339,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58aZlr",
            "original_commit_id": "78d6ed5ec426ce3691b92e4e4d0c672d71e56c27",
            "original_line": 89,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/region.lua",
            "position": null,
            "pull_request_review_id": 2837558098,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087295339/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:14:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087295339",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2087351683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087351683"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have no proof, but a quick experimentation showed that \r\nAlacritty, Wezterm, Konsole, Foot and Kitty all use integer grid sizes, and render FiraCode 10.5 with a slightly wider spacing than Neovide, which in turn renders it with the same spacing as editors like Kate and LibreOffice.\r\n\r\nSo those terminals should all be unaffected by the change. But I wonder if there are any terminals that renders fractional widths in a different way than Neovide. In that case the calculation code might have to be moved to the provider.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-13T17:46:33Z",
            "diff_hunk": "@@ -0,0 +1,95 @@\n+---@class vim.ui.img.utils.Region\n+---@field x integer\n+---@field y integer\n+---@field width integer\n+---@field height integer\n+---@field unit vim.ui.img.utils.Unit\n+local M = {}\n+M.__index = M\n+\n+---Creates a new instance of a region corresponding to an image.\n+---@param x integer\n+---@param y integer\n+---@param width integer\n+---@param height integer\n+---@param unit vim.ui.img.utils.Unit\n+---@return vim.ui.img.utils.Region\n+---@overload fun(opts:{x:integer, y:integer, width:integer, height:integer, unit:vim.ui.img.utils.Unit}):vim.ui.img.utils.Region\n+function M.new(x, y, width, height, unit)\n+  local instance = {}\n+\n+  -- For overloaded function, options table provided\n+  if type(x) == 'table' and y == nil and width == nil and height == nil and unit == nil then\n+    instance = x\n+  else\n+    instance.x = x\n+    instance.y = y\n+    instance.width = width\n+    instance.height = height\n+    instance.unit = unit\n+  end\n+\n+  vim.validate('region.x', instance.x, 'number')\n+  vim.validate('region.y', instance.y, 'number')\n+  vim.validate('region.width', instance.width, 'number')\n+  vim.validate('region.height', instance.height, 'number')\n+  vim.validate('region.unit', instance.unit, 'string')\n+\n+  setmetatable(instance, M)\n+  return instance\n+end\n+\n+---Creates a new region from two positions.\n+---@param pos1 vim.ui.img.utils.Position\n+---@param pos2 vim.ui.img.utils.Position\n+---@return vim.ui.img.utils.Region\n+function M.from_positions(pos1, pos2)\n+  assert(pos1.unit == pos2.unit, 'positions must have same unit')\n+  local x, y = math.min(pos1.x, pos2.x), math.min(pos1.y, pos2.y)\n+  local w, h = math.max(pos1.x, pos2.x) - x, math.max(pos1.y, pos2.y) - y\n+  return M.new(x, y, w, h, pos1.unit)\n+end\n+\n+---Convert unit of region to cells, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_cells()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'pixel' then\n+    local cell_x, cell_y = screen.pixels_to_cells(self.x, self.y)\n+    local cell_width, cell_height = screen.pixels_to_cells(self.width, self.height)\n+    return M.new(cell_x, cell_y, cell_width, cell_height, 'cell')\n+  end\n+\n+  return self\n+end\n+\n+---Convert unit of region to pixels, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_pixels()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'cell' then\n+    local px_x, px_y = screen.cells_to_pixels(self.x, self.y)\n+    local px_width, px_height = screen.cells_to_pixels(self.width, self.height)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2087351683",
            "id": 2087351683,
            "in_reply_to_id": 2087295339,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58anWD",
            "original_commit_id": "78d6ed5ec426ce3691b92e4e4d0c672d71e56c27",
            "original_line": 89,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/region.lua",
            "position": null,
            "pull_request_review_id": 2837649871,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087351683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T17:52:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087351683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2087706133"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087706133"
                }
            },
            "author_association": "NONE",
            "body": "@fredizzimo acknowledging I've seen your messages. Heading back on a flight stateside, so I'll be out for a bit from a mix of jetlag and travel. Rounding vs flooring is fine with me for the helper tools.\r\n\r\n@justinmk had made the comment that it was confusing when something needed pixels vs cells, and the table you showed earlier also exemplified that different protocols want them in different units. To me, this means that the neovim interface should provide an abstraction where the user can provide units in either form (when it makes sense) and does the calculations. If that means that each provider needs to implement their own calculations, I think it's an okay tradeoff. Neovim can provide a stock implementation that its built-in providers use, unless the logic ends up being different for each one. Any concerns there?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-13T22:12:45Z",
            "diff_hunk": "@@ -0,0 +1,95 @@\n+---@class vim.ui.img.utils.Region\n+---@field x integer\n+---@field y integer\n+---@field width integer\n+---@field height integer\n+---@field unit vim.ui.img.utils.Unit\n+local M = {}\n+M.__index = M\n+\n+---Creates a new instance of a region corresponding to an image.\n+---@param x integer\n+---@param y integer\n+---@param width integer\n+---@param height integer\n+---@param unit vim.ui.img.utils.Unit\n+---@return vim.ui.img.utils.Region\n+---@overload fun(opts:{x:integer, y:integer, width:integer, height:integer, unit:vim.ui.img.utils.Unit}):vim.ui.img.utils.Region\n+function M.new(x, y, width, height, unit)\n+  local instance = {}\n+\n+  -- For overloaded function, options table provided\n+  if type(x) == 'table' and y == nil and width == nil and height == nil and unit == nil then\n+    instance = x\n+  else\n+    instance.x = x\n+    instance.y = y\n+    instance.width = width\n+    instance.height = height\n+    instance.unit = unit\n+  end\n+\n+  vim.validate('region.x', instance.x, 'number')\n+  vim.validate('region.y', instance.y, 'number')\n+  vim.validate('region.width', instance.width, 'number')\n+  vim.validate('region.height', instance.height, 'number')\n+  vim.validate('region.unit', instance.unit, 'string')\n+\n+  setmetatable(instance, M)\n+  return instance\n+end\n+\n+---Creates a new region from two positions.\n+---@param pos1 vim.ui.img.utils.Position\n+---@param pos2 vim.ui.img.utils.Position\n+---@return vim.ui.img.utils.Region\n+function M.from_positions(pos1, pos2)\n+  assert(pos1.unit == pos2.unit, 'positions must have same unit')\n+  local x, y = math.min(pos1.x, pos2.x), math.min(pos1.y, pos2.y)\n+  local w, h = math.max(pos1.x, pos2.x) - x, math.max(pos1.y, pos2.y) - y\n+  return M.new(x, y, w, h, pos1.unit)\n+end\n+\n+---Convert unit of region to cells, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_cells()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'pixel' then\n+    local cell_x, cell_y = screen.pixels_to_cells(self.x, self.y)\n+    local cell_width, cell_height = screen.pixels_to_cells(self.width, self.height)\n+    return M.new(cell_x, cell_y, cell_width, cell_height, 'cell')\n+  end\n+\n+  return self\n+end\n+\n+---Convert unit of region to pixels, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_pixels()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'cell' then\n+    local px_x, px_y = screen.cells_to_pixels(self.x, self.y)\n+    local px_width, px_height = screen.cells_to_pixels(self.width, self.height)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2087706133",
            "id": 2087706133,
            "in_reply_to_id": 2087295339,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58b94V",
            "original_commit_id": "78d6ed5ec426ce3691b92e4e4d0c672d71e56c27",
            "original_line": 89,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/region.lua",
            "position": null,
            "pull_request_review_id": 2838246923,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087706133/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T22:12:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087706133",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2087771291"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087771291"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, I was thinking that Neovim at the core would only support cells units, since none of the terminals can perfectly support pixel units. They all need actual image manipulating, like resizing and adding borders. \r\n\r\nBut Neovim can still provide an API to query the pixel size, and even do calculations based on it. An advanced plugin that takes use of this would first manipulate the image itself before calling the API.\r\n\r\nIt should also be noted, that for example snacks.nvim only uses grid coordinates, so it's not super limiting. The limit comes when you want to build advanced UIs using multiple images for example, but even then, it might not be a huge problem if you restrict yourself to the grid.\r\n\r\nNote that the user of the API still needs some pixel information, to be able to determine for example how many rows that needs to be reserved if displaying the image taking exactly x columns, for example. But when displaying, they can just set the columns to x, and the low level protocol (Kitty, iterm2, Neovide) will make sure that the correct number of pixels are used for displaying, and the last row will likely not be fully covered by the image.\r\n\r\nFor example, if the cell size is 9x13 and the image is 100x200, and we want to display it over 10 columns, then our API tells that 14 rows are needed, and the image will be displayed as 90x180, leaving two pixels unused in the last row. An advanced plugin might add a 1 pixel border at the top and bottom of the image itself to make it 90x182 and display it centred.\r\n\r\nEdit: I wish I knew about the Kitty protocol limit before going this far. I thought that it supported exact pixel positions and sizes, and that we could get more complete support by limiting ourselves to that.\r\n",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-13T23:35:06Z",
            "diff_hunk": "@@ -0,0 +1,95 @@\n+---@class vim.ui.img.utils.Region\n+---@field x integer\n+---@field y integer\n+---@field width integer\n+---@field height integer\n+---@field unit vim.ui.img.utils.Unit\n+local M = {}\n+M.__index = M\n+\n+---Creates a new instance of a region corresponding to an image.\n+---@param x integer\n+---@param y integer\n+---@param width integer\n+---@param height integer\n+---@param unit vim.ui.img.utils.Unit\n+---@return vim.ui.img.utils.Region\n+---@overload fun(opts:{x:integer, y:integer, width:integer, height:integer, unit:vim.ui.img.utils.Unit}):vim.ui.img.utils.Region\n+function M.new(x, y, width, height, unit)\n+  local instance = {}\n+\n+  -- For overloaded function, options table provided\n+  if type(x) == 'table' and y == nil and width == nil and height == nil and unit == nil then\n+    instance = x\n+  else\n+    instance.x = x\n+    instance.y = y\n+    instance.width = width\n+    instance.height = height\n+    instance.unit = unit\n+  end\n+\n+  vim.validate('region.x', instance.x, 'number')\n+  vim.validate('region.y', instance.y, 'number')\n+  vim.validate('region.width', instance.width, 'number')\n+  vim.validate('region.height', instance.height, 'number')\n+  vim.validate('region.unit', instance.unit, 'string')\n+\n+  setmetatable(instance, M)\n+  return instance\n+end\n+\n+---Creates a new region from two positions.\n+---@param pos1 vim.ui.img.utils.Position\n+---@param pos2 vim.ui.img.utils.Position\n+---@return vim.ui.img.utils.Region\n+function M.from_positions(pos1, pos2)\n+  assert(pos1.unit == pos2.unit, 'positions must have same unit')\n+  local x, y = math.min(pos1.x, pos2.x), math.min(pos1.y, pos2.y)\n+  local w, h = math.max(pos1.x, pos2.x) - x, math.max(pos1.y, pos2.y) - y\n+  return M.new(x, y, w, h, pos1.unit)\n+end\n+\n+---Convert unit of region to cells, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_cells()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'pixel' then\n+    local cell_x, cell_y = screen.pixels_to_cells(self.x, self.y)\n+    local cell_width, cell_height = screen.pixels_to_cells(self.width, self.height)\n+    return M.new(cell_x, cell_y, cell_width, cell_height, 'cell')\n+  end\n+\n+  return self\n+end\n+\n+---Convert unit of region to pixels, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_pixels()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'cell' then\n+    local px_x, px_y = screen.cells_to_pixels(self.x, self.y)\n+    local px_width, px_height = screen.cells_to_pixels(self.width, self.height)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2087771291",
            "id": 2087771291,
            "in_reply_to_id": 2087295339,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58cNyb",
            "original_commit_id": "78d6ed5ec426ce3691b92e4e4d0c672d71e56c27",
            "original_line": 89,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/region.lua",
            "position": null,
            "pull_request_review_id": 2838339270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087771291/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-13T23:37:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2087771291",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2091979724"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091979724"
                }
            },
            "author_association": "NONE",
            "body": "I'm guessing this is just testing whether vim itself is running on Windows, which isn't particularly meaningful. If you're using a Windows terminal you're just as likely (if not more likely) to be running vim in WSL. or when connected to a Linux server. And you'd assumedly also get a false positive with a Linux terminal remoting onto a Windows server.\r\n\r\nI thought this would be an easy win, but if it's a problem to make 10x20 the universal default, it's probably best to just drop it for now, and wait for queries to be fixed.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-15T21:23:27Z",
            "diff_hunk": "@@ -0,0 +1,174 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__csi_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen using CSI escape codes.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__csi_size()\n+  -- TODO: Introduce support for querying CSI. Neovim eats the response right now.\n+  --\n+  --       CSI 14 t and CSI 16 t are both supported by Windows Terminal\n+  --\n+  --       CSI 14 t :: tells us the pixel dimensions of the view space\n+  --       CSI 16 t :: tells us the pixel dimensions of a terminal character\n+  vim.notify(\n+    'support querying CSI 14 t and/or CSI 16 t is not available',\n+    vim.log.levels.WARN\n+  )\n+  return nil\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.\n+  --\n+  -- Because of this, we define a structure to collect\n+  -- the size information and specify ioctl as available.\n+  local ffi = require('ffi')\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef struct {\n+        unsigned short row;\n+        unsigned short col;\n+        unsigned short xpixel;\n+        unsigned short ypixel;\n+      } winsize;\n+      int ioctl(int, int, ...);\n+    ]])\n+    M.__def = true\n+  end\n+\n+  local TIOCGWINSZ = nil\n+\n+  -- 1. For Linux, Android, GNU Hurd, and WSL\n+  -- 2. For MacOS and BSD like FreeBSD, OpenBSD, NetBSD, and DragonflyBSD\n+  -- 3. For Solaris\n+  if vim.fn.has('linux') == 1 then\n+    TIOCGWINSZ = 0x5413\n+  elseif vim.fn.has('mac') == 1 or vim.fn.has('bsd') == 1 then\n+    TIOCGWINSZ = 0x40087468\n+  elseif vim.fn.has('sun') == 1 then\n+    TIOCGWINSZ = 0x5468\n+  end\n+\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    ---@type { row: number, col: number, xpixel: number, ypixel: number }\n+    local sz = ffi.new('winsize')\n+    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\n+      return\n+    end\n+    size = {\n+      width = sz.xpixel,\n+      height = sz.ypixel,\n+      columns = sz.col,\n+      rows = sz.row,\n+      cell_width = sz.xpixel / sz.col,\n+      cell_height = sz.ypixel / sz.row,\n+      scale = math.max(1, sz.xpixel / sz.col / 8),\n+    }\n+  end)\n+\n+  if not ok then\n+    vim.notify(\n+      string.format('unable to retrieve screen size (POSIX): %s', err or ''),\n+      vim.log.levels.WARN\n+    )\n+  end\n+\n+  return size\n+end\n+\n+---@private\n+---@return vim.ui.img.utils.ScreenSize\n+function M.__default_size()\n+  local cell_width = 9\n+  local cell_height = 18\n+\n+  -- Assume that for Windows the 10x20 used by Windows Terminal\n+  -- is a better choice for a default\n+  if vim.fn.has('win32') == 1 then\n+    cell_width = 10\n+    cell_height = 20\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2091979724",
            "id": 2091979724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58sRPM",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 161,
            "original_position": 161,
            "original_start_line": 156,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2845001631,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091979724/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T21:35:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091979724",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2091987068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091987068"
                }
            },
            "author_association": "NONE",
            "body": "FYI, this is probably not doing what you think it's doing. Mode `?80` is Sixel Display Mode, which is the opposite of Sixel scrolling. By disabling this mode you're actually _enabling_ scrolling. You're doing the right thing, though, because if Sixel Display Mode was enabled, all images would be drawn in the top left corner. It's just that the comment is incorrect.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-15T21:30:25Z",
            "diff_hunk": "@@ -0,0 +1,266 @@\n+local M = {}\n+\n+---@alias vim.ui.img.utils.Unit 'cell'|'pixel'\n+\n+---@class vim.ui.img.utils.Codes\n+M.codes = {\n+  ---Hides the cursor from being shown in terminal.\n+  CURSOR_HIDE            = '\\027[?25l',\n+  ---Restore cursor position based on last save.\n+  CURSOR_RESTORE         = '\\0278',\n+  ---Save cursor position to be restored later.\n+  CURSOR_SAVE            = '\\0277',\n+  ---Shows the cursor if it was hidden in terminal.\n+  CURSOR_SHOW            = '\\027[?25h',\n+  ---Queries the terminal for its background color.\n+  QUERY_BACKGROUND_COLOR = '\\027]11;?',\n+  ---Disables scrolling mode for sixel.\n+  SIXEL_SCROLL_DISABLE   = '\\027[?80l',",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2091987068",
            "id": 2091987068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58sTB8",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": 17,
            "path": "runtime/lua/vim/ui/img/utils.lua",
            "position": null,
            "pull_request_review_id": 2845001631,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091987068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T21:35:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2091987068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2092009682"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092009682"
                }
            },
            "author_association": "NONE",
            "body": "I can set the whole thing to 10x20. When I was browsing `snacks.nvim`, one of a handful of plugins that wrote earlier image logic for neovim, they defaulted to 9x18, hence why I picked that first. But I have no preference either way on what the default is.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-15T21:52:25Z",
            "diff_hunk": "@@ -0,0 +1,174 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__csi_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen using CSI escape codes.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__csi_size()\n+  -- TODO: Introduce support for querying CSI. Neovim eats the response right now.\n+  --\n+  --       CSI 14 t and CSI 16 t are both supported by Windows Terminal\n+  --\n+  --       CSI 14 t :: tells us the pixel dimensions of the view space\n+  --       CSI 16 t :: tells us the pixel dimensions of a terminal character\n+  vim.notify(\n+    'support querying CSI 14 t and/or CSI 16 t is not available',\n+    vim.log.levels.WARN\n+  )\n+  return nil\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.\n+  --\n+  -- Because of this, we define a structure to collect\n+  -- the size information and specify ioctl as available.\n+  local ffi = require('ffi')\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef struct {\n+        unsigned short row;\n+        unsigned short col;\n+        unsigned short xpixel;\n+        unsigned short ypixel;\n+      } winsize;\n+      int ioctl(int, int, ...);\n+    ]])\n+    M.__def = true\n+  end\n+\n+  local TIOCGWINSZ = nil\n+\n+  -- 1. For Linux, Android, GNU Hurd, and WSL\n+  -- 2. For MacOS and BSD like FreeBSD, OpenBSD, NetBSD, and DragonflyBSD\n+  -- 3. For Solaris\n+  if vim.fn.has('linux') == 1 then\n+    TIOCGWINSZ = 0x5413\n+  elseif vim.fn.has('mac') == 1 or vim.fn.has('bsd') == 1 then\n+    TIOCGWINSZ = 0x40087468\n+  elseif vim.fn.has('sun') == 1 then\n+    TIOCGWINSZ = 0x5468\n+  end\n+\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    ---@type { row: number, col: number, xpixel: number, ypixel: number }\n+    local sz = ffi.new('winsize')\n+    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\n+      return\n+    end\n+    size = {\n+      width = sz.xpixel,\n+      height = sz.ypixel,\n+      columns = sz.col,\n+      rows = sz.row,\n+      cell_width = sz.xpixel / sz.col,\n+      cell_height = sz.ypixel / sz.row,\n+      scale = math.max(1, sz.xpixel / sz.col / 8),\n+    }\n+  end)\n+\n+  if not ok then\n+    vim.notify(\n+      string.format('unable to retrieve screen size (POSIX): %s', err or ''),\n+      vim.log.levels.WARN\n+    )\n+  end\n+\n+  return size\n+end\n+\n+---@private\n+---@return vim.ui.img.utils.ScreenSize\n+function M.__default_size()\n+  local cell_width = 9\n+  local cell_height = 18\n+\n+  -- Assume that for Windows the 10x20 used by Windows Terminal\n+  -- is a better choice for a default\n+  if vim.fn.has('win32') == 1 then\n+    cell_width = 10\n+    cell_height = 20\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2092009682",
            "id": 2092009682,
            "in_reply_to_id": 2091979724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58sYjS",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 161,
            "original_position": 161,
            "original_start_line": 156,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2845047411,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092009682/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T21:52:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092009682",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2092013909"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092013909"
                }
            },
            "author_association": "NONE",
            "body": "Ah, so I'm really disabling sixel display mode, which in turn is also disabling sixel scrolling?\r\n\r\nWas following the bottom of this page: https://vt100.net/docs/vt3xx-gp/chapter14.html\r\n\r\nSo, really, this should be named something like `SIXEL_DISPLAY_MODE_DISABLE`?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-15T21:56:38Z",
            "diff_hunk": "@@ -0,0 +1,266 @@\n+local M = {}\n+\n+---@alias vim.ui.img.utils.Unit 'cell'|'pixel'\n+\n+---@class vim.ui.img.utils.Codes\n+M.codes = {\n+  ---Hides the cursor from being shown in terminal.\n+  CURSOR_HIDE            = '\\027[?25l',\n+  ---Restore cursor position based on last save.\n+  CURSOR_RESTORE         = '\\0278',\n+  ---Save cursor position to be restored later.\n+  CURSOR_SAVE            = '\\0277',\n+  ---Shows the cursor if it was hidden in terminal.\n+  CURSOR_SHOW            = '\\027[?25h',\n+  ---Queries the terminal for its background color.\n+  QUERY_BACKGROUND_COLOR = '\\027]11;?',\n+  ---Disables scrolling mode for sixel.\n+  SIXEL_SCROLL_DISABLE   = '\\027[?80l',",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2092013909",
            "id": 2092013909,
            "in_reply_to_id": 2091987068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58sZlV",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": 17,
            "path": "runtime/lua/vim/ui/img/utils.lua",
            "position": null,
            "pull_request_review_id": 2845053719,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092013909/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-15T21:56:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092013909",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2092150280"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092150280"
                }
            },
            "author_association": "NONE",
            "body": "> Ah, so I'm really disabling sixel display mode, which in turn is also disabling sixel scrolling?\r\n\r\nNo, you're disabling sixel display mode, which in turn is _ENABLING_ sixel scrolling. They're the exact opposite of each other.\r\n\r\nThe documentation in the VT340 manual is unfortunately wrong, and has been a source of much confusion. So for many years, at least half of the Sixel terminals had the mode implemented backwards. I'd usually advocate for leaving it unchanged, because it has the potential to make your app unusable on some terminals, but that's probably less of a risk these days.\r\n\r\n> So, really, this should be named something like `SIXEL_DISPLAY_MODE_DISABLE`?\r\n\r\nThat would be more accurate, yes.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-16T00:45:18Z",
            "diff_hunk": "@@ -0,0 +1,266 @@\n+local M = {}\n+\n+---@alias vim.ui.img.utils.Unit 'cell'|'pixel'\n+\n+---@class vim.ui.img.utils.Codes\n+M.codes = {\n+  ---Hides the cursor from being shown in terminal.\n+  CURSOR_HIDE            = '\\027[?25l',\n+  ---Restore cursor position based on last save.\n+  CURSOR_RESTORE         = '\\0278',\n+  ---Save cursor position to be restored later.\n+  CURSOR_SAVE            = '\\0277',\n+  ---Shows the cursor if it was hidden in terminal.\n+  CURSOR_SHOW            = '\\027[?25h',\n+  ---Queries the terminal for its background color.\n+  QUERY_BACKGROUND_COLOR = '\\027]11;?',\n+  ---Disables scrolling mode for sixel.\n+  SIXEL_SCROLL_DISABLE   = '\\027[?80l',",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2092150280",
            "id": 2092150280,
            "in_reply_to_id": 2091987068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58s64I",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": 17,
            "path": "runtime/lua/vim/ui/img/utils.lua",
            "position": null,
            "pull_request_review_id": 2845256541,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092150280/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-16T00:45:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092150280",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2092154157"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092154157"
                }
            },
            "author_association": "NONE",
            "body": "I'm not sure why anyone would choose 9x18 as a default (there may well be a good reason). I just know that 10x20 is the cell size of the original VT240 and VT330/340 terminals, so it's what real terminal emulators need to emulate if they want to be able to run software that targetted those devices.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-16T00:51:23Z",
            "diff_hunk": "@@ -0,0 +1,174 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__csi_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen using CSI escape codes.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__csi_size()\n+  -- TODO: Introduce support for querying CSI. Neovim eats the response right now.\n+  --\n+  --       CSI 14 t and CSI 16 t are both supported by Windows Terminal\n+  --\n+  --       CSI 14 t :: tells us the pixel dimensions of the view space\n+  --       CSI 16 t :: tells us the pixel dimensions of a terminal character\n+  vim.notify(\n+    'support querying CSI 14 t and/or CSI 16 t is not available',\n+    vim.log.levels.WARN\n+  )\n+  return nil\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.\n+  --\n+  -- Because of this, we define a structure to collect\n+  -- the size information and specify ioctl as available.\n+  local ffi = require('ffi')\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef struct {\n+        unsigned short row;\n+        unsigned short col;\n+        unsigned short xpixel;\n+        unsigned short ypixel;\n+      } winsize;\n+      int ioctl(int, int, ...);\n+    ]])\n+    M.__def = true\n+  end\n+\n+  local TIOCGWINSZ = nil\n+\n+  -- 1. For Linux, Android, GNU Hurd, and WSL\n+  -- 2. For MacOS and BSD like FreeBSD, OpenBSD, NetBSD, and DragonflyBSD\n+  -- 3. For Solaris\n+  if vim.fn.has('linux') == 1 then\n+    TIOCGWINSZ = 0x5413\n+  elseif vim.fn.has('mac') == 1 or vim.fn.has('bsd') == 1 then\n+    TIOCGWINSZ = 0x40087468\n+  elseif vim.fn.has('sun') == 1 then\n+    TIOCGWINSZ = 0x5468\n+  end\n+\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    ---@type { row: number, col: number, xpixel: number, ypixel: number }\n+    local sz = ffi.new('winsize')\n+    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\n+      return\n+    end\n+    size = {\n+      width = sz.xpixel,\n+      height = sz.ypixel,\n+      columns = sz.col,\n+      rows = sz.row,\n+      cell_width = sz.xpixel / sz.col,\n+      cell_height = sz.ypixel / sz.row,\n+      scale = math.max(1, sz.xpixel / sz.col / 8),\n+    }\n+  end)\n+\n+  if not ok then\n+    vim.notify(\n+      string.format('unable to retrieve screen size (POSIX): %s', err or ''),\n+      vim.log.levels.WARN\n+    )\n+  end\n+\n+  return size\n+end\n+\n+---@private\n+---@return vim.ui.img.utils.ScreenSize\n+function M.__default_size()\n+  local cell_width = 9\n+  local cell_height = 18\n+\n+  -- Assume that for Windows the 10x20 used by Windows Terminal\n+  -- is a better choice for a default\n+  if vim.fn.has('win32') == 1 then\n+    cell_width = 10\n+    cell_height = 20\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2092154157",
            "id": 2092154157,
            "in_reply_to_id": 2091979724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58s70t",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 161,
            "original_position": 161,
            "original_start_line": 156,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2845261599,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092154157/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-16T00:51:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092154157",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2092875711"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092875711"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Is windows terminal hard coded to that? Do you maybe have a link to resources about how windows terminal does things? I am obviously also interested in that because of #32408 , but don't have access to a windows machine at the moment to test things. I should really just spin it up in a VM though anyway. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-16T11:32:58Z",
            "diff_hunk": "@@ -0,0 +1,174 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__csi_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen using CSI escape codes.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__csi_size()\n+  -- TODO: Introduce support for querying CSI. Neovim eats the response right now.\n+  --\n+  --       CSI 14 t and CSI 16 t are both supported by Windows Terminal\n+  --\n+  --       CSI 14 t :: tells us the pixel dimensions of the view space\n+  --       CSI 16 t :: tells us the pixel dimensions of a terminal character\n+  vim.notify(\n+    'support querying CSI 14 t and/or CSI 16 t is not available',\n+    vim.log.levels.WARN\n+  )\n+  return nil\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.\n+  --\n+  -- Because of this, we define a structure to collect\n+  -- the size information and specify ioctl as available.\n+  local ffi = require('ffi')\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef struct {\n+        unsigned short row;\n+        unsigned short col;\n+        unsigned short xpixel;\n+        unsigned short ypixel;\n+      } winsize;\n+      int ioctl(int, int, ...);\n+    ]])\n+    M.__def = true\n+  end\n+\n+  local TIOCGWINSZ = nil\n+\n+  -- 1. For Linux, Android, GNU Hurd, and WSL\n+  -- 2. For MacOS and BSD like FreeBSD, OpenBSD, NetBSD, and DragonflyBSD\n+  -- 3. For Solaris\n+  if vim.fn.has('linux') == 1 then\n+    TIOCGWINSZ = 0x5413\n+  elseif vim.fn.has('mac') == 1 or vim.fn.has('bsd') == 1 then\n+    TIOCGWINSZ = 0x40087468\n+  elseif vim.fn.has('sun') == 1 then\n+    TIOCGWINSZ = 0x5468\n+  end\n+\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    ---@type { row: number, col: number, xpixel: number, ypixel: number }\n+    local sz = ffi.new('winsize')\n+    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\n+      return\n+    end\n+    size = {\n+      width = sz.xpixel,\n+      height = sz.ypixel,\n+      columns = sz.col,\n+      rows = sz.row,\n+      cell_width = sz.xpixel / sz.col,\n+      cell_height = sz.ypixel / sz.row,\n+      scale = math.max(1, sz.xpixel / sz.col / 8),\n+    }\n+  end)\n+\n+  if not ok then\n+    vim.notify(\n+      string.format('unable to retrieve screen size (POSIX): %s', err or ''),\n+      vim.log.levels.WARN\n+    )\n+  end\n+\n+  return size\n+end\n+\n+---@private\n+---@return vim.ui.img.utils.ScreenSize\n+function M.__default_size()\n+  local cell_width = 9\n+  local cell_height = 18\n+\n+  -- Assume that for Windows the 10x20 used by Windows Terminal\n+  -- is a better choice for a default\n+  if vim.fn.has('win32') == 1 then\n+    cell_width = 10\n+    cell_height = 20\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2092875711",
            "id": 2092875711,
            "in_reply_to_id": 2091979724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58vr-_",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 161,
            "original_position": 161,
            "original_start_line": 156,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2846360495,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092875711/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-16T11:33:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2092875711",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4084982?v=4",
                "events_url": "https://api.github.com/users/tbung/events{/privacy}",
                "followers_url": "https://api.github.com/users/tbung/followers",
                "following_url": "https://api.github.com/users/tbung/following{/other_user}",
                "gists_url": "https://api.github.com/users/tbung/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tbung",
                "id": 4084982,
                "login": "tbung",
                "node_id": "MDQ6VXNlcjQwODQ5ODI=",
                "organizations_url": "https://api.github.com/users/tbung/orgs",
                "received_events_url": "https://api.github.com/users/tbung/received_events",
                "repos_url": "https://api.github.com/users/tbung/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tbung/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tbung/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tbung",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2093698547"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093698547"
                }
            },
            "author_association": "NONE",
            "body": "Yeah, at least for now Windows Terminal is hardcoded to 10x20, but it's possible there might come a time where they make that a configurable option. I personally don't think that's a good idea, and if it were up to me I wouldn't allow it, but it's not my decision to make.\r\n\r\nSo again I would recommend the use of size query sequences if at all possible. If you want to support third-party terminals like WezTerm, Contour, or Mintty, then that's essential. But falling back to 10x20 is better than nothing, because that should at least work on _some_ terminals.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-16T21:32:08Z",
            "diff_hunk": "@@ -0,0 +1,174 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('win32') == 1 then\n+    size = M.__csi_size()\n+  elseif vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen using CSI escape codes.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__csi_size()\n+  -- TODO: Introduce support for querying CSI. Neovim eats the response right now.\n+  --\n+  --       CSI 14 t and CSI 16 t are both supported by Windows Terminal\n+  --\n+  --       CSI 14 t :: tells us the pixel dimensions of the view space\n+  --       CSI 16 t :: tells us the pixel dimensions of a terminal character\n+  vim.notify(\n+    'support querying CSI 14 t and/or CSI 16 t is not available',\n+    vim.log.levels.WARN\n+  )\n+  return nil\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.\n+  --\n+  -- Because of this, we define a structure to collect\n+  -- the size information and specify ioctl as available.\n+  local ffi = require('ffi')\n+  if not M.__def then\n+    ffi.cdef([[\n+      typedef struct {\n+        unsigned short row;\n+        unsigned short col;\n+        unsigned short xpixel;\n+        unsigned short ypixel;\n+      } winsize;\n+      int ioctl(int, int, ...);\n+    ]])\n+    M.__def = true\n+  end\n+\n+  local TIOCGWINSZ = nil\n+\n+  -- 1. For Linux, Android, GNU Hurd, and WSL\n+  -- 2. For MacOS and BSD like FreeBSD, OpenBSD, NetBSD, and DragonflyBSD\n+  -- 3. For Solaris\n+  if vim.fn.has('linux') == 1 then\n+    TIOCGWINSZ = 0x5413\n+  elseif vim.fn.has('mac') == 1 or vim.fn.has('bsd') == 1 then\n+    TIOCGWINSZ = 0x40087468\n+  elseif vim.fn.has('sun') == 1 then\n+    TIOCGWINSZ = 0x5468\n+  end\n+\n+  ---@type boolean, string|nil\n+  local ok, err = pcall(function()\n+    ---@type { row: number, col: number, xpixel: number, ypixel: number }\n+    local sz = ffi.new('winsize')\n+    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\n+      return\n+    end\n+    size = {\n+      width = sz.xpixel,\n+      height = sz.ypixel,\n+      columns = sz.col,\n+      rows = sz.row,\n+      cell_width = sz.xpixel / sz.col,\n+      cell_height = sz.ypixel / sz.row,\n+      scale = math.max(1, sz.xpixel / sz.col / 8),\n+    }\n+  end)\n+\n+  if not ok then\n+    vim.notify(\n+      string.format('unable to retrieve screen size (POSIX): %s', err or ''),\n+      vim.log.levels.WARN\n+    )\n+  end\n+\n+  return size\n+end\n+\n+---@private\n+---@return vim.ui.img.utils.ScreenSize\n+function M.__default_size()\n+  local cell_width = 9\n+  local cell_height = 18\n+\n+  -- Assume that for Windows the 10x20 used by Windows Terminal\n+  -- is a better choice for a default\n+  if vim.fn.has('win32') == 1 then\n+    cell_width = 10\n+    cell_height = 20\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2093698547",
            "id": 2093698547,
            "in_reply_to_id": 2091979724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM58y03z",
            "original_commit_id": "b140d7d85f8dcd5a3eca838ee6668822312d1592",
            "original_line": 161,
            "original_position": 161,
            "original_start_line": 156,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2847655754,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093698547/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-16T21:32:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2093698547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099897465"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099897465"
                }
            },
            "author_association": "MEMBER",
            "body": "this test looks useful, definitely keep it",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:07:53Z",
            "diff_hunk": "@@ -0,0 +1,104 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#ifdef _MSC_VER\n+# include <Windows.h>\n+# define usleep(usecs) Sleep((usecs) / 1000)\n+#else\n+# include <unistd.h>\n+#endif\n+\n+static void help(void)\n+{\n+  puts(\"Print input/output\");\n+  puts(\"\");\n+  puts(\"Usage:\");\n+  puts(\"  printio-test --help\");\n+  puts(\"    Prints this help to stdout.\");\n+  puts(\"  printio-test [-a file] [-o file] [-e file] [-x code] -- {command}\");\n+  puts(\"    Saves args after -- into file specified by \\\"-a\\\".\");\n+  puts(\"    Prints file specified by \\\"-o\\\" to stdout.\");\n+  puts(\"    Prints file specified by \\\"-e\\\" to stderr.\");\n+  puts(\"    Returns exit code specified by \\\"-x\\\" (default 0).\");\n+}\n+\n+static void copy_file_to_stream(const char *path, FILE *stream) {",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099897465",
            "id": 2099897465,
            "line": 26,
            "node_id": "PRRC_kwDOAPphoM59KeR5",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 26,
            "original_position": 26,
            "original_start_line": null,
            "path": "test/functional/fixtures/printio-test.c",
            "position": 26,
            "pull_request_review_id": 2857112608,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099897465/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:07:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099897465",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099899773"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099899773"
                }
            },
            "author_association": "MEMBER",
            "body": "drop these for now. push the drop as a new commit, then we will have that in the repo history (won't squash-merge)",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:09:09Z",
            "diff_hunk": "@@ -366,6 +366,8 @@ EXTERN int p_arshape;           ///< 'arabicshape'\n EXTERN int p_icon;              ///< 'icon'\n EXTERN char *p_iconstring;      ///< 'iconstring'\n EXTERN int p_ic;                ///< 'ignorecase'\n+EXTERN char *p_imgprg;          ///< 'imgprg'\n+EXTERN char *p_imgprovider;     ///< 'imgprovider'",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099899773",
            "id": 2099899773,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Ke19",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 370,
            "original_position": 5,
            "original_start_line": 369,
            "path": "src/nvim/option_vars.h",
            "position": null,
            "pull_request_review_id": 2857116147,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099899773/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T10:09:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099899773",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099901200"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099901200"
                }
            },
            "author_association": "MEMBER",
            "body": "all of these `img/utils/*` should live in `img/*` with underscore.\r\n\r\n    runtime/lua/vim/ui/img/_size.lua\r\n\r\n don't need extra nesting of `img/utils`.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:09:52Z",
            "diff_hunk": "@@ -0,0 +1,83 @@\n+---@class vim.ui.img.utils.Size",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099901200",
            "id": 2099901200,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KfMQ",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/size.lua",
            "position": null,
            "pull_request_review_id": 2857118729,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099901200/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:10:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099901200",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099907343"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099907343"
                }
            },
            "author_association": "MEMBER",
            "body": "don't we have  `VimResize` event? or see `runtime/lua/vim/termcap.lua` , `TermResponse` (idk if that helps)",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:13:24Z",
            "diff_hunk": "@@ -0,0 +1,149 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099907343",
            "id": 2099907343,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KgsP",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2857129053,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099907343/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:13:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099907343",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099911494"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099911494"
                }
            },
            "author_association": "MEMBER",
            "body": "This looks useful, but make sure it's internal-only for now (`img/_region.lua`). Also doesn't need to be perfect for now. We only care about the public `vim.ui.img` interface, which might not support pixels yet if it requires this PR to decide a permanent \"region\" api.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:15:48Z",
            "diff_hunk": "@@ -0,0 +1,110 @@\n+---@class vim.ui.img.utils.Region\n+---@field x integer\n+---@field y integer\n+---@field width integer\n+---@field height integer\n+---@field unit vim.ui.img.utils.Unit\n+local M = {}\n+M.__index = M\n+\n+---Creates a new instance of a region corresponding to an image.\n+---@param x integer\n+---@param y integer\n+---@param width integer\n+---@param height integer\n+---@param unit vim.ui.img.utils.Unit\n+---@return vim.ui.img.utils.Region\n+---@overload fun(opts:{x:integer, y:integer, width:integer, height:integer, unit:vim.ui.img.utils.Unit}):vim.ui.img.utils.Region\n+function M.new(x, y, width, height, unit)\n+  local instance = {}\n+\n+  -- For overloaded function, options table provided\n+  if type(x) == 'table' and y == nil and width == nil and height == nil and unit == nil then\n+    instance = x\n+  else\n+    instance.x = x\n+    instance.y = y\n+    instance.width = width\n+    instance.height = height\n+    instance.unit = unit\n+  end\n+\n+  vim.validate('region.x', instance.x, 'number')\n+  vim.validate('region.y', instance.y, 'number')\n+  vim.validate('region.width', instance.width, 'number')\n+  vim.validate('region.height', instance.height, 'number')\n+  vim.validate('region.unit', instance.unit, 'string')\n+\n+  setmetatable(instance, M)\n+  return instance\n+end\n+\n+---@param a vim.ui.img.utils.Region\n+---@param b vim.ui.img.utils.Region\n+---@return boolean\n+function M.__eq(a, b)\n+  if type(a) ~= 'table' or type(b) ~= 'table' then\n+    return false\n+  end\n+\n+  return a.x == b.x\n+    and a.y == b.y\n+    and a.width == b.width\n+    and a.height == b.height\n+    and a.unit == b.unit\n+end\n+\n+---Creates a new region from two positions.\n+---@param pos1 vim.ui.img.utils.Position\n+---@param pos2 vim.ui.img.utils.Position\n+---@return vim.ui.img.utils.Region\n+function M.from_positions(pos1, pos2)\n+  assert(pos1.unit == pos2.unit, 'positions must have same unit')\n+  local x, y = math.min(pos1.x, pos2.x), math.min(pos1.y, pos2.y)\n+  local w, h = math.max(pos1.x, pos2.x) - x, math.max(pos1.y, pos2.y) - y\n+  return M.new(x, y, w, h, pos1.unit)\n+end\n+\n+---Convert unit of region to cells, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_cells()\n+  local screen = require('vim.ui.img.utils.screen')\n+\n+  if self.unit == 'pixel' then\n+    local cell_x, cell_y = screen.pixels_to_cells(self.x, self.y)\n+    local cell_width, cell_height = screen.pixels_to_cells(self.width, self.height)\n+    return M.new(cell_x, cell_y, cell_width, cell_height, 'cell')\n+  end\n+\n+  return self\n+end\n+\n+---Convert unit of region to pixels, returning a copy of the region.\n+---@return vim.ui.img.utils.Region\n+function M:to_pixels()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099911494",
            "id": 2099911494,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KhtG",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 84,
            "original_position": 84,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/region.lua",
            "position": null,
            "pull_request_review_id": 2857135418,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099911494/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:15:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099911494",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099914127"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099914127"
                }
            },
            "author_association": "MEMBER",
            "body": "This module should be internal-only, though certainly callbacks and `:wait()` concept are normal things already in the Nvim stdlib, so those functions/callbacks may be public.\r\n\r\nIdeally this module could be dropped entirely, but that could be a followup PR since I would like to resolve this one ASAP.",
            "commit_id": "ea8083808e962f43610556517192e2829010b832",
            "created_at": "2025-05-21T10:17:20Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099914127",
            "id": 2099914127,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM59KiWP",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/promise.lua",
            "position": 1,
            "pull_request_review_id": 2857139405,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099914127/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2025-05-21T10:17:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099914127",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099916126"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099916126"
                }
            },
            "author_association": "MEMBER",
            "body": "lowercase\r\n```suggestion\r\n  cursor_hide = '\\027[?25l',\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:18:37Z",
            "diff_hunk": "@@ -0,0 +1,309 @@\n+local M = {}\n+\n+---@alias vim.ui.img.utils.Unit 'cell'|'pixel'\n+\n+---@class vim.ui.img.utils.Codes\n+M.codes = {\n+  ---Hides the cursor from being shown in terminal.\n+  CURSOR_HIDE = '\\027[?25l',",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099916126",
            "id": 2099916126,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Ki1e",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 8,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils.lua",
            "position": null,
            "pull_request_review_id": 2857142736,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099916126/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:18:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099916126",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099920614"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099920614"
                }
            },
            "author_association": "MEMBER",
            "body": "`_defer_require` might be useful here https://github.com/neovim/neovim/blob/dfad6138131f86a229d6fb9fb21742a8b979ede7/runtime/lua/vim/lsp.lua#L4",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:21:09Z",
            "diff_hunk": "@@ -1,5 +1,217 @@\n local M = {}\n \n+---Endpoint for the nvim image API.\n+---\n+---The API follows a simplistic, object-oriented design similar to `vim.system()`.\n+---You specify an image, optionally eagerly loading its data, and then display it\n+---within nvim. The information about where and how it is displayed is provided\n+---through a single table.\n+---\n+---Each image, once shown, returns a placement, which represents the specific\n+---instance of the image on screen. This is to support the separation of an\n+---image and its data from the details and management of displaying it.\n+---\n+---The image API makes use of an internal `Promise<T>` class in order to support\n+---both synchronous and asynchronous operation, meaning that images can be loaded,\n+---shown, hidden, and updated asynchronously in order to be efficient, but also can\n+---manually be waited upon at any stage.\n+---\n+---Examples in action\n+---\n+---```lua\n+----- Supports loading PNG images into memory\n+---local img = assert(vim.ui.img.load(\"/path/to/img.png\"):wait())\n+---\n+----- Supports lazy-loading image for a provider to request later if needed\n+---local img = vim.ui.img.new(\"/path/to/img.png\")\n+---\n+----- Supports specifying an image and explicitly providing the data\n+---local img = vim.ui.img.new({ bytes = \"...\", filename = \"/path/to/img.png\" })\n+---```\n+---\n+---Placements are instances of images that have been \"placed\" onto the screen\n+---in nvim. Whenever you show an image, a placement is created.\n+---\n+---```lua\n+----- Once created, an image can be shown, returning an object\n+----- deemed a \"placement\" that represents the instance\n+---local placement = img:show():wait() -- Places in top-left of editor with default size\n+---local placement = img:show({ pos = { x = 4, y = 8, unit = 'cell' }):wait()\n+---local placement = img:show({ relative = 'cursor' }):wait()\n+---```\n+---\n+---```lua\n+---local placement = assert(img:hide():wait())\n+---```\n+---\n+---```lua\n+---local img = vim.ui.img.new(\"/path/to/img.png\")\n+---local placement = assert(img:show({ pos = { x = 1, y = 2, unit = 'cell' } }):wait())\n+---\n+----- Supports updating a displayed image with a new position\n+---placement:update({ pos = { x = 5, y = 6, unit = 'cell' } }):wait()\n+---\n+----- Supports resizing a displayed image\n+---placement:update({ size = { width = 10, height = 5, unit = \"cell\" } }):wait()\n+---\n+----- Of course, you can do all of this at the same time\n+---placement:update({\n+---    pos = { x = 5, y = 6, unit = 'cell' },\n+---    size = { width = 10, height = 5, unit = 'cell' },\n+---}):wait()\n+---```\n+---\n+---Backed by promises\n+---\n+---Each Promise<T> supports chaining callbacks for individual\n+---conditions of success or failure as well as combining the two\n+---together.\n+--\n+---The on_* methods can be called multiple times and each\n+---callback will be invoked when finished.\n+---\n+---You can also still choose to wait in a synchronous fashion\n+---using `:wait()` which supports supplying a specific timeout\n+---in milliseconds.\n+---\n+---```lua\n+---img:show({ ... })\n+---    :on_ok(function(placement)\n+---        -- Use the placement once it has been confirmed as shown\n+---    end)\n+---    :on_fail(function(err)\n+---        -- Do something with the error that occurred\n+---    end)\n+---    :on_done(function(err, placement)\n+---        -- When either ok or fail happens\n+---    end)\n+---```\n+---\n+---Using magic on images\n+---\n+---Leveraging *ImageMagick* for the functionality, the image API supports\n+---converting images into different formats as well as transforming them.\n+---This is particularly needed for sixel, which would normally require\n+---advanced image decoding to convert to an RGB format and then packaged in\n+---sixel's format.\n+---\n+---By default, the path to the magick binary is specified with the *imgprg* option.\n+---\n+---```lua\n+---vim.o.imgprg = 'magick'\n+---```\n+---\n+---ImageMagick supports features like cropping and resizing,\n+---which we expose through the `convert` method.\n+---\n+---```lua\n+---img:convert({\n+---    format = 'jpeg', -- Supports a variety of formats, including sixel!\n+---    size = { width = 50, height = 30, unit = 'pixel' },\n+---}):on_done(function(err, data)\n+---    -- By default, this returns the data of the image\n+---    -- instead of updating the instance or saving it\n+---    -- to disk\n+---    --\n+---    -- Use img:convert({ out = '/path/to/img.jpeg' })\n+---    -- to write to disk instead\n+---end)\n+---```\n+---\n+---Additionally, the image API provides a retrieval method called `identify`\n+---(modeled after `magick identify`) to inspect images without needing advanced\n+---header parsing per image format in order to learn details like the true image\n+---format (not just reading the file extension) and pixel dimensions of the image.\n+---\n+---```lua\n+---img:identify({ format = true, size = true }):on_done(function(err, info)\n+---    -- Info is a table containing the information requested by each\n+---    -- field marked true.\n+---    --\n+---    -- In this case,\n+---    -- info.format == \"PNG\"\n+---    -- info.size == vim.ui.img.utils.Size { width = 50, height = 30, unit = 'pixel' }\n+---    --\n+---    -- If the field is unsupported, it can still be rovided using\n+---    -- name = \"format\" syntax of ImageMagick.\n+---    --\n+---    -- img:identify({ depth = \"%z\" }) would capture image depth\n+---    -- as specified by ImageMagick's escape shorthand for metadata:\n+---    -- https://imagemagick.org/script/escape.php\n+---end)\n+---```\n+---\n+---Providing an implementation\n+---\n+---nvim comes with three providers that interface with various\n+---graphics protocols supported by |TUI|s and GUIs.\n+---\n+---1. kitty\n+---2. iterm2\n+---3. sixel\n+---\n+---The global provider to use with all placements is specified via the option,\n+---*imgprovider*, which is set to *kitty* by default. When the global provider\n+---is changed, the old provider is unloaded.\n+---\n+---```lua\n+---vim.o.imgprovider = 'kitty'\n+---```\n+---\n+---The image API also supports 3rd party provider integrations. To create a\n+---new provider, the implementer should leverage `vim.ui.img.providers.new()`.\n+---\n+---To register the provider such that it is accessible globally, the implementer\n+---should assign it with a name to the dictionary at `vim.ui.img.providers`.\n+---\n+---```lua\n+---vim.ui.img.providers['neovide'] = vim.ui.img.providers.new({\n+---    ---(Optional) Called to initialize the provider.\n+---    ---@param ... any arguments for the specific provider upon loading\n+---    load = function(...)\n+---      -- Implement here\n+---    end,\n+---\n+---    ---(Optional) Called to cleanup the provider.\n+---    unload = function()\n+---      -- Implement here\n+---    end,\n+---\n+---    ---(Optional) Reports whether this provider is supported in the current environment.\n+---    ---@param on_supported? fun(supported:boolean) callback when finished checking\n+---    supported = function(on_supported)\n+---        -- Implement here\n+---    end,\n+---\n+---    ---Displays an image, returning (through callback) an id tied to the instance.\n+---    ---@param img vim.ui.Image image data container to display\n+---    ---@param opts vim.ui.img.Opts specification of how to display the image\n+---    ---@param on_shown? fun(err:string|nil, id:integer|nil) callback when finished showing\n+---    ---@return integer id unique identifier connected to the displayed image (not vim.ui.Image)\n+---    show = function(img, opts, on_shown)\n+---        -- Implement here\n+---    end,\n+---\n+---    ---Hides one or more displayed images.\n+---    ---@param ids integer[] list of displayed image ids to hide\n+---    ---@param on_hidden fun(err:string|nil, ids:integer[]|nil) callback when finished hiding\n+---    hide = function(ids, on_hidden)\n+---        -- Implement here\n+---    end,\n+---\n+---    ---(Optional) Updates an image, returning (through callback) a refreshed id tied to the instance.\n+---    ---If not specified, nvim will invoke `hide(id)` followed by `show(img, opts, on_updated)`.\n+---    ---@param id integer id of the displayed image to update\n+---    ---@param opts vim.ui.img.Opts specification of how to display the image\n+---    ---@param on_updated? fun(err:string|nil, id:integer|nil) callback when finished updating\n+---    ---@return integer id unique identifier connected to the displayed image (not vim.ui.Image)\n+---    update = function(id, opts, on_updated)\n+---        -- Implement here\n+---    end,\n+---})\n+---```\n+M.img = require('vim.ui.img')",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099920614",
            "id": 2099920614,
            "line": 91,
            "node_id": "PRRC_kwDOAPphoM59Kj7m",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 91,
            "original_position": 213,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui.lua",
            "position": 91,
            "pull_request_review_id": 2857150614,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099920614/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:21:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099920614",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099929135"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099929135"
                }
            },
            "author_association": "MEMBER",
            "body": "  using windows/extmarks for positioning is a good idea. \r\n\r\nI also would expect that we don't need specific types like `vim.ui.img.opts.Relative`, I expect we can reuse things in `vim.api.keyset.win_config` . But this doesn't matter too much since we currently don't have a contract for \"Lua types\", and may break/rename them at will.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:25:59Z",
            "diff_hunk": "@@ -0,0 +1,126 @@\n+---@alias vim.ui.img.opts.Relative 'editor'|'win'|'cursor'|'mouse'\n+\n+---@class vim.ui.img.Opts\n+---@field relative? vim.ui.img.opts.Relative\n+---@field crop? vim.ui.img.utils.Region portion of image to display\n+---@field pos? vim.ui.img.utils.Position upper-left position of image within editor\n+---@field size? vim.ui.img.utils.Size explicit size to scale the image\n+---@field win? integer window to use when `relative` is `win`\n+---@field z? integer z-index of the image with lower values being drawn before higher values\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image opts instance, copying from `opts` any fields.\n+---Performs type checks and transformations into typed objects.\n+---@param opts? table\n+---@return vim.ui.img.Opts\n+function M.new(opts)\n+  opts = opts or {}\n+\n+  -- NOTE: We copy the opts to ensure that other fields carry forward\n+  --       alongside the fields that we type check.\n+  local instance = vim.deepcopy(opts)\n+  setmetatable(instance, M)\n+\n+  local Position = require('vim.ui.img.utils.position')\n+  local Region = require('vim.ui.img.utils.region')\n+  local Size = require('vim.ui.img.utils.size')\n+\n+  ---@type vim.ui.img.opts.Relative|nil\n+  local relative = opts.relative\n+  vim.validate('opts.relative', relative, 'string', true)\n+\n+  ---@type vim.ui.img.utils.Region|nil\n+  local crop = opts.crop\n+  vim.validate('opts.crop', crop, 'table', true)\n+  if type(crop) == 'table' then\n+    crop = Region.new(crop)\n+  end\n+\n+  ---@type vim.ui.img.utils.Position|nil\n+  local pos = opts.pos\n+  vim.validate('opts.pos', pos, 'table', true)\n+  if type(pos) == 'table' then\n+    pos = Position.new(pos)\n+  end\n+\n+  ---@type vim.ui.img.utils.Size|nil\n+  local size = opts.size\n+  vim.validate('opts.size', size, 'table', true)\n+  if type(size) == 'table' then\n+    size = Size.new(size)\n+  end\n+\n+  ---@type integer|nil\n+  local win = opts.win\n+  vim.validate('opts.win', win, 'number', true)\n+\n+  ---@type integer|nil\n+  local z = opts.z\n+  vim.validate('opts.z', z, 'number', true)\n+\n+  instance.relative = relative\n+  instance.crop = crop\n+  instance.pos = pos\n+  instance.size = size\n+  instance.win = win\n+  instance.z = z\n+\n+  return instance\n+end\n+\n+---Calculates and returns the position dictated by `relative` and `pos`.\n+---@return vim.ui.img.utils.Position\n+function M:position()\n+  local Position = require('vim.ui.img.utils.position')\n+  local x, y = 0, 0\n+\n+  if self.pos or self.relative then\n+    local xoffset, yoffset = 0, 0\n+    local relative = self.relative\n+\n+    if self.pos then\n+      local pos_cells = self.pos:to_cells()\n+      x, y = pos_cells.x, pos_cells.y\n+    end\n+\n+    -- Adjust the x,y position using relative indicator\n+    if relative == 'editor' then\n+      xoffset = 0\n+      yoffset = 0\n+    elseif relative == 'win' then\n+      ---@type {[1]:number, [2]:number}\n+      local pos = vim.api.nvim_win_get_position(self.win or 0)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099929135",
            "id": 2099929135,
            "line": 108,
            "node_id": "PRRC_kwDOAPphoM59KmAv",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 108,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/opts.lua",
            "position": 108,
            "pull_request_review_id": 2857165017,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099929135/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T08:47:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099929135",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099931678"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099931678"
                }
            },
            "author_association": "MEMBER",
            "body": "\"data\" is pretty standard in the codebase.\r\n\r\n```suggestion\r\n---@field data string|nil bytes of the image loaded into memory\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:27:30Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099931678",
            "id": 2099931678,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Kmoe",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 7,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857168925,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099931678/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:27:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099931678",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099932296"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099932296"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    vim.validate('opts.data', opts.data, 'string', true)\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:27:51Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099932296",
            "id": 2099932296,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KmyI",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 28,
            "original_position": 28,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857169871,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099932296/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:27:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099932296",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099933504"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099933504"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    vim.validate('opts.data', opts.data, 'string', true)\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:28:37Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099933504",
            "id": 2099933504,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KnFA",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 28,
            "original_position": 28,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857171840,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099933504/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:28:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099933504",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099934524"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099934524"
                }
            },
            "author_association": "MEMBER",
            "body": "\"file\" is common in `vim.fs`. Eventually we will have URIs, and \"file\" is more compatible with that.\r\n\r\n```suggestion\r\n    vim.validate('opts.file', opts.file, 'string')\r\n```",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:29:15Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099934524",
            "id": 2099934524,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KnU8",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 29,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857173545,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099934524/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-21T10:29:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099934524",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099940889"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099940889"
                }
            },
            "author_association": "MEMBER",
            "body": "strange for a boolean getter to throw. can this be `format():'png'|nil` instead, where `nil` means \"unknown\"? or maybe `format():'png'|'error'|nil`\r\n\r\nor perhaps `is_png():boolean|nil`",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:33:11Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099940889",
            "id": 2099940889,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Ko4Z",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 156,
            "original_position": 141,
            "original_start_line": 138,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857184595,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099940889/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T10:33:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099940889",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099942316"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099942316"
                }
            },
            "author_association": "MEMBER",
            "body": "this is definitely out of scope for this PR",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:34:01Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099942316",
            "id": 2099942316,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KpOs",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": 246,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857186893,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099942316/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T10:34:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099942316",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099943027"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099943027"
                }
            },
            "author_association": "MEMBER",
            "body": "out of scope",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:34:28Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099943027",
            "id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KpZz",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857188019,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099943027/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T10:34:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099943027",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2099946349"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099946349"
                }
            },
            "author_association": "MEMBER",
            "body": "seems overwrought to represent \"placements\" as objects which need to be created. I would expect something like `M:set_pos`.\r\n\r\nPositions are called \"pos\". Avoid a new \"placement\" concept.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T10:36:27Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)\n+  opts = opts or {}\n+\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.convert',\n+  })\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    table.insert(cmd, 'convert')\n+    table.insert(cmd, self.filename)\n+\n+    if opts.background then\n+      table.insert(cmd, '-background')\n+      table.insert(cmd, opts.background)\n+      table.insert(cmd, '-flatten')\n+    end\n+    if opts.crop then\n+      local region = opts.crop:to_pixels()\n+      table.insert(cmd, '-crop')\n+      table.insert(\n+        cmd,\n+        string.format('%sx%s+%s+%s', region.width, region.height, region.x, region.y)\n+      )\n+    end\n+    if opts.size then\n+      local size_px = opts.size:to_pixels()\n+      table.insert(cmd, '-resize')\n+      table.insert(cmd, string.format('%sx%s', size_px.width, size_px.height))\n+    end\n+\n+    if opts.quality then\n+      table.insert(cmd, '-quality')\n+      table.insert(cmd, tostring(opts.quality))\n+    end\n+\n+    local format = opts.format or 'png'\n+    local output = opts.out or '-'\n+    table.insert(cmd, format .. ':' .. output)\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to convert image')\n+        return\n+      end\n+\n+      -- In the case we wrote to a file, there's nothing to capture\n+      if opts.out ~= nil then\n+        promise:ok('')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('converted image output missing')\n+        return\n+      end\n+\n+      promise:ok(data)\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Displays an image, returning a reference to its visual representation (placement).\n+---```lua\n+---local img = ...\n+---\n+-----Can be invoked synchronously\n+---local placement = assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err, placement)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts|{provider?:string}\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Placement>\n+function M:show(opts)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local placement = self:new_placement(opts)\n+  placement\n+    :show(opts)\n+    :on_ok(function()\n+      promise:ok(placement)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Creates a placement of this image that is not yet visible.\n+---@param opts? {provider?:string}\n+---@return vim.ui.img.Placement\n+function M:new_placement(opts)\n+  return require('vim.ui.img.placement').new(self, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2099946349",
            "id": 2099946349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59KqNt",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 554,
            "original_position": 554,
            "original_start_line": 550,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2857193253,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099946349/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T10:36:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2099946349",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101275455"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101275455"
                }
            },
            "author_association": "NONE",
            "body": "Maybe the naming is wrong on this - was following kitty's naming - but the concept is that the image is the file path and (optionally) data of the image itself and a placement is the reference to the image managed by the provider in the terminal (or UI) of which there may be multiple. Maybe we just don't make this a public method or we change the name, but `M:set_pos` makes me think that I'm moving the `vim.ui.Image` instead of one of the displayed versions on the terminal.\r\n\r\n![neovim-img-placement-example](https://github.com/user-attachments/assets/fe57b401-cf0d-4be7-b868-8369ad9c92ba)\r\n",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T22:26:40Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)\n+  opts = opts or {}\n+\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.convert',\n+  })\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    table.insert(cmd, 'convert')\n+    table.insert(cmd, self.filename)\n+\n+    if opts.background then\n+      table.insert(cmd, '-background')\n+      table.insert(cmd, opts.background)\n+      table.insert(cmd, '-flatten')\n+    end\n+    if opts.crop then\n+      local region = opts.crop:to_pixels()\n+      table.insert(cmd, '-crop')\n+      table.insert(\n+        cmd,\n+        string.format('%sx%s+%s+%s', region.width, region.height, region.x, region.y)\n+      )\n+    end\n+    if opts.size then\n+      local size_px = opts.size:to_pixels()\n+      table.insert(cmd, '-resize')\n+      table.insert(cmd, string.format('%sx%s', size_px.width, size_px.height))\n+    end\n+\n+    if opts.quality then\n+      table.insert(cmd, '-quality')\n+      table.insert(cmd, tostring(opts.quality))\n+    end\n+\n+    local format = opts.format or 'png'\n+    local output = opts.out or '-'\n+    table.insert(cmd, format .. ':' .. output)\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to convert image')\n+        return\n+      end\n+\n+      -- In the case we wrote to a file, there's nothing to capture\n+      if opts.out ~= nil then\n+        promise:ok('')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('converted image output missing')\n+        return\n+      end\n+\n+      promise:ok(data)\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Displays an image, returning a reference to its visual representation (placement).\n+---```lua\n+---local img = ...\n+---\n+-----Can be invoked synchronously\n+---local placement = assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err, placement)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts|{provider?:string}\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Placement>\n+function M:show(opts)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local placement = self:new_placement(opts)\n+  placement\n+    :show(opts)\n+    :on_ok(function()\n+      promise:ok(placement)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Creates a placement of this image that is not yet visible.\n+---@param opts? {provider?:string}\n+---@return vim.ui.img.Placement\n+function M:new_placement(opts)\n+  return require('vim.ui.img.placement').new(self, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101275455",
            "id": 2101275455,
            "in_reply_to_id": 2099946349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Pus_",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 554,
            "original_position": 554,
            "original_start_line": 550,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2859273247,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101275455/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T22:26:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101275455",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101281643"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101281643"
                }
            },
            "author_association": "NONE",
            "body": "Not a problem. If we did want `sixel` or need cropping for `iterm2` (if we brought it in), then we would need this. Or we'd have to provide or write a PNG decoder.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T22:28:53Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101281643",
            "id": 2101281643,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59PwNr",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2859280261,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101281643/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T22:28:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101281643",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101283548"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101283548"
                }
            },
            "author_association": "NONE",
            "body": "Only reason it existed was to easily find any image format's dimensions (width & height). If we just stick with PNG, I know how to read that from the file header. So, no problem.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T22:29:36Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101283548",
            "id": 2101283548,
            "in_reply_to_id": 2099942316,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Pwrc",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": 246,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2859282188,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101283548/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T22:29:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101283548",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101285694"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101285694"
                }
            },
            "author_association": "NONE",
            "body": "Yeah, can do that instead. Do you expect to support other formats other than PNG down the line? If so, one of the `format` functions makes sense. If not, the `is_png` makes more sense.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-21T22:30:42Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101285694",
            "id": 2101285694,
            "in_reply_to_id": 2099940889,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59PxM-",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 156,
            "original_position": 141,
            "original_start_line": 138,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2859284509,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101285694/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-21T22:30:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101285694",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101446746"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101446746"
                }
            },
            "author_association": "NONE",
            "body": "`VimResized` lets you know of the resize, but we can only get the rows and columns from neovim, not the pixel dimensions, which we want to figure out how big a cell in the terminal is in relation to pixels to perform the conversions.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T01:25:43Z",
            "diff_hunk": "@@ -0,0 +1,149 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101446746",
            "id": 2101446746,
            "in_reply_to_id": 2099907343,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59QYha",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2859514474,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101446746/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T01:25:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101446746",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101997374"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101997374"
                }
            },
            "author_association": "MEMBER",
            "body": "requiring PNG seems reasonable. converting to PNG is a different topic, which could be covered in some other api in the future. but the caller of this api is expected to provide PNG.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T08:46:31Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101997374",
            "id": 2101997374,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Se8-",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2860346402,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101997374/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T08:46:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101997374",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2101998740"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101998740"
                }
            },
            "author_association": "MEMBER",
            "body": "let's assume PNG. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T08:47:16Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2101998740",
            "id": 2101998740,
            "in_reply_to_id": 2099940889,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59SfSU",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 156,
            "original_position": 141,
            "original_start_line": 138,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2860348935,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101998740/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T08:47:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2101998740",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102012838"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102012838"
                }
            },
            "author_association": "MEMBER",
            "body": "> Maybe we just don't make this a public method or we change the name,\r\n\r\nIf it can be private for now, let's do that.\r\n\r\n> but `M:set_pos` makes me think that I'm moving the `vim.ui.Image` instead of one of the displayed versions on the terminal.\r\n\r\nIs the intention to avoid creating a new image for each placement? Can we instead just say \"a new placement requires new image\". So an image object has *one* position, and cannot be placed in multiple places. That might be \"inefficient\", but so what?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T08:53:30Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)\n+  opts = opts or {}\n+\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.convert',\n+  })\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    table.insert(cmd, 'convert')\n+    table.insert(cmd, self.filename)\n+\n+    if opts.background then\n+      table.insert(cmd, '-background')\n+      table.insert(cmd, opts.background)\n+      table.insert(cmd, '-flatten')\n+    end\n+    if opts.crop then\n+      local region = opts.crop:to_pixels()\n+      table.insert(cmd, '-crop')\n+      table.insert(\n+        cmd,\n+        string.format('%sx%s+%s+%s', region.width, region.height, region.x, region.y)\n+      )\n+    end\n+    if opts.size then\n+      local size_px = opts.size:to_pixels()\n+      table.insert(cmd, '-resize')\n+      table.insert(cmd, string.format('%sx%s', size_px.width, size_px.height))\n+    end\n+\n+    if opts.quality then\n+      table.insert(cmd, '-quality')\n+      table.insert(cmd, tostring(opts.quality))\n+    end\n+\n+    local format = opts.format or 'png'\n+    local output = opts.out or '-'\n+    table.insert(cmd, format .. ':' .. output)\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to convert image')\n+        return\n+      end\n+\n+      -- In the case we wrote to a file, there's nothing to capture\n+      if opts.out ~= nil then\n+        promise:ok('')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('converted image output missing')\n+        return\n+      end\n+\n+      promise:ok(data)\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Displays an image, returning a reference to its visual representation (placement).\n+---```lua\n+---local img = ...\n+---\n+-----Can be invoked synchronously\n+---local placement = assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err, placement)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts|{provider?:string}\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Placement>\n+function M:show(opts)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local placement = self:new_placement(opts)\n+  placement\n+    :show(opts)\n+    :on_ok(function()\n+      promise:ok(placement)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Creates a placement of this image that is not yet visible.\n+---@param opts? {provider?:string}\n+---@return vim.ui.img.Placement\n+function M:new_placement(opts)\n+  return require('vim.ui.img.placement').new(self, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102012838",
            "id": 2102012838,
            "in_reply_to_id": 2099946349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59Sium",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 554,
            "original_position": 554,
            "original_start_line": 550,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2860370862,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102012838/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T08:53:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102012838",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102204093"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102204093"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The use cases for showing the same image multiple times, is probably quite limited. I can only really think of demo type effects, games and repeated UI elements. So, I think limiting the interface to only support images would be fine.\r\n\r\nFurthermore, I'm pretty sure this can be optimized on the provider side. It can calculate the hash of the image data and properties and internally share it and keep track of the ids.\r\n\r\n",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T10:20:54Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)\n+  opts = opts or {}\n+\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.convert',\n+  })\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    table.insert(cmd, 'convert')\n+    table.insert(cmd, self.filename)\n+\n+    if opts.background then\n+      table.insert(cmd, '-background')\n+      table.insert(cmd, opts.background)\n+      table.insert(cmd, '-flatten')\n+    end\n+    if opts.crop then\n+      local region = opts.crop:to_pixels()\n+      table.insert(cmd, '-crop')\n+      table.insert(\n+        cmd,\n+        string.format('%sx%s+%s+%s', region.width, region.height, region.x, region.y)\n+      )\n+    end\n+    if opts.size then\n+      local size_px = opts.size:to_pixels()\n+      table.insert(cmd, '-resize')\n+      table.insert(cmd, string.format('%sx%s', size_px.width, size_px.height))\n+    end\n+\n+    if opts.quality then\n+      table.insert(cmd, '-quality')\n+      table.insert(cmd, tostring(opts.quality))\n+    end\n+\n+    local format = opts.format or 'png'\n+    local output = opts.out or '-'\n+    table.insert(cmd, format .. ':' .. output)\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to convert image')\n+        return\n+      end\n+\n+      -- In the case we wrote to a file, there's nothing to capture\n+      if opts.out ~= nil then\n+        promise:ok('')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('converted image output missing')\n+        return\n+      end\n+\n+      promise:ok(data)\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Displays an image, returning a reference to its visual representation (placement).\n+---```lua\n+---local img = ...\n+---\n+-----Can be invoked synchronously\n+---local placement = assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err, placement)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts|{provider?:string}\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Placement>\n+function M:show(opts)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local placement = self:new_placement(opts)\n+  placement\n+    :show(opts)\n+    :on_ok(function()\n+      promise:ok(placement)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Creates a placement of this image that is not yet visible.\n+---@param opts? {provider?:string}\n+---@return vim.ui.img.Placement\n+function M:new_placement(opts)\n+  return require('vim.ui.img.placement').new(self, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102204093",
            "id": 2102204093,
            "in_reply_to_id": 2099946349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59TRa9",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 554,
            "original_position": 554,
            "original_start_line": 550,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2860676044,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102204093/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T10:20:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102204093",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102215795"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102215795"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, I think supporting png only is reasonable. It also makes storing the images in memory more efficient, which we will need to do, since Kitty has a limited buffer size and images can be evicted.\r\n\r\nWhat makes the evection even worse, is that on tmux with pass through, we don't have a way to know when that happens or how much quota is used. So, I think the only safe way to do it, is to re-upload the image to kitty each time a new image is brought to view.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T10:26:10Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102215795",
            "id": 2102215795,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59TURz",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2860690107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102215795/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T10:26:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102215795",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102485229"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102485229"
                }
            },
            "author_association": "NONE",
            "body": "> The use cases for showing the same image multiple times, is probably quite limited. I can only really think of demo type effects, games and repeated UI elements. So, I think limiting the interface to only support images would be fine.\n\nTotally fair! I don't have a use case for same image repeated, and should be able to merge placement and image without much trouble. \n\n> Furthermore, I'm pretty sure this can be optimized on the provider side. It can calculate the hash of the image data and properties and internally share it and keep track of the ids.\n> \n> \n\nYep! I already do that within the sixel and iterm2 providers, and it works well. So agreed the optimization can be on the provider side. :smile:\n\nWill make the change along with the other requests. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T12:51:42Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)\n+  opts = opts or {}\n+\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.convert',\n+  })\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    table.insert(cmd, 'convert')\n+    table.insert(cmd, self.filename)\n+\n+    if opts.background then\n+      table.insert(cmd, '-background')\n+      table.insert(cmd, opts.background)\n+      table.insert(cmd, '-flatten')\n+    end\n+    if opts.crop then\n+      local region = opts.crop:to_pixels()\n+      table.insert(cmd, '-crop')\n+      table.insert(\n+        cmd,\n+        string.format('%sx%s+%s+%s', region.width, region.height, region.x, region.y)\n+      )\n+    end\n+    if opts.size then\n+      local size_px = opts.size:to_pixels()\n+      table.insert(cmd, '-resize')\n+      table.insert(cmd, string.format('%sx%s', size_px.width, size_px.height))\n+    end\n+\n+    if opts.quality then\n+      table.insert(cmd, '-quality')\n+      table.insert(cmd, tostring(opts.quality))\n+    end\n+\n+    local format = opts.format or 'png'\n+    local output = opts.out or '-'\n+    table.insert(cmd, format .. ':' .. output)\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to convert image')\n+        return\n+      end\n+\n+      -- In the case we wrote to a file, there's nothing to capture\n+      if opts.out ~= nil then\n+        promise:ok('')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('converted image output missing')\n+        return\n+      end\n+\n+      promise:ok(data)\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Displays an image, returning a reference to its visual representation (placement).\n+---```lua\n+---local img = ...\n+---\n+-----Can be invoked synchronously\n+---local placement = assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err, placement)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts|{provider?:string}\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Placement>\n+function M:show(opts)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local placement = self:new_placement(opts)\n+  placement\n+    :show(opts)\n+    :on_ok(function()\n+      promise:ok(placement)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Creates a placement of this image that is not yet visible.\n+---@param opts? {provider?:string}\n+---@return vim.ui.img.Placement\n+function M:new_placement(opts)\n+  return require('vim.ui.img.placement').new(self, opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102485229",
            "id": 2102485229,
            "in_reply_to_id": 2099946349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59UWDt",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 554,
            "original_position": 554,
            "original_start_line": 550,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2861108732,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102485229/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T12:52:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102485229",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102494940"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102494940"
                }
            },
            "author_association": "NONE",
            "body": "@fredizzimo in snacks they use a least recently used queue to know which images to re-upload. I was going to implement that, but held off when discussion started back.\n\nOr we transmit again every time, but that definitely has noticeable performance considerations from what I saw with iterm2 and sixel.\n\nLRU out of scope for this PR? Retransmitting out of scope for this PR? ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T12:56:20Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102494940",
            "id": 2102494940,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59UYbc",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2861123968,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102494940/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T12:56:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102494940",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102502029"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102502029"
                }
            },
            "author_association": "NONE",
            "body": "By the way, if we aren't cropping, then there's no confusion on unit type for conversions and number will be cell like you said, so I'm going to delete all of the screen code. ",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T12:59:33Z",
            "diff_hunk": "@@ -0,0 +1,149 @@\n+---@class vim.ui.img.utils.ScreenSize\n+---@field width number in pixels (may be fractional)\n+---@field height number in pixels (may be fractional)\n+---@field columns integer\n+---@field rows integer\n+---@field cell_width number in pixels (may be fractional)\n+---@field cell_height number in pixels (may be fractional)\n+---@field scale number dpi\n+\n+---@class vim.ui.img.utils.Screen\n+---@field private __def boolean has created necessary cdefs\n+---@field private __size vim.ui.img.utils.ScreenSize|nil cached screen size\n+local M = {\n+  __def = false,\n+  __size = nil,\n+}\n+\n+vim.api.nvim_create_autocmd('VimResized', {\n+  desc = 'Screen size has changed',\n+  callback = function()\n+    -- Clear our cache when the screen size changes\n+    M.__size = nil\n+  end,\n+})\n+\n+---Convert an integer representing absolute pixels to a cell.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.pixels_to_cells(x, y)\n+  local size = M.size()\n+  return math.floor((x / size.cell_width) + 0.5), math.floor((y / size.cell_height) + 0.5)\n+end\n+\n+---Convert an integer representing a cell to absolute pixels.\n+---Rounds to the nearest integer.\n+---@param x integer\n+---@param y integer\n+---@return integer x, integer y\n+function M.cells_to_pixels(x, y)\n+  local size = M.size()\n+  return math.floor((x * size.cell_width) + 0.5), math.floor((y * size.cell_height) + 0.5)\n+end\n+\n+---Determines the size of the terminal screen.\n+---@return vim.ui.img.utils.ScreenSize\n+function M.size()\n+  local size = M.__size\n+\n+  if size then\n+    return size\n+  end\n+\n+  if vim.fn.has('unix') == 1 then\n+    size = M.__posix_size()\n+  end\n+\n+  M.__size = size or M.__default_size()\n+\n+  return M.__size\n+end\n+\n+---@private\n+---Determines the size of the terminal screen for POSIX systems.\n+---@return vim.ui.img.utils.ScreenSize|nil\n+function M.__posix_size()\n+  ---@type vim.ui.img.utils.ScreenSize|nil\n+  local size\n+\n+  -- On Linux/Android, BSD, MacOS, and Solaris we use\n+  -- ioctl with TIOCGWINSZ to calculate the size.",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102502029",
            "id": 2102502029,
            "in_reply_to_id": 2099907343,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59UaKN",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 72,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/utils/screen.lua",
            "position": null,
            "pull_request_review_id": 2861134581,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102502029/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T12:59:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102502029",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102565831"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102565831"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think we only need to retransmit when a new image appears, not for every movement, but yes it could still be annoying when scrolling up and down.\r\n\r\nLRU, with some size limit could work. The only thing we really have to be careful with is when the image is displayed in tmux or similar, in the other cases, neovim has full control.  And the same thing applies to unique id collisions, not much we can do about that in a tmux context.\r\n\r\nSince this does not affect the interface, I would vote for out of scope.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T13:28:13Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102565831",
            "id": 2102565831,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59UpvH",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2861237149,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102565831/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T13:28:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102565831",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2102591741"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102591741"
                }
            },
            "author_association": "MEMBER",
            "body": "For LRU we have `vim.ringbuf`. But yes, let's save performance improvements for a followup, not here.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T13:38:55Z",
            "diff_hunk": "@@ -0,0 +1,557 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field bytes string|nil bytes of the image loaded into memory\n+---@field filename string path to the image on disk\n+---@field private __metadata vim.ui.img.Metadata\n+local M = {}\n+M.__index = M\n+\n+---Path to the directory where images may be cached.\n+---@type string\n+---@diagnostic disable-next-line:param-type-mismatch\n+M.cache_dir = vim.fs.joinpath(vim.fn.stdpath('cache'), 'img')\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded bytes.\n+---@param opts string|{bytes?:string, filename:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.bytes', opts.bytes, 'string', true)\n+    vim.validate('opts.filename', opts.filename, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__metadata = {}\n+  if type(opts) == 'table' then\n+    instance.bytes = opts.bytes\n+    instance.filename = opts.filename\n+  elseif type(opts) == 'string' then\n+    instance.filename = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads bytes for an image from a local file.\n+---@param filename string\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M.load(filename)\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ filename = filename })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the bytes for an image from its filename.\n+---@return vim.ui.img.utils.Promise<vim.NIL>\n+function M:reload()\n+  local filename = self.filename\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(filename, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(filename, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, bytes)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.bytes = bytes or ''\n+        self.filename = filename\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(vim.NIL)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's bytes, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.bytes or '')\n+end\n+\n+---Returns a hash (sha256) of the image's bytes.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.bytes or '')\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the bytes of the file.\n+---Works without ImageMagick.\n+---@return boolean\n+function M:is_png()\n+  if self.__metadata.format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded bytes, or synchronously load the file magic number\n+  local bytes = self.bytes\n+  if not bytes then\n+    local fd = assert(vim.uv.fs_open(self.filename, 'r', 0))\n+    bytes = assert(vim.uv.fs_read(fd, 8, nil)) or ''\n+    vim.uv.fs_close(fd, function() end)\n+  end\n+\n+  local is_png = string.sub(bytes, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__metadata.format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Converts this image into a PNG version.\n+---Default compression is 7 and filter type is 5.\n+---@param opts? {compression?:0|1|2|3|4|5|6|7|8|9, filter?:0|1|2|3|4|5|6|7|8|9, force?:boolean}\n+---@return vim.ui.img.utils.Promise<vim.ui.Image>\n+function M:into_png(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.into_png',\n+  })\n+\n+  -- If true and trying to use cache, will force recreation\n+  local force = opts.force or false\n+  local compression = opts.compression\n+  local filter_type = opts.filter\n+\n+  ---@type integer|nil\n+  local quality = nil\n+  if compression or filter_type then\n+    quality = ((compression or 7) * 10) + ((filter_type or 5) % 10)\n+  end\n+\n+  -- If image is a png, we are good to show it as is,\n+  -- otherwise we'll need to convert it to a png\n+  if self:is_png() and not force then\n+    return promise:ok(self)\n+  end\n+\n+  local cache_dir = M.cache_dir\n+  assert(vim.fn.mkdir(cache_dir, 'p') == 1, 'failed to create ' .. cache_dir)\n+\n+  vim.uv.fs_realpath(\n+    self.filename,\n+    vim.schedule_wrap(function(err_realpath, path)\n+      if err_realpath then\n+        promise:fail(err_realpath)\n+        return\n+      end\n+\n+      -- Cached output image uses a sha256 of the full path to the original file\n+      -- so we don't accidentally use a previously-cached image with a similar name\n+      local out = vim.fs.joinpath(cache_dir, string.format('%s.png', vim.fn.sha256(path)))\n+      local png = vim.ui.img.new(out)\n+\n+      -- Check if the image already exists\n+      vim.uv.fs_stat(out, function(_, stat)\n+        if stat and not force then\n+          png\n+            :into_png(opts)\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        else\n+          self\n+            :convert({ format = 'png', out = out, quality = quality })\n+            :on_ok(function()\n+              promise:ok(png)\n+            end)\n+            :on_fail(function(err)\n+              promise:fail(err)\n+            end)\n+        end\n+      end)\n+    end)\n+  )\n+\n+  return promise\n+end\n+\n+---@class vim.ui.img.IdentifyOpts\n+---@field format? boolean\n+---@field size? boolean\n+---@field [string] string|nil\n+\n+---@class vim.ui.img.Metadata\n+---@field format? string\n+---@field size? vim.ui.img.utils.Size\n+---@field [string] string|nil\n+\n+---Returns information about the image by invoking ImageMagick's identify.\n+---This will be some uppercase string like 'PNG'.\n+---@param opts? vim.ui.img.IdentifyOpts\n+---@return vim.ui.img.utils.Promise<vim.ui.img.Metadata>\n+function M:identify(opts)\n+  opts = opts or {}\n+  local promise = require('vim.ui.img.utils.promise').new({\n+    context = 'image.identify',\n+  })\n+\n+  -- If everything we want is already cached, return it\n+  local has_everything = true\n+  ---@cast opts table<string, string|boolean>\n+  for name, want in pairs(opts) do\n+    if want and self.__metadata[name] == nil then\n+      has_everything = false\n+      break\n+    end\n+  end\n+\n+  if has_everything then\n+    return promise:ok(self.__metadata)\n+  end\n+\n+  -- Schedule now to allow access to the ImageMagick option\n+  -- in the case that we're currently in a fast function\n+  vim.schedule(function()\n+    -- Build a string representing our format in json\n+    local format = {\n+      format = opts.format and '%m' or nil,\n+      width = opts.size and '%w' or nil,\n+      height = opts.size and '%h' or nil,\n+    }\n+\n+    -- Support extra requests that follow ImageMagick's escape formatting\n+    -- E.g. [\"depth\"] = \"%z\" will include the image depth as \"depth\"\n+    for name, value in pairs(opts) do\n+      if type(value) == 'string' then\n+        format[name] = value\n+      end\n+    end\n+\n+    ---@type string[]\n+    local cmd = require('vim.ui.img.utils').split_quoted(vim.o.imgprg)\n+    vim.list_extend(cmd, {\n+      'identify',\n+      '-format',\n+      vim.json.encode(format),\n+      self.filename,\n+    })\n+\n+    local ok, err = pcall(vim.system, cmd, nil, function(out)\n+      if out.code ~= 0 then\n+        promise:fail(out.stderr and out.stderr or 'failed to identify image')\n+        return\n+      end\n+\n+      local data = out.stdout\n+      if not data or data == '' then\n+        promise:fail('failed to identify image')\n+        return\n+      end\n+\n+      ---@type boolean, table<string, string>|string\n+      local ok, tbl_or_err = pcall(vim.json.decode, vim.trim(data), {\n+        array = true,\n+        object = true,\n+      })\n+      if not ok then\n+        ---@cast tbl_or_err string\n+        promise:fail(tbl_or_err)\n+        return\n+      else\n+        ---@cast tbl_or_err -string\n+        local tbl = tbl_or_err\n+\n+        local size = nil\n+        if tbl.width and tbl.height then\n+          local width = tonumber(tbl.width)\n+          local height = tonumber(tbl.height)\n+          if width and height then\n+            size = require('vim.ui.img.utils.size').new({\n+              width = width,\n+              height = height,\n+              unit = 'pixel',\n+            })\n+          end\n+        end\n+\n+        -- Update our cached metadata\n+        self.__metadata.format = tbl.format or self.__metadata.format\n+        self.__metadata.size = size or self.__metadata.size\n+\n+        promise:ok({\n+          format = tbl.format,\n+          size = size,\n+        })\n+      end\n+    end)\n+\n+    if not ok then\n+      ---@cast err +string\n+      ---@cast err -vim.SystemObj\n+      promise:fail(err)\n+    end\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the bytes using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk bytes\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local bytes = self.bytes\n+  if not bytes or bytes == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    bytes = vim.base64.encode(bytes)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(bytes)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = bytes:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@class (exact) vim.ui.img.ConvertOpts\n+---@field background? string hex string representing background color\n+---@field crop? vim.ui.img.utils.Region\n+---@field format? string such as 'png', 'rgb', or 'sixel' (default 'png')\n+---@field out? string write to output instead of stdout\n+---@field quality? integer default for PNG is 75 (see https://imagemagick.org/script/command-line-options.php#quality)\n+---@field size? vim.ui.img.utils.Size\n+---@field timeout? integer maximum time (in milliseconds) to wait for conversion\n+\n+---Converts an image using ImageMagick, returning the bytes of the new image.\n+---\n+---If `background` is specified, will convert alpha pixels to the background color (e.g. #ABCDEF).\n+---If `crop` is specified, will crop the image to the specified pixel dimensions.\n+---If `format` is specified, will convert to the image format, defaulting to png.\n+---If `out` is specified, will treat as output file and write to it, and promise returns empty str.\n+---If `size` is specified, will resize the image to the desired size.\n+---@param opts? vim.ui.img.ConvertOpts\n+---@return vim.ui.img.utils.Promise<string>\n+function M:convert(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2102591741",
            "id": 2102591741,
            "in_reply_to_id": 2099943027,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59UwD9",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 444,
            "original_position": 444,
            "original_start_line": 435,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": null,
            "pull_request_review_id": 2861279501,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102591741/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-22T13:38:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2102591741",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103403210"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103403210"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "If the position is not meant to be dynamically updated when the mouse or window moves, I think this calculation should be moved out of the provider. And the provider gets the precalculated position.\r\n\r\nI had previously assumed that it was up to the provider to dynamically watch and update this, partially because of the mouse movement demo. But looking at the code, that does not appear to be the case.\r\n\r\nIf could be interesting though if it is updated dynamically by the provider, for example Neovide could move the image pixel by pixel with the mouse, and the image would follow smoothly with an animated window.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:09:50Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103403210",
            "id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X2LK",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862577656,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103403210/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:09:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103403210",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103407760"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103407760"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Hm... Maybe it has to be on the provider side after all, in the case of multigrid with custom window placement, only the provider will know the location it should be displayed.\r\n\r\nIn any case, it needs to be specified if it's supposed to dynamically update or not",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:13:38Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103407760",
            "id": 2103407760,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X3SQ",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862584213,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103407760/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:13:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103407760",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103421009"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103421009"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It gets even more tricky than that. Since the provider processes this asynchronously, the cursor or mouse might have moved since the request, which results in another image location than intended. So, I think it has to be either continuously on the provider side, or immediately when the request is done outside the provider. \r\n\r\nThat means that multigrid UIs that make their own placement breaks, but that's the case with a lot of things, so I don't think it's a huge problem. These kinds of UIs probably need their own specialized plugins anyway. Also with inline placement, none of this is a problem, other than that the image will never follow the mouse or cursor automatically.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:25:26Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103421009",
            "id": 2103421009,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X6hR",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862603507,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103421009/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:25:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103421009",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103431084"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103431084"
                }
            },
            "author_association": "NONE",
            "body": "This is batched together and not sent immediately. That's what the writer does when it calls `flush()`. So it aggregates:\r\n\r\n1. Saving the cursor\r\n2. Hiding the cursor\r\n3. Moving to a new location\r\n4. Sending the display request\r\n5. Restoring the cursor position\r\n6. Showing the cursor\r\n\r\nAll of that is sent at once, so the jump of the cursor and return to its original position (wherever that may be) is really quick.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:35:11Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103431084",
            "id": 2103431084,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X8-s",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862618538,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103431084/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:35:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103431084",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103435087"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435087"
                }
            },
            "author_association": "NONE",
            "body": "> If the position is not meant to be dynamically updated when the mouse or window moves, I think this calculation should be moved out of the provider. And the provider gets the precalculated position.\r\n\r\nThis is a static location sent to the provider. The call to `position()` just figures out the row and column based on the `relative` field. So, not a dynamic moving position. Every time you call `position()` it will return the same value unless you change the opts.\r\n\r\nIt's a helper function attached to the opts so each provider doesn't need to implement that calculation itself.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:39:15Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103435087",
            "id": 2103435087,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X99P",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862624338,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435087/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:39:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435087",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103435398"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435398"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I'm talking about this sequence and the positions specified by the placement\r\n\r\n1. The user clicks somewhere\r\n2. It takes x amount of time until the request is processed by the provider, which might be on a remote machine. With UI updates being batched.\r\n3. At this point the Neovim cursor or mouse pointer might have moved",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:39:35Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103435398",
            "id": 2103435398,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X-CG",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862624830,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435398/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:39:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103435398",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2103442833"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103442833"
                }
            },
            "author_association": "NONE",
            "body": "Oh, I see. Yeah, to avoid that, we'd need to calculate it on the spot before sending to the provider.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-22T21:46:57Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2103442833",
            "id": 2103442833,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59X_2R",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2862635631,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103442833/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-22T21:46:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2103442833",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2104632379"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104632379"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "One way to fix this, would be to remove the support for `opts.Relative`, and only support `editor` for now, I'm not sure how much convenance functionality the protocol should provide, those are all easy to do on the caller side.\r\n\r\nAnd as I mentioned, another option is to make it dynamic, meaning it updates in real-time when the cursor or mouse is moved. In that case it would also do something that can't be done otherwise.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-23T13:46:12Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2104632379",
            "id": 2104632379,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59ciQ7",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2864487978,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104632379/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-23T13:46:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2104632379",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105480475"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105480475"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The indexing of this function is inconsistent and unclear. Personally, I think that all of them should be 0-indexed, since we are specifying offsets. \r\n\r\nCurrently, you need to specify 1-indexed positions, even for the ones that are commented as 0-indexed, since the terminal cursor position is 1-indexed\r\n\r\nWell, technically you can specify both 0 and 1 to mean the edge of the editor, but to leave one space you need to pass 2",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-23T22:12:17Z",
            "diff_hunk": "@@ -0,0 +1,126 @@\n+---@alias vim.ui.img.opts.Relative 'editor'|'win'|'cursor'|'mouse'\n+\n+---@class vim.ui.img.Opts\n+---@field relative? vim.ui.img.opts.Relative\n+---@field crop? vim.ui.img.utils.Region portion of image to display\n+---@field pos? vim.ui.img.utils.Position upper-left position of image within editor\n+---@field size? vim.ui.img.utils.Size explicit size to scale the image\n+---@field win? integer window to use when `relative` is `win`\n+---@field z? integer z-index of the image with lower values being drawn before higher values\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image opts instance, copying from `opts` any fields.\n+---Performs type checks and transformations into typed objects.\n+---@param opts? table\n+---@return vim.ui.img.Opts\n+function M.new(opts)\n+  opts = opts or {}\n+\n+  -- NOTE: We copy the opts to ensure that other fields carry forward\n+  --       alongside the fields that we type check.\n+  local instance = vim.deepcopy(opts)\n+  setmetatable(instance, M)\n+\n+  local Position = require('vim.ui.img.utils.position')\n+  local Region = require('vim.ui.img.utils.region')\n+  local Size = require('vim.ui.img.utils.size')\n+\n+  ---@type vim.ui.img.opts.Relative|nil\n+  local relative = opts.relative\n+  vim.validate('opts.relative', relative, 'string', true)\n+\n+  ---@type vim.ui.img.utils.Region|nil\n+  local crop = opts.crop\n+  vim.validate('opts.crop', crop, 'table', true)\n+  if type(crop) == 'table' then\n+    crop = Region.new(crop)\n+  end\n+\n+  ---@type vim.ui.img.utils.Position|nil\n+  local pos = opts.pos\n+  vim.validate('opts.pos', pos, 'table', true)\n+  if type(pos) == 'table' then\n+    pos = Position.new(pos)\n+  end\n+\n+  ---@type vim.ui.img.utils.Size|nil\n+  local size = opts.size\n+  vim.validate('opts.size', size, 'table', true)\n+  if type(size) == 'table' then\n+    size = Size.new(size)\n+  end\n+\n+  ---@type integer|nil\n+  local win = opts.win\n+  vim.validate('opts.win', win, 'number', true)\n+\n+  ---@type integer|nil\n+  local z = opts.z\n+  vim.validate('opts.z', z, 'number', true)\n+\n+  instance.relative = relative\n+  instance.crop = crop\n+  instance.pos = pos\n+  instance.size = size\n+  instance.win = win\n+  instance.z = z\n+\n+  return instance\n+end\n+\n+---Calculates and returns the position dictated by `relative` and `pos`.\n+---@return vim.ui.img.utils.Position\n+function M:position()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105480475",
            "id": 2105480475,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59fxUb",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 74,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/opts.lua",
            "position": null,
            "pull_request_review_id": 2865818565,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105480475/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-23T22:15:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105480475",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105689843"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105689843"
                }
            },
            "author_association": "NONE",
            "body": "@fredizzimo I just submitted a bunch of cleanup, and a distinct commit to try to solve this. I just updated the data structure that is fed to the provider to just have a row, col, optional width/height, and optional z.\r\n\r\nThe user-provided opts get mapped to the internal opts used by the provider. This gets calculated at the point in time when the user wants to show/update an image, and the provider can assume it always has the precalculated opts. Thoughts?",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-24T03:44:42Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105689843",
            "id": 2105689843,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59gkbz",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2866068639,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105689843/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-24T03:44:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105689843",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105910043"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105910043"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, I think this part looks good now. We can possibly add real-time update support with an option in the future if needed.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-24T19:20:41Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+---Kitty supports 4096 bytes per chunk when sending remote client data.\n+---\n+local MAX_DATA_CHUNK = 4096\n+\n+---@class vim.ui.img.providers.Kitty\n+---@field private __autocmds integer[]\n+---@field private __has_loaded boolean loaded at least once\n+---@field private __images table<integer, integer> neovim image id -> kitty image id\n+---@field private __is_tmux boolean\n+---@field private __placements table<integer, integer> kitty placement id -> kitty image id\n+---@field private __writer vim.ui.img.utils.BatchWriter\n+local M = {\n+  __autocmds = {},\n+  __has_loaded = false,\n+  __images = {},\n+  __is_tmux = false,\n+  __placements = {},\n+  __writer = nil, -- To be filled in during load()\n+}\n+\n+---@param opts? {write?:fun(...:string)}\n+function M:load(opts)\n+  opts = opts or {}\n+\n+  if self.__has_loaded then\n+    return\n+  end\n+\n+  -- Check if we are inside tmux, and if so we need to configure it to support\n+  -- allowing passthrough of escape codes for kitty's graphics protocol and\n+  -- flag that we need to transform escape codes sent to be compliant with tmux\n+  if vim.env['TMUX'] ~= nil then\n+    local res = vim.system({ 'tmux', 'set', '-p', 'allow-passthrough', 'all' }):wait()\n+    assert(res.code == 0, 'failed to \"set -p allow-passthrough all\" for tmux')\n+    self.__is_tmux = true\n+  end\n+\n+  local utils = require('vim.ui.img.utils')\n+  self.__writer = utils.new_batch_writer({\n+    use_chan_send = true,\n+    map = function(s)\n+      if self.__is_tmux then\n+        s = utils.codes.escape_tmux_passthrough(s)\n+      end\n+      return s\n+    end,\n+    write = opts.write,\n+  })\n+\n+  -- For kitty, we want to make sure that we properly unload when exiting\n+  -- neovim, especially if we're in tmux\n+  table.insert(\n+    self.__autocmds,\n+    vim.api.nvim_create_autocmd('VimLeavePre', {\n+      callback = function()\n+        self:unload()\n+      end,\n+    })\n+  )\n+\n+  self.__has_loaded = true\n+end\n+\n+function M:unload()\n+  self:__delete_all()\n+\n+  for _, id in ipairs(self.__autocmds) do\n+    pcall(vim.api.nvim_del_autocmd, id)\n+  end\n+\n+  self.__autocmds = {}\n+  self.__images = {}\n+  self.__is_tmux = false\n+  self.__placements = {}\n+  self.__writer = nil\n+end\n+\n+---@param on_supported fun(supported:boolean)\n+function M:supported(on_supported)\n+  -- TODO: Kitty recommends sending a DA1 request after the\n+  --       query regarding kitty support, which would let us\n+  --       determine faster (as soon as we get DA1 response)\n+  --       that kitty is unsupported. We cannot do this until\n+  --       CSI responses are supported in TermResponse.\n+  --\n+  --       In fact, this does not work right now as kitty's\n+  --       response seems to get partially-consumed by neovim\n+  --       and results in arbitrary key presses.\n+  local query = '\\027_Gi=31,s=10,v=2,t=s;YQ==\\027\\\\'\n+  local promise = require('vim.ui.img.utils').query_term(query, {\n+    -- Not a guarantee that we're loaded when this is called,\n+    -- so we try to make use of our writer if we are, otherwise\n+    -- we default to stdout to send our query\n+    write = self.__writer and self.__writer.write_fast or nil,\n+  }, function(seq)\n+    -- Get OK or some error response\n+    local pattern = '\\027_Gi=%d+;[^\\027]*\\027\\\\'\n+    if string.find(seq, pattern) then\n+      return true\n+    end\n+  end)\n+\n+  promise:on_ok(on_supported):on_fail(function()\n+    on_supported(false)\n+  end)\n+end\n+\n+---@param img vim.ui.Image\n+---@param opts vim.ui.img.Opts\n+---@param on_shown fun(err:string|nil, id:integer|nil)\n+function M:show(img, opts, on_shown)\n+  on_shown = vim.schedule_wrap(on_shown)\n+\n+  ---@param png vim.ui.Image\n+  local function do_show(png)\n+    -- Check if we need to transmit our image or if it is already available\n+    -- TODO: This should really query to see if the image is still loaded\n+    --       otherwise re-transmit the image. This is especially apparent\n+    --       when switching between providers as something happens to clear\n+    --       the images (I think) and they don't show up anymore\n+    local image_id = self.__images[png.id]\n+    if not image_id then\n+      -- If remote, we have to use a direct transmit instead of file\n+      if self:__is_remote() then\n+        image_id = self:__transmit_image_direct(png)\n+      else\n+        image_id = self:__transmit_image_file(png)\n+      end\n+      self.__images[png.id] = image_id\n+    end\n+\n+    local placement_id = self:__display_image(image_id, opts)\n+    self.__placements[placement_id] = image_id\n+\n+    -- Since we're writing the image display and ignoring the response,\n+    -- we will just assume that no Lua error at this point means success\n+    on_shown(nil, placement_id)\n+  end\n+\n+  img:into_png():on_ok(do_show):on_fail(on_shown)\n+end\n+\n+---@param ids integer[]\n+---@param on_hidden fun(err:string|nil, ids:integer[]|nil)\n+function M:hide(ids, on_hidden)\n+  for _, pid in ipairs(ids) do\n+    local id = self.__placements[pid]\n+    if id then\n+      self:__delete_image_or_placement(id, pid)\n+      self.__placements[pid] = nil\n+    end\n+  end\n+\n+  -- Since we're writing the image deletion and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_hidden(nil, ids)\n+  end)\n+end\n+\n+---@param pid integer\n+---@param opts vim.ui.img.Opts\n+---@param on_updated fun(err:string|nil, id:integer|nil)\n+function M:update(pid, opts, on_updated)\n+  local id = assert(self.__placements[pid], string.format('kitty(update): invalid id %s', pid))\n+\n+  ---@diagnostic disable-next-line:inject-field\n+  opts.pid = pid\n+\n+  local new_id = self:__display_image(id, opts)\n+\n+  -- Since we're writing the image display and ignoring the response,\n+  -- we will just assume that no Lua error at this point means success\n+  vim.schedule(function()\n+    on_updated(nil, new_id)\n+  end)\n+end\n+\n+---@private\n+---Kitty operates via graphics codes in the form:\n+---\n+---    <ESC>_G<control data>;<payload><ESC>\\\n+---\n+---This function converts the provided information into\n+---a graphics code sequence to be sent to the terminal.\n+---\n+---@param control table<string, string|number>\n+---@param payload? string\n+---@return string\n+function M:__make_seq(control, payload)\n+  ---Tokenized graphics code data\n+  ---@type string[]\n+  local data = {}\n+\n+  -- Begin the graphics code sequence\n+  table.insert(data, '\\027_G')\n+\n+  -- Build up our control data if we have any\n+  if control then\n+    local tmp = {}\n+    for k, v in pairs(control) do\n+      table.insert(tmp, k .. '=' .. v)\n+    end\n+\n+    -- Convert our series of k=v into k1=v1,k2=v2,...\n+    if #tmp > 0 then\n+      table.insert(data, table.concat(tmp, ','))\n+    end\n+  end\n+\n+  if payload and string.len(payload) > 0 then\n+    table.insert(data, ';')\n+    table.insert(data, payload)\n+  end\n+\n+  -- Finalize the graphics code sequence\n+  table.insert(data, '\\027\\\\')\n+\n+  return table.concat(data)\n+end\n+\n+---@private\n+---Transmit an image directly via a filesystem path.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_file(image)\n+  local id = self:__next_id()\n+\n+  local control = {}\n+  control['f'] = '100' -- Assume we are working with PNG\n+  control['a'] = 't' -- Transmit image data without displaying\n+  control['t'] = 'f' -- Signify that this is a file transmit\n+  control['i'] = id -- Specify the id of the image\n+  control['q'] = 2 -- Suppress all responses\n+\n+  -- Payload for a file transmit is the base64-encoded file path\n+  local payload = vim.base64.encode(image.filename)\n+\n+  self.__writer.write_fast(self:__make_seq(control, payload))\n+\n+  return id\n+end\n+\n+---@private\n+---Transmit an image directly via escape codes.\n+---\n+---This is the approach to take with remote clients (i.e. ssh) when the\n+---filesystem and shared memory are not accessible.\n+---@param image vim.ui.Image\n+---@return integer id unique id assigned to the image\n+function M:__transmit_image_direct(image)\n+  local id = self:__next_id()\n+\n+  -- If the image is not loaded yet, do so before directly transmitting it\n+  if image:len() == 0 then\n+    assert(image:reload():wait())\n+  end\n+\n+  ---@param chunk string data of chunk\n+  ---@param pos integer starting byte position of chunk\n+  ---@param last boolean true if final chunk\n+  image:chunks({ base64 = true, size = MAX_DATA_CHUNK }):each(function(chunk, pos, last)\n+    local control = {}\n+\n+    -- If at the beginning of our image, supply common control info\n+    if pos == 1 then\n+      control['f'] = '100' -- Assume we are working with PNG\n+      control['a'] = 't' -- Transmit image data without displaying\n+      control['t'] = 'd' -- Signify that this is a direct transmit\n+      control['i'] = id -- Specify the id of the image\n+      control['q'] = 2 -- Suppress all responses\n+    end\n+\n+    -- Mark whether we have more data to send\n+    control['m'] = last and 0 or 1\n+\n+    -- NOTE: This may need direct tty device access to function!\n+    self.__writer.write_fast(self:__make_seq(control, chunk))\n+  end)\n+\n+  return id\n+end\n+\n+---@private\n+---Display a transmitted image into the kitty terminal.\n+---@param id integer\n+---@param opts vim.ui.img.Opts|{pid?:integer}\n+---@return integer placement_id\n+function M:__display_image(id, opts)\n+  local utils = require('vim.ui.img.utils')\n+\n+  -- Create a unique placement id for this new display\n+  local pid = opts.pid or self:__next_id()\n+\n+  -- Ensure the queue is empty before we start a sequence\n+  self.__writer.flush()\n+\n+  -- Capture old cursor position, hide the cursor, and move to the\n+  -- position where the image should be displayed\n+  local pos = opts:position():to_cells()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105910043",
            "id": 2105910043,
            "in_reply_to_id": 2103403210,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59haMb",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 300,
            "original_position": 300,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/providers/kitty.lua",
            "position": null,
            "pull_request_review_id": 2866409998,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105910043/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-24T19:20:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105910043",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105913462"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105913462"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Another note regarding this. Snacks win could use `relative = win`, but in practice has to use `relative = editor`, since it needs to take the border into account.\r\n\r\nAnd now that we have `vim.ui.img.InternalOpts` for the provider, the indexing need to be specified for that as well. Right now, in my implementation, I'm assuming a 1-based index, since the Kitty provider use it directly.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-24T19:38:09Z",
            "diff_hunk": "@@ -0,0 +1,126 @@\n+---@alias vim.ui.img.opts.Relative 'editor'|'win'|'cursor'|'mouse'\n+\n+---@class vim.ui.img.Opts\n+---@field relative? vim.ui.img.opts.Relative\n+---@field crop? vim.ui.img.utils.Region portion of image to display\n+---@field pos? vim.ui.img.utils.Position upper-left position of image within editor\n+---@field size? vim.ui.img.utils.Size explicit size to scale the image\n+---@field win? integer window to use when `relative` is `win`\n+---@field z? integer z-index of the image with lower values being drawn before higher values\n+local M = {}\n+M.__index = M\n+\n+---Creates a new image opts instance, copying from `opts` any fields.\n+---Performs type checks and transformations into typed objects.\n+---@param opts? table\n+---@return vim.ui.img.Opts\n+function M.new(opts)\n+  opts = opts or {}\n+\n+  -- NOTE: We copy the opts to ensure that other fields carry forward\n+  --       alongside the fields that we type check.\n+  local instance = vim.deepcopy(opts)\n+  setmetatable(instance, M)\n+\n+  local Position = require('vim.ui.img.utils.position')\n+  local Region = require('vim.ui.img.utils.region')\n+  local Size = require('vim.ui.img.utils.size')\n+\n+  ---@type vim.ui.img.opts.Relative|nil\n+  local relative = opts.relative\n+  vim.validate('opts.relative', relative, 'string', true)\n+\n+  ---@type vim.ui.img.utils.Region|nil\n+  local crop = opts.crop\n+  vim.validate('opts.crop', crop, 'table', true)\n+  if type(crop) == 'table' then\n+    crop = Region.new(crop)\n+  end\n+\n+  ---@type vim.ui.img.utils.Position|nil\n+  local pos = opts.pos\n+  vim.validate('opts.pos', pos, 'table', true)\n+  if type(pos) == 'table' then\n+    pos = Position.new(pos)\n+  end\n+\n+  ---@type vim.ui.img.utils.Size|nil\n+  local size = opts.size\n+  vim.validate('opts.size', size, 'table', true)\n+  if type(size) == 'table' then\n+    size = Size.new(size)\n+  end\n+\n+  ---@type integer|nil\n+  local win = opts.win\n+  vim.validate('opts.win', win, 'number', true)\n+\n+  ---@type integer|nil\n+  local z = opts.z\n+  vim.validate('opts.z', z, 'number', true)\n+\n+  instance.relative = relative\n+  instance.crop = crop\n+  instance.pos = pos\n+  instance.size = size\n+  instance.win = win\n+  instance.z = z\n+\n+  return instance\n+end\n+\n+---Calculates and returns the position dictated by `relative` and `pos`.\n+---@return vim.ui.img.utils.Position\n+function M:position()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105913462",
            "id": 2105913462,
            "in_reply_to_id": 2105480475,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59hbB2",
            "original_commit_id": "ea8083808e962f43610556517192e2829010b832",
            "original_line": 74,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img/opts.lua",
            "position": null,
            "pull_request_review_id": 2866412870,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105913462/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-24T19:38:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105913462",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105914491"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105914491"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think this function could internally check if the image is visible or not, so that hide can be called multiple times, it makes the API more pleasant to use.",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-24T19:43:32Z",
            "diff_hunk": "@@ -0,0 +1,486 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field data string|nil data of the image loaded into memory\n+---@field file string path to the image on disk\n+---@field private __format string|nil\n+---@field private __id integer|nil when loaded, id is populated by provider\n+---@field private __provider string\n+---@field private __next {action:(fun():vim.ui.img._Promise<true>), promise:vim.ui.img._Promise<true>}|nil\n+---@field private __opts vim.ui.img.Opts|nil last opts of image when displayed\n+---@field private __redrawing boolean if true, image is actively redrawing itself\n+local M = {}\n+M.__index = M\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded data.\n+---@param opts string|{data?:string, file:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.data', opts.data, 'string', true)\n+    vim.validate('opts.file', opts.file, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__provider = 'kitty'\n+  instance.__redrawing = false\n+\n+  if type(opts) == 'table' then\n+    instance.data = opts.data\n+    instance.file = opts.file\n+  elseif type(opts) == 'string' then\n+    instance.file = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads data for an image from a local file.\n+---@param file string\n+---@return vim.ui.img._Promise<vim.ui.Image>\n+function M.load(file)\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ file = file })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the data for an image from its file.\n+---@return vim.ui.img._Promise<true>\n+function M:reload()\n+  local file = self.file\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(file, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(file, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, data)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.data = data or ''\n+        self.file = file\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(true)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's data, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.data or '')\n+end\n+\n+---Returns a hash (sha256) of the image's data.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.data or '')\n+end\n+\n+---Whether or not the image is actively shown.\n+---@return boolean\n+function M:is_visible()\n+  return self.__id ~= nil\n+end\n+\n+---Returns true if the image is actively redrawing itself in any situation:\n+---showing, hiding, or updating.\n+---@return boolean\n+function M:is_redrawing()\n+  return self.__redrawing\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the data of the file.\n+---Works without ImageMagick.\n+---@return boolean|nil\n+function M:is_png()\n+  if self.__format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded data, or synchronously load the file magic number\n+  local data = self.data\n+  if not data then\n+    local fd = vim.uv.fs_open(self.file, 'r', 0)\n+    if fd then\n+      data = vim.uv.fs_read(fd, 8, nil)\n+      vim.uv.fs_close(fd, function() end)\n+    end\n+  end\n+\n+  -- If unable to load data, we return an explicitly nil\n+  -- value to differentiate from a false value\n+  if not data then\n+    return\n+  end\n+\n+  local is_png = string.sub(data, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the data using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk data\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local data = self.data\n+  if not data or data == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    data = vim.base64.encode(data)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(data)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = data:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@private\n+---Loads the provider used to display and manage the image.\n+---@param opts? {write?:fun(...:string)}\n+---@return vim.ui.img.Provider|nil\n+function M:__load_provider(opts)\n+  return require('vim.ui.img.providers').load(self.__provider, opts)\n+end\n+\n+---Displays the image.\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+-----Can be invoked synchronously\n+---assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts\n+---@return vim.ui.img._Promise<true>\n+function M:show(opts)\n+  -- Update the opts to reflect what we should be showing next\n+  -- such that future updates can work properly in batch\n+  self.__opts = require('vim.ui.img.opts').new(opts)\n+\n+  return self:__schedule(self.__show, self, self.__opts:into_internal_opts())\n+end\n+\n+---@private\n+---@param opts vim.ui.img.InternalOpts\n+---@return vim.ui.img._Promise<true>\n+function M:__show(opts)\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local provider = self:__load_provider()\n+  if not provider then\n+    promise:fail('unable to retrieve provider')\n+  else\n+    provider\n+      .show(self, opts)\n+      :on_ok(function(id)\n+        self.__id = id\n+        promise:ok(true)\n+      end)\n+      :on_fail(function(show_err)\n+        promise:fail(show_err)\n+      end)\n+  end\n+\n+  return promise\n+end\n+\n+---Hides the image.\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+-----Can be invoked synchronously\n+---assert(img:hide():wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:hide():on_done(function(err)\n+---  -- Do something\n+---end)\n+---```\n+---@return vim.ui.img._Promise<true>\n+function M:hide()",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105914491",
            "id": 2105914491,
            "line": 329,
            "node_id": "PRRC_kwDOAPphoM59hbR7",
            "original_commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "original_line": 329,
            "original_position": 329,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": 329,
            "pull_request_review_id": 2866413740,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105914491/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-24T19:54:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105914491",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31399#discussion_r2105916134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31399"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105916134"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Update and show work almost the opposite way of what I would expect.\r\n\r\nOn one hand, show is used for initially showing an image, but on the other hand it can also be thought of a pair to hide. And in that case, I would like to be able to just re-use the existing options without specifying anything.\r\n\r\nI think we could use only one function, but support three modes\r\n1. nil opts - keep the existing configuration\r\n2. partial opts - merge the configuration\r\n3. full opts - replace the configuration\r\n\r\nThe difference between 2. and 3. could for example be expressed with a special field `update=true` to select mode 3, otherwise mode 2. is used. \r\n\r\n",
            "commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "created_at": "2025-05-24T19:53:04Z",
            "diff_hunk": "@@ -0,0 +1,486 @@\n+---Id of the last image created.\n+---@type integer\n+local LAST_IMAGE_ID = 0\n+\n+---@class vim.ui.Image\n+---@field id integer unique id associated with the image\n+---@field data string|nil data of the image loaded into memory\n+---@field file string path to the image on disk\n+---@field private __format string|nil\n+---@field private __id integer|nil when loaded, id is populated by provider\n+---@field private __provider string\n+---@field private __next {action:(fun():vim.ui.img._Promise<true>), promise:vim.ui.img._Promise<true>}|nil\n+---@field private __opts vim.ui.img.Opts|nil last opts of image when displayed\n+---@field private __redrawing boolean if true, image is actively redrawing itself\n+local M = {}\n+M.__index = M\n+\n+---Collection of names to associated providers used to display and manipulate images.\n+---@type vim.ui.img.Providers\n+M.providers = require('vim.ui.img.providers')\n+\n+---Creates a new image instance, optionally taking pre-loaded data.\n+---@param opts string|{data?:string, file:string}\n+---@return vim.ui.Image\n+function M.new(opts)\n+  vim.validate('opts', opts, { 'string', 'table' })\n+  if type(opts) == 'table' then\n+    vim.validate('opts.data', opts.data, 'string', true)\n+    vim.validate('opts.file', opts.file, 'string')\n+  end\n+\n+  local instance = {}\n+  setmetatable(instance, M)\n+\n+  instance.id = LAST_IMAGE_ID + 1\n+  instance.__provider = 'kitty'\n+  instance.__redrawing = false\n+\n+  if type(opts) == 'table' then\n+    instance.data = opts.data\n+    instance.file = opts.file\n+  elseif type(opts) == 'string' then\n+    instance.file = opts\n+  end\n+\n+  -- Bump our counter for future image ids\n+  LAST_IMAGE_ID = instance.id\n+\n+  return instance\n+end\n+\n+---Loads data for an image from a local file.\n+---@param file string\n+---@return vim.ui.img._Promise<vim.ui.Image>\n+function M.load(file)\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.load',\n+  })\n+\n+  local img = M.new({ file = file })\n+  img\n+    :reload()\n+    :on_ok(function()\n+      promise:ok(img)\n+    end)\n+    :on_fail(function(err)\n+      promise:fail(err)\n+    end)\n+\n+  return promise\n+end\n+\n+---Reloads the data for an image from its file.\n+---@return vim.ui.img._Promise<true>\n+function M:reload()\n+  local file = self.file\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.reload',\n+  })\n+\n+  ---@param err string|nil\n+  ---@return boolean\n+  local function report_err(err)\n+    if err then\n+      promise:fail(err)\n+    end\n+\n+    return err ~= nil\n+  end\n+\n+  vim.uv.fs_stat(file, function(stat_err, stat)\n+    if report_err(stat_err) then\n+      return\n+    end\n+    if not stat then\n+      report_err('missing stat')\n+      return\n+    end\n+\n+    vim.uv.fs_open(file, 'r', 644, function(open_err, fd)\n+      if report_err(open_err) then\n+        return\n+      end\n+      if not fd then\n+        report_err('missing fd')\n+        return\n+      end\n+\n+      vim.uv.fs_read(fd, stat.size, -1, function(read_err, data)\n+        if report_err(read_err) then\n+          return\n+        end\n+\n+        self.data = data or ''\n+        self.file = file\n+\n+        vim.uv.fs_close(fd, function()\n+          promise:ok(true)\n+        end)\n+      end)\n+    end)\n+  end)\n+\n+  return promise\n+end\n+\n+---Returns the byte length of the image's data, or 0 if not loaded.\n+---@return integer\n+function M:len()\n+  return string.len(self.data or '')\n+end\n+\n+---Returns a hash (sha256) of the image's data.\n+---@return string\n+function M:hash()\n+  return vim.fn.sha256(self.data or '')\n+end\n+\n+---Whether or not the image is actively shown.\n+---@return boolean\n+function M:is_visible()\n+  return self.__id ~= nil\n+end\n+\n+---Returns true if the image is actively redrawing itself in any situation:\n+---showing, hiding, or updating.\n+---@return boolean\n+function M:is_redrawing()\n+  return self.__redrawing\n+end\n+\n+---Check if the image is PNG format, optionally loading the magic number of the image.\n+---Will throw an error if unable to load the data of the file.\n+---Works without ImageMagick.\n+---@return boolean|nil\n+function M:is_png()\n+  if self.__format == 'PNG' then\n+    return true\n+  end\n+\n+  ---Magic number of a PNG file.\n+  ---@type string\n+  local PNG_SIGNATURE = '\\137PNG\\r\\n\\26\\n'\n+\n+  -- Use loaded data, or synchronously load the file magic number\n+  local data = self.data\n+  if not data then\n+    local fd = vim.uv.fs_open(self.file, 'r', 0)\n+    if fd then\n+      data = vim.uv.fs_read(fd, 8, nil)\n+      vim.uv.fs_close(fd, function() end)\n+    end\n+  end\n+\n+  -- If unable to load data, we return an explicitly nil\n+  -- value to differentiate from a false value\n+  if not data then\n+    return\n+  end\n+\n+  local is_png = string.sub(data, 1, #PNG_SIGNATURE) == PNG_SIGNATURE\n+  if is_png then\n+    self.__format = 'PNG'\n+  end\n+  return is_png\n+end\n+\n+---Returns an iterator over the chunks of the image, returning the chunk, byte position, and\n+---an indicator of whether the current chunk is the last chunk.\n+---\n+---If `base64=true`, will encode the data using base64 before iterating chunks.\n+---Takes an optional size to indicate how big each chunk should be, defaulting to 4096.\n+---\n+---Examples:\n+---\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+------@param chunk string\n+------@param pos integer\n+------@param last boolean\n+---img:chunks():each(function(chunk, pos, last)\n+---  vim.print(\"Chunk data\", chunk)\n+---  vim.print(\"Chunk starts at\", pos)\n+---  vim.print(\"Is last chunk\", last)\n+---end)\n+---```\n+---\n+---@param opts? {base64?:boolean, size?:integer}\n+---@return Iter\n+function M:chunks(opts)\n+  opts = opts or {}\n+\n+  -- Chunk size, defaulting to 4k\n+  local chunk_size = opts.size or 4096\n+\n+  local data = self.data\n+  if not data or data == '' then\n+    return vim.iter(function()\n+      return nil, nil, nil\n+    end)\n+  end\n+\n+  if opts.base64 then\n+    data = vim.base64.encode(data)\n+  end\n+\n+  local pos = 1\n+  local len = string.len(data)\n+\n+  return vim.iter(function()\n+    -- If we are past the last chunk, this iterator should terminate\n+    if pos > len then\n+      return nil, nil, nil\n+    end\n+\n+    -- Get our next chunk from [pos, pos + chunk_size)\n+    local end_pos = pos + chunk_size - 1\n+    local chunk = data:sub(pos, end_pos)\n+\n+    -- If we have a chunk available, mark as such\n+    local last = true\n+    if string.len(chunk) > 0 then\n+      last = not (end_pos + 1 <= len)\n+    end\n+\n+    -- Mark where our current chunk is positioned\n+    local chunk_pos = pos\n+\n+    -- Update our global position\n+    pos = end_pos + 1\n+\n+    return chunk, chunk_pos, last\n+  end)\n+end\n+\n+---@private\n+---Loads the provider used to display and manage the image.\n+---@param opts? {write?:fun(...:string)}\n+---@return vim.ui.img.Provider|nil\n+function M:__load_provider(opts)\n+  return require('vim.ui.img.providers').load(self.__provider, opts)\n+end\n+\n+---Displays the image.\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+-----Can be invoked synchronously\n+---assert(img:show({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:show({ ... }):on_done(function(err)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts\n+---@return vim.ui.img._Promise<true>\n+function M:show(opts)\n+  -- Update the opts to reflect what we should be showing next\n+  -- such that future updates can work properly in batch\n+  self.__opts = require('vim.ui.img.opts').new(opts)\n+\n+  return self:__schedule(self.__show, self, self.__opts:into_internal_opts())\n+end\n+\n+---@private\n+---@param opts vim.ui.img.InternalOpts\n+---@return vim.ui.img._Promise<true>\n+function M:__show(opts)\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.show',\n+  })\n+\n+  local provider = self:__load_provider()\n+  if not provider then\n+    promise:fail('unable to retrieve provider')\n+  else\n+    provider\n+      .show(self, opts)\n+      :on_ok(function(id)\n+        self.__id = id\n+        promise:ok(true)\n+      end)\n+      :on_fail(function(show_err)\n+        promise:fail(show_err)\n+      end)\n+  end\n+\n+  return promise\n+end\n+\n+---Hides the image.\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+-----Can be invoked synchronously\n+---assert(img:hide():wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:hide():on_done(function(err)\n+---  -- Do something\n+---end)\n+---```\n+---@return vim.ui.img._Promise<true>\n+function M:hide()\n+  -- Update the opts to reflect that we are showing nothing next\n+  -- such that future updates can work properly in batch\n+  self.__opts = nil\n+\n+  return self:__schedule(self.__hide, self)\n+end\n+\n+---@private\n+---@return vim.ui.img._Promise<true>\n+function M:__hide()\n+  local promise = require('vim.ui.img._promise').new({\n+    context = 'image.hide',\n+  })\n+\n+  local provider = self:__load_provider()\n+  if not provider then\n+    promise:fail('unable to retrieve provider')\n+  else\n+    provider\n+      .hide(self.__id)\n+      :on_ok(function()\n+        self.__id = nil\n+        promise:ok(true)\n+      end)\n+      :on_fail(function(hide_err)\n+        promise:fail(hide_err)\n+      end)\n+  end\n+\n+  return promise\n+end\n+\n+---Updates the image by altering any of the specified `opts`.\n+---```lua\n+----- Some predefined image\n+---local img = vim.ui.img.new({ ... })\n+---\n+-----Can be invoked synchronously\n+---assert(img:update({ ... }):wait())\n+---\n+-----Can also be invoked asynchronously\n+---img:update({ ... }):on_done(function(err)\n+---  -- Do something\n+---end)\n+---```\n+---@param opts? vim.ui.img.Opts\n+---@return vim.ui.img._Promise<true>\n+function M:update(opts)",
            "html_url": "https://github.com/neovim/neovim/pull/31399#discussion_r2105916134",
            "id": 2105916134,
            "line": 377,
            "node_id": "PRRC_kwDOAPphoM59hbrm",
            "original_commit_id": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
            "original_line": 377,
            "original_position": 377,
            "original_start_line": null,
            "path": "runtime/lua/vim/ui/img.lua",
            "position": 377,
            "pull_request_review_id": 2866413740,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105916134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-24T19:53:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2105916134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "NONE",
            "body": "Heads up, I know there is formatting of commit messages needed and linting for preferences in Lua style guides.\r\n\r\nThe current code is me migrating over my working code from a private repo - not a fork of neovim - to be a pull request here. I'll work on updating the PR to be compliant, but wanted the code to be visible for comments.\r\n\r\nIn particular, I could use help in rewriting that parts of the PR that make use of Lua's io library - assuming we want to use a neovim equivalent - and to refactor parts of the code that could be improved. So looking for stronger critique, challenges, and suggestions  This was an example-turned-PR, so not all of the code is high quality!\r\n\r\n---\r\n\r\nAn example of doing this with the current PR:\r\n\r\n![image-example-pr](https://github.com/user-attachments/assets/466de1a6-333f-4e97-a90f-ea3e1ae241da)\r\n\r\n```lua\r\nlocal file = vim.img.load({\r\n    filename = \"/Users/senkwich/Pictures/org-roam-logo.png\",\r\n})\r\n\r\nvim.img.show(file, {\r\n    pos = { row = 8, col = 8 }, \r\n    backend = \"iterm2\",\r\n})\r\n```\r\n",
            "created_at": "2024-11-30T00:42:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2508758798",
            "id": 2508758798,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6ViJ8O",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 5,
                "total_count": 5,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2508758798/reactions"
            },
            "updated_at": "2025-05-20T00:29:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2508758798",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@justinmk heads up, one complexity that we'll punt for now is supporting non-PNG images. I think we can write a pretty straightforward decoder for BMP & GIF, but JPEG is very complex and would /probably/ need a specialized C function to do it with the assistance of a JPEG-oriented library. This is in order to get RGB or RGBA data.\r\n\r\n@kovidgoyal I'm assuming my understanding of pixel formats is correct in that if we fed in any other image format that was not PNG, using `f=100` would not work, and we'd need to instead decode the base64 image data, figure out the format (i.e. bmp, jpeg, etc) and then extract a 24-bit RGB or a 32-bit RGBA set of data to feed in order for your protocol to work.\r\n\r\nI don't know what iterm2's graphics protocol supports as I've only tested with png and I don't see anything mentioned on their doc page. I also don't know what sixel supports or how it works since I haven't read the documentation yet, but I imagine given the age of sixel that we'd need to support image decoding of some kind to break out rgb/rgba data.",
            "created_at": "2024-11-30T21:29:04Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2509390983",
            "id": 2509390983,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6VkkSH",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2509390983/reactions"
            },
            "updated_at": "2025-05-20T00:29:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2509390983",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "On Sat, Nov 30, 2024 at 01:29:25PM -0800, Chip Senkbeil wrote:\n> @justinmk heads up, one complexity that we'll punt for now is supporting non-PNG images. I think we can write a pretty straightforward decoder for BMP & GIF, but JPEG is very complex and would /probably/ need a specialized C function to do it with the assistance of a JPEG-oriented library. This is in order to get RGB or RGBA data.\n>\n> @kovidgoyal I'm assuming my understanding of pixel formats is correct in that if we fed in any other image format that was not PNG, using `f=100` would not work, and we'd need to instead decode the base64 image data, figure out the format (i.e. bmp, jpeg, etc) and then extract a 24-bit RGB or a 32-bit RGBA set of data to feed in order for your protocol to work.\n\nYes, correct. You can use either imagemagick or the statically compiled\nkitten binary that comes as part of kitty to do this.\n\n>\n> I don't know what iterm2's graphics protocol supports as I've only tested with png and I don't see anything mentioned on their doc page. I also don't know what sixel supports or how it works since I haven't read the documentation yet, but I imagine given the age of sixel that we'd need to support image decoding of some kind to break out rgb/rgba data.\n\nsixel supports nothing, you need to convert every image format to the\nsixel format and transmit that.\n",
            "created_at": "2024-12-01T03:15:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2509545697",
            "id": 2509545697,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6VlKDh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2509545697/reactions"
            },
            "updated_at": "2024-12-01T03:15:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2509545697",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> This generally LGTM  , modulo the above comments. Thank you!\r\n> \r\n> If you are wondering how to write tests, my first thought is to look at `terminal/clipboard_spec.lua`\r\n> \r\n> https://github.com/neovim/neovim/blob/c7ec010ade0832e43c7a319ea69fae642771479d/test/functional/terminal/clipboard_spec.lua#L49\r\n> \r\n> \r\n> , and maybe `:help v:termresponse`, `:help TermResponse`.\r\n\r\nGreat, I'll take a look. I've written tests for plugins of mine using the busted/luassert libraries.\r\n\r\nAn open question for you and others is if there's a best practice for testing the images themselves. I can verify that we write escape codes to a terminal in a format that we expect. I don't know how - or if it matters - to test that an image actually shows up. Feels like that's out of scope beyond manually asserting that they work on a handful of terminals.",
            "created_at": "2024-12-02T16:03:44Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2511936495",
            "id": 2511936495,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6VuRvv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511936495/reactions"
            },
            "updated_at": "2025-05-20T00:29:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511936495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> there's a best practice for testing the images themselves. I can verify that we write escape codes to a terminal in a format that we expect. I don't know how - or if it matters - to test that an image actually shows up. Feels like that's out of scope beyond manually asserting that they work on a handful of terminals.\r\n\r\nFor now it's fine to just test that the right escape codes surround a bunch of base64 bytes. ",
            "created_at": "2024-12-02T16:07:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2511953737",
            "id": 2511953737,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6VuV9J",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511953737/reactions"
            },
            "updated_at": "2024-12-02T16:07:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511953737",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Just a drive by comment on my concern over the inclusion of the iterm2 protocol. Disclaimer: I don't have any experience implementing it, but I have been through the protocol.\r\n\r\nSo...the kitty graphics protocol lets you transmit an image and very finely control it's placement, *including a clip region.* By specifying a clip region, it is trivial to \"scroll\" an image partially off the screen - you can specify the horizontal or vertical offset (in pixels) to clip the image.\r\n\r\nWithout this clip capability, it seems that neovim would need to have an image processing library as well to internally clip images for display? What would the plan be for an image which gets partially scrolled?",
            "created_at": "2024-12-12T18:40:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2539754154",
            "id": 2539754154,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6XYZKq",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2539754154/reactions"
            },
            "updated_at": "2024-12-12T18:40:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2539754154",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/476352?v=4",
                "events_url": "https://api.github.com/users/rockorager/events{/privacy}",
                "followers_url": "https://api.github.com/users/rockorager/followers",
                "following_url": "https://api.github.com/users/rockorager/following{/other_user}",
                "gists_url": "https://api.github.com/users/rockorager/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/rockorager",
                "id": 476352,
                "login": "rockorager",
                "node_id": "MDQ6VXNlcjQ3NjM1Mg==",
                "organizations_url": "https://api.github.com/users/rockorager/orgs",
                "received_events_url": "https://api.github.com/users/rockorager/received_events",
                "repos_url": "https://api.github.com/users/rockorager/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/rockorager/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/rockorager/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/rockorager",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": ">Just a drive by comment on my concern over the inclusion of the iterm2 protocol\r\n\r\nI share this concern. The iTerm2 protocol is supported by only 2 terminals: iTerm2 and WezTerm. The latter also supports the kitty graphics protocol, meaning there is only one terminal for which supporting the iTerm image protocol would be useful.\r\n\r\nConsidering the additional complexity for supporting it, as well as the apparent feature gap mentioned here, I'd propose implementing support only for the kitty graphics protocol first.",
            "created_at": "2024-12-12T18:43:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2539759864",
            "id": 2539759864,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6XYaj4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2539759864/reactions"
            },
            "updated_at": "2024-12-12T18:43:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2539759864",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Considering the additional complexity for supporting it, as well as the apparent feature gap mentioned here, I'd propose implementing support only for the kitty graphics protocol first\r\n\r\nSGTM. The next step for this interface would be to emit a UI event so that GUIs can handle the data in their own way. Then we get coverage of all kitty-supporting terminals + GUIs, with minimal complexity. ",
            "created_at": "2024-12-13T12:07:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2541305368",
            "id": 2541305368,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6XeT4Y",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2541305368/reactions"
            },
            "updated_at": "2024-12-13T12:07:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2541305368",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Thanks for the feedback, folks. Been traveling for work last few weeks, and I may have some free time this weekend to start applying some of the recommendations.",
            "created_at": "2024-12-13T17:44:40Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2541950986",
            "id": 2541950986,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6XgxgK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 4,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2541950986/reactions"
            },
            "updated_at": "2025-05-20T00:29:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2541950986",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Just a drive by comment on my concern over the inclusion of the iterm2 protocol\r\n> \r\n> I share this concern. The iTerm2 protocol is supported by only 2 terminals: iTerm2 and WezTerm. The latter also supports the kitty graphics protocol, meaning there is only one terminal for which supporting the iTerm image protocol would be useful.\r\n> \r\n> Considering the additional complexity for supporting it, as well as the apparent feature gap mentioned here, I'd propose implementing support only for the kitty graphics protocol first.\r\n\r\nKonsole supports iTerm2 protocol too",
            "created_at": "2025-01-14T06:33:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2589139824",
            "id": 2589139824,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6aUyNw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2589139824/reactions"
            },
            "updated_at": "2025-01-14T06:33:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2589139824",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Just a link to this comment pre-dating this pull request cause once again it was implied here more terminals support kitty than iTerm2 which does not seem to be the case:\r\nhttps://github.com/neovim/neovim/issues/30889#issuecomment-2505137135\r\nI count at least eight for iTerm2 there and wezterm supporting it would be news for me, but maybe I overlooked it.\r\nNow, the relevancy of them is probably a different story.\r\nIn the meantime another new terminal emulator got a bit of a spike: ghostty. I think this supports iTerm2 and kitty.",
            "created_at": "2025-03-04T20:07:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2698783357",
            "id": 2698783357,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6g3Cp9",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2698783357/reactions"
            },
            "updated_at": "2025-03-04T20:15:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2698783357",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/32062480?v=4",
                "events_url": "https://api.github.com/users/schrmh/events{/privacy}",
                "followers_url": "https://api.github.com/users/schrmh/followers",
                "following_url": "https://api.github.com/users/schrmh/following{/other_user}",
                "gists_url": "https://api.github.com/users/schrmh/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/schrmh",
                "id": 32062480,
                "login": "schrmh",
                "node_id": "MDQ6VXNlcjMyMDYyNDgw",
                "organizations_url": "https://api.github.com/users/schrmh/orgs",
                "received_events_url": "https://api.github.com/users/schrmh/received_events",
                "repos_url": "https://api.github.com/users/schrmh/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/schrmh/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/schrmh/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/schrmh",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Hey folks, heads up that I'll finally get around to reviewing and implementing some of the suggestions in the next couple of weeks. @justinmk where did we align on keeping/removing iTerm protocol support? And sixel support?\r\n\r\nMy perspective is that we figure out a good interface for new backends (like these) to be injected, but having them directly included here may be too much. I have iterm and kitty today, although seems like kitty has a lot of different nuances on how it's implemented.\r\n\r\nAnd from the feedback @gpanders has given, we can reuse parts of the existing codebase for terminal queries and other logic, which is nice. Will have to retest everything once those changes are made.",
            "created_at": "2025-03-04T21:05:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2698903750",
            "id": 2698903750,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6g3gDG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2698903750/reactions"
            },
            "updated_at": "2025-05-20T00:29:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2698903750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I made a quick and dirty integration into Neovide here https://github.com/neovide/neovide/pull/3039 to get some feel about the work done so far.\r\n\r\nHere are some observations and comments:\r\n1. If we have a better way of adding new custom backends, then a GUI implementation in Neovim might not be necessary. Although GUI events might have the advantage of being totally in sync with the UI protocol.\r\n3. Since Neovim supports connecting multiple UIs to the same instance, I think the backend should be connected to the UI connections instead of globally, with the possibility of connecting different backends to different UIs. It probably won't work perfectly, since UIs have different grid sizes with different aspect ratios, but I think it would still be decent enough.\r\n4. It should be possible to hide/destroy images\r\n5. I echo the request for supporting different units. Pixel units will most likely be needed to align multiple images perfectly\r\n6. You should be able to specify either with or height, otherwise it's impossible to render a resized image with the correct aspect ratio, especially when using grid-based sizes\r\n7. I think a z-index is needed, and just like the Kitty protocol, making it possible to render both in front and behind the text\r\n8. I think the image data and rendered instances should be separated, otherwise you will pay both transfer costs and memory for displaying the same image multiple times\r\n9. I think ids for both the data and the instances are needed. I had to hack some in my implementation. The data id could perhaps be some kind of hash, to untie it from lua objects, so that the user never has to care.\r\n\r\nFinally, given that this code, at least at the moment doesn't need to be in Neovim, I wonder if it would make sense to pull it out to a plugin for the time being? That way things can be iterated more quickly, it's easier for multiple people to contribute. It would also allow the API to be stabilized, and maybe get some real-world testing before it's integrated into Neovim (if it actually ever needs to be).",
            "created_at": "2025-03-05T15:21:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2701255114",
            "id": 2701255114,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hAeHK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 11,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 7,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 18,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2701255114/reactions"
            },
            "updated_at": "2025-03-05T15:21:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2701255114",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> @justinmk where did we align on keeping/removing iTerm protocol support? And sixel support?\r\n> \r\n> My perspective is that we figure out a good interface for new backends (like these) to be injected, but having them directly included here may be too much\r\n\r\nyeah, other backends/providers can be added later. definitely more important to get the interface right and focus on simplicity here, first.",
            "created_at": "2025-03-09T13:30:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2708858268",
            "id": 2708858268,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hdeWc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2708858268/reactions"
            },
            "updated_at": "2025-03-09T13:30:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2708858268",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@fredizzimo those are great notes, would you mind creating a new issue to track that as \"phase 2\"? \r\n\r\n> 7\\. I think the image data and rendered instances should be separated, otherwise you will pay both transfer costs and memory for displaying the same image multiple times\r\n>\r\n> 8\\. I think ids for both the data and the instances are needed. I had to hack some in my implementation. The data id could perhaps be some kind of hash, to untie it from lua objects, so that the user never has to care.\r\n\r\nAll of your notes sound like non-blockers except these two  .\r\n\r\n> Finally, given that this code, at least at the moment doesn't need to be in Neovim, I wonder if it would make sense to pull it out to a plugin for the time being?\r\n\r\nNo, plugins already exist, and now we're taking the next step. We can mark this as experimental (and prefix the interface with underscore, `vim.ui._img`), if we think there are one-way decisions that haven't been resolved.",
            "created_at": "2025-03-09T13:35:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2708860495",
            "id": 2708860495,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hde5P",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2708860495/reactions"
            },
            "updated_at": "2025-03-10T21:49:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2708860495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm not interested in working for free for Neovim until there's some co-operation in the PRs and open issues to make Neovide work *correctly* with it, which has far higher priority than an image protocol IMO.",
            "created_at": "2025-03-10T06:09:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2709531328",
            "id": 2709531328,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hgCrA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 2,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2709531328/reactions"
            },
            "updated_at": "2025-03-10T15:41:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2709531328",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@fredizzimo your PRs aren't being ignored, I'm trying my best to attend to everything and prepare for the 0.11 release. I asked you to create an issue so your notes don't get lost here.",
            "created_at": "2025-03-10T15:10:25Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2710927984",
            "id": 2710927984,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hlXpw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2710927984/reactions"
            },
            "updated_at": "2025-03-10T15:41:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2710927984",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@justinmk, thank you!\r\n\r\nI was thinking that the upcoming 0.11 release was the reason, but a simple short response saying that would have cleared up a lot of confusion. I have been doing a lot of work with those, and was pushing for 0.11 myself, especially since I started working on them in the autumn already, but that's probably out of question now.\r\n\r\nI will create an issue after this PR has been iterated a bit more, since I don't know how big changes @chipsenkbeil is planning to make, and what remains after that.\r\n",
            "created_at": "2025-03-10T15:38:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2711015052",
            "id": 2711015052,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hls6M",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711015052/reactions"
            },
            "updated_at": "2025-03-10T15:38:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711015052",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@fredizzimo happy to collaborate with you on this.  I wanted to do this in steps (each its own PR?)\r\n\r\n1. A static image you can place within neovim (supporting just PNG or whatever works by default in terminals)\r\n2. Support deleting the image placed within neovim\r\n3. Dynamically resize/move an image\r\n4. Injection of an image into a buffer within neovim (tracking its movement properly, possibly through the use of extmarks); this involves reflowing text around the image (in my mind) versus just covering it up or placing behind it. Think to the examples of images within markdown/org documents but with images as first-class citizens\r\n5. Multiple image type support (bmp, jpg at least) within neovim (seems like the common way is to farm out to imagemagick, which I'm not a fan of, but seems like what we'd have to do first)\r\n6. Video/gif support (there are reasons why this would be neat, but not a dealbreaker if we want to exclude this from neovim core)\r\n\r\nRight now, this PR represents step 1.\r\n\r\nNot saying all of these will make it in even as experiments, just thoughts on the priorities. This also doesn't discuss which terminals to support with which protocols underneath, so could imagine sliding those in at some point, too. So plenty that could be done inbetween or in place of the above.\r\n\r\nI've gotten very busy with work, which is why this was delayed. Even having to work today while I'm on vacation, so haven't been able to come back to this PR yet. Any thoughts on how you want to tackle this in a collaborative setting? Probably starting by opening an issue or something to track additional items per @justinmk suggestion would be good.",
            "created_at": "2025-03-10T15:49:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2711051292",
            "id": 2711051292,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hl1wc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711051292/reactions"
            },
            "updated_at": "2025-03-10T15:49:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711051292",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@chipsenkbeil in item 1 of your list, should [items 7/8 from fredizzimo's list](https://github.com/neovim/neovim/pull/31399#issuecomment-2708860495) be part of that (this PR)?",
            "created_at": "2025-03-10T16:22:41Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2711146606",
            "id": 2711146606,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hmNBu",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711146606/reactions"
            },
            "updated_at": "2025-03-10T16:23:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711146606",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> @chipsenkbeil in item 1 of your list, should [items 7/8 from fredizzimo's list](https://github.com/neovim/neovim/pull/31399#issuecomment-2708860495) be part of that (this PR)?\r\n\r\nsure, I can take a stab at that as part of this PR.",
            "created_at": "2025-03-10T16:30:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2711169123",
            "id": 2711169123,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6hmShj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711169123/reactions"
            },
            "updated_at": "2025-03-10T16:30:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2711169123",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Hey, look at that! Months later, I finally am getting around to applying the feedback from @justinmk and @gpanders while at the airport  \r\n\r\nStill reading through all of the comments, but first cleaning things up. Going to see if I can entirely remove the terminal code in favor of `termcaps`, although I suspect I still need a helper function to move the cursor to properly place the image at a specific location.\r\n\r\n@fredizzimo @schrmh @brianhuster @rockorager I haven't forgotten all of your comments, either! Once the code is cleaned up more and we get as simplistic as I can make it, we can revisit if we just want kitty (seems like a push for yes for now?).\r\n\r\nI know that the iterm2 protocol is really limited, so I don't think we'd be able to get it to support the same functionality as kitty. It's also inconsistent in behavior from kitty on absolute image positioning as kitty renders an image over everything else whereas iterm2 scrolls the image out of view (and clears it) as you move lines around.\r\n\r\nFor sixel, this seems a bit more difficult for me to tackle in this first PR, so I'd propose that we instead keep things simple by me deleting iterm2 support, just focusing on kitty, and then new providers can be added in separate PRs as this evolves. And this SHOULD evolve quite a lot, btw.\r\n\r\nThoughts?",
            "created_at": "2025-04-29T20:16:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2840138206",
            "id": 2840138206,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6pSRHe",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2840138206/reactions"
            },
            "updated_at": "2025-05-20T00:30:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2840138206",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Just a drive by comment on my concern over the inclusion of the iterm2 protocol. Disclaimer: I don't have any experience implementing it, but I have been through the protocol.\r\n> \r\n> So...the kitty graphics protocol lets you transmit an image and very finely control it's placement, _including a clip region._ By specifying a clip region, it is trivial to \"scroll\" an image partially off the screen - you can specify the horizontal or vertical offset (in pixels) to clip the image.\r\n> \r\n> Without this clip capability, it seems that neovim would need to have an image processing library as well to internally clip images for display? What would the plan be for an image which gets partially scrolled?\r\n\r\nCommenting here that I'm fine and most likely moving forward with removing iterm2 and just using kitty. I was already aware of limitations in iterm2 with cropping. My first thought is to farm externally to a process like image magick to crop, which I \"think\" can be done without creating a temporary image. So if we ever revisit supporting iterm2, that would be the approach I'd take.",
            "created_at": "2025-04-30T21:02:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2843273979",
            "id": 2843273979,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6peOr7",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2843273979/reactions"
            },
            "updated_at": "2025-05-20T00:30:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2843273979",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> My first thought is to farm externally to a process like image magick to crop, which I \"think\" can be done without creating a temporary image.\r\n\r\nJust FYI, on terminals with level 4 capabilities, you can crop an image by rendering it to an offscreen [page](https://vt100.net/docs/vt510-rm/PPA.html), and then [copying](https://vt100.net/docs/vt510-rm/DECCRA.html) the relevant segments back to the main page. This can also serve as a way to cache images to a certain extent. I'm not sure about the iterm image protocol, but I do know this works with Sixel. The only catch is that DEC pages may not interoperate very well with the Xterm alt buffer mode, assuming that's a requirement.",
            "created_at": "2025-05-01T01:18:59Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2843865119",
            "id": 2843865119,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6pgfAf",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2843865119/reactions"
            },
            "updated_at": "2025-05-01T01:18:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2843865119",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@gpanders I figured out why `io.stdout:write()` would not work and I needed to access the tty device directly. Using kitty's direct transfer - you send all of the image bytes directly via escape codes - seems to not work with `io.stdout:write()` but does work if you access and use the tty device directly.\r\n\r\nIf you switch to local filesystem access via a file transfer (not escape codes), then it works fine to use `io.stdout:write()`. I'll document this in the PR.",
            "created_at": "2025-05-03T23:33:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2848858123",
            "id": 2848858123,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6pziAL",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2848858123/reactions"
            },
            "updated_at": "2025-05-03T23:33:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2848858123",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@justinmk @fredizzimo I've rewritten the provider interface and implemented basic kitty graphics logic to hide an image. This provides a bit of an abstraction between the image (the data) and the placement by having two separate ids. Whenever you show an image, the provider is expected to generate some id that can be passed back to it later to hide/remove the image. Thoughts?\r\n\r\n@gpanders I've been able to fully remove the terminal helper code and just use `io.stdout:write()`. I did keep the cursor move, but removed the restore logic and instead - for the kitty provider - use an option to prevent the cursor moving like you alluded to.\r\n\r\nStill got some open questions in this code at this point, but ready for another skim to get thoughts on this one.\r\n\r\n```lua\r\n-- Load the image from disk. We assume all images are loaded from disk right now, and are PNGs\r\nlocal img = vim.ui.img.load(\"/Users/senkwich/projects/neovim-img-test/org-roam-logo.png\")\r\n\r\n-- Calls the underlying provider (kitty) to show the image, returning an id that can hide it later\r\nlocal id = img:show({\r\n    pos = { x = 8, y = 8 },\r\n    provider = \"kitty\",\r\n})\r\n\r\n-- For the test, as soon as any key is pressed, the image is hidden\r\nvim.on_key(function()\r\n    img:hide(id)\r\nend)\r\n\r\n```\r\n\r\n\r\nhttps://github.com/user-attachments/assets/65be17a6-b01d-411e-b571-72bad4fd8524\r\n\r\n",
            "created_at": "2025-05-04T00:18:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2848872677",
            "id": 2848872677,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6pzljl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2848872677/reactions"
            },
            "updated_at": "2025-05-20T00:30:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2848872677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "I added in some additional options as an experiment to mirror a bit of what it looks like the floating window api can do when it comes to the relative position of the image, now supporting `editor` (what you've seen thus far), `win` to display relative to a specific window, `cursor` to display relative to a specific window's cursor, and `mouse` to display relative to the  mouse (from last click, unless mousemoveevent is enabled).\r\n\r\nHere's a silly preview of an image being displayed where the mouse is presently, and then on move it hides the only image (in kitty, by deleting the placement) and then showing a new image where the cursor is. Seems fairly quick, which is nice.\r\n\r\nThe reason I did this was to potentially set up what the config might look like to set relative to a buffer, which would then rely on something like the kitty implementation using the unicode placement functionality.\r\n\r\n\r\nhttps://github.com/user-attachments/assets/49ced131-a483-4f3e-8d7b-11d74e794cc5\r\n\r\n",
            "created_at": "2025-05-04T20:02:40Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2849392477",
            "id": 2849392477,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6p1kdd",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 5,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 5,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2849392477/reactions"
            },
            "updated_at": "2025-05-04T20:02:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2849392477",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@gpanders does `TermResponse` work with CSI escape sequences? Seems like it's documented for just OSC and DCS?\r\n\r\nReason I ask is that one issue popped up with trying to support converting between pixel and cell units, and that's getting the screen size in pixels. I was trying to do this via `\\027[14t` to request the screen size in the form `\\027[4;888;999t` where 888 is height and 999 is width, but I'm not getting `TermResponse` to trigger nor do I see anything being printed out. Works fine with a lua shell printing it out via `io.stdout:write()`.\r\n\r\nI'm assuming it's filtered out as `TERMKEY_RES_NONE` from `termkey_interpret_string` based on  \r\n\r\nhttps://github.com/neovim/neovim/blob/0862c1036a8e45c594ed279dd4576719f93614c5/src/nvim/tui/input.c#L577\r\n\r\n### FFI alternative\r\n\r\n@justinmk the alternative way I've seen this done is using `ioctl` and `TIOCGWINSZ` via ffi calls. And you'd have to do something completely different to support windows. Example of `ioctl` usage from snacks:\r\n\r\nhttps://github.com/folke/snacks.nvim/blob/bc0630e43be5699bb94dadc302c0d21615421d93/lua/snacks/image/terminal.lua#L67-L120\r\n\r\n```lua\r\nfunction M.size()\r\n  if size then\r\n    return size\r\n  end\r\n  local ffi = require(\"ffi\")\r\n  ffi.cdef([[\r\n    typedef struct {\r\n      unsigned short row;\r\n      unsigned short col;\r\n      unsigned short xpixel;\r\n      unsigned short ypixel;\r\n    } winsize;\r\n    int ioctl(int, int, ...);\r\n  ]])\r\n\r\n  local TIOCGWINSZ = nil\r\n  if vim.fn.has(\"linux\") == 1 then\r\n    TIOCGWINSZ = 0x5413\r\n  elseif vim.fn.has(\"mac\") == 1 or vim.fn.has(\"bsd\") == 1 then\r\n    TIOCGWINSZ = 0x40087468\r\n  end\r\n\r\n  local dw, dh = 9, 18\r\n  ---@class snacks.image.terminal.Dim\r\n  size = {\r\n    width = vim.o.columns * dw,\r\n    height = vim.o.lines * dh,\r\n    columns = vim.o.columns,\r\n    rows = vim.o.lines,\r\n    cell_width = dw,\r\n    cell_height = dh,\r\n    scale = dw / 8,\r\n  }\r\n\r\n  pcall(function()\r\n    ---@type { row: number, col: number, xpixel: number, ypixel: number }\r\n    local sz = ffi.new(\"winsize\")\r\n    if ffi.C.ioctl(1, TIOCGWINSZ, sz) ~= 0 or sz.col == 0 or sz.row == 0 then\r\n      return\r\n    end\r\n    size = {\r\n      width = sz.xpixel,\r\n      height = sz.ypixel,\r\n      columns = sz.col,\r\n      rows = sz.row,\r\n      cell_width = sz.xpixel / sz.col,\r\n      cell_height = sz.ypixel / sz.row,\r\n      -- try to guess dpi scale\r\n      scale = math.max(1, sz.xpixel / sz.col / 8),\r\n    }\r\n  end)\r\n\r\n  return size\r\nend\r\n```",
            "created_at": "2025-05-04T22:58:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2849484377",
            "id": 2849484377,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6p165Z",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2849484377/reactions"
            },
            "updated_at": "2025-05-04T23:24:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2849484377",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@gpanders @justinmk in terms of retrieving the terminal size in pixels, it seems like https://github.com/neovim/neovim/pull/32408 was already started earlier this year, but per @fredizzimo it might need more work to be flexible enough for 3rd party UIs like neovide.\r\n\r\nI could try to work on incorporating a single new API function that retrieves the rows & columns in pixel form - was working on code that was compatible with Windows alongside all of those that support `ioctl` usage - but wasn't sure if that was appropriate for this PR or even needed in comparison to extending the dimensions reported  by the `RemoteUI` struct.\r\n\r\nThoughts on this one? For now, I can just make this PR error when you try to provide a unit that isn't the one we need:\r\n\r\n1. For image placement, size & position would use cells\r\n2. For image cropping, would use pixels\r\n\r\ncc @tbung ",
            "created_at": "2025-05-07T08:35:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2857672936",
            "id": 2857672936,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qVKDo",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857672936/reactions"
            },
            "updated_at": "2025-05-07T08:36:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857672936",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I will read through the rest and look at your changes a bit later, but a quick comment right now (edit: it wasn't so quick and short)\r\n\r\nI suggest that you use the same units as the kitty image protocol. That allows for pixel perfect alignment of images next to each other for example. And works for both placeholders and absolute coordinates\r\n\r\n|  key  | type  | default  | description\r\n|--|--|--|--|\r\n| x | Positive integer | 0 | The left edge (in pixels) of the image area to display |\r\n| y | Positive integer | 0 | The top edge (in pixels) of the image area to display |\r\n| w | Positive integer | 0 | The width (in pixels) of the image area to display. By default, the entire width is used |\r\n| h | Positive integer | 0 | The height (in pixels) of the image area to display. By default, the entire height is used |\r\n| X | Positive integer | 0 | The x-offset within the first cell at which to start displaying the image |\r\n| Y | Positive integer | 0 | The y-offset within the first cell at which to start displaying the image |\r\n| c | Positive integer | 0 | The number of columns to display the image over | \r\n| r | Positive integer | 0 | The number of rows to display the image over |\r\n\r\nFor example to let's say you grid width is 9 pixels and you want to place the image from pixel 95 to 133, cropping the right of the image, you could do this\r\n\r\n* Set the cursor position to 10,\r\n* Set X to 5,\r\n* Set c to 5 (column 15 - 10)\r\n* Set w to 38 (133 - 95)\r\n\r\nUnfortunately, the Kitty protocol does not have full control of the scaling of the image. So, in many cases the image probably has to be resized on the Neovim side before being placed. But Neovide for example could easily do this on the fly using the GPU, and I guess that's something Kitty could support as well. \r\n\r\nThere's some other complication, the cell width in Neovide for example is fractional. But we recently implemented support for rendering box drawing characters into an integer-based grid. So, at least for us using integer pixels is viable, as long as the protocol rounds the coordinate the same way, it needs to round both the start and end pixel in each cell. That way images can be displayed next to box drawing characters without gaps, or with exact pixel gaps if desired.\r\n\r\nBased on all this, I actually suggest a simpler low level struct, the struct would be just this, **all coordinates in pixels**\r\n```\r\npos_x -- Relative for unicode placeholders, otherwise absolute,\r\npos_y ,\r\nwidth,\r\nheight,\r\nsrc_pos_x,\r\nsrc_pos_y,\r\nsrc_width,\r\nsrc_height,\r\n-- Maybe some filtering mode settings, to control how the image is scaled, different types of images and up and down scaling looks better with different settings.\r\n```\r\n\r\nIf scaling needs to be done due to mismatch between `width`, and `src_width` for example, the protocol can do it internally for Kitty, keep in mind that it does that in a limited way when either `width` or `height` is unspecified.  It can be sent directly to UIs and let them do the resizing as needed.\r\n\r\nOn top of this, there's a more powerful API for filing the struct, giving the desired number of cells for example.\r\n\r\nThe reason for letting the Neovim, or actually the plugin that uses the image protocol to be in charge of the exact pixel layout is important, since the number of cells used is dependent on the cell aspect ratio and the image aspect ratio, and that information can only be used before the actual placement.  If the cells were square, it would be easy to allow specifying fractional cells for example and just use that everywhere.\r\n\r\n",
            "created_at": "2025-05-07T10:00:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2857951189",
            "id": 2857951189,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qWN_V",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857951189/reactions"
            },
            "updated_at": "2025-05-07T10:01:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857951189",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I forgot to say, that two important use cases for the x and y offsets in pixels are \r\n* Right aligning the image to a cell\r\n* Center the image in the cells",
            "created_at": "2025-05-07T10:08:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2857979391",
            "id": 2857979391,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qWU3_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857979391/reactions"
            },
            "updated_at": "2025-05-07T10:08:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2857979391",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm still interested in finishing up #32408, I am somewhat waiting on #33392 so the API changes can be done properly, but I guess I can work on it now if people already want to make use of it unmerged.",
            "created_at": "2025-05-07T10:54:32Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2858109303",
            "id": 2858109303,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qW0l3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2858109303/reactions"
            },
            "updated_at": "2025-05-07T10:54:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2858109303",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4084982?v=4",
                "events_url": "https://api.github.com/users/tbung/events{/privacy}",
                "followers_url": "https://api.github.com/users/tbung/followers",
                "following_url": "https://api.github.com/users/tbung/following{/other_user}",
                "gists_url": "https://api.github.com/users/tbung/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tbung",
                "id": 4084982,
                "login": "tbung",
                "node_id": "MDQ6VXNlcjQwODQ5ODI=",
                "organizations_url": "https://api.github.com/users/tbung/orgs",
                "received_events_url": "https://api.github.com/users/tbung/received_events",
                "repos_url": "https://api.github.com/users/tbung/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tbung/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tbung/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tbung",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@fredizzimo thanks for the insight! On the same page about the flexibility needed, especially how the image placement doesn't need to be restricted to grid cells or integer-based units.\r\n\r\nI do think that having a simplistic ability to convert between cell and pixel units is important as many consumers of the image API - not providers, but the users - will probably think in terms of cells/grid when it comes to where they want to place their images when they're not being embedded into a buffer's content. So they should be able to pass along, \"I want to place my picture starting at row 5, column 3\r\n and have neovim - or maybe the underlying attached UI - do the conversion for them.\r\n\r\nRight now, I have (non-working) code to support conversions where providers can convert between cell units and pixel units (either direction). So a provider could choose to work with just cell units if they needed to restrict to a grid, but neovide and others can work entirely with pixel units if they'd like, even if the user of the image API is supply things in cells.\r\n\r\nIt works by specifying a unit, creating a `vim.ui.img.Size`, `vim.ui.img.Position`, or `vim.ui.img.Region` through specialized functions:\r\n\r\n```lua\r\nlocal pos = vim.ui.img.new_position(x, y, 'cell')\r\nlocal pos_px = pos:to_pixels()\r\nlocal pos_cell = pos_px:to_cells()\r\n\r\n-- Same for a size or a rectangular region\r\nlocal size = vim.ui.img.new_size(width, height, 'pixel')\r\nlocal size_cell = size:to_cells()\r\nlocal size_px = size:to_pixels()\r\n```\r\n\r\nThe dimensions provided through `vim.ui.img.Opts` would have a default - right now, cells - but could be explicitly set by the user if they know which one they want to consider.\r\n\r\n```lua\r\nlocal img = vim.ui.img.load('/path/to/img.png')\r\nlocal id = img:show({\r\n  pos = { x = 5, y = 8 },\r\n})\r\n\r\n-- The above is the same as\r\nlocal id = img:show({\r\n  pos = vim.ui.img.new_position(5, 8, 'cell'),\r\n})\r\n\r\n-- And so when a provider gets this as part of the options, they can do\r\nlocal function provider_show(self, img, opts)\r\n  -- Guarantee that to the provider we're working with pixel units regardless of whether\r\n  -- they were specified as pixels by the user\r\n  local pos = opts.pos:to_pixels()\r\n\r\n  -- ...\r\nend\r\n```\r\n\r\n### Platform support for pixel dimensions\r\n\r\nIf we have a way to get the pixel dimensions across all supported neovim platforms consistently, then I think having the units default to pixels (internally) would be fine, but I don't know if that's the case even with #32408. \r\n\r\nTo my understanding, `ioctl` via `TIOCSWINSZ` is supported on the major BSDs, MacOS, Linux/Android, and Solaris. And there's some code I was working on that would support traditional Windows console (even if the kitty graphics api itself isn't implemented in that terminal, I think sixel is??). You can alternatively use `CSI 14 t` to request the dimensions in pixels, which seems to be compatible with many different terminals, but neovim consumes the response without a way to retrieve it unless you go straight to the tty (and that has been flaky for me). cc @gpanders \r\n\r\nAre there any other platforms that would be missing for neovim these days? I don't recall what it supports other than the above, and I thought it had reduced older system support compared to vim.\r\n\r\nThe reason I ask is that unless we can get the ability to retrieve these dimensions consistently - maybe included as part of the attached UI spec - it's going to make it difficult for users or providers to manage the calculations needed to figure out pixel placement, right? It's why every plugin I've seen that works with images that wants to do pixel-oriented placement (or at least know the true cell pixel width/height) has to farm the work externally through `ffi` (snacks and I believe image.nvim do this), [`CSI 14 t`](https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Functions-using-CSI-_-ordered-by-the-final-character_s_) ([Windows Terminal support](https://github.com/microsoft/terminal/issues/8581#issuecomment-2395553315), most xterm-compatible terminals), or some external program.\r\n\r\n### PR #32408\r\n\r\n@tbung I haven't looked closely at your PR other than seeing it introduces `ioctl(..., TIOCSWINSZ, ...)` and extends some of the APIs to supply pixel dimensions on resize, etc. What is the blocker with the API contract bit? Would there be any way to split the PR into a smaller \"retrieve the pixel width & height\" PR first and then the other features second to try to get that in earlier?\r\n\r\nI'd love to have it where I could make a call to `vim.api.nvim_list_uis()` and read pixel width & height fields to use to determine the (fractional) cell pixel width & height.\r\n\r\n@fredizzimo assuming neovide would be able to supply this from its side, and then from more traditional terminals we'd be able to use the above `TIOCSWINSZ` or some Windows API calls like [GetConsoleScreenBufferInfo](https://learn.microsoft.com/en-us/windows/console/getconsolescreenbufferinfo) and [GetConsoleFontSize](https://learn.microsoft.com/en-us/windows/console/getconsolefontsize) to figure out the grid size and pixels per character to get the total pixel dimensions.",
            "created_at": "2025-05-08T08:56:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2862282857",
            "id": 2862282857,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qmvhp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862282857/reactions"
            },
            "updated_at": "2025-05-08T09:21:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862282857",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@chipsenkbeil If you're planning to use ioctl, other than the fact that it isn't universally supported (even on Linux), you should also be aware that the dimensions returned may include padding, so if you're using it to calculate the cell size, the result will occasionally be incorrect.\r\n\r\nFor example, imagine a cell height of 20 pixels on a terminal with 24 rows, so the height of the text area is 480 pixels. If that terminal has padding of 12 pixels (e.g. `xterm -b 12`), then the ioctl-reported height could be 504 pixels. So if you're dividing that height by the number of rows to calculate the cell height, you're going to get the wrong answer (504/24 = 21).\r\n\r\nThat's only off by 1, but if you're using the cell height to determine the pixel height needed to fill a certain row count, it can easily end up far out of range, and break the layout of the page. This may be a rare edge case, but it can happen.\r\n\r\nSo I think the safest way to calculate the cell size is with a `CSI 16 t` query, assuming that's supported and you can get queries to work in neovim. Using `CSI 14 t` might be the next safest option, but there may still be some terminals that return a padded size for that too, so it has similar risks to ioctl.",
            "created_at": "2025-05-08T11:09:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2862658283",
            "id": 2862658283,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qoLLr",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862658283/reactions"
            },
            "updated_at": "2025-05-08T11:09:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862658283",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I would assume that all terminals that implements the Kitty protocol supports getting the window size, and without padding, since that's a requirement of the protocol https://sw.kovidgoyal.net/kitty/graphics-protocol/#getting-the-window-size\r\n\r\nAllthough Ghostty doesn't, but I think that can be considered a bug. https://github.com/ghostty-org/ghostty/discussions/4265",
            "created_at": "2025-05-08T11:21:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2862697048",
            "id": 2862697048,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qoUpY",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862697048/reactions"
            },
            "updated_at": "2025-05-08T11:21:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862697048",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "That said, if the UI supports it, it would be good to be able for the GUI to pass the padding as well and that it's a usable area for image display. And perhaps also for terminals, if a protocol extension is made for it.\r\n\r\n",
            "created_at": "2025-05-08T11:30:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2862717015",
            "id": 2862717015,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qoZhX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862717015/reactions"
            },
            "updated_at": "2025-05-08T11:30:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862717015",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Yes, the PR should also make `vim.api.nvim_list_uis()` return pixel sizes (it doesn't yet because I was mostly concerned with the builtin terminal properly responding to `ioctl`). I don't think it can be decoupled from API changes because `nvim_ui_attach` and `nvim_ui_try_resize` need to accept pixel sizes from a UI, and I was told this should be done through optional arguments as per the proposed API changes. \r\n\r\nWhile it  does currently use `ioctl` on the TUI side to get the sizes, it should then be easy to expand on that and include stuff that works on windows or uses CSI queries. Also, since UIs report their pixel size it completely abstracts that concern away for this implementation of an image protocol.\r\n\r\nI'll just finish up the PR over the weekend under the assumption that #33392 or something similar gets merged at some point and put pixel sizes into optional argument dicts for existing APIs and also make `vim.api.nvim_list_uis()` report pixel sizes. We can then have another discussion on getting that merged.",
            "created_at": "2025-05-08T11:49:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2862761220",
            "id": 2862761220,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qokUE",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862761220/reactions"
            },
            "updated_at": "2025-05-08T11:49:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2862761220",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4084982?v=4",
                "events_url": "https://api.github.com/users/tbung/events{/privacy}",
                "followers_url": "https://api.github.com/users/tbung/followers",
                "following_url": "https://api.github.com/users/tbung/following{/other_user}",
                "gists_url": "https://api.github.com/users/tbung/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tbung",
                "id": 4084982,
                "login": "tbung",
                "node_id": "MDQ6VXNlcjQwODQ5ODI=",
                "organizations_url": "https://api.github.com/users/tbung/orgs",
                "received_events_url": "https://api.github.com/users/tbung/received_events",
                "repos_url": "https://api.github.com/users/tbung/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tbung/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tbung/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tbung",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I would assume that all terminals that implements the Kitty protocol supports getting the window size, and without padding, since that's a requirement of the protocol\r\n\r\nThat's certainly not the case at the moment, and some terminals have been using ioctl to report the window size for more than 30 years now, so I'd be surprised if they *all* could be convinced to change their implementation just because Kitty says so. Although if your plan for this API is _only_ to support Kitty, and _only_ in situations where ioctl works, then maybe that's not a problem.\r\n",
            "created_at": "2025-05-08T13:47:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863133590",
            "id": 2863133590,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qp_OW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863133590/reactions"
            },
            "updated_at": "2025-05-08T13:47:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863133590",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Yes, I think it's pretty much agreed on here to only support the Kitty protocol, with possible other protocols following, if an implementation is possible. \r\n\r\nAnd the ability to get the window size and cell size, is specified by the protocol https://sw.kovidgoyal.net/kitty/graphics-protocol/#getting-the-window-size.\r\n> In order to know what size of images to display and how to position them, the client must be able to get the window size in pixels and the number of cells per row and colum\r\n\r\nSo, a terminal that returns wrong, has a buggy implementation of the Kitty protocol. They could of course also provide some custom extension to get it, but they do need to provide it somehow. And in that case the support should be integrated into https://github.com/neovim/neovim/pull/32408",
            "created_at": "2025-05-08T14:11:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863220452",
            "id": 2863220452,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qqUbk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863220452/reactions"
            },
            "updated_at": "2025-05-08T14:11:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863220452",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "16t is not going to work, its not implemented in many terminals, libvte based ones and alacritty for two prominent examples off the top of my head (though its been a while since I checked, so check for yourself). There is a reason I chose to recommend 14t rather than 16t if you must use an escape code for this.\r\n\r\nBut I strongly suggest you use the ioctl (except on windows). It is a bug for any terminal that claims to support the kitty protocol to not report the window size as cell_size * num_cells. It makes zero sense for terminals to report window padding to terminal programs anyway, they might as well be adding in window decoration sizes and random numbers as well if they are going to do that. Since terminal programs cannot draw onto or in any way affect the window padding, they shouldn't be knowing about it. Just like they dont know how large the OS window's titlebar is. ",
            "created_at": "2025-05-08T14:11:58Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863221800",
            "id": 2863221800,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qqUwo",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863221800/reactions"
            },
            "updated_at": "2025-05-08T14:11:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863221800",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I think there's at least one use case for *additionally* being able to query the padding and displaying images there. That would be to show background images if the terminal or GUI don't support it natively or when it only can show file backed images. If the image protocol supports, there could be dynamic backgrounds, or even animations.\r\n\r\nWith the kitty protocol that's impossible though (with the major limitation of the coordinates having to be positive), but in Neovide it would be cool to support this. \r\n\r\nBut that's just a nice to have, not a requirement. I think we, will implement dynamic font sizing at some point to get rid of the border completely by slightly scaling the fonts, which probably is better for most, but with slightly inconsistent font sizes  and/or spacing.",
            "created_at": "2025-05-08T14:54:32Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863347668",
            "id": 2863347668,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qqzfU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863347668/reactions"
            },
            "updated_at": "2025-05-08T14:54:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863347668",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "At this point, there are three things I'm trying to accomplish with this PR:\r\n\r\n1. **API:** Establish a generic interface (that can be expanded) to support displaying, updating, and hiding images. And try to get it to be simple enough to extend by 3rd parties (providers) and b easily used by consumers. This means figuring out what neovim needs to track & manage versus what is the responsibility of each provider.\r\n2. **Information:** Incorporate a consistent way to get the basic information about the user interface to support (1), which in this case means a way to convert between cells and pixels. Ideally, this is **abstract**, meaning that whether it uses `ioctl`, `CSI 14 t`, `CSI 16 t`, or some other method should not matter (and can change), only that we have a way to get the information needed (possibly through `nvim_list_uis()`). Hopefully @tbung 's work to introduce pixel dimensions - even if the implementation may not be correct/available for everyone immediately - unblocks here.\r\n3. **Implementation:** Provide a basic implementation of the provider using kitty's graphics protocol to both serve as a reference and support a variety of modern terminals where neovim is used today with the understanding that someone else (or me) could come in later with an additional PR to add a sixel provider, or other core support if it makes sense.\r\n\r\n@fredizzimo @kovidgoyal @j4james thoughts on how we stand (at the moment) when it comes to the above three? \r\n\r\n@fredizzimo I know you're pushing for pixels as the preferred unit for internal structures. Thoughts on the conversion approach assuming that implementations correctly can get the width/height pixel dimensions and use that to translate into the fractional column and row dimensions? How does the provider interface look if neovide was to incorporate it?\r\n\r\n@kovidgoyal is the kitty provider following best practices when it comes to displaying and hiding images? I know from reading kitty's docs that there's a limit to the amount of images that can be stored, and I think snacks.nvim maintains a LRU cache to discard images over time, but that seemed a lot more complex than needed for a first attempt.\r\n\r\n@j4james kitty is the first implementation. There seems like there's interest for sixel by others, and even a renewed discussion about iterm2's protocol, but I think for this PR it makes sense to focus on a single provider. We build out an API that's simple, and then when a new PR comes in that may uncover limitations that need to be removed to support it. Any thoughts on the PR today?",
            "created_at": "2025-05-08T15:57:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863556079",
            "id": 2863556079,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qrmXv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863556079/reactions"
            },
            "updated_at": "2025-05-08T15:57:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863556079",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "On Thu, May 08, 2025 at 08:57:31AM -0700, Chip Senkbeil wrote:\n> @kovidgoyal is the kitty provider following best practices when it comes to displaying and hiding images? I know from reading kitty's docs that there's a limit to the amount of images that can be stored, and I think snacks.nvim maintains a LRU cache to discard images over time, but that seemed a lot more complex than needed for a first attempt.\n\nSorry, I haven't had time to review your actual code, but, in general,\nthe kitty protocol recommends that terminals store at least a few\nscreenfuls of images, in kitty that's 320MB per screen. See\nhttps://sw.kovidgoyal.net/kitty/graphics-protocol/#image-persistence-and-storage-quotas\n\nTo be maximally robust a terminal program should use the report features\nof the protocol to check if a previously displayed image is still\navailable when it is redisplayed and if not resend it. But, in practice,\nfor most use cases, assuming the last N images are available and\nresending any older than that is fine. In all the years since this\nfeature has been available in kitty, I haven't heard of any terminal\nprogram having cache eviction issues displaying images.\n\nCertainly, for a first attempt you can just display images as you get\nthem and if they need to be redisplayed, assume they are still available\nunless N newer images have been displayed since they were first\ntransmitted. This will work fine in all except a few edge cases.\n\nYou could just use a rough heuristic like width*height*4*N > 100MB ->\nresend, otherwise just redisplay. Experience with other terminal\nemulators will allow you to adjust that heuristic in the future if\nneeded. Or for a MVP always resend.\n",
            "created_at": "2025-05-08T16:12:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863597474",
            "id": 2863597474,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qrwei",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863597474/reactions"
            },
            "updated_at": "2025-05-08T16:12:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863597474",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@chipsenkbeil, I'm not sure if I can answer the first three questions yet. I need to take a deeper look at the current code, and possibly attempt to integrate it to Neovide (which has been stalled, both due to lack of time, and limitations of the rust messagepack protocol, it's virtually unmaintained so I'm doing some fixes myself)\r\n\r\n> @fredizzimo I know you're pushing for pixels as the preferred unit for internal structures. Thoughts on the conversion approach assuming that implementations correctly can get the width/height pixel dimensions and use that to translate into the fractional column and row dimensions? \r\n\r\nI was thinking that we should expose an API to manipulate the image, for things like you currently use internally like `pixels_to_cells/cells_to_pixels`. There are so many different use cases, so it's probably better to provide a quite low level, but complete API. I higher level one that builds on that could be added in the future. I expect that applications displaying images will need to take both the image raw sizes, and the cell sizes into account when displaying them.\r\n\r\nI also think that we expose the pixel values directly, if someone prefers to do all the calculations themself.\r\n\r\nBut I think your approach of supporting coordinates to functions like `new_position` is also a reasonable approach in many cases.\r\n\r\nAlso, note that the cell dimensions will not only have to be pixels, but also support fractional pixels. But as I mentioned earlier, the coordinates can be rounded before storing in the image, so that only contains integers. Currently the client width is also fractional in Neovide, but that could be changed by slightly adjusting the font size so that the last cell ends exactly on a full pixel.\r\n\r\n> How does the provider interface look if neovide was to incorporate it?\r\n\r\nI know better after trying it, but I don't see any problems currently. It could perhaps be a generic RPC provider, so we don't need to include any UI specific code in Neovim itself. Each of the function could call an RPC on a channel. And then some register function like `register_image_provide(channel)`",
            "created_at": "2025-05-08T16:55:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863704592",
            "id": 2863704592,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qsKoQ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863704592/reactions"
            },
            "updated_at": "2025-05-08T16:55:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863704592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> 16t is not going to work, its not implemented in many terminals\r\n\r\n@kovidgoyal I've got 17 terminals that support `CSI 16t`, which I think is actually more than the number that support `ioctl`. But I'm not suggesting you rely on `16t` exclusively - if it's not supported then you can fallback to `14t` or `ioctl`. I just think it makes sense to use values that are known to be correct in preference to estimates that could potentially be wrong.\r\n\r\n> they might as well be adding in window decoration sizes and random numbers as well if they are going to do that.\r\n\r\nI think some actually do. Because the usage of these reports (both `CSI 14t` and `ioctl`) predates the use of images in the terminal (at least Linux terminals). I suspect they were originally used to help position the terminal relative to the larger desktop screen area, which is why there are also sequences for moving the window, and querying the screen size.\r\n\r\n> Establish a generic interface (that can be expanded) to support displaying, updating, and hiding images. \r\n\r\n@chipsenkbeil The concept of hiding images doesn't really exist outside of the Kitty protocol. For Sixel (and I assume also iTerm), you hide an image in the same way you hide text - by writing over it. For example, you might popup a window with an image in it, and you hide that window by redrawing the text that was beneath it. The image doesn't require any special handling. I don't see being able to hide images independently as being a particular useful concept, but maybe there's something I'm missing.\r\n\r\nAnd this is why I think it would have made more sense to design this protocol around a set of common use cases you actually expect it to handle, and then figure out how the different protocols can support those use cases. Making it a one-for-one mapping of the Kitty image protocol (which is what some people seem to be pushing) is just going leave you with something that only works on Kitty. Which is fine if that's your goal, but not a great idea if you want broader terminal support.",
            "created_at": "2025-05-08T17:12:13Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2863741749",
            "id": 2863741749,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qsTs1",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863741749/reactions"
            },
            "updated_at": "2025-05-08T17:12:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2863741749",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> The concept of hiding images doesn't really exist outside of the Kitty protocol. For Sixel (and I assume also iTerm), you hide an image in the same way you hide text - by writing over it. For example, you might popup a window with an image in it, and you hide that window by redrawing the text that was beneath it. The image doesn't require any special handling.\r\n\r\nFrom my perspective, that's for the underlying provider to implement. If the way it does that is to write over it, that's fine. From a consumer's perspective, I don't want to have to maintain or think about that logic, and instead need the ability to hide an image that I have displayed at some point.\r\n\r\nThis may be because I displayed an image on top of neovim and need to clear it later. Or I was having an image visible alongside a buffer. Could be a lot of reasons, but I already faced the problem of having a permanently-visible image that I could not clear.\r\n\r\nSo how it's done - whether having some specific command in the protocol like kitty, or writing over it in the case of sixel - seems more like a provider implementation detail. But this does seem like a necessary feature to me from an API perspective, so I guess we'd disagree on this one.  \r\n\r\n> And this is why I think it would have made more sense to design this protocol around a set of common use cases you actually expect it to handle, and then figure out how the different protocols can support those use cases.\r\n\r\nThat's what I'm trying to do, hopefully!  Hence me attempting to make sure that @fredizzimo 's concerns about factoring in frontend UIs like neovide are heard and factored into this PR. It just so happens that the kitty protocol is the one that addresses the use cases that I had in mind, at least for a basic version of the API, and is supported by several of the advanced terminals (ghostty, wezterm, kitty) that I've actively used at work and home. I was trying to do the same with iterm2 when I first started this PR, but learned as I tried to keep both providers (kitty and iterm2) in sync that iterm2's protocol didn't give enough control (to my knowledge) to provide basic graphics support in a way that neovim could offer for the use cases I need and have seen from others.\r\n\r\nThe part I haven't figured out generically (yet) is embedding images within a buffer that reflows text around them, which is what I'd want when viewing markdown and orgmode documents with embedded images. Kitty does this through unicode placeholders such that the image follows the placeholders as they move around. Maybe we use extmarks to inject them in the kitty provider, but I don't know yet what should be the responsibility of neovim and what should be the responsibility of a provider in this use case.\r\n\r\n@fredizzimo I think you shared thoughts earlier on the approach that would support neovide. Would you mind resharing that - a link to the comment above - or restating your thoughts on this matter? Anything changed in your thoughts here since last time?\r\n\r\n> Certainly, for a first attempt you can just display images as you get\r\nthem and if they need to be redisplayed, assume they are still available\r\nunless N newer images have been displayed since they were first\r\ntransmitted. This will work fine in all except a few edge cases.\r\n\r\n@kovidgoyal thanks for the feedback! No worries that you haven't reviewed the PR's implementation of kitty's protocol. Your insight so far is helpful in validating some of the approaches I've seen. Will probably start with something like this, unless querying image availability isn't too difficult in which I may take that approach right away.\r\n\r\n> I was thinking that we should expose an API to manipulate the image, for things like you currently use internally like pixels_to_cells/cells_to_pixels. There are so many different use cases, so it's probably better to provide a quite low level, but complete API. I higher level one that builds on that could be added in the future. I expect that applications displaying images will need to take both the image raw sizes, and the cell sizes into account when displaying them.\r\n>\r\n> I also think that we expose the pixel values directly, if someone prefers to do all the calculations themself.\r\n\r\n@fredizzimo I guess we could expose the conversion methods. If someone wanted to do it themselves, do you think that's necessary or would just having the information directly exposed within `nvim_list_uis()` be good enough? What would neovide use if it had both available? Or would it not use either since it has all of this data itself?\r\n\r\nAnything needed when it comes to applications taking into account image raw sizes and cell sizes? I guess I could add to `vim.ui.img.Image` for PNGs the ability to know what the width and height of the image is in pixels.",
            "created_at": "2025-05-08T19:57:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2864128663",
            "id": 2864128663,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qtyKX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864128663/reactions"
            },
            "updated_at": "2025-05-08T19:57:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864128663",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> From my perspective, that's for the underlying provider to implement. If the way it does that is to write over it, that's fine. From a consumer's perspective, I don't want to have to maintain or think about that logic, and instead need the ability to hide an image that I have displayed at some point.\r\n\r\nPersonally I'm more likely to want to just clear an area of the screen, and I wouldn't want to have to keep track of all the images I might have previously rendered in that area, and then individually request their removal.\r\n\r\nAnd for other protocols, clearing an area of the screen containing an image is trivial, but restoring the content that was previously below that image is not. So if the only reason for doing so is to emulate the way kitty deletes images, that's an expensive and pointless complication. \r\n\r\nBut if this is the approach you want to take, I'll stop interfering now.",
            "created_at": "2025-05-08T22:33:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2864577144",
            "id": 2864577144,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qvfp4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864577144/reactions"
            },
            "updated_at": "2025-05-08T22:33:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864577144",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > 16t is not going to work, its not implemented in many terminals\r\n> \r\n> @kovidgoyal I've got 17 terminals that support `CSI 16t`, which I think is actually more than the number that support `ioctl`. But I'm not suggesting you rely on `16t` exclusively - if it's not supported then you can fallback to `14t` or `ioctl`. I just think it makes sense to use values that are known to be correct in preference to estimates that could potentially be wrong.\r\n\r\nThe absolute number that support it is irrelevant. The intersection of those that support the kitty protocol and report pixel sizes in the ioctl is what matters. It is a protocol error to support the kitty protocol and report anything other than the cell area size in the ioctl. Therefore for *consumers* of the protocol relying on the ioctl makes perfect sense. \r\n\r\n> \r\n> > they might as well be adding in window decoration sizes and random numbers as well if they are going to do that.\r\n> \r\n> I think some actually do. Because the usage of these reports (both `CSI 14t` and `ioctl`) predates the use of images in the terminal (at least Linux terminals). I suspect they were originally used to help position the terminal relative to the larger desktop screen area, which is why there are also sequences for moving the window, and querying the screen size.\r\n\r\nWell, Linux has sadly moved away from the paradigm where applications can position their own windows on the desktop, see Wayland. So it makes perfect sense for Linux terminals to not do that anymore, regardless of the kitty protocol. Though I have to say I highly doubt they were ever used for that since there are no escape codes that I know of to query the terminal for the desktop geometry, workarea, etc, so how were programs supposed to position terminal windows anyway?\r\n\r\nAnd let me quote the xterm spec for you:\r\n```\r\nPs = 1 4    Report xterm text area size in pixels.\r\n          Result is CSI  4 ;  height ;  width t\r\nPs = 1 4 ;  2    Report xterm window size in pixels.\r\n          Normally xterm's window is larger than its text area, since it\r\n          includes the frame (or decoration) applied by the window\r\n          manager, as well as the area used by a scroll-bar.\r\n```\r\nhttps://invisible-island.net/xterm/ctlseqs/ctlseqs.html\r\n\r\nThat pretty comprehensively establishes that 14t is indeed the correct escape code to use if a consumer wishes to know the size of the *text area* not the *window including padding/decorations/random numbers*.\r\n",
            "created_at": "2025-05-09T01:44:33Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2864858625",
            "id": 2864858625,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qwkYB",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864858625/reactions"
            },
            "updated_at": "2025-05-09T01:45:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864858625",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> Personally I'm more likely to want to just clear an area of the screen, and I wouldn't want to have to keep track of all the images I might have previously rendered in that area, and then individually request their removal.\r\n> \r\n> And for other protocols, clearing an area of the screen containing an image is trivial, but restoring the content that was previously below that image is not. So if the only reason for doing so is to emulate the way kitty deletes images, that's an expensive and pointless complication.\r\n\r\nMaybe read up on how the kitty protocol deletes images first. In the kitty protocol you can delete images that intersect any cell, row or column on the screen, without needing to keep track of the images.\r\nhttps://sw.kovidgoyal.net/kitty/graphics-protocol/#deleting-images\r\n",
            "created_at": "2025-05-09T01:50:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2864864246",
            "id": 2864864246,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qwlv2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864864246/reactions"
            },
            "updated_at": "2025-05-09T01:50:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2864864246",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The part I haven't figured out generically (yet) is embedding images within a buffer that reflows text around them, which is what I'd want when viewing markdown and orgmode documents with embedded images. Kitty does this through unicode placeholders such that the image follows the placeholders as they move around. Maybe we use extmarks to inject them in the kitty provider, but I don't know yet what should be the responsibility of neovim and what should be the responsibility of a provider in this use case.\r\n\r\n> @fredizzimo I think you shared thoughts earlier on the approach that would support neovide. Would you mind resharing that - a link to the comment above - or restating your thoughts on this matter? Anything changed in your thoughts here since last time?\r\n\r\nI think you can take a look at the image plugin from `snacks.nvim`. That one uses kitty placeholders, and extmarks for managing them. \r\n\r\nMy previous idea was a bit different, but I now think that using the unicode placeholders directly on the protocol level is good and gives a lot of flexibility. And I have also done a preliminary implementation of that in Neovide. My message about that is here https://github.com/neovim/neovim/issues/30889#issuecomment-2830670498\r\n\r\nI'm not sure if I wrote a more detailed message about my initial design, I can't find it either right now.  But in any case, it was not completely thought out, so using snacks a reference is probably the best.",
            "created_at": "2025-05-09T08:50:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2865717586",
            "id": 2865717586,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6qz2FS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2865717586/reactions"
            },
            "updated_at": "2025-05-09T08:50:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2865717586",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "### Sixel Provider on Windows Terminal (Windows 11)\r\n\r\nSmall update, I was playing around with decoding a PNG with the thought of sixel down the line, and then realized that ImageMagick actually supports directly converting an image to sixel.\r\n\r\n@j4james I put together a bit of a hack using sixel, and it seems like WezTerm doesn't work well unless I circumvent using neovim's `io.stdout:write()` in favor of directly accessing the tty. The image shown when using neovim's stdout ends up being garbled as if parts of it are getting cut off.\r\n\r\nHowever, when using with Windows Terminal, the sixel provider works _okay_ in that the images can be rendered and I can place them in different locations together. This isn't optimized at all as I'm having to use `vim.cmd.mode()` to force a full refresh, and I imagine using `vim.api.nvim__redraw()` with some better logic to determine which areas need to be refreshed (for removing images) would help.\r\n\r\nHere's a preview of this PR's sixel provider enabling images to work on Windows. I had to install ImageMagick, of course.\r\n\r\n\r\nhttps://github.com/user-attachments/assets/cfbe539c-66b2-4fba-be97-d8cc665a5eb5\r\n\r\n",
            "created_at": "2025-05-10T00:35:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2868149324",
            "id": 2868149324,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6q9HxM",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868149324/reactions"
            },
            "updated_at": "2025-05-10T00:36:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868149324",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> The absolute number that support it is irrelevant. The intersection of those that support the kitty protocol and report pixel sizes in the ioctl is what matters. \r\n\r\nI was under the impression that neovim was hoping to support image protocols other than just kitty, and I think all of those that I've counted implement some form of image protocol.\r\n\r\n> And let me quote the xterm spec for you:\r\n\r\nThe problem is that the spec used to be different. This is what the documentation originally said:\r\nhttps://github.com/ThomasDickey/xterm-snapshots/blob/9ac75bb2bdcf5c7e19a2fb32c507e454fe847253/ctlseqs.txt#L1116-L1119\r\n```\r\nPs = 1 4  -> Report xterm window size in pixels.  Normally\r\nxterm's window is larger than its text area, since it includes\r\nthe frame (or decoration) applied by the window manager, as\r\nwell as the area used by a scroll-bar.\r\n```\r\nAnd while it would be great if everyone went along with Xterm's changed behavior, that's unfortunately not what happened. And the ioctl situation is worse than `CSI 14 t`.\r\n\r\nStill, if you're happy with the limitations of ioctl and/or `CSI 14 t`, I'm not going to push the issue. I just wasn't expecting such a strong objection to using a report that was more likely to be correct.\r\n\r\n> Maybe read up on how the kitty protocol deletes images first. In the kitty protocol you can delete images that intersect any cell, row or column on the screen\r\n\r\nSorry, that wasn't intended to be a criticism of the kitty protocol. I am well aware of all the delete options. My point was that the image API being proposed in this PR doesn't work that way - it _requires_ images be deleted by ID. But I don't want to continue arguing against that approach. I just wanted to clarify the point I was making.",
            "created_at": "2025-05-10T12:42:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2868829445",
            "id": 2868829445,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6q_t0F",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868829445/reactions"
            },
            "updated_at": "2025-05-10T12:42:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868829445",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> WezTerm doesn't work well unless I circumvent using neovim's `io.stdout:write()` in favor of directly accessing the tty.\r\n\r\n@chipsenkbeil If you're testing WezTerm on Windows, and you're using the Windows version of neovim, that could be part of the problem. If you just want to test WezTerm's Sixel support, then it would be best to start with the Linux version, or using `wezterm ssh` to connect to a WSL shell from the Windows version. A native Windows console app introduces an additional level of complexity, so maybe that could be left for later.\r\n\r\n> ImageMagick actually supports directly converting an image to sixel.\r\n\r\nNote that ImageMagick doesn't support transparency for Sixel images as far as I know, but that's probably not essential for most use cases.\r\n\r\nAlso note that you might be able to reduce the flickering by using synchronized updates (mode ?2026). That's supported by quite a few Sixel terminals, although it was only recently added to Windows Terminal, so you'll need to use a nightly build for that.\r\n",
            "created_at": "2025-05-10T13:06:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2868839787",
            "id": 2868839787,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6q_wVr",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868839787/reactions"
            },
            "updated_at": "2025-05-10T13:06:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868839787",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > WezTerm doesn't work well unless I circumvent using neovim's `io.stdout:write()` in favor of directly accessing the tty.\n> \n> @chipsenkbeil If you're testing WezTerm on Windows, and you're using the Windows version of neovim\n\nAh, no, sorry for the confusion. I was testing sixel on wezterm on MacOS. The video I showed was Windows Terminal running neovim from powershell after building from msys64 for arm processor on windows. ",
            "created_at": "2025-05-10T13:37:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2868860152",
            "id": 2868860152,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6q_1T4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868860152/reactions"
            },
            "updated_at": "2025-05-10T13:37:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2868860152",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > The absolute number that support it is irrelevant. The intersection of those that support the kitty protocol and report pixel sizes in the ioctl is what matters.\r\n> \r\n> I was under the impression that neovim was hoping to support image protocols other than just kitty, and I think all of those that I've counted implement some form of image protocol.\r\n\r\nNo idea about that, they seem to be going back and forth on it, I certainly feel for them if they try to do it. It will be pretty hard to get right. I was talking purely about the kitty protocol, since that's what I was invited here to discuss. And for terminals that support the kitty protocol, the ioctl is the best way to get sizes followed by 14t. \r\n\r\n> \r\n> > And let me quote the xterm spec for you:\r\n> \r\n> The problem is that the spec used to be different. This is what the documentation originally said: https://github.com/ThomasDickey/xterm-snapshots/blob/9ac75bb2bdcf5c7e19a2fb32c507e454fe847253/ctlseqs.txt#L1116-L1119\r\n> \r\n> ```\r\n> Ps = 1 4  -> Report xterm window size in pixels.  Normally\r\n> xterm's window is larger than its text area, since it includes\r\n> the frame (or decoration) applied by the window manager, as\r\n> well as the area used by a scroll-bar.\r\n> ```\r\n> \r\n> And while it would be great if everyone went along with Xterm's changed behavior, that's unfortunately not what happened. And the ioctl situation is worse than `CSI 14 t`.\r\n\r\nSo terminals that get this wrong are in violation of the xterm spec, xterm being the terminal that originated this feature, it gets to decide what the right thing to do is. This is 2025, we are not dealing with hardware terminals set in stone anymore. IMO it would be perfectly acceptable for neovim to require terminals to do the right thing.  \r\n\r\n> \r\n> Still, if you're happy with the limitations of ioctl and/or `CSI 14 t`, I'm not going to push the issue. I just wasn't expecting such a strong objection to using a report that was more likely to be correct.\r\n\r\nI actually have no objection to using 16t, per se, my objection is that it is not widely supported and therefore is not suitable as a *replacement* for 14t or the ioctl. But I am perfectly OK with querying *all of* 16t and the ioctl and 14t and using the results of them in that order.\r\n\r\n> Sorry, that wasn't intended to be a criticism of the kitty protocol. I am well aware of all the delete options. My point was that the image API being proposed in this PR doesn't work that way - it _requires_ images be deleted by ID. But I don't want to continue arguing against that approach. I just wanted to clarify the point I was making.\r\n\r\nIt would be fairly trivial for the neovim API to add a method to delete by screen area in addition, after all it is presumably tracking the location of images internally. As a first step deleting by id will be a decent MVP. Later it can layer on more delete methods, for the kitty protocol, it can just generate the equivalent escape codes, if it implements other image backends it will need to loop over its internal set of image references and delete by intersection area.",
            "created_at": "2025-05-11T14:46:04Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2869907761",
            "id": 2869907761,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rD1Ex",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2869907761/reactions"
            },
            "updated_at": "2025-05-11T14:46:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2869907761",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "If getting the window dimensions still needs more discussion, let's continue discussing it where it belongs in https://github.com/neovim/neovim/pull/32408. Neovim already knows which terminal is running, so it should be able to return the correct information for all of them, using a combination of methods discussed here.",
            "created_at": "2025-05-12T13:49:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2872657639",
            "id": 2872657639,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rOUbn",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2872657639/reactions"
            },
            "updated_at": "2025-05-12T13:49:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2872657639",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Hm, it might not be possible to perfectly pixel align the images even with the kitty protocol without manually adding transparent borders using ImageMagic or similar\r\n\r\nYou can set the offset with 'X', but as far as I can see the right border is always aligned to the column. I wouldn't want to limit Neovim support to just that though. And indeed, your current protocol, does not seem to forbid it.\r\n\r\nI guess that even the kitty protocol needs to rely on Neovim/ImageMagick doing some resizing, Neovide can implement it using the GPU though.",
            "created_at": "2025-05-13T12:54:33Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2876398780",
            "id": 2876398780,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rcly8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876398780/reactions"
            },
            "updated_at": "2025-05-13T12:54:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876398780",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "On Tue, May 13, 2025 at 05:54:57AM -0700, fredizzimo wrote:\n> fredizzimo left a comment (neovim/neovim#31399)\n>\n> Hm, it might not be possible to perfectly pixel align the images even with the kitty protocol without manually adding transparent borders using ImageMagic or similar\n>\n> You can set the offset with 'X', but as far as I can see the right border is always aligned to the column. I wouldn't want to limit Neovim support to just that though. And indeed, your current protocol, does not seem to forbid it.\n\nNo the right border is not aligned to anything, you specify the top left\ncell and the image is simply rendered from there, unless you use the c\nand r control codes to render it in a specific area.\n",
            "created_at": "2025-05-13T13:03:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2876436175",
            "id": 2876436175,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rcu7P",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876436175/reactions"
            },
            "updated_at": "2025-05-13T13:03:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876436175",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> No the right border is not aligned to anything, you specify the top left cell and the image is simply rendered from there, unless you use the c and r control codes to render it in a specific area.\r\n\r\nI do specify 'c' to give it the width I want, but it only takes an integer and seem to right align in my tests. So, the option is to resize the image before displaying, or add a border, to let Kitty resize.\r\n\r\nA more concrete example is that I want to display an image starting from column 2.5 and end at column 37.75",
            "created_at": "2025-05-13T13:09:54Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2876462155",
            "id": 2876462155,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rc1RL",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876462155/reactions"
            },
            "updated_at": "2025-05-13T13:09:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876462155",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "On Tue, May 13, 2025 at 06:10:17AM -0700, fredizzimo wrote:\n> fredizzimo left a comment (neovim/neovim#31399)\n>\n> > No the right border is not aligned to anything, you specify the top left cell and the image is simply rendered from there, unless you use the c and r control codes to render it in a specific area.\n>\n> I do specify 'c' to give it the width I want, but it only takes an integer and seem to right align in my tests. So, the option is to resize the image before displaying, or add a border, to let Kitty resize.\n>\n> A more concrete example is that I want to display an image starting from column 2.5 and end at column 37.75\n\nYes, if you want to display images *at a specific pixel size different from\nthe images actual size* then you need to resize the image yourself.\nThat's by design. Resizing images is not a trivial task, the algorithm\nyou select for it can significantly alter the end result, whether you do\nit on the GPU or the CPU. Thus the protocol has only limited options for\nresizing.\n",
            "created_at": "2025-05-13T13:15:42Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2876480517",
            "id": 2876480517,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rc5wF",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876480517/reactions"
            },
            "updated_at": "2025-05-13T13:15:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876480517",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1308621?v=4",
                "events_url": "https://api.github.com/users/kovidgoyal/events{/privacy}",
                "followers_url": "https://api.github.com/users/kovidgoyal/followers",
                "following_url": "https://api.github.com/users/kovidgoyal/following{/other_user}",
                "gists_url": "https://api.github.com/users/kovidgoyal/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kovidgoyal",
                "id": 1308621,
                "login": "kovidgoyal",
                "node_id": "MDQ6VXNlcjEzMDg2MjE=",
                "organizations_url": "https://api.github.com/users/kovidgoyal/orgs",
                "received_events_url": "https://api.github.com/users/kovidgoyal/received_events",
                "repos_url": "https://api.github.com/users/kovidgoyal/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kovidgoyal/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kovidgoyal/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kovidgoyal",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@chipsenkbeil,\r\n\r\nIn that case it's probably the easiest to unify at least all of the terminal implementations to always add a transparent border and resize the image to fit to an exact cell width and height multipliers. As mentioned, Neovide could do that by itself for simple filtering, but the protocol could also be simplified to only deal with cell coordinates on the provider side. It also has the advantage that more advanced algorithms could be used.\r\n\r\nLinear upsampling and lancos-3 downsampling, are good compromises for default resizing strategies https://entropymine.com/resamplescope/notes/browsers/. And I don't think Lancos-3 can be done in real-time on the GPU anyway, so we are not losing too much by delegating it to some library or another process.\r\n\r\nWhat do you think?\r\n\r\n**Edit:** Probably not to be done in this PR\r\n**Edit2:** It also means that each placement potentially needs its own internal image.\r\n**Edit3:** It also removes the need for cropping on the provider side. Except for protocols that don't have a placeholder style protocol and can therefore go out of floating windows, but that needs to be handled as special cases anyway.",
            "created_at": "2025-05-13T14:30:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2876763299",
            "id": 2876763299,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rd-yj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876763299/reactions"
            },
            "updated_at": "2025-05-13T16:03:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2876763299",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "So, if I get this right\r\n|Protocol | Positioning | Sizing | Perfect Aspect Ratio | Crop Support | Needs conversion |\r\n| - | - | -| - | - | - |\r\n|Kitty| Pixel | Cell (*) | Yes | Yes | No| For other formats than png |\r\n|Iterm|Cell| Pixel| Yes | No | No | No (supports a lot of formats |\r\n|Sixel|Cell|Cell| No | No | Yes | Yes |\r\n\r\n(*) - Limited pixel-based sizing, affected by the position\r\nPerfect Aspect Ratio = Automatically calculated with pixel accuracy when one dimension is left out\r\nCrop support = Can show a cropped portion of the source scaled to the destination size\r\n\r\nSo, Sixel will need custom resizing and conversion anyway. And the rest would have to be limited to a common factor of only supporting grid based positioning, and grid based resizing, where one dimension can be left out to have it scale automatically.\r\n\r\nThat is an option for the core protocol though, loading custom formats, resizing and adding transparent borders for pixel based positioning could be delegated to plugins as long as Neovim provides accurate grid dimensions, and helper functions to do the calculations. And I think that's what's essentially implemented currently, if the pixel support and crop is removed from the opts  table.",
            "created_at": "2025-05-13T16:40:21Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2877250193",
            "id": 2877250193,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rf1qR",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877250193/reactions"
            },
            "updated_at": "2025-05-13T16:56:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2877250193",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@justinmk @gpanders @j4james  okay, I think I'm hitting a wall and need your help on this piece. I'm illustrating the problems I'm facing in two videos:\r\n\r\n### Flicker on sixel and iterm2\r\n\r\nBelow is a video of iTerm2, WezTerm, Ghostty, and Windows Terminal displaying images. \r\n\r\n1. In the top-left, iTerm2 using the iTerm2 provider (sixel also works).\r\n2. In the top-right, WezTerm using the sixel provider (kitty and iTerm2 also work)\r\n3. In the bottom-left, Ghostty using the kitty provider\r\n4. In the bottom-right, Windows Terminal using the sixel provider\r\n\r\nhttps://github.com/user-attachments/assets/a10da5fa-c4b3-4f3c-a155-f3712bf603b0\r\n\r\nThe sixel and iterm2 are a bit rough because - unlike kitty - I need to manually clear the screen and redraw all images whenever something changes. This could be scrolling, could be typing over the image, could be swapping buffers within a window where an image is present, etc. I have to add a delay from when I trigger a screen redraw (via `vim.cmd.mode()`) to reduce the broken escape code problem below, which exacerbates the flicker.\r\n\r\n1. `nvim__redraw` doesn't offer a way to specify a rectangular region of the screen to redraw. I can work to partially optimize by detecting which windows an image is over and using `nvim__redraw` to refresh it and only redraw those images, but otherwise seems like I'm stuck.\r\n2. I can't tell when neovim has finished redrawing from `vim.cmd.mode()` (or other redraw asks), which means I have to use `vim.defer_fn()` with an arbitrary time (30ms) to reduce the second problem below. Is there any way to determine this from neovim? Or, @j4james, from any sort of terminal codes?\r\n3. @j4james you'd mentioned pages to do image cropping. Is there any sort of double buffering I can take advantage of? Ideally, I could clear the screen, have neovim render itself, and then render all of the images again on top in some frame buffer and then copy it over, but my guess is nothing like that exists that will work with neovim (that already uses the alternate screen).\r\n\r\n### Broken Escape Codes\r\n\r\nhttps://github.com/user-attachments/assets/1aac7d38-2973-4880-b271-1976356d972a\r\n\r\n@gpanders @j4james I'm still getting parts of my sixel and iterm2 escape codes showing up (with images broken) every so often, and I think this is because I'm fighting neovim to write to the same tty, but I'm not fully sure.\r\n\r\nI haven't noticed this problem on Windows with the Windows terminal. When I trigger a full refresh via `vim.cmd.mode()`, introducing a delay (of 30 milliseconds) before I write the escape codes for sixel or iterm2 seems to reduce the frequency a lot, but it can still happen. Even when using `vim.api.nvim_chan_send(2, 'escape codes')` that I saw with the clipboard code and OSC, I still get this problem. I changed the delay to 1 millisecond for the above video to show just how bad it can be (shows base64 encoded PNG data; sixel is similar with RGB).\r\n\r\nIs there any way to control this more effectively? I'm currently batching all of my escape codes together to send out at once with the above `nvim_chan_send`. Been trying a bunch of different approaches and what I have now illustrated in the first video is the best I've got thus far.\r\n\r\n### Neovim eats terminal responses\r\n\r\n@gpanders you may have missed my previous callout on this. Seems like `CSI 14 t` and `CSI 16 t` responses don't show up in `TermResponse` and I'm assuming are eaten in part of neovim's codebase. Same goes for when I try to request the current cursor position, but I didn't end up needing that code to get where I am thus far.\r\n\r\nWithout being able to get a response for one or both of those, Windows pixel sizes for individual cells can't be calculated. At least, based on what @j4james has mentioned in a recent comment.\r\n\r\n",
            "created_at": "2025-05-13T22:09:13Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2878071572",
            "id": 2878071572,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6ri-MU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878071572/reactions"
            },
            "updated_at": "2025-05-13T22:24:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878071572",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> The sixel and iterm2 are a bit rough because - unlike kitty - I need to manually clear the screen and redraw all images whenever something changes. This could be scrolling, could be typing over the image, could be swapping buffers within a window where an image is present, etc. I have to add a delay from when I trigger a screen redraw (via vim.cmd.mode()) to reduce the broken escape code problem below, which exacerbates the flicker.\r\n\r\nIf those were to be supported, the integration probably needs to be at a deeper level, in tui.c, with the data transferred there over the UI protocol. That part of the code knows exactly what has changed and needs to be redrawn. That's actually probably the case even for Kitty if you connect to a remote instance. \r\n\r\nBut it also makes the whole feature quite a bit more complex. \r\n\r\nIt might also be that it's easier to forget the absolute positioning support, and only support something similar to unicode placeholders. That way Neovim will automatically resolve all overlaps and partially visible images. And then you \"just\" need to refresh the cells as they are transferred to the tui.c code. But you still also need a way to transfer the actual image data there somehow.\r\n\r\n",
            "created_at": "2025-05-13T23:13:58Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2878159024",
            "id": 2878159024,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rjTiw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878159024/reactions"
            },
            "updated_at": "2025-05-13T23:13:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878159024",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I can't tell when neovim has finished redrawing from vim.cmd.mode() (or other redraw asks), which means I have to use vim.defer_fn() with an arbitrary time (30ms) to reduce the second problem below.\r\n\r\n@chipsenkbeil I don't know anything about nvim scripting, so I'm just guessing here, but I noticed that `nvim__redraw` has a `flush` option. Would that not avoid the need for the deferred refresh, even if it still meant redrawing the entire screen? Because that might avoid the sixel/iterm sequences getting mixed up with other output if you could guarantee the redraw was flushed before you began the image output.\r\n\r\nAnd assuming that does work, you might then be able to wrap both the call to `nvim__redraw` and the sixel/item images in the same synchronized output block, which should reduce the flickering.\r\n\r\n> Is there any sort of double buffering I can take advantage of? Ideally, I could clear the screen, have neovim render itself, and then render all of the images again on top in some frame buffer and then copy it over,\r\n\r\nAll of that is feasible in theory, but I know at least on Windows Terminal it isn't currently supported in the alt buffer (although I'd be happy to see if we could extend that support if there was a demand for it). There are a few other terminals that support paging, and which can potentially be used from within the alt buffer, but there are some idiosyncrasies in their implementation which makes me doubt whether they could support this use case.\r\n\r\nThe bottom line is this is probably something best left for later, if there is need for further optimization (particularly for clipping). But I think synchronized output is still the best short term solution for the flickering issue, and it's likely to be far more widely supported.\r\n\r\n> Without being able to get a response for one or both of those, Windows pixel sizes for individual cells can't be calculated. At least, based on what @j4james has mentioned in a recent comment.\r\n\r\nNote that for Windows Terminal in particular, you could just fallback to a hardcoded cell size of 10x20 if you can't determine the cell size through any other means. That won't work on most other terminals though.",
            "created_at": "2025-05-13T23:35:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2878183257",
            "id": 2878183257,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rjZdZ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878183257/reactions"
            },
            "updated_at": "2025-05-13T23:35:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2878183257",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > I can't tell when neovim has finished redrawing from vim.cmd.mode() (or other redraw asks), which means I have to use vim.defer_fn() with an arbitrary time (30ms) to reduce the second problem below.\n> \n> @chipsenkbeil I don't know anything about nvim scripting, so I'm just guessing here, but I noticed that `nvim__redraw` has a `flush` option. Would that not avoid the need for the deferred refresh, even if it still meant redrawing the entire screen? Because that might avoid the sixel/iterm sequences getting mixed up with other output if you could guarantee the redraw was flushed before you began the image output.\n> \n> And assuming that does work, you might then be able to wrap both the call to `nvim__redraw` and the sixel/item images in the same synchronized output block, which should reduce the flickering.\n\nI got the synchronized output working. Reading through neovim's source, turns out it uses that mode already, but it can be disabled with an option, `vim.o.termsync`. So, I temporarily disable it while I refresh.\n\nFlicker is gone, and I tested as well on nightly windows terminal and it works great for sixel!\n\n@j4james is there any alternative I can pursue outside of CSI for windows pixel dimensions, cell or text area? If not, that'll need to be added to neovim core, I think. ",
            "created_at": "2025-05-14T20:42:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2881514838",
            "id": 2881514838,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rwG1W",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881514838/reactions"
            },
            "updated_at": "2025-05-14T20:42:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881514838",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> @j4james is there any alternative I can pursue outside of CSI for windows pixel dimensions, cell or text area? If not, that'll need to be added to neovim core, I think.\r\n\r\n@chipsenkbeil Not sure if you missed this comment, but I mentioned above you can just hardcode a cell size of 10x20 and it'll work on Windows Terminal. I'm assuming you already know the number of columns and rows, so if you need the window pixel dimensions you would just multiple the columns by 10 and the rows by 20 (it's a kind of virtual size, but the images are automatically scaled, so that's all you need to know).\r\n\r\nThat won't work for most other terminals, though, but it's at least a temporary solution until neovim core can support the `CSI t` size queries.",
            "created_at": "2025-05-14T22:23:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2881725092",
            "id": 2881725092,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rw6Kk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881725092/reactions"
            },
            "updated_at": "2025-05-14T22:23:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881725092",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > @j4james is there any alternative I can pursue outside of CSI for windows pixel dimensions, cell or text area? If not, that'll need to be added to neovim core, I think.\r\n> \r\n> @chipsenkbeil Not sure if you missed this comment, but I mentioned above you can just hardcode a cell size of 10x20 and it'll work on Windows Terminal. I'm assuming you already know the number of columns and rows, so if you need the window pixel dimensions you would just multiple the columns by 10 and the rows by 20 (it's a kind of virtual size, but the images are automatically scaled, so that's all you need to know).\r\n> \r\n> That won't work for most other terminals, though, but it's at least a temporary solution until neovim core can support the `CSI t` size queries.\r\n\r\nOh, I misread that and thought that was a fallback in case I couldn't get the size for Windows Terminal. So Windows Terminal is always 10x20? I'm checking for the presence of `WT_SESSION` right now to see if I'm in the Windows Terminal, which is a best guess unless you have another suggestion.\r\n\r\nAnyway, thanks for all of your help on the sixel, escape codes, and Windows. Really sped up the development on this side :)",
            "created_at": "2025-05-14T22:28:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2881736084",
            "id": 2881736084,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rw82U",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881736084/reactions"
            },
            "updated_at": "2025-05-14T22:28:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881736084",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I'm checking for the presence of `WT_SESSION` right now to see if I'm in the Windows Terminal, which is a best guess unless you have another suggestion.\r\n\r\n@chipsenkbeil I wouldn't recommend `WT_SESSION` - it's not guaranteed to be set, and there's nothing you should be doing that's specific to Windows Terminal anyway. The 10x20 size can potentially work on other terminals too (at the very least the Windows console, but also possibly a few commercial terminal emulators). That why I was saying to use it as a fallback, assuming nothing else worked (i.e. there is no ioctl, or ioctl is returning 0 dimensions). Because under those conditions you've got nothing to lose - hardcoding the size as 10x20 at least has a chance of working.",
            "created_at": "2025-05-14T22:44:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2881759011",
            "id": 2881759011,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6rxCcj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881759011/reactions"
            },
            "updated_at": "2025-05-14T22:44:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2881759011",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4181424?v=4",
                "events_url": "https://api.github.com/users/j4james/events{/privacy}",
                "followers_url": "https://api.github.com/users/j4james/followers",
                "following_url": "https://api.github.com/users/j4james/following{/other_user}",
                "gists_url": "https://api.github.com/users/j4james/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/j4james",
                "id": 4181424,
                "login": "j4james",
                "node_id": "MDQ6VXNlcjQxODE0MjQ=",
                "organizations_url": "https://api.github.com/users/j4james/orgs",
                "received_events_url": "https://api.github.com/users/j4james/received_events",
                "repos_url": "https://api.github.com/users/j4james/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/j4james/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/j4james/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/j4james",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I opened a new issue for the Pixel/Grid size discussion, along with an API proposal. https://github.com/neovim/neovim/issues/34093\r\n\r\n@chipsenkbeil, So far it's only a proposal, but I do think it makes a lot of sense. And if implemented I hope that it does not invalidate too much of the work that's done here.",
            "created_at": "2025-05-19T23:08:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2892481526",
            "id": 2892481526,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6sZ8P2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2892481526/reactions"
            },
            "updated_at": "2025-05-19T23:09:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2892481526",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> I opened a new issue for the Pixel/Grid size discussion, along with an API proposal. #34093\r\n> \r\n> @chipsenkbeil, So far it's only a proposal, but I do think it makes a lot of sense. And if implemented I hope that it does not invalidate too much of the work that's done here.\r\n\r\nRevising as what I wrote was too focused on my concerns about another issue and not about what you were proposing. I also took the liberty of updating the PR's original message to reflect the state of the PR, provide examples of the API in action, and show a video of each provider being used to display, hide, and update images.\r\n\r\n1. Thanks for continuing to provide feedback and perspective on the image API. You're one of the most involved and have been giving it serious thought, and I appreciate the engagement. :)\r\n2. I read through some of your proposal. I think the changes you suggested, at least on the API side using `nvim_` could work where we just shove the existing API here (objects) underneath, making them private. I personally like the object approach more in a similar vein to `vim.system()`.\r\n3. I'd push for keeping the three providers at this point: they're actually decently performant and we need sixel to support Windows Terminal at all. This does mean introducing a dependency on a binary (ImageMagick) for *some* of the providers (sixel, and iterm2 when cropping), which originally I was against, but now I'm in favor of having as a configurable option (`vim.o.imgprg`) in the same manner that `grepprg` exists, defaulting to `rg` and falling back to `grep`.\r\n4. I'd also push to keep image cropping, mainly as I had in mind to have neovim handle tracking and communicating to providers when images need to be moved around and cropped based on being placed in a buffer, while providers like `kitty` and `neovide` can overwrite that default behavior and supply their own method to indicate that they will manage it themselves.\r\n\r\nI would like @justinmk to weigh in on direction soon. The PR is just about at the finish line with me writing tests and preparing documentation for it, so if we go a different route it'd be helpful for me to know",
            "created_at": "2025-05-19T23:17:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2892491856",
            "id": 2892491856,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6sZ-xQ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2892491856/reactions"
            },
            "updated_at": "2025-05-20T04:40:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2892491856",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@chipsenkbeil thank you for all the hard work you have done here, it's not a small feat. \r\n\r\nI'm sorry for pushing you towards a design that supports pixels, I should have studied the Kitty protocol better to know that it's not fully possible. On the positive side, dropping the support for that makes the common use cases much easier, and the protocol easier to reason about.\r\n\r\n> I read through some of your proposal. I think the changes you suggested, at least on the API side using nvim_ could work where we just shove the existing API here (objects) underneath, making them private. I personally like the object approach more in a similar vein to vim.system().\r\n\r\nI don't have any strong personal opinions about that, and my proposal can be translated to an object oriented approach quite easily. But I do think my suggestions fits better in with the rest of the nvim API. I was actually going to comment about that a long time ago, but waited for some of the maintainers to do it. But with the re-design of the API, I saw the opportunity to do so.\r\n\r\n> I'd push for keeping the three providers at this point: they're actually decently performant and we need sixel to support Windows Terminal at all. This does mean introducing a dependency on a binary (ImageMagick) for some of the providers (sixel, and iterm2 when cropping), which originally I was against, but now I'm in favor of having as a configurable option (vim.o.imgprg) in the same manner that grepprg exists, defaulting to rg and falling back to grep.\r\n\r\nThat's not my call, but I can see that inline image support in the buffers will be much harder to implement for those protocols. ITerm2 also supports Kitty as far as I know, so out of the popular terminals only the Windows terminal is unsupported, but both Alacritty and Wezterm are well supported on Windows, so IMO, it's not a huge drawback.\r\n\r\nThere are also other protocol limitations, outside my table. For example, I think the Iterm2 protocol only supports a single transparent color, the default background, so it will look wrong if the image is displayed on top of multiple nvim background colors. \r\n\r\n**Edit:** I think the additional providers could be supported as external plugins that overrides the default providers and depends on imagemagick. That way your work doesn't go to waste.\r\n\r\n> I'd also push to keep image cropping, mainly as I had in mind to have neovim handle tracking and communicating to providers when images need to be moved around and cropped based on being placed in a buffer, while providers like kitty and neovide can overwrite that default behavior and supply their own method to indicate that they will manage it themselves.\r\n\r\nI think the cropping can be implicit; it's only really needed when displaying an image inline in the buffer. And cropping area is constantly changing when you scroll the document, so it doesn't really belong in the options. Cropping can also still be supported by using ImageMagick or something similar on the plugin side. In fact, it gets much more flexible that way and could support arbitrary clipping shapes for example.\r\n\r\nCropping also implies an ImageMagick dependency for Iterm2 as well. Which I think should be avoided\r\n",
            "created_at": "2025-05-20T09:28:00Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2893634294",
            "id": 2893634294,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6seVr2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2893634294/reactions"
            },
            "updated_at": "2025-05-22T08:49:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2893634294",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "The work done here won't get \"lost\" if we reduce the scope. In fact, reducing the scope ensures that it doesn't get lost, whereas if we don't reduce the scope, this won't get merged. This initial change should be as minimal as possible, and then the rest of it can be proposed in followup PRs.\r\n\r\nEverything that is a two-way door should be dropped, if it slows down our ability to merge this. I don't want to risk this getting stalled/blocked.\r\n\r\n\r\n\r\n- is inline image support a 2-way door? why is it needed *now*? can we drop it, while leaving the door open for the future?\r\n- Windows terminal support (sixel) is a 2-way door.\r\n    - also: Windows terminal is actively maintained, it will likely gain kitty protocol support.\r\n- `vim.o.imgprg` is too much for now. `:checkhealth` can say \"install X for image support\".\r\n- the \"provider\" model should be internal-only, so that we don't get blocked thinking about that surface area for now.\r\n- pixel support is be a 2-way door: make sure we don't assume \"units\", i.e. `width` can be a `\"42px\"` string in the future, but if it's a number then it's \"columns\".\r\n\r\nI don't care about complaints from users who want this and that. The main goal is to have basic image support for e.g. markdown.\r\n\r\n> Edit: I think the additional providers could be supported as external plugins that overrides the default providers and depends on imagemagick. That way your work doesn't go to waste.\r\n\r\nThat's an option, but can follow as a separate PR which decides the \"provider model\". This PR should not get bogged down with deciding a provider model.",
            "created_at": "2025-05-21T09:59:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2897362022",
            "id": 2897362022,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6ssjxm",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2897362022/reactions"
            },
            "updated_at": "2025-05-21T10:03:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2897362022",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Thanks @justinmk and @fredizzimo for locking down discussion and changes. I'll get to these soon.\n\nSo it's clear what I'll do:\n\n1. Remove ImageMagick\n2. Remove iterm2 and sixel providers\n3. Rename filename param to file and bytes param to data within Image\n4. Remove crop option when showing an image\n5. Remove Region as it was only needed for cropping\n6. Remove Size and Position and flatten those parameters in the Opts table as we no longer need to carry around unit type\n7. Merge Image and Placement\n8. Remove supported check from providers as they don't function in neovim (can't capture CSI or kitty responses) \n9. Remove screen size code (was temporary) \n10. Move promise to _promise internally\n11. Update PNG function to return boolean or nil\n12. Wrap img import within ui.lua via the defer @justinmk mentioned\n13. Remove imgprg and imgprovider and hard code kitty.\n14. Keep the printio-test bin per @justinmk feedback \n\nWhat I won't do unless you tell me you want it now:\n\n1. Convert provider to be synchronous \n2. Remove promise code in favor of libuv/luv style (ironically, what I started with) \n3. Change to use the nvim_* discussed by @fredizzimo \n4. Add LRU to kitty provider to track which images to retransmit \n5. Update kitty provider to transmit every time you show the image\n\nAnything I missed? Typing from my phone, so going from memory. \n",
            "created_at": "2025-05-22T13:11:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901180328",
            "id": 2901180328,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s7H-o",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 2,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901180328/reactions"
            },
            "updated_at": "2025-05-22T13:18:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901180328",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Remove Size and Position and flatten those parameters in the Opts table as we no longer need to carry around unit type\r\n\r\nYes. It can be done in a way that allows us to re-add those in the future, right? If I'm wrong, can you show a small example of the function signature before/after.\r\n\r\n> What I won't do unless you tell me you want it now:\r\n>\r\n> Convert provider to be synchronous\r\n> Remove promise code in favor of libuv/luv style (ironically, what I started with)\r\n\r\nNot required here, but hopefully in a followup. Async should ideally be opt-in via an optional callback param.",
            "created_at": "2025-05-22T13:45:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901289492",
            "id": 2901289492,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s7ioU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901289492/reactions"
            },
            "updated_at": "2025-05-22T13:45:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901289492",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Remove promise code in favor of libuv/luv style (ironically, what I started with)\n\nI would prefer this. I'm working on adding `vim.async` and porting luv style will be easier.",
            "created_at": "2025-05-22T13:48:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901299838",
            "id": 2901299838,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s7lJ-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 3,
                "total_count": 7,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901299838/reactions"
            },
            "updated_at": "2025-05-22T13:48:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901299838",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "**We still need to discuss the exact API semantics, especially regarding the size paramete**r. That was the main reason I opened my API proposal, to have a specification. The removal of the absolute position support wasn't even included in the initial version.\r\n\r\nAs far as I can see the exact behaviour is unspecified here, but from based on the actual implementation and interface we have the following. Size is either optional or present, and if present both width and height are required. And when present, it's passed directly along to Kitty.\r\n\r\nThis means.\r\n1. Not present - The image is displayed with the size of the source image\r\n2. Present - The image is stretched/shrunk so that both the width and height fit the columns and rows exactly\r\n3. There's no way to control how big the image, while at the same time keeping the aspect ratio.\r\n\r\nThis seemed OK to me when I though Kitty worked differently, and we would have more control being able to specify pixel sizes, preserving the aspect ratio. I was counting on the helper functions, which were unspecified to take care of the details. But that would still only have worked for a single TUI/GUI case.\r\n\r\nSo, this is what I specified instead here https://github.com/neovim/neovim/issues/34093\r\nFor buffer/inline positions both dimensions are always required, otherwise only one. Furthermore, there's a `keep_aspect` field that defines the behaviour when both dimensions are specified, with the idea that one of the dimensions is always filled. I thought that this was doable without knowing the cell aspect ratio, but it's actually not so I'm revising my suggestion:\r\n\r\n**Regardless of the placement mode, you can specify non, one or both of the dimensions. If both are specified, the `keep_aspect` ratio field determines if both dimensions should be used fully or only the one with the best fit. If none are specified, the number of columns and rows is automatically determined.**\r\n\r\nBonus: minimum maximum support like snacks.\r\n\r\nAs mentioned, we will need to know the cell aspect ratio and/or size according to the following:\r\n1. Non specified and absolute positioning - No need unless we want to be able to query how many cells the image actually is\r\n2. Non specified and inline positioning - We need the exact cell size so that we can allocate room for the image in the buffer\r\n3. One specified and absolute positioning - No need, kitty supports scaling accordingly unless we want to query\r\n4. One specified and inline positioning - We only need the aspect ratio\r\n5. Both specified - We need the aspect ratio to determine which size to use\r\n6. Bonus - We need aspect ratio\r\n\r\nNote that the cell aspect ratio can be virtual, for example 1:2, and the images would still be displayed with the correct proportions.  It's just that the reserved area might be bigger or smaller than intended. So, in that case no terminal query support is needed, and no decision needs to be taken about which terminal is the main one. This approach also works well when multiple different UIs are connected.\r\n\r\n**Therefore, I suggest that we always require at least one dimension for now in this initial version**, because terminal query support and designating a primary UI, which need a lot of design thought by itself, is still not implemented.\r\n\r\n**The z-index behaviour also needs specification**\r\n1. Do we copy the Kitty one?\r\n  > Finally, you can specify the image z-index, i.e. the vertical stacking order. Images placed in the same location with different z-index values will be blended if they are semi-transparent. You can specify z-index values using the z key. Negative z-index values mean that the images will be drawn under the text. This allows rendering of text on top of images. Negative z-index values below INT32_MIN/2 (-1,073,741,824) will be drawn under cells with non-default background colors. If two images with the same z-index overlap then the image with the lower id is considered to have the lower z-index. If the images have the same z-index and the same id, then the behavior is undefined.\r\n\r\n  That is the only thing we can implement with the Kitty protocol I think. But it's hard to do in Neovide, since it fights against the natural order of floating windows in Neovim\r\n2. Do we allow only positive indices? Meaning that the images will always be on top of all other Neovim elements. The z-index has no relation to the window z-index at all. At least this interpretation is much more doable\r\n3. Or do we leave it undefined? I don't like this at all, even if Neovide itself would benefit from an interpretation where the z-index follows the window z-index, or even more fine grained. But the compatibility issues are worrying me.\r\n\r\n**I suggest that we implement 2.**\r\n\r\n\r\n\r\n\r\n\r\n",
            "created_at": "2025-05-22T16:05:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901790661",
            "id": 2901790661,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s9c_F",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901790661/reactions"
            },
            "updated_at": "2025-05-22T16:05:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901790661",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I also suggest that we battle test this against snacks.nvim. It has an absolute positioning mode to support wezterm.",
            "created_at": "2025-05-22T16:12:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901818356",
            "id": 2901818356,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s9jv0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901818356/reactions"
            },
            "updated_at": "2025-05-22T16:12:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901818356",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > Remove promise code in favor of libuv/luv style (ironically, what I started with)\r\n> \r\n> I would prefer this. I'm working on adding `vim.async` and porting luv style will be easier.\r\n\r\nCouldn't we avoid async support altogether by externalizing the file loading, and pass a data buffer containing the PNG file data to the API? I see zero reasons why anything in here should ever block or require calculation.",
            "created_at": "2025-05-22T16:20:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2901838362",
            "id": 2901838362,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6s9ooa",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901838362/reactions"
            },
            "updated_at": "2025-05-22T16:20:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2901838362",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> We still need to discuss the exact API semantics, especially regarding the size parameter.\r\n\r\nThe details that you pointed out are useful to track in a (concise) issue. If we find things that need to be changed, we can quickly adjust. \r\n\r\nThe point is to have something that works on master branch NOW instead of endlessly debating it and not having real-world feedback from master branch users.\r\n\r\n> I suggest that we always require at least one dimension for now in this initial version,\r\n\r\nok.\r\n\r\n> Do we allow only positive indices? Meaning that the images will always be on top of all other Neovim elements. The z-index has no relation to the window z-index at all. \r\n\r\nsure. start with the most restricive thing. constraints can always be relaxed later, but the opposite is much harder.",
            "created_at": "2025-05-23T15:01:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2904737491",
            "id": 2904737491,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tIsbT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2904737491/reactions"
            },
            "updated_at": "2025-05-23T15:05:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2904737491",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I can't find a function that deletes an image to free up memory, I can only see hide for placements.\r\n\r\nEven if we combine images and placements, I think there needs to be a function to free up the memory. I also think that hiding an image without deleting the data should still be possible.",
            "created_at": "2025-05-23T22:49:59Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2905973565",
            "id": 2905973565,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tNaM9",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2905973565/reactions"
            },
            "updated_at": "2025-05-23T22:49:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2905973565",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@justinmk @fredizzimo @gpanders @clason I've updated the PR to follow through with the items I listed to make it just kitty and clean up/remove a lot of the code we talked about. I hope this makes it easier to review going forward!\r\n\r\n@fredizzimo I haven't updated docs or added checks to assert that one or both width & height are specified yet.\r\n\r\n> 2. Do we allow only positive indices? Meaning that the images will always be on top of all other Neovim elements. The z-index has no relation to the window z-index at all. At least this interpretation is much more doable\r\n\r\nWhen I implemented sixel and iterm2, this is essentially what I did because it would be near impossible to get them to behave the same way as kitty when it comes to negative indices. I didn't stop anyone from creating them with negative indices, but it would just behave the same way as positive.\r\n\r\n> I can't find a function that deletes an image to free up memory, I can only see hide for placements.\r\n>\r\n> Even if we combine images and placements, I think there needs to be a function to free up the memory. I also think that hiding an image without deleting the data should still be possible.\r\n\r\nAre you referring to the data loaded into the image class? If so, it's a public field, why can't the user just do `img.data = nil` to remove it if they want to keep the image instance itself around?",
            "created_at": "2025-05-24T03:49:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2906361540",
            "id": 2906361540,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tO47E",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906361540/reactions"
            },
            "updated_at": "2025-05-24T03:49:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906361540",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> > I can't find a function that deletes an image to free up memory, I can only see hide for placements.\r\n> > Even if we combine images and placements, I think there needs to be a function to free up the memory. I also think that hiding an image without deleting the data should still be possible.\r\n> \r\n> Are you referring to the data loaded into the image class? If so, it's a public field, why can't the user just do `img.data = nil` to remove it if they want to keep the image instance itself around?\r\n\r\nI'm thinking more about the provider side, without deletion on the user side we are forcing all providers to implement some kind of eviction system. Even with the automatic eviction on the Kitty side, it's not a good idea to keep the buffer full, since other applications that shows images will suffer.\r\n\r\nBut maybe the planned fifo system could do it two ways, to also send deletion requests and keep a fixed size allocation on the provider side at all times? That has the advantage of the user not having to do any management themselves.\r\n\r\nI'm not sure if it's possible to use the lua `__gc` hooks with luajit, but even if it is, it's probably not too well suitable, due to its non-deterministic behaviour.\r\n\r\nIf it's going to be done on the FIFO side, no actions are required for this PR.",
            "created_at": "2025-05-24T10:34:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2906762258",
            "id": 2906762258,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tQawS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906762258/reactions"
            },
            "updated_at": "2025-05-24T10:34:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906762258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> I also suggest that we battle test this against snacks.nvim. It has an absolute positioning mode to support wezterm.\r\n\r\nI made a working implementation of that yesterday, but I need to redo it with the new API changes, probably done later today. After that I will share it. It works both with the kitty protocol and a custom branch of Neovide.\r\n\r\nIt works, but is not really practical due to the zindex limitations. As predicted, images meant to be displayed in the main buffer, are always displayed on top of floating windows. Maybe some clever tricks with dynamically hiding and showing images could be done, but my focus will be on inline image support.\r\n\r\n**Edit:** Snacks already does the dynamic hiding and showing part, I just didn't call the API hide properly",
            "created_at": "2025-05-24T11:22:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2906780580",
            "id": 2906780580,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tQfOk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906780580/reactions"
            },
            "updated_at": "2025-05-24T19:14:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2906780580",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "There does not seem to be a way to override the provider in the latest version, so I'm unable to test it against Neovide. I also think that the image itself shouldn't store any references to the provider as ideally the same image should display on all connected UIs simultaneously.\r\n\r\nBut I do have my hacks to snacks.nvim here https://github.com/fredizzimo/snacks.nvim/tree/nvim-api, which allows it to work with this API in terminals with Kitty protocol support.\r\n\r\nThe images are stretched, since the automatic aspect ratio calculation when both with and height is specified described here https://github.com/neovim/neovim/pull/31399#issuecomment-2901790661 isn't implemented. And that can't be done on the snacks side, since the decisions of using width or height depends on the terminal aspect ratio.\r\n\r\nThe lack of querying basic image information like width and height is missing, so that's done on the snacks side for now.\r\n\r\nAll the API usage there is synchronous with wait, as that's still how I think that's how it should work. The provider could deal with all the asynchronous support internally. At most the loading could be asynchronous, since that needs to load the header to be able to provide the image information.\r\n\r\n**Edit:** Only the picker and raw buffer display works, the doc for markdown documents needs some fixes.\r\n**Edit2:** The doc display works now. but the image is displayed in the wrong position. I don't have time to check if what's the cause is right now, but likely somewhere in my snacks changes. **Update:** That bug exists in the main version of snacks as well, if a hover window is moved, then the image does not follow. It's just worse in my version since the windows are always big due to lack of terminal query support.",
            "created_at": "2025-05-24T21:20:59Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2907049489",
            "id": 2907049489,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tRg4R",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2907049489/reactions"
            },
            "updated_at": "2025-05-25T10:02:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2907049489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm sorry, but I think that my previous suggestion of allowing either the width or the height to be unspecified wasn't a wise one. \r\n\r\nAllowing that is still not enough for many practical use cases, as I found out when changing snacks.nvim. Many will need access to the actual cell geometry to determine how big the images should be displayed. \r\n\r\nTherefore, I suggest that the size decision as a whole is externalized to the plugin, using whatever comes out of https://github.com/neovim/neovim/pull/32408. So, for now I suggest that both the width and height are required.\r\n\r\nI'm afraid that specifying what aspect ratio is used for automatically calculating the unspecified dimension would be a bit premature, when we don't fully understand the requirements yet. It's easier to add support for that later, than to have to modify the specification and maybe break plugins that were made against the previous spec. I'm mostly worried about how multiple simultaneously connected UIs will affect it.\r\n\r\nIf https://github.com/neovim/neovim/pull/32408, is kept general so that plugins can query the cell information of all connected UIs, then the plugins have all the information needed to experiment and come up with the best solution, that can be adopted in the core later.\r\n\r\nThis specification should not affect this PR very much, other than specifying that both dimensions are required. There's no query support, and the whole existing implementation relies on the Kitty protocol doing its magic. So other than that, everything works as before.\r\n\r\nI would still rather see that keeping the aspect ratio is the default when both dimensions are specified, than stretching/shrinking like currently implemented. But that requires determining the cell geometry on the provider side, which is an easier problem, since hopefully there will be separate providers for every UI connected. For now, that could be documented as an implementation bug.",
            "created_at": "2025-05-25T21:16:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/31399#issuecomment-2908086918",
            "id": 2908086918,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
            "node_id": "IC_kwDOAPphoM6tVeKG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2908086918/reactions"
            },
            "updated_at": "2025-05-25T21:16:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2908086918",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/9946255?v=4",
                "events_url": "https://api.github.com/users/fredizzimo/events{/privacy}",
                "followers_url": "https://api.github.com/users/fredizzimo/followers",
                "following_url": "https://api.github.com/users/fredizzimo/following{/other_user}",
                "gists_url": "https://api.github.com/users/fredizzimo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/fredizzimo",
                "id": 9946255,
                "login": "fredizzimo",
                "node_id": "MDQ6VXNlcjk5NDYyNTU=",
                "organizations_url": "https://api.github.com/users/fredizzimo/orgs",
                "received_events_url": "https://api.github.com/users/fredizzimo/received_events",
                "repos_url": "https://api.github.com/users/fredizzimo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/fredizzimo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/fredizzimo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/fredizzimo",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/31399/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/31399/commits",
    "created_at": "2024-11-29T22:01:21Z",
    "diff_url": "https://github.com/neovim/neovim/pull/31399.diff",
    "draft": true,
    "head": {
        "label": "chipsenkbeil:feat/ImageApi",
        "ref": "feat/ImageApi",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/chipsenkbeil/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/chipsenkbeil/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/chipsenkbeil/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/chipsenkbeil/neovim/branches{/branch}",
            "clone_url": "https://github.com/chipsenkbeil/neovim.git",
            "collaborators_url": "https://api.github.com/repos/chipsenkbeil/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/chipsenkbeil/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/chipsenkbeil/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/chipsenkbeil/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/chipsenkbeil/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/chipsenkbeil/neovim/contributors",
            "created_at": "2024-11-29T21:51:25Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/chipsenkbeil/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/chipsenkbeil/neovim/downloads",
            "events_url": "https://api.github.com/repos/chipsenkbeil/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/chipsenkbeil/neovim/forks",
            "full_name": "chipsenkbeil/neovim",
            "git_commits_url": "https://api.github.com/repos/chipsenkbeil/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/chipsenkbeil/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/chipsenkbeil/neovim/git/tags{/sha}",
            "git_url": "git://github.com/chipsenkbeil/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": false,
            "has_wiki": false,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/chipsenkbeil/neovim/hooks",
            "html_url": "https://github.com/chipsenkbeil/neovim",
            "id": 896248861,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/chipsenkbeil/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/chipsenkbeil/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/chipsenkbeil/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/chipsenkbeil/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/chipsenkbeil/neovim/labels{/name}",
            "language": null,
            "languages_url": "https://api.github.com/repos/chipsenkbeil/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/chipsenkbeil/neovim/merges",
            "milestones_url": "https://api.github.com/repos/chipsenkbeil/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDONWusHQ",
            "notifications_url": "https://api.github.com/repos/chipsenkbeil/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
                "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
                "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
                "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
                "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/chipsenkbeil",
                "id": 2481802,
                "login": "chipsenkbeil",
                "node_id": "MDQ6VXNlcjI0ODE4MDI=",
                "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
                "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
                "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/chipsenkbeil",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/chipsenkbeil/neovim/pulls{/number}",
            "pushed_at": "2025-05-24T18:36:28Z",
            "releases_url": "https://api.github.com/repos/chipsenkbeil/neovim/releases{/id}",
            "size": 314894,
            "ssh_url": "git@github.com:chipsenkbeil/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/chipsenkbeil/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/chipsenkbeil/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/chipsenkbeil/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/chipsenkbeil/neovim/subscription",
            "svn_url": "https://github.com/chipsenkbeil/neovim",
            "tags_url": "https://api.github.com/repos/chipsenkbeil/neovim/tags",
            "teams_url": "https://api.github.com/repos/chipsenkbeil/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/chipsenkbeil/neovim/git/trees{/sha}",
            "updated_at": "2024-12-01T06:32:39Z",
            "url": "https://api.github.com/repos/chipsenkbeil/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "a719c674a90c3d053d79cb1b20c9df657e2a4d98",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
            "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
            "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
            "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
            "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/chipsenkbeil",
            "id": 2481802,
            "login": "chipsenkbeil",
            "node_id": "MDQ6VXNlcjI0ODE4MDI=",
            "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
            "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
            "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/chipsenkbeil",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/31399",
    "id": 2207978338,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31399",
    "labels": [
        {
            "color": "FBCA04",
            "default": false,
            "description": "issue needs attention from an expert, or PR proposes significant changes to architecture or API",
            "id": 212680983,
            "name": "needs:discussion",
            "node_id": "MDU6TGFiZWwyMTI2ODA5ODM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/needs:discussion"
        }
    ],
    "locked": false,
    "merge_commit_sha": "0cb1fe4419f003290fb8e1ba52943cf6f22d17be",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6DmxNi",
    "number": 31399,
    "patch_url": "https://github.com/neovim/neovim/pull/31399.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/31399/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/a719c674a90c3d053d79cb1b20c9df657e2a4d98",
    "title": "feat(img): implement rudimentary image API",
    "updated_at": "2025-05-25T21:16:38Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/31399",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/2481802?v=4",
        "events_url": "https://api.github.com/users/chipsenkbeil/events{/privacy}",
        "followers_url": "https://api.github.com/users/chipsenkbeil/followers",
        "following_url": "https://api.github.com/users/chipsenkbeil/following{/other_user}",
        "gists_url": "https://api.github.com/users/chipsenkbeil/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/chipsenkbeil",
        "id": 2481802,
        "login": "chipsenkbeil",
        "node_id": "MDQ6VXNlcjI0ODE4MDI=",
        "organizations_url": "https://api.github.com/users/chipsenkbeil/orgs",
        "received_events_url": "https://api.github.com/users/chipsenkbeil/received_events",
        "repos_url": "https://api.github.com/users/chipsenkbeil/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/chipsenkbeil/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/chipsenkbeil/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/chipsenkbeil",
        "user_view_type": "public"
    }
}