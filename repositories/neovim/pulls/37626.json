{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/37626/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/37626"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/37626"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/6e17f060fef374e66d8ff53dbc6bdded05740686"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6562,
            "forks_count": 6562,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 2079,
            "open_issues_count": 2079,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2026-02-03T03:16:17Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 368582,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 96189,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2026-02-03T03:16:22Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 96189,
            "watchers_count": 96189,
            "web_commit_signoff_required": false
        },
        "sha": "4c0d1aceec79f56097b87363cc81ffa4f6f86b32",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Alternative to  #22115.\r\n\r\n## Problem\r\n1. Unnecessary redraws are causing flickering in the previous implementation.\r\n2. This API deviates from our current `enable/is_enabled`  pattern.\r\n3. Code lenses are shown at the end of the line, which is not expected by servers in practice.\r\n4. No reasonable way to implement `workspace/codeLens/refresh`\r\n\r\n## Solution\r\nReimplement it by the decorator provider and `vim.lsp.Capability`, showing code lenses in a single new line, implement `workspace/codeLens/refresh` on top of that.\r\n\r\n<img width=\"1962\" height=\"1892\" alt=\"screenshot\" src=\"https://github.com/user-attachments/assets/6c7eae43-ad7a-4347-bcf2-dcf85111dece\" />\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754958908"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908"
                }
            },
            "author_association": "MEMBER",
            "body": "Before it used virt_text and hl_mode = \"combine\" instead of virt_lines + above. Can you change that to keep the existing behavior?\n\n(Can discuss if we should change this or make it configurable, but should be a follow up PR)",
            "commit_id": "6e17f060fef374e66d8ff53dbc6bdded05740686",
            "created_at": "2026-02-02T15:37:01Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754958908",
            "id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kNVY8",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754975932"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n\n          local client = assert(vim.lsp.get_client_by(client_id))\n          local range = vim.range.lsp(\n            self.bufnr,\n            lenses[1].range,\n            client.offset_encoding\n          )\n```\n\nCan then also change the resolve call further down to `self:resolve(client, lens)` to avoid doing the lookup twice\n",
            "commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "created_at": "2026-02-02T15:40:45Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754975932",
            "id": 2754975932,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6kNZi8",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 226,
            "original_position": 366,
            "original_start_line": 221,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 1,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754987861"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861"
                }
            },
            "author_association": "MEMBER",
            "body": "A user can call `.enable(false)` during the resolve action in which case the client_state would get empty. I think here should be a nil check instead of an assert that simply exits without error.",
            "commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "created_at": "2026-02-02T15:43:29Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754987861",
            "id": 2754987861,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6kNcdV",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 187,
            "original_position": 319,
            "original_start_line": 185,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 1,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2756917826"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I thought the previous approach was a compromise for the `refresh` mechanism? I even added some logic and tests to handle edge cases for it, but since you mentioned it, I'll remove them from this PR for now and leave them for a follow-up PR or #36469, which I hadn't noticed before.",
            "commit_id": "6e17f060fef374e66d8ff53dbc6bdded05740686",
            "created_at": "2026-02-03T02:39:16Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2756917826",
            "id": 2756917826,
            "in_reply_to_id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kUzpC",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3742619597,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-03T02:39:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "Considering that the module name `codelens` deviates from our current naming convention (using underscores to separate words) and that this will be a breaking change, I am considering keeping the previous version at `vim.lsp.codelens` and marking it as deprecated, while providing the current version via `vim.lsp.code_lens`. Is this approach feasible? @MariaSolOs @mfussenegger I'd like to get your thoughts on this when you have a moment.",
            "created_at": "2026-01-30T09:40:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3822785330",
            "id": 3822785330,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7j2xMy",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3822785330/reactions"
            },
            "updated_at": "2026-01-30T09:40:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3822785330",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Considering that the module name codelens deviates from our current naming convention (using underscores to separate words)\r\n\r\nIt's actually already a bit of a mix. In the lua stdlib there's a tendency to avoid the underscore if not really necessary. `tonumber`, `setmetatable` are examples. In some places neovim carried that over - e.g. `vim.iter(..):totable`. So it's not that clear cut.\r\n\r\nI'd tend to keep the `codelens` name and change the `refresh()` to call `.enable()` and force a refresh if it was already enabled. `display()` I'd turn into a no-op. And mark both as deprecated.",
            "created_at": "2026-01-30T14:31:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3824072474",
            "id": 3824072474,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7j7rca",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 5,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 5,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3824072474/reactions"
            },
            "updated_at": "2026-01-30T14:31:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3824072474",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have also implemented `workspace/codeLens/refresh` in this PR, which is useful because servers often return empty codeLens when they are not ready, and subsequently use refresh to return the actual valid results.\r\n\r\nThis PR should be ready for review now, and I will be modifying/adding tests in the meantime.",
            "created_at": "2026-01-31T13:53:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828570489",
            "id": 3828570489,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kM1l5",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828570489/reactions"
            },
            "updated_at": "2026-01-31T13:53:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828570489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Could you fix the failing tests first?",
            "created_at": "2026-01-31T14:57:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828672823",
            "id": 3828672823,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kNOk3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828672823/reactions"
            },
            "updated_at": "2026-01-31T14:57:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828672823",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Could you fix the failing tests first?\r\n\r\nDone. The previous failing tests were outdated (targeting the deprecated `clear()` and `show()`); I have now removed them and added new tests for the current version.",
            "created_at": "2026-01-31T17:04:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828847038",
            "id": 3828847038,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kN5G-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828847038/reactions"
            },
            "updated_at": "2026-01-31T17:04:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828847038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "#37647 will fix the remaining CI failures.",
            "created_at": "2026-02-01T01:36:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3830035677",
            "id": 3830035677,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kSbTd",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3830035677/reactions"
            },
            "updated_at": "2026-02-01T01:36:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3830035677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I've rebased on master, so the tests are now passed.",
            "created_at": "2026-02-02T04:48:09Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3832893247",
            "id": 3832893247,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kdU8_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3832893247/reactions"
            },
            "updated_at": "2026-02-02T04:48:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3832893247",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "~~This would obsolete https://github.com/neovim/neovim/pull/36469.~~ I built off of this and it feels smooth as well.\r\n\r\n~~One question - Would it be better to snap the virtual line display to the indent rather than the LSP data? This would involve an extra calculation to get the line's indent, but the output might be more in line with what the user would expect.~~",
            "created_at": "2026-02-02T18:04:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3836815232",
            "id": 3836815232,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7ksSeA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836815232/reactions"
            },
            "updated_at": "2026-02-02T18:21:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836815232",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62523234?v=4",
                "events_url": "https://api.github.com/users/mikejmcguirk/events{/privacy}",
                "followers_url": "https://api.github.com/users/mikejmcguirk/followers",
                "following_url": "https://api.github.com/users/mikejmcguirk/following{/other_user}",
                "gists_url": "https://api.github.com/users/mikejmcguirk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mikejmcguirk",
                "id": 62523234,
                "login": "mikejmcguirk",
                "node_id": "MDQ6VXNlcjYyNTIzMjM0",
                "organizations_url": "https://api.github.com/users/mikejmcguirk/orgs",
                "received_events_url": "https://api.github.com/users/mikejmcguirk/received_events",
                "repos_url": "https://api.github.com/users/mikejmcguirk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mikejmcguirk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mikejmcguirk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mikejmcguirk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> This would obsolete #36469. I built off of this and it feels smooth as well.\r\n> \r\n> One question - Would it be better to snap the virtual line display to the indent rather than the LSP data? This would involve an extra calculation to get the line's indent, but the output might be more in line with what the user would expect.\r\n\r\nPlease don't get virtual-lines mixed into this PR. As mentioned in my other review comment, this PR must not change the display behavior. Scope should be limited to the decoration provider refactor. ",
            "created_at": "2026-02-02T18:07:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3836828988",
            "id": 3836828988,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7ksV08",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836828988/reactions"
            },
            "updated_at": "2026-02-02T18:07:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836828988",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have cherry-picked out the two out-of-scope commits (using virt_lines and creating default mappings, see https://github.com/ofseed/neovim/compare/lsp-codelens...ofseed:neovim:lsp-codelens-follow-ups). We can discuss these two changes in other PRs.",
            "created_at": "2026-02-03T03:22:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3838818940",
            "id": 3838818940,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kz7p8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3838818940/reactions"
            },
            "updated_at": "2026-02-03T03:29:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3838818940",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/37626/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/37626/commits",
    "created_at": "2026-01-30T09:30:16Z",
    "diff_url": "https://github.com/neovim/neovim/pull/37626.diff",
    "draft": false,
    "head": {
        "label": "ofseed:lsp-codelens",
        "ref": "lsp-codelens",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/ofseed/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/ofseed/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/ofseed/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/ofseed/neovim/branches{/branch}",
            "clone_url": "https://github.com/ofseed/neovim.git",
            "collaborators_url": "https://api.github.com/repos/ofseed/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/ofseed/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/ofseed/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/ofseed/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/ofseed/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/ofseed/neovim/contributors",
            "created_at": "2021-11-30T18:13:03Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/ofseed/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/ofseed/neovim/downloads",
            "events_url": "https://api.github.com/repos/ofseed/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/ofseed/neovim/forks",
            "full_name": "ofseed/neovim",
            "git_commits_url": "https://api.github.com/repos/ofseed/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/ofseed/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/ofseed/neovim/git/tags{/sha}",
            "git_url": "git://github.com/ofseed/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/ofseed/neovim/hooks",
            "html_url": "https://github.com/ofseed/neovim",
            "id": 433537354,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/ofseed/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/ofseed/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/ofseed/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/ofseed/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/ofseed/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/ofseed/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/ofseed/neovim/merges",
            "milestones_url": "https://api.github.com/repos/ofseed/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGddBSg",
            "notifications_url": "https://api.github.com/repos/ofseed/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/ofseed/neovim/pulls{/number}",
            "pushed_at": "2026-02-03T03:23:40Z",
            "releases_url": "https://api.github.com/repos/ofseed/neovim/releases{/id}",
            "size": 356297,
            "ssh_url": "git@github.com:ofseed/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/ofseed/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/ofseed/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/ofseed/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/ofseed/neovim/subscription",
            "svn_url": "https://github.com/ofseed/neovim",
            "tags_url": "https://api.github.com/repos/ofseed/neovim/tags",
            "teams_url": "https://api.github.com/repos/ofseed/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/ofseed/neovim/git/trees{/sha}",
            "updated_at": "2026-01-12T04:20:08Z",
            "url": "https://api.github.com/repos/ofseed/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "6e17f060fef374e66d8ff53dbc6bdded05740686",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
            "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
            "followers_url": "https://api.github.com/users/ofseed/followers",
            "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
            "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ofseed",
            "id": 61115159,
            "login": "ofseed",
            "node_id": "MDQ6VXNlcjYxMTE1MTU5",
            "organizations_url": "https://api.github.com/users/ofseed/orgs",
            "received_events_url": "https://api.github.com/users/ofseed/received_events",
            "repos_url": "https://api.github.com/users/ofseed/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ofseed",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/37626",
    "id": 3227082829,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        },
        {
            "color": "F9D0C4",
            "default": false,
            "description": "",
            "id": 3968935075,
            "name": "breaking-change",
            "node_id": "LA_kwDOAPphoM7skSSj",
            "url": "https://api.github.com/repos/neovim/neovim/labels/breaking-change"
        }
    ],
    "locked": false,
    "merge_commit_sha": "10b03e1238b5c6b3e338dd055dc3cc68fceebe64",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM7AWWBN",
    "number": 37626,
    "patch_url": "https://github.com/neovim/neovim/pull/37626.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
            "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
            "followers_url": "https://api.github.com/users/ribru17/followers",
            "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
            "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ribru17",
            "id": 55766287,
            "login": "ribru17",
            "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
            "organizations_url": "https://api.github.com/users/ribru17/orgs",
            "received_events_url": "https://api.github.com/users/ribru17/received_events",
            "repos_url": "https://api.github.com/users/ribru17/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ribru17",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/37626/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/6e17f060fef374e66d8ff53dbc6bdded05740686",
    "title": "feat(lsp)!: reimplement `textDocument/codeLens` as decoration provider",
    "updated_at": "2026-02-03T03:29:42Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
        "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
        "followers_url": "https://api.github.com/users/ofseed/followers",
        "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
        "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/ofseed",
        "id": 61115159,
        "login": "ofseed",
        "node_id": "MDQ6VXNlcjYxMTE1MTU5",
        "organizations_url": "https://api.github.com/users/ofseed/orgs",
        "received_events_url": "https://api.github.com/users/ofseed/received_events",
        "repos_url": "https://api.github.com/users/ofseed/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/ofseed",
        "user_view_type": "public"
    }
}