{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/37626/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/37626"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/37626"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/965468fca1e7c465292ea9dd767f5cf02fc61dad"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6574,
            "forks_count": 6574,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 2065,
            "open_issues_count": 2065,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2026-02-10T04:03:36Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 369214,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 96334,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2026-02-10T02:38:41Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 96334,
            "watchers_count": 96334,
            "web_commit_signoff_required": false
        },
        "sha": "16680e57bacadbf2b0493e89f5f62e9fb1b69328",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "close #22115\r\nclose #37658\r\n\r\n## Problem\r\n1. Unnecessary redraws are causing flickering in the previous implementation.\r\n2. This API deviates from our current `enable/is_enabled`  pattern.\r\n3. Code lenses are shown at the end of the line, which is not expected by servers in practice.\r\n4. No reasonable way to implement `workspace/codeLens/refresh`\r\n\r\n## Solution\r\nReimplement it by the decorator provider and `vim.lsp.Capability`, showing code lenses in a single new line, implement `workspace/codeLens/refresh` on top of that.\r\n\r\n<img width=\"1962\" height=\"1892\" alt=\"screenshot\" src=\"https://github.com/user-attachments/assets/6c7eae43-ad7a-4347-bcf2-dcf85111dece\" />\r\n",
    "closed_at": "2026-02-03T14:46:38Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754958908"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908"
                }
            },
            "author_association": "MEMBER",
            "body": "Before it used virt_text and hl_mode = \"combine\" instead of virt_lines + above. Can you change that to keep the existing behavior?\n\n(Can discuss if we should change this or make it configurable, but should be a follow up PR)",
            "commit_id": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
            "created_at": "2026-02-02T15:37:01Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754958908",
            "id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kNVY8",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754958908",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754975932"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n\n          local client = assert(vim.lsp.get_client_by(client_id))\n          local range = vim.range.lsp(\n            self.bufnr,\n            lenses[1].range,\n            client.offset_encoding\n          )\n```\n\nCan then also change the resolve call further down to `self:resolve(client, lens)` to avoid doing the lookup twice\n",
            "commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "created_at": "2026-02-02T15:40:45Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754975932",
            "id": 2754975932,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6kNZi8",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 226,
            "original_position": 366,
            "original_start_line": 221,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 1,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754975932",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2754987861"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861"
                }
            },
            "author_association": "MEMBER",
            "body": "A user can call `.enable(false)` during the resolve action in which case the client_state would get empty. I think here should be a nil check instead of an assert that simply exits without error.",
            "commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "created_at": "2026-02-02T15:43:29Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2754987861",
            "id": 2754987861,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6kNcdV",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 187,
            "original_position": 319,
            "original_start_line": 185,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 1,
            "pull_request_review_id": 3740240916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-02T15:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2754987861",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2756917826"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I thought the previous approach was a compromise for the `refresh` mechanism? I even added some logic and tests to handle edge cases for it, but since you mentioned it, I'll remove them from this PR for now and leave them for a follow-up PR or #36469, which I hadn't noticed before.",
            "commit_id": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
            "created_at": "2026-02-03T02:39:16Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2756917826",
            "id": 2756917826,
            "in_reply_to_id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kUzpC",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3742619597,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-03T02:39:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2756917826",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2757223778"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757223778"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "What if, instead of filter, the settings table naming went back to opts? This implies that the table can be extended with more configuration, without having to address specifics right now.",
            "commit_id": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
            "created_at": "2026-02-03T05:08:41Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2757223778",
            "id": 2757223778,
            "in_reply_to_id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kV-Vi",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3742982957,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757223778/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-03T05:12:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757223778",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62523234?v=4",
                "events_url": "https://api.github.com/users/mikejmcguirk/events{/privacy}",
                "followers_url": "https://api.github.com/users/mikejmcguirk/followers",
                "following_url": "https://api.github.com/users/mikejmcguirk/following{/other_user}",
                "gists_url": "https://api.github.com/users/mikejmcguirk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mikejmcguirk",
                "id": 62523234,
                "login": "mikejmcguirk",
                "node_id": "MDQ6VXNlcjYyNTIzMjM0",
                "organizations_url": "https://api.github.com/users/mikejmcguirk/orgs",
                "received_events_url": "https://api.github.com/users/mikejmcguirk/received_events",
                "repos_url": "https://api.github.com/users/mikejmcguirk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mikejmcguirk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mikejmcguirk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mikejmcguirk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2757290395"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757290395"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Are you referring to `enable({true?}, {filter})`? This is a positional argument, and its name is for descriptive purposes so that we can change it to a more appropriate name at any time.\r\n\r\nSince you mentioned configuring them, I took into account when creating this PR that there was once a strong demand for a way to configure inlay hints; however, we did not reach a consensus on such an interface (see #28261). Therefore, I prefer to change the default to the display style expected by most servers—that is, a separate line (see [haskell-language-server](https://haskell-language-server.readthedocs.io/en/latest/features.html#evaluation-code-snippets-in-comments) as an example )—rather than providing configuration options.",
            "commit_id": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
            "created_at": "2026-02-03T05:39:04Z",
            "diff_hunk": "@@ -3,352 +3,513 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  return lenses\n-end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n-    end\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Clear the lenses\n----\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n-      end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n+---\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client_id integer\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client_id, unresolved_lens)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local state = assert(self.client_state[client_id])\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-    else\n-      has_unresolved = true\n     end\n-  end\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  -- Virtual text on the last line's Code Lens pushes it out of the viewport,\n+  -- leading to a feedback loop of repeated triggering. Minus one from botrow.\n+  for row = toprow, botrow - 1 do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          local range = vim.range.lsp(\n+            self.bufnr,\n+            lenses[1].range,\n+            assert(vim.lsp.get_client_by_id(client_id)).offset_encoding\n+          )\n+          ---@type [string, string][]\n+          local virt_text = {\n+            { string.rep(' ', range.start.col), 'LspCodeLensSeparator' },\n+          }\n+\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              self:resolve(client_id, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          -- Use a placeholder to prevent flickering caused by layout shifts.\n+          if #virt_text == 1 then\n+            table.insert(virt_text, { '', 'LspCodeLens' })\n+          end\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2757290395",
            "id": 2757290395,
            "in_reply_to_id": 2754958908,
            "line": 240,
            "node_id": "PRRC_kwDOAPphoM6kWOmb",
            "original_commit_id": "648cdc1e83b0ae4a0675734dce5774ebe0882554",
            "original_line": 240,
            "original_position": 391,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 349,
            "pull_request_review_id": 3743063802,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757290395/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-03T05:40:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2757290395",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2759178669"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759178669"
                }
            },
            "author_association": "MEMBER",
            "body": "Fantastic cleanup!",
            "commit_id": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
            "created_at": "2026-02-03T13:47:21Z",
            "diff_hunk": "@@ -42,6 +42,11 @@ LSP\n • *vim.lsp.get_buffers_by_client_id()*\tUse `vim.lsp.get_client_by_id(id).attached_buffers`\n \t\t\t\t\tinstead\n • *vim.lsp.stop_client()*\t\tUse |Client:stop()| instead\n+• *vim.lsp.codelens.refresh()*\t\tUse `vim.lsp.codelens.enable(true)` instead\n+• *vim.lsp.codelens.clear()*\t\tUse `vim.lsp.codelens.enable(false)` instead\n+• *vim.lsp.codelens.display()*\n+• *vim.lsp.codelens.save()*\n+• *vim.lsp.codelens.on_codelens()*",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2759178669",
            "id": 2759178669,
            "line": 49,
            "node_id": "PRRC_kwDOAPphoM6kdbmt",
            "original_commit_id": "6e17f060fef374e66d8ff53dbc6bdded05740686",
            "original_line": 49,
            "original_position": 8,
            "original_start_line": 45,
            "path": "runtime/doc/deprecated.txt",
            "position": 8,
            "pull_request_review_id": 3745382305,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759178669/reactions"
            },
            "side": "RIGHT",
            "start_line": 45,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-03T13:47:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759178669",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/37626#discussion_r2759190436"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/37626"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759190436"
                }
            },
            "author_association": "MEMBER",
            "body": "might need to bump these to 0.13 depending on third-party usage",
            "commit_id": "6e17f060fef374e66d8ff53dbc6bdded05740686",
            "created_at": "2026-02-03T13:50:03Z",
            "diff_hunk": "@@ -3,352 +3,488 @@ local log = require('vim.lsp.log')\n local api = vim.api\n local M = {}\n \n---- bufnr → true|nil\n---- to throttle refreshes to at most one at a time\n-local active_refreshes = {} --- @type table<integer,true>\n-\n----@type table<integer, table<integer, lsp.CodeLens[]>>\n---- bufnr -> client_id -> lenses\n-local lens_cache_by_buf = setmetatable({}, {\n-  __index = function(t, b)\n-    local key = b > 0 and b or api.nvim_get_current_buf()\n-    return rawget(t, key)\n-  end,\n-})\n+local Capability = require('vim.lsp._capability')\n \n----@type table<integer, integer>\n----client_id -> namespace\n-local namespaces = setmetatable({}, {\n-  __index = function(t, key)\n-    local value = api.nvim_create_namespace('nvim.lsp.codelens:' .. key)\n-    rawset(t, key, value)\n-    return value\n-  end,\n-})\n+---@class (private) vim.lsp.codelens.ClientState\n+---@field row_lenses table<integer, lsp.CodeLens[]?> row -> lens\n+---@field namespace integer\n \n----@private\n-M.__namespaces = namespaces\n+---@class (private) vim.lsp.codelens.Provider : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.codelens.Provider?>\n+---\n+--- `TextDocument` version current state corresponds to.\n+---@field version? integer\n+---\n+--- Last version of codelens applied to this line.\n+---\n+--- Index In the form of row -> true?\n+---@field row_version table<integer, integer?>\n+---\n+--- Index In the form of client_id -> client_state\n+---@field client_state? table<integer, vim.lsp.codelens.ClientState?>\n+---\n+--- Timer for debouncing automatic requests.\n+---\n+---@field timer? uv.uv_timer_t\n+local Provider = {\n+  name = 'codelens',\n+  method = 'textDocument/codeLens',\n+  active = {},\n+}\n+Provider.__index = Provider\n+setmetatable(Provider, Capability)\n+Capability.all[Provider.name] = Provider\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.codelens.Provider\n+function Provider:new(bufnr)\n+  ---@type vim.lsp.codelens.Provider\n+  self = Capability.new(self, bufnr)\n+  self.client_state = {}\n+  self.row_version = {}\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if not provider then\n+        return true\n+      end\n+      provider:automatic_request()\n+    end,\n+    on_reload = function(_, buf)\n+      local provider = Provider.active[buf]\n+      if provider then\n+        provider:automatic_request()\n+      end\n+    end,\n+  })\n \n-local augroup = api.nvim_create_augroup('nvim.lsp.codelens', {})\n+  return self\n+end\n \n-api.nvim_create_autocmd('LspDetach', {\n-  group = augroup,\n-  callback = function(ev)\n-    M.clear(ev.data.client_id, ev.buf)\n-  end,\n-})\n+---@package\n+---@param client_id integer\n+function Provider:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    state = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.codelens:' .. client_id),\n+      row_lenses = {},\n+    }\n+    self.client_state[client_id] = state\n+  end\n+  self:request(client_id)\n+end\n \n----@param lens lsp.CodeLens\n----@param bufnr integer\n+---@package\n ---@param client_id integer\n-local function execute_lens(lens, bufnr, client_id)\n-  local line = lens.range.start.line\n-  api.nvim_buf_clear_namespace(bufnr, namespaces[client_id], line, line + 1)\n-\n-  local client = vim.lsp.get_client_by_id(client_id)\n-  assert(client, 'Client is required to execute lens, client_id=' .. client_id)\n-  client:exec_cmd(lens.command, { bufnr = bufnr }, function(...)\n-    vim.lsp.handlers['workspace/executeCommand'](...)\n-    M.refresh()\n-  end)\n+function Provider:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    self.client_state[client_id] = nil\n+  end\n end\n \n---- Return all lenses for the given buffer\n+--- `lsp.Handler` for `textDocument/codeLens`.\n ---\n----@param bufnr integer  Buffer number. 0 can be used for the current buffer.\n----@return lsp.CodeLens[]\n-function M.get(bufnr)\n-  local lenses_by_client = lens_cache_by_buf[bufnr or 0]\n-  if not lenses_by_client then\n-    return {}\n+---@package\n+---@param err? lsp.ResponseError\n+---@param result? lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function Provider:handler(err, result, ctx)\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n+  end\n+\n+  if err then\n+    log.error('codelens', err)\n+    return\n   end\n-  local lenses = {}\n-  for _, client_lenses in pairs(lenses_by_client) do\n-    vim.list_extend(lenses, client_lenses)\n+\n+  if util.buf_versions[self.bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  ---@type table<integer, lsp.CodeLens[]>\n+  local row_lenses = {}\n+\n+  -- Code lenses should only span a single line.\n+  for _, lens in ipairs(result or {}) do\n+    local row = lens.range.start.line\n+    local lenses = row_lenses[row] or {}\n+    table.insert(lenses, lens)\n+    row_lenses[row] = lenses\n   end\n-  return lenses\n+\n+  state.row_lenses = row_lenses\n+  self.version = ctx.version\n end\n \n---- Run the code lens available in the current line.\n-function M.run()\n-  local line = api.nvim_win_get_cursor(0)[1] - 1\n-  local bufnr = api.nvim_get_current_buf()\n-  local options = {} --- @type {client: integer, lens: lsp.CodeLens}[]\n-  local lenses_by_client = lens_cache_by_buf[bufnr] or {}\n-  for client, lenses in pairs(lenses_by_client) do\n-    for _, lens in pairs(lenses) do\n-      if\n-        lens.command\n-        and lens.command.command ~= ''\n-        and lens.range.start.line <= line\n-        and lens.range['end'].line >= line\n-      then\n-        table.insert(options, { client = client, lens = lens })\n-      end\n+---@package\n+---@param client_id? integer\n+---@param on_response? function\n+function Provider:request(client_id, on_response)\n+  ---@type lsp.CodeLensParams\n+  local params = { textDocument = util.make_text_document_params(self.bufnr) }\n+  for id in pairs(self.client_state) do\n+    if not client_id or client_id == id then\n+      local client = assert(vim.lsp.get_client_by_id(id))\n+      client:request('textDocument/codeLens', params, function(...)\n+        self:handler(...)\n+\n+        if on_response then\n+          on_response()\n+        end\n+      end, self.bufnr)\n     end\n   end\n-  if #options == 0 then\n-    vim.notify('No executable codelens found at current line')\n-  elseif #options == 1 then\n-    local option = options[1]\n-    execute_lens(option.lens, bufnr, option.client)\n-  else\n-    vim.ui.select(options, {\n-      prompt = 'Code lenses:',\n-      kind = 'codelens',\n-      format_item = function(option)\n-        return option.lens.command.title\n-      end,\n-    }, function(option)\n-      if option then\n-        execute_lens(option.lens, bufnr, option.client)\n-      end\n-    end)\n+end\n+\n+---@private\n+function Provider:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n+    end\n   end\n end\n \n---- Clear the lenses\n+--- Automatically request with debouncing, used as callbacks in autocmd events.\n ---\n----@param client_id integer|nil filter by client_id. All clients if nil\n----@param bufnr integer|nil filter by buffer. All buffers if nil, 0 for current buffer\n-function M.clear(client_id, bufnr)\n-  bufnr = bufnr and vim._resolve_bufnr(bufnr)\n-  local buffers = bufnr and { bufnr }\n-    or vim.tbl_filter(api.nvim_buf_is_loaded, api.nvim_list_bufs())\n-  for _, iter_bufnr in pairs(buffers) do\n-    local client_ids = client_id and { client_id } or vim.tbl_keys(namespaces)\n-    for _, iter_client_id in pairs(client_ids) do\n-      local ns = namespaces[iter_client_id]\n-      -- there can be display()ed lenses, which are not stored in cache\n-      if lens_cache_by_buf[iter_bufnr] then\n-        lens_cache_by_buf[iter_bufnr][iter_client_id] = {}\n+---@package\n+function Provider:automatic_request()\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+  end, 200)\n+end\n+\n+---@private\n+---@param client vim.lsp.Client\n+---@param unresolved_lens lsp.CodeLens\n+function Provider:resolve(client, unresolved_lens)\n+  ---@param resolved_lens lsp.CodeLens\n+  client:request('codeLens/resolve', unresolved_lens, function(err, resolved_lens, ctx)\n+    local state = self.client_state[client.id]\n+    if not state then\n+      return\n+    end\n+\n+    if err then\n+      log.error('codelens/resolve', err)\n+      return\n+    end\n+\n+    if util.buf_versions[self.bufnr] ~= ctx.version then\n+      return\n+    end\n+\n+    local row = unresolved_lens.range.start.line\n+    local lenses = assert(state.row_lenses[row])\n+    for i, lens in ipairs(lenses) do\n+      if lens == unresolved_lens then\n+        lenses[i] = resolved_lens\n       end\n-      api.nvim_buf_clear_namespace(iter_bufnr, ns, 0, -1)\n     end\n-  end\n+\n+    self.row_version[row] = nil\n+    api.nvim__redraw({\n+      buf = self.bufnr,\n+      range = { row, row + 1 },\n+      valid = true,\n+      flush = false,\n+    })\n+  end, self.bufnr)\n end\n \n----@param lenses lsp.CodeLens[]\n----@return table<integer, lsp.CodeLens[]>\n-local function group_lenses_by_start_line(lenses)\n-  local lenses_by_lnum = {} ---@type table<integer, lsp.CodeLens[]>\n-  for _, lens in pairs(lenses) do\n-    local line_lenses = lenses_by_lnum[lens.range.start.line]\n-    if not line_lenses then\n-      line_lenses = {}\n-      lenses_by_lnum[lens.range.start.line] = line_lenses\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function Provider:on_win(toprow, botrow)\n+  for row = toprow, botrow do\n+    if self.row_version[row] ~= self.version then\n+      for client_id, state in pairs(self.client_state) do\n+        local namespace = state.namespace\n+\n+        api.nvim_buf_clear_namespace(self.bufnr, namespace, row, row + 1)\n+\n+        local lenses = state.row_lenses[row]\n+        if lenses then\n+          table.sort(lenses, function(a, b)\n+            return a.range.start.character < b.range.start.character\n+          end)\n+\n+          ---@type [string, string][]\n+          local virt_text = {}\n+          for _, lens in ipairs(lenses) do\n+            -- A code lens is unresolved when no command is associated to it.\n+            if not lens.command then\n+              local client = assert(vim.lsp.get_client_by_id(client_id))\n+              self:resolve(client, lens)\n+            else\n+              vim.list_extend(virt_text, {\n+                { lens.command.title, 'LspCodeLens' },\n+                { ' | ', 'LspCodeLensSeparator' },\n+              })\n+            end\n+          end\n+          -- Remove trailing separator.\n+          table.remove(virt_text)\n+\n+          api.nvim_buf_set_extmark(self.bufnr, namespace, row, 0, {\n+            virt_text = virt_text,\n+            hl_mode = 'combine',\n+          })\n+        end\n+        self.row_version[row] = self.version\n+      end\n     end\n-    table.insert(line_lenses, lens)\n   end\n-  return lenses_by_lnum\n end\n \n----@param bufnr integer\n----@param ns integer\n----@param line integer\n----@param lenses lsp.CodeLens[] Lenses that start at `line`\n-local function display_line_lenses(bufnr, ns, line, lenses)\n-  local chunks = {}\n-  local num_lenses = #lenses\n-  table.sort(lenses, function(a, b)\n-    return a.range.start.character < b.range.start.character\n-  end)\n-\n-  local has_unresolved = false\n-  for i, lens in ipairs(lenses) do\n-    if lens.command then\n-      local text = lens.command.title:gsub('%s+', ' ')\n-      table.insert(chunks, { text, 'LspCodeLens' })\n-      if i < num_lenses then\n-        table.insert(chunks, { ' | ', 'LspCodeLensSeparator' })\n-      end\n-    else\n-      has_unresolved = true\n+local namespace = api.nvim_create_namespace('nvim.lsp.codelens')\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local provider = Provider.active[bufnr]\n+    if provider then\n+      provider:on_win(toprow, botrow)\n     end\n-  end\n+  end,\n+})\n \n-  -- If some lenses are not resolved yet, don't update the line's virtual text. Due to this, user\n-  -- may see outdated lenses or not see already resolved lenses. However, showing outdated lenses\n-  -- for short period of time is better than spamming user with virtual text updates.\n-  if has_unresolved then\n-    return\n-  end\n+--- Query whether code lens is enabled in the {filter}ed scope\n+---\n+---@param filter? vim.lsp.capability.enable.Filter\n+---@return boolean whether code lens is enabled.\n+function M.is_enabled(filter)\n+  return vim.lsp._capability.is_enabled('codelens', filter)\n+end\n \n-  api.nvim_buf_clear_namespace(bufnr, ns, line, line + 1)\n-  if #chunks > 0 then\n-    api.nvim_buf_set_extmark(bufnr, ns, line, 0, {\n-      virt_text = chunks,\n-      hl_mode = 'combine',\n-    })\n-  end\n+--- Enables or disables code lens for the {filter}ed scope.\n+---\n+--- To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+--- ```lua\n+--- vim.lsp.codelens.enable(not vim.lsp.codelens.is_enabled())\n+--- ```\n+---\n+--- To run a code lens, see |vim.lsp.codelens.run()|.\n+---\n+---@param enable? boolean true/nil to enable, false to disable\n+---@param filter? vim.lsp.capability.enable.Filter\n+function M.enable(enable, filter)\n+  vim.lsp._capability.enable('codelens', enable, filter)\n end\n \n---- Display the lenses using virtual text\n+--- Optional filters |kwargs|:\n+---@class vim.lsp.codelens.get.Filter\n+---@inlinedoc\n ---\n----@param lenses? lsp.CodeLens[] lenses to display\n----@param bufnr integer\n----@param client_id integer\n-function M.display(lenses, bufnr, client_id)\n-  if not api.nvim_buf_is_loaded(bufnr) then\n-    return\n+--- Buffer handle, or 0 for current.\n+--- (default: 0)\n+---@field bufnr? integer\n+---\n+--- Client ID, or nil for all.\n+--- (default: all)\n+---@field client_id? integer\n+\n+---@class vim.lsp.codelens.get.Result\n+---@inlinedoc\n+---@field client_id integer\n+---@field lens lsp.CodeLens\n+\n+--- Get all code lenses in the {filter}ed scope.\n+---\n+---@param filter? vim.lsp.codelens.get.Filter\n+---@return vim.lsp.codelens.get.Result[]\n+function M.get(filter)\n+  if type(filter) == 'number' then\n+    vim.deprecate(\n+      'vim.lsp.codelens.get(bufnr)',\n+      'vim.lsp.codelens.get({ bufnr = bufnr })',\n+      '0.12.0'\n+    )\n+    local bufnr = vim._resolve_bufnr(filter)\n+    local provider = Provider.active[bufnr]\n+    if not provider then\n+      return {}\n+    end\n+    ---@type lsp.CodeLens[]\n+    local result = {}\n+    for _, state in pairs(provider.client_state) do\n+      for _, lenses in pairs(state.row_lenses) do\n+        result = vim.list_extend(result, lenses)\n+      end\n+    end\n+    return result\n   end\n \n-  local ns = namespaces[client_id]\n-  if not lenses or not next(lenses) then\n-    api.nvim_buf_clear_namespace(bufnr, ns, 0, -1)\n-    return\n+  vim.validate('filter', filter, 'table', true)\n+  filter = filter or {}\n+\n+  local bufnr = vim._resolve_bufnr(filter.bufnr)\n+  local provider = Provider.active[bufnr]\n+  if not provider then\n+    return {}\n   end\n \n-  local lenses_by_lnum = group_lenses_by_start_line(lenses)\n-  local num_lines = api.nvim_buf_line_count(bufnr)\n-  for i = 0, num_lines do\n-    display_line_lenses(bufnr, ns, i, lenses_by_lnum[i] or {})\n+  local result = {}\n+  for client_id, state in pairs(provider.client_state) do\n+    if not filter.client_id or filter.client_id == client_id then\n+      for _, lenses in pairs(state.row_lenses) do\n+        for _, lens in ipairs(lenses) do\n+          table.insert(result, { client_id = client_id, lens = lens })\n+        end\n+      end\n+    end\n   end\n+  return result\n end\n \n---- Store lenses for a specific buffer and client\n+--- Optional parameters |kwargs|:\n+---@class vim.lsp.codelens.run.Opts\n+---@inlinedoc\n ---\n----@param lenses? lsp.CodeLens[] lenses to store\n----@param bufnr integer\n----@param client_id integer\n-function M.save(lenses, bufnr, client_id)\n-  if not api.nvim_buf_is_loaded(bufnr) then\n-    return\n-  end\n+--- Client ID, or nil for all.\n+--- (default: all)\n+---@field client_id? integer\n \n-  local lenses_by_client = lens_cache_by_buf[bufnr]\n-  if not lenses_by_client then\n-    lenses_by_client = {}\n-    lens_cache_by_buf[bufnr] = lenses_by_client\n-    local ns = namespaces[client_id]\n-    api.nvim_buf_attach(bufnr, false, {\n-      on_detach = function(_, b)\n-        lens_cache_by_buf[b] = nil\n-      end,\n-      on_lines = function(_, b, _, first_lnum, last_lnum)\n-        api.nvim_buf_clear_namespace(b, ns, first_lnum, last_lnum)\n-      end,\n-    })\n-  end\n-  lenses_by_client[client_id] = lenses\n-end\n+--- Run code lens above the current cursor position.\n+---\n+---@param opts? vim.lsp.codelens.run.Opts\n+function M.run(opts)\n+  vim.validate('opts', opts, 'table', true)\n+  opts = opts or {}\n \n----@param lenses? lsp.CodeLens[]\n----@param bufnr integer\n----@param client_id integer\n----@param callback fun()\n-local function resolve_lenses(lenses, bufnr, client_id, callback)\n-  lenses = lenses or {}\n-  local num_lens = vim.tbl_count(lenses)\n-  if num_lens == 0 then\n-    callback()\n+  local winid = api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local pos = vim.pos.cursor(api.nvim_win_get_cursor(winid))\n+  local provider = Provider.active[bufnr]\n+  if not provider then\n     return\n   end\n \n-  ---@param n integer\n-  local function countdown(n)\n-    num_lens = num_lens - n\n-    if num_lens == 0 then\n-      callback()\n-    end\n-  end\n-\n-  local ns = namespaces[client_id]\n-  local client = vim.lsp.get_client_by_id(client_id)\n-\n-  -- Resolve all lenses in a line, then display them.\n-  local lenses_by_lnum = group_lenses_by_start_line(lenses)\n-  for line, line_lenses in pairs(lenses_by_lnum) do\n-    local num_resolved_line_lenses = 0\n-    local function display_line_countdown()\n-      num_resolved_line_lenses = num_resolved_line_lenses + 1\n-      if num_resolved_line_lenses == #line_lenses then\n-        if api.nvim_buf_is_valid(bufnr) and line <= api.nvim_buf_line_count(bufnr) then\n-          display_line_lenses(bufnr, ns, line, line_lenses)\n+  ---@type [integer, lsp.CodeLens][]\n+  local items = {}\n+  for client_id, state in pairs(provider.client_state) do\n+    if not opts.client_id or opts.client_id == client_id then\n+      for _, lens in ipairs(state.row_lenses[pos.row] or {}) do\n+        -- Ignore unresolved and empty command lenses.\n+        if lens.command and lens.command.command ~= '' then\n+          table.insert(items, { client_id, lens })\n         end\n-        countdown(#line_lenses)\n       end\n     end\n+  end\n \n-    for _, lens in pairs(line_lenses) do\n-      if lens.command then\n-        display_line_countdown()\n-      else\n-        assert(client)\n-        client:request('codeLens/resolve', lens, function(_, result)\n-          if api.nvim_buf_is_loaded(bufnr) and result and result.command then\n-            lens.command = result.command\n-          end\n-          display_line_countdown()\n-        end, bufnr)\n+  if #items == 0 then\n+    vim.notify('No code lens avaliable')\n+    return\n+  elseif #items == 1 then\n+    local client_id, lens = unpack(items[1])\n+    local client = assert(vim.lsp.get_client_by_id(client_id))\n+    client:exec_cmd(lens.command)\n+  else\n+    vim.ui.select(items, {\n+      prompt = 'Code Lens',\n+      ---@param item [integer, lsp.CodeLens]\n+      format_item = function(item)\n+        local client_id, lens = unpack(item)\n+        local client = assert(vim.lsp.get_client_by_id(client_id))\n+        return ('%s [%s]'):format(lens.command.title, client.name)\n+      end,\n+    }, function(item)\n+      if item then\n+        local client_id, lens = unpack(item)\n+        local client = assert(vim.lsp.get_client_by_id(client_id))\n+        client:exec_cmd(lens.command)\n       end\n-    end\n+    end)\n   end\n end\n \n---- |lsp-handler| for the method `textDocument/codeLens`\n+--- |lsp-handler| for the method `workspace/codeLens/refresh`\n ---\n----@param err lsp.ResponseError?\n----@param result lsp.CodeLens[]\n----@param ctx lsp.HandlerContext\n-function M.on_codelens(err, result, ctx)\n-  local bufnr = assert(ctx.bufnr)\n-\n+---@private\n+---@type lsp.Handler\n+function M.on_refresh(err, _, ctx)\n   if err then\n-    active_refreshes[bufnr] = nil\n-    log.error('codelens', err)\n-    return\n+    return vim.NIL\n   end\n \n-  M.save(result, bufnr, ctx.client_id)\n+  for bufnr, provider in pairs(Provider.active) do\n+    for client_id in pairs(provider.client_state) do\n+      if client_id == ctx.client_id then\n+        provider:request(client_id, function()\n+          provider.row_version = {}\n+          vim.api.nvim__redraw({ buf = bufnr, valid = true, flush = false })\n+        end)\n+      end\n+    end\n+  end\n+  return vim.NIL\n+end\n \n-  -- Eager display for any resolved lenses and refresh them once resolved.\n-  M.display(result, bufnr, ctx.client_id)\n-  resolve_lenses(result, bufnr, ctx.client_id, function()\n-    active_refreshes[bufnr] = nil\n-  end)\n+---@deprecated\n+---@param client_id? integer\n+---@param bufnr? integer\n+function M.clear(client_id, bufnr)\n+  vim.deprecate(\n+    'vim.lsp.codelens.clear(client_id, bufnr)',\n+    'vim.lsp.codelens.enable(false, { bufnr = bufnr, client_id = client_id })',\n+    '0.12.0'\n+  )\n+  M.enable(false, { bufnr = bufnr, client_id = client_id })\n end\n \n---- @class vim.lsp.codelens.refresh.Opts\n---- @inlinedoc\n---- @field bufnr integer? filter by buffer. All buffers if nil, 0 for current buffer\n+---@deprecated\n+---@param lenses? lsp.CodeLens[] lenses to display\n+---@param bufnr integer\n+---@param client_id integer\n+function M.display(lenses, bufnr, client_id)\n+  vim.deprecate('vim.lsp.codelens.display()', nil, '0.12.0')\n+  local _, _, _ = lenses, bufnr, client_id\n+end\n \n---- Refresh the lenses.\n----\n---- It is recommended to trigger this using an autocmd or via keymap.\n----\n---- Example:\n----\n---- ```vim\n---- autocmd BufEnter,CursorHold,InsertLeave <buffer> lua vim.lsp.codelens.refresh({ bufnr = 0 })\n---- ```\n----\n---- @param opts? vim.lsp.codelens.refresh.Opts Optional fields\n+---@deprecated\n+---@param lenses? lsp.CodeLens[] lenses to store\n+---@param bufnr integer\n+---@param client_id integer\n+function M.save(lenses, bufnr, client_id)\n+  vim.deprecate('vim.lsp.codelens.save()', nil, '0.12.0')\n+  local _, _, _ = lenses, bufnr, client_id\n+end\n+\n+---@deprecated\n+---@param err? lsp.ResponseError\n+---@param result lsp.CodeLens[]\n+---@param ctx lsp.HandlerContext\n+function M.on_codelens(err, result, ctx)\n+  vim.deprecate('vim.lsp.codelens.on_codelens()', nil, '0.12.0')",
            "html_url": "https://github.com/neovim/neovim/pull/37626#discussion_r2759190436",
            "id": 2759190436,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6kdeek",
            "original_commit_id": "6e17f060fef374e66d8ff53dbc6bdded05740686",
            "original_line": 469,
            "original_position": 726,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/codelens.lua",
            "position": 1,
            "pull_request_review_id": 3745396051,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759190436/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-03T13:50:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2759190436",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "Considering that the module name `codelens` deviates from our current naming convention (using underscores to separate words) and that this will be a breaking change, I am considering keeping the previous version at `vim.lsp.codelens` and marking it as deprecated, while providing the current version via `vim.lsp.code_lens`. Is this approach feasible? @MariaSolOs @mfussenegger I'd like to get your thoughts on this when you have a moment.",
            "created_at": "2026-01-30T09:40:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3822785330",
            "id": 3822785330,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7j2xMy",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3822785330/reactions"
            },
            "updated_at": "2026-01-30T09:40:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3822785330",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Considering that the module name codelens deviates from our current naming convention (using underscores to separate words)\r\n\r\nIt's actually already a bit of a mix. In the lua stdlib there's a tendency to avoid the underscore if not really necessary. `tonumber`, `setmetatable` are examples. In some places neovim carried that over - e.g. `vim.iter(..):totable`. So it's not that clear cut.\r\n\r\nI'd tend to keep the `codelens` name and change the `refresh()` to call `.enable()` and force a refresh if it was already enabled. `display()` I'd turn into a no-op. And mark both as deprecated.",
            "created_at": "2026-01-30T14:31:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3824072474",
            "id": 3824072474,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7j7rca",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 5,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 5,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3824072474/reactions"
            },
            "updated_at": "2026-01-30T14:31:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3824072474",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have also implemented `workspace/codeLens/refresh` in this PR, which is useful because servers often return empty codeLens when they are not ready, and subsequently use refresh to return the actual valid results.\r\n\r\nThis PR should be ready for review now, and I will be modifying/adding tests in the meantime.",
            "created_at": "2026-01-31T13:53:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828570489",
            "id": 3828570489,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kM1l5",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828570489/reactions"
            },
            "updated_at": "2026-01-31T13:53:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828570489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Could you fix the failing tests first?",
            "created_at": "2026-01-31T14:57:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828672823",
            "id": 3828672823,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kNOk3",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828672823/reactions"
            },
            "updated_at": "2026-01-31T14:57:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828672823",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Could you fix the failing tests first?\r\n\r\nDone. The previous failing tests were outdated (targeting the deprecated `clear()` and `show()`); I have now removed them and added new tests for the current version.",
            "created_at": "2026-01-31T17:04:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3828847038",
            "id": 3828847038,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kN5G-",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828847038/reactions"
            },
            "updated_at": "2026-01-31T17:04:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3828847038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "#37647 will fix the remaining CI failures.",
            "created_at": "2026-02-01T01:36:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3830035677",
            "id": 3830035677,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kSbTd",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3830035677/reactions"
            },
            "updated_at": "2026-02-01T01:36:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3830035677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I've rebased on master, so the tests are now passed.",
            "created_at": "2026-02-02T04:48:09Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3832893247",
            "id": 3832893247,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kdU8_",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3832893247/reactions"
            },
            "updated_at": "2026-02-02T04:48:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3832893247",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "~~This would obsolete https://github.com/neovim/neovim/pull/36469.~~ I built off of this and it feels smooth as well.\r\n\r\n~~One question - Would it be better to snap the virtual line display to the indent rather than the LSP data? This would involve an extra calculation to get the line's indent, but the output might be more in line with what the user would expect.~~",
            "created_at": "2026-02-02T18:04:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3836815232",
            "id": 3836815232,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7ksSeA",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836815232/reactions"
            },
            "updated_at": "2026-02-02T18:21:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836815232",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62523234?v=4",
                "events_url": "https://api.github.com/users/mikejmcguirk/events{/privacy}",
                "followers_url": "https://api.github.com/users/mikejmcguirk/followers",
                "following_url": "https://api.github.com/users/mikejmcguirk/following{/other_user}",
                "gists_url": "https://api.github.com/users/mikejmcguirk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mikejmcguirk",
                "id": 62523234,
                "login": "mikejmcguirk",
                "node_id": "MDQ6VXNlcjYyNTIzMjM0",
                "organizations_url": "https://api.github.com/users/mikejmcguirk/orgs",
                "received_events_url": "https://api.github.com/users/mikejmcguirk/received_events",
                "repos_url": "https://api.github.com/users/mikejmcguirk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mikejmcguirk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mikejmcguirk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mikejmcguirk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> This would obsolete #36469. I built off of this and it feels smooth as well.\r\n> \r\n> One question - Would it be better to snap the virtual line display to the indent rather than the LSP data? This would involve an extra calculation to get the line's indent, but the output might be more in line with what the user would expect.\r\n\r\nPlease don't get virtual-lines mixed into this PR. As mentioned in my other review comment, this PR must not change the display behavior. Scope should be limited to the decoration provider refactor. ",
            "created_at": "2026-02-02T18:07:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3836828988",
            "id": 3836828988,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7ksV08",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836828988/reactions"
            },
            "updated_at": "2026-02-02T18:07:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3836828988",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have cherry-picked out the two out-of-scope commits (using virt_lines and creating default mappings, see https://github.com/ofseed/neovim/compare/lsp-codelens...ofseed:neovim:lsp-codelens-follow-ups). We can discuss these two changes in other PRs.",
            "created_at": "2026-02-03T03:22:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/37626#issuecomment-3838818940",
            "id": 3838818940,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
            "node_id": "IC_kwDOAPphoM7kz7p8",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3838818940/reactions"
            },
            "updated_at": "2026-02-03T03:29:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3838818940",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/37626/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/37626/commits",
    "created_at": "2026-01-30T09:30:16Z",
    "diff_url": "https://github.com/neovim/neovim/pull/37626.diff",
    "draft": false,
    "head": {
        "label": "ofseed:lsp-codelens",
        "ref": "lsp-codelens",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/ofseed/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/ofseed/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/ofseed/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/ofseed/neovim/branches{/branch}",
            "clone_url": "https://github.com/ofseed/neovim.git",
            "collaborators_url": "https://api.github.com/repos/ofseed/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/ofseed/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/ofseed/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/ofseed/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/ofseed/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/ofseed/neovim/contributors",
            "created_at": "2021-11-30T18:13:03Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/ofseed/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/ofseed/neovim/downloads",
            "events_url": "https://api.github.com/repos/ofseed/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/ofseed/neovim/forks",
            "full_name": "ofseed/neovim",
            "git_commits_url": "https://api.github.com/repos/ofseed/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/ofseed/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/ofseed/neovim/git/tags{/sha}",
            "git_url": "git://github.com/ofseed/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/ofseed/neovim/hooks",
            "html_url": "https://github.com/ofseed/neovim",
            "id": 433537354,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/ofseed/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/ofseed/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/ofseed/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/ofseed/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/ofseed/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/ofseed/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/ofseed/neovim/merges",
            "milestones_url": "https://api.github.com/repos/ofseed/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGddBSg",
            "notifications_url": "https://api.github.com/repos/ofseed/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/ofseed/neovim/pulls{/number}",
            "pushed_at": "2026-02-05T03:22:18Z",
            "releases_url": "https://api.github.com/repos/ofseed/neovim/releases{/id}",
            "size": 356233,
            "ssh_url": "git@github.com:ofseed/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/ofseed/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/ofseed/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/ofseed/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/ofseed/neovim/subscription",
            "svn_url": "https://github.com/ofseed/neovim",
            "tags_url": "https://api.github.com/repos/ofseed/neovim/tags",
            "teams_url": "https://api.github.com/repos/ofseed/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/ofseed/neovim/git/trees{/sha}",
            "updated_at": "2026-02-05T03:23:10Z",
            "url": "https://api.github.com/repos/ofseed/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "965468fca1e7c465292ea9dd767f5cf02fc61dad",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
            "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
            "followers_url": "https://api.github.com/users/ofseed/followers",
            "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
            "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ofseed",
            "id": 61115159,
            "login": "ofseed",
            "node_id": "MDQ6VXNlcjYxMTE1MTU5",
            "organizations_url": "https://api.github.com/users/ofseed/orgs",
            "received_events_url": "https://api.github.com/users/ofseed/received_events",
            "repos_url": "https://api.github.com/users/ofseed/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ofseed",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/37626",
    "id": 3227082829,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/37626",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        },
        {
            "color": "F9D0C4",
            "default": false,
            "description": "",
            "id": 3968935075,
            "name": "breaking-change",
            "node_id": "LA_kwDOAPphoM7skSSj",
            "url": "https://api.github.com/repos/neovim/neovim/labels/breaking-change"
        }
    ],
    "locked": false,
    "merge_commit_sha": "f5931102f8c8d859930eb205088d83cab3efee01",
    "merged_at": "2026-02-03T14:46:38Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM7AWWBN",
    "number": 37626,
    "patch_url": "https://github.com/neovim/neovim/pull/37626.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/37626/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/965468fca1e7c465292ea9dd767f5cf02fc61dad",
    "title": "feat(lsp)!: reimplement `textDocument/codeLens` as decoration provider",
    "updated_at": "2026-02-03T14:46:51Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/37626",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
        "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
        "followers_url": "https://api.github.com/users/ofseed/followers",
        "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
        "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/ofseed",
        "id": 61115159,
        "login": "ofseed",
        "node_id": "MDQ6VXNlcjYxMTE1MTU5",
        "organizations_url": "https://api.github.com/users/ofseed/orgs",
        "received_events_url": "https://api.github.com/users/ofseed/received_events",
        "repos_url": "https://api.github.com/users/ofseed/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/ofseed",
        "user_view_type": "public"
    }
}