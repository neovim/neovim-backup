{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/36993/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36993/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/36993"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/36993"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36993/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/334624a08e6c97f67f3941cbd63a5a837fd28686"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6598,
            "forks_count": 6598,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_pull_requests": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 2011,
            "open_issues_count": 2011,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pull_request_creation_policy": "all",
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2026-02-23T22:33:57Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 370553,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 96717,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2026-02-24T02:43:24Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 96717,
            "watchers_count": 96717,
            "web_commit_signoff_required": false
        },
        "sha": "3f4ef487da80da73f4943d81fb8549c9de70f55f",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Mostly the same as helix's implementation (for now), but ignore unnamed nodes (and some QoL stuff) and handle overlapping and disjointed injections.\r\n\r\n# TODO\r\n- [x] Hijack `vim.lsp.buf.selection_range` default mappings\r\n    - What about next-/prev-node\r\n- [x] Implement handling of disjointed tree\r\n    - Happens when `injection.combined` is ON\r\n    - Happens when `injection.include-children` is OFF\r\n    - [x] Test that it works\r\n- [x] Implement handling of overlapping trees\r\n    - Happens when `injection.include-children` is ON\r\n    - Solution: if there are overlapping trees, ignore one of them\r\n    - [x] Test that it works\r\n- [x] Documentation\r\n- [x] Tests\r\n- [x] Fallbacks when no child/parent node found\r\n\r\n# Ideas for better performance (not implemented in this PR)\r\nCurrently, the way this gets what trees have what injected trees is by looping over both of them and looking if one of them contains the other one. Possible solution: save this data in the injection-query-loop.\r\nSimilarly, the way this gets what tree-region (e.g. `TSTree:included_ranges`) contains what injected-tree-region is also just a loop, and similar solution could be applied.\r\nCurrently, the tree is fully parsed, but doesn't need to be. One way to solve this is to have fine grained control over parsing: even if you haven't parsed the whole tree, you get access to all the injected tree unparsed (including it's regions), and then, when needed, parse those trees...",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2623991227"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623991227"
                }
            },
            "author_association": "MEMBER",
            "body": "`vim._memoize` the `get_node` call instead. (But since these calls don't happen in a hot loop, I would not worry about caching at first and only add this after credible reports of performance issues.)",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-16T16:38:30Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)\n+    local node=assert(parser:named_node_for_range(range,{ignore_injections=false}))\n+    return node\n+end\n+---@param node TSNode\n+---@param _rec any?\n+---@return table\n+local function get_data(node,_rec)\n+    local view,injections,rinjections=create_treeview()\n+    if view[node:id()] then\n+        return view[node:id()]\n+    end\n+\n+    assert(node:byte_length()~=0)\n+\n+    local parent=rinjections[node:id()] or node:parent() or nil\n+    if parent and same_range(node,parent) and not _rec then\n+        return get_data(parent)\n+    end\n+\n+    local data=_rec or {}\n+    view[node:id()]=data\n+\n+    data.children={}\n+\n+    local injection=injections[node:id()]\n+    if injection then\n+        if injection:byte_length()~=0 then\n+            if same_range(injection,node) then\n+                get_data(injection,data)\n+            else\n+                table.insert(data.children,injection)\n+            end\n+        end\n+    end\n+\n+    for _,child in ipairs(node:named_children()) do\n+        if child:byte_length()~=0 then\n+            if same_range(child,node) then\n+                get_data(child,data)\n+            else\n+                table.insert(data.children,child)\n+            end\n+        end\n+    end\n+\n+    if not _rec then\n+        data.parent=parent\n+    end\n+\n+    return data\n+end\n+---@param node TSNode\n+---@return TSNode\n+function M.get_parent_node(node)\n+    cache_check()\n+    local data=get_data(node)\n+    if not data.parent then\n+        return node\n+    end\n+    assert(not same_range(node,data.parent))\n+    return data.parent\n+end\n+---@param node TSNode\n+---@return TSNode\n+function M.get_child_node(node)\n+    cache_check()\n+    local data=get_data(node)\n+    for _,child in ipairs(data.children) do\n+        assert(not data.parent or not same_range(node,data.parent))\n+        assert(child:byte_length()~=0)\n+        return child\n+    end\n+    return node\n+end\n+---@param node TSNode\n+---@param prev boolean\n+---@return TSNode\n+function M.get_sibling_node(node,prev)\n+    cache_check()\n+    local data=get_data(node)\n+    local parent=data.parent\n+    if not parent then\n+        return node\n+    end\n+    local parent_data=get_data(parent)\n+    local idx=-1\n+    for i,child in ipairs(parent_data.children) do\n+        if get_data(child)==get_data(node) then\n+            idx=i+(prev and -1 or 1)\n+            break\n+        end\n+    end\n+    if parent_data.children[idx] then\n+        assert(not same_range(node,parent_data.children[idx]))\n+        assert(parent_data.children[idx]:byte_length()~=0)\n+        return parent_data.children[idx]\n+    end\n+    assert(not same_range(node,parent))\n+    return node\n+end\n+---@param node TSNode\n+function M.select(node)\n+    cache_check()\n+    local rows,cols,rowe,cole=node:range()\n+    local other=false\n+    if vim.fn.mode()=='v'  then\n+        local vcol,vline=vim.fn.col'v',vim.fn.line'v'\n+        local dcol,dline=vim.fn.col'.',vim.fn.line'.'\n+        if vline>dline or (vline==dline and vcol>dcol) then\n+            other=true\n+        end\n+    end\n+    vim.api.nvim_win_set_cursor(0,{rows+1,cols})\n+    vim.api.nvim_feedkeys(vim.keycode'<C-\\\\><C-n>v','nx',true)\n+    if not pcall(vim.api.nvim_win_set_cursor,0,{rowe+1,cole-1}) then\n+        vim.api.nvim_win_set_cursor(0,{rowe,#vim.fn.getline(rowe)})\n+    end\n+    if other then\n+        vim.api.nvim_feedkeys('o','nx',true)\n+    end\n+end\n+function M.up()\n+    cache_check()\n+    local node=M.get_node()\n+    local parent=M.get_parent_node(node)\n+    if get_data(parent)==get_data(node) then return end\n+    table.insert(M.stack,{parent,node})\n+    M.select(parent)\n+end\n+function M.down()\n+    cache_check()\n+    local node=M.get_node()\n+    if #M.stack>0 and same_range(node,M.stack[#M.stack][1]) then\n+        M.select(table.remove(M.stack)[2])\n+        return\n+    end\n+    M.stack={}\n+    local child=M.get_child_node(node)\n+    if get_data(child)==get_data(node) then return end\n+    M.select(child)\n+end\n+function M.next()\n+    cache_check()\n+    local node=M.get_node()",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2623991227",
            "id": 2623991227,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cZu27",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 285,
            "original_position": 285,
            "original_start_line": 284,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3584004825,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623991227/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-16T16:38:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623991227",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2623993750"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623993750"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    parser:parse({vim.fn.line(\"w0\") - 1, vim.fn.line(\"w$\")})\n```\n",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-16T16:39:22Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2623993750",
            "id": 2623993750,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cZveW",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": null,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3584008013,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623993750/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-16T16:39:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2623993750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2628131725"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628131725"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Credible report: me running it in big file (with comment-parser installed).\r\nAlso renamed the function to make it more clear...",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-17T18:20:18Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)\n+    local node=assert(parser:named_node_for_range(range,{ignore_injections=false}))\n+    return node\n+end\n+---@param node TSNode\n+---@param _rec any?\n+---@return table\n+local function get_data(node,_rec)\n+    local view,injections,rinjections=create_treeview()\n+    if view[node:id()] then\n+        return view[node:id()]\n+    end\n+\n+    assert(node:byte_length()~=0)\n+\n+    local parent=rinjections[node:id()] or node:parent() or nil\n+    if parent and same_range(node,parent) and not _rec then\n+        return get_data(parent)\n+    end\n+\n+    local data=_rec or {}\n+    view[node:id()]=data\n+\n+    data.children={}\n+\n+    local injection=injections[node:id()]\n+    if injection then\n+        if injection:byte_length()~=0 then\n+            if same_range(injection,node) then\n+                get_data(injection,data)\n+            else\n+                table.insert(data.children,injection)\n+            end\n+        end\n+    end\n+\n+    for _,child in ipairs(node:named_children()) do\n+        if child:byte_length()~=0 then\n+            if same_range(child,node) then\n+                get_data(child,data)\n+            else\n+                table.insert(data.children,child)\n+            end\n+        end\n+    end\n+\n+    if not _rec then\n+        data.parent=parent\n+    end\n+\n+    return data\n+end\n+---@param node TSNode\n+---@return TSNode\n+function M.get_parent_node(node)\n+    cache_check()\n+    local data=get_data(node)\n+    if not data.parent then\n+        return node\n+    end\n+    assert(not same_range(node,data.parent))\n+    return data.parent\n+end\n+---@param node TSNode\n+---@return TSNode\n+function M.get_child_node(node)\n+    cache_check()\n+    local data=get_data(node)\n+    for _,child in ipairs(data.children) do\n+        assert(not data.parent or not same_range(node,data.parent))\n+        assert(child:byte_length()~=0)\n+        return child\n+    end\n+    return node\n+end\n+---@param node TSNode\n+---@param prev boolean\n+---@return TSNode\n+function M.get_sibling_node(node,prev)\n+    cache_check()\n+    local data=get_data(node)\n+    local parent=data.parent\n+    if not parent then\n+        return node\n+    end\n+    local parent_data=get_data(parent)\n+    local idx=-1\n+    for i,child in ipairs(parent_data.children) do\n+        if get_data(child)==get_data(node) then\n+            idx=i+(prev and -1 or 1)\n+            break\n+        end\n+    end\n+    if parent_data.children[idx] then\n+        assert(not same_range(node,parent_data.children[idx]))\n+        assert(parent_data.children[idx]:byte_length()~=0)\n+        return parent_data.children[idx]\n+    end\n+    assert(not same_range(node,parent))\n+    return node\n+end\n+---@param node TSNode\n+function M.select(node)\n+    cache_check()\n+    local rows,cols,rowe,cole=node:range()\n+    local other=false\n+    if vim.fn.mode()=='v'  then\n+        local vcol,vline=vim.fn.col'v',vim.fn.line'v'\n+        local dcol,dline=vim.fn.col'.',vim.fn.line'.'\n+        if vline>dline or (vline==dline and vcol>dcol) then\n+            other=true\n+        end\n+    end\n+    vim.api.nvim_win_set_cursor(0,{rows+1,cols})\n+    vim.api.nvim_feedkeys(vim.keycode'<C-\\\\><C-n>v','nx',true)\n+    if not pcall(vim.api.nvim_win_set_cursor,0,{rowe+1,cole-1}) then\n+        vim.api.nvim_win_set_cursor(0,{rowe,#vim.fn.getline(rowe)})\n+    end\n+    if other then\n+        vim.api.nvim_feedkeys('o','nx',true)\n+    end\n+end\n+function M.up()\n+    cache_check()\n+    local node=M.get_node()\n+    local parent=M.get_parent_node(node)\n+    if get_data(parent)==get_data(node) then return end\n+    table.insert(M.stack,{parent,node})\n+    M.select(parent)\n+end\n+function M.down()\n+    cache_check()\n+    local node=M.get_node()\n+    if #M.stack>0 and same_range(node,M.stack[#M.stack][1]) then\n+        M.select(table.remove(M.stack)[2])\n+        return\n+    end\n+    M.stack={}\n+    local child=M.get_child_node(node)\n+    if get_data(child)==get_data(node) then return end\n+    M.select(child)\n+end\n+function M.next()\n+    cache_check()\n+    local node=M.get_node()",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2628131725",
            "id": 2628131725,
            "in_reply_to_id": 2623991227,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cphuN",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 285,
            "original_position": 285,
            "original_start_line": 284,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3589041065,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628131725/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-17T18:20:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628131725",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2628223975"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628223975"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Full injection knowledge is required for it to work...\r\n(Though can replaced once some kind of fine grain injection parsing is implemented).",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-17T18:44:42Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2628223975",
            "id": 2628223975,
            "in_reply_to_id": 2623993750,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cp4Pn",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": null,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3589153603,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628223975/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-17T18:44:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628223975",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2628407738"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628407738"
                }
            },
            "author_association": "MEMBER",
            "body": "The OG nvim-treesitter incremental selection didn't need it, so I'm somewhat surprised that this does.",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-17T19:41:47Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2628407738",
            "id": 2628407738,
            "in_reply_to_id": 2623993750,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cqlG6",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": null,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3589369130,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628407738/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-17T19:41:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628407738",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2628480047"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628480047"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Now that I think about it, there might be a way...",
            "commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "created_at": "2025-12-17T20:07:36Z",
            "diff_hunk": "@@ -0,0 +1,301 @@\n+local Range=require'vim.treesitter._range'\n+\n+local state={}\n+local M={}\n+\n+---@class nvim.treeselect.tree_range\n+---@field range Range4\n+---@field clamped boolean\n+\n+---@class nvim.treeselect.clamped_node\n+---@field clamp_range Range4\n+---@field node TSNode\n+\n+---@alias nvim.treeselect.node\n+--- | TSNode\n+--- | nvim.treeselect.tree_range\n+--- | nvim.treeselect.clamped_node\n+\n+---@param node nvim.treeselect.node\n+---@return boolean\n+local function node_is_tsnode(node)\n+  return type(node)=='userdata'\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return any\n+local function node_id(node)\n+  return node_is_tsnode(node) and node:id() or node\n+end\n+\n+---@param node1 nvim.treeselect.node\n+---@param node2 nvim.treeselect.node\n+---@return boolean\n+local function nodes_same_range(node1,node2)\n+  error('TODO')\n+end\n+\n+---@param range Range4\n+---@return nvim.treeselect.node?\n+local function get_node(range,_tsnode)\n+  local tsnode=_tsnode or state.root_tsnode\n+  local regions=state.injection_regions[tsnode:id()]\n+  for injection_tsnode,region in pairs(regions) do\n+    if Range.contains(region,range) then\n+      error'TODO'\n+    end\n+  end\n+end\n+\n+---@param node nvim.treeselect.node\n+---@return nvim.treeselect.node?\n+local function node_get_parent(node)\n+  local parent=state.parent[node_id(node)] or node:parent()\n+  if not parent then\n+    return\n+  end\n+  while true do\n+    local parent_parent=node_get_parent(parent)\n+    if parent_parent and nodes_same_range(parent,parent_parent) then\n+      parent=parent_parent\n+    else\n+      return parent\n+    end\n+  end\n+end\n+\n+function M.select_parent_node()\n+  local node=get_node()\n+  local parent=node_get_parent(node)\n+  select(parent)\n+end\n+\n+M.stack={}\n+local _treeview_cache\n+local _cache_check={\n+    bufnr=-1,\n+    changedtick=-1,\n+}\n+local function cache_check()\n+    if vim.api.nvim_get_current_buf()==_cache_check.bufnr\n+        and vim.b.changedtick==_cache_check.changedtick then\n+        return\n+    end\n+    M.stack={}\n+    _treeview_cache=nil\n+    _cache_check={\n+        bufnr=vim.api.nvim_get_current_buf(),\n+        changedtick=vim.b.changedtick,\n+    }\n+end\n+---@return table,table,table\n+local function create_treeview()\n+    if _treeview_cache then\n+        return _treeview_cache.view,_treeview_cache.injections,_treeview_cache.rinjections\n+    end\n+    local parser=assert(vim.treesitter.get_parser())\n+    local injections={}\n+    local rinjections={}\n+    parser:for_each_tree(function(parent_tree,parent_ltree)\n+        local parent=parent_tree:root()\n+        for _,child in pairs(parent_ltree:children()) do\n+            for _,child_tree in pairs(child:trees()) do\n+                local child_root=child_tree:root()\n+                if vim.treesitter.node_contains(parent,{child_root:range()}) then\n+                    local node=assert(parent:named_descendant_for_range(child_root:range()))\n+                    local id=node:id()\n+                    if not injections[id] or child_root:byte_length()>injections[id]:byte_length() then\n+                        injections[id]=child_root\n+                        rinjections[child_root:id()]=node\n+                    end\n+                end\n+            end\n+        end\n+    end)\n+    local view={}\n+    _treeview_cache={\n+        view=view,\n+        injections=injections,\n+        rinjections=rinjections,\n+    }\n+    return view,injections,rinjections\n+end\n+---@param a TSNode\n+---@param b TSNode\n+---@return boolean\n+local function same_range(a,b)\n+    local arows,acols,arowe,acole=a:range()\n+    local brows,bcols,browe,bcole=b:range()\n+    return arows==brows and acols==bcols and arowe==browe and acole==bcole\n+end\n+---@return TSNode\n+function M.get_node()\n+    cache_check()\n+    local pos1=vim.fn.getpos('v')\n+    local pos2=vim.fn.getpos('.')\n+    if pos1[2]>pos2[2] or (pos1[2]==pos2[2] and pos1[3]>pos2[3]) then\n+        pos1,pos2=pos2,pos1\n+    end\n+    local range={pos1[2]-1,pos1[3]-1,pos2[2]-1,pos2[3]}\n+    local parser=assert(vim.treesitter.get_parser())\n+    parser:parse(true)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2628480047",
            "id": 2628480047,
            "in_reply_to_id": 2623993750,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6cq2wv",
            "original_commit_id": "417efd3cde6cbc1e9035d92cef0ab4b4c91a48f2",
            "original_line": 141,
            "original_position": 141,
            "original_start_line": null,
            "path": "runtime/lua/treeselect.lua",
            "position": 1,
            "pull_request_review_id": 3589452509,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628480047/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-17T20:07:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2628480047",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2645748110"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645748110"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\nThings to note with these mappings:\n- May fail silently.\n```\nIn which situations? (I don't think this is useful information without more details.)",
            "commit_id": "fcf2d53c2c014176e7604d8dd8c1f4cb59471a3b",
            "created_at": "2025-12-24T14:01:59Z",
            "diff_hunk": "@@ -607,6 +607,31 @@ Injection queries are currently run over the entire buffer, which can be slow\n for large buffers. To disable injections for, e.g.,  `c`, just place an\n empty `queries/c/injections.scm` file in your 'runtimepath'.\n \n+==============================================================================\n+DEFAULTS                                                 *treesitter-defaults*\n+\n+Thigs to note with these mappings:\n+- May fail silently.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2645748110",
            "id": 2645748110,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6dsumO",
            "original_commit_id": "fcf2d53c2c014176e7604d8dd8c1f4cb59471a3b",
            "original_line": 614,
            "original_position": 8,
            "original_start_line": 613,
            "path": "runtime/doc/treesitter.txt",
            "position": 1,
            "pull_request_review_id": 3611045149,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645748110/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-24T14:03:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645748110",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2645749217"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645749217"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n |v_an| |v_in| |v_]n| |v_[n| incremental selection of treesitter nodes.\n```",
            "commit_id": "fcf2d53c2c014176e7604d8dd8c1f4cb59471a3b",
            "created_at": "2025-12-24T14:02:40Z",
            "diff_hunk": "@@ -371,6 +369,7 @@ TREESITTER\n  |Query:iter_captures()| supports specifying starting and ending columns.\n  |:EditQuery| command gained tab-completion, works with injected languages.\n  |LanguageTree:parse()| now accepts a list of ranges.\n+ |v_an| |v_in| |v_]n| |v_[n| incremental treesitter selection mpappings.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2645749217",
            "id": 2645749217,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6dsu3h",
            "original_commit_id": "fcf2d53c2c014176e7604d8dd8c1f4cb59471a3b",
            "original_line": 372,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": 1,
            "pull_request_review_id": 3611045149,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645749217/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-24T14:03:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2645749217",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2675971414"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2675971414"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Can be moved to `./test/functional/treesitter/select_spec.lua`",
            "commit_id": "334624a08e6c97f67f3941cbd63a5a837fd28686",
            "created_at": "2026-01-09T12:12:39Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2675971414",
            "id": 2675971414,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM6fgBVW",
            "original_commit_id": "1cb36613e146d41281de49b1e7576b75d30fea75",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "test/functional/treesitter/select_spec.lua",
            "position": 1,
            "pull_request_review_id": 3643675807,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2675971414/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2026-01-09T12:12:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2675971414",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/23235841?v=4",
                "events_url": "https://api.github.com/users/yochem/events{/privacy}",
                "followers_url": "https://api.github.com/users/yochem/followers",
                "following_url": "https://api.github.com/users/yochem/following{/other_user}",
                "gists_url": "https://api.github.com/users/yochem/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/yochem",
                "id": 23235841,
                "login": "yochem",
                "node_id": "MDQ6VXNlcjIzMjM1ODQx",
                "organizations_url": "https://api.github.com/users/yochem/orgs",
                "received_events_url": "https://api.github.com/users/yochem/received_events",
                "repos_url": "https://api.github.com/users/yochem/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/yochem/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/yochem/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/yochem",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2822574165"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2822574165"
                }
            },
            "author_association": "MEMBER",
            "body": "removing the tags from lsp.txt makes sense, but i think we should still mention this here?",
            "commit_id": "334624a08e6c97f67f3941cbd63a5a837fd28686",
            "created_at": "2026-02-18T14:13:30Z",
            "diff_hunk": "@@ -78,8 +78,6 @@ These GLOBAL keymaps are created unconditionally when Nvim starts:\n - \"grt\" is mapped to |vim.lsp.buf.type_definition()|\n - \"gO\" is mapped to |vim.lsp.buf.document_symbol()|\n - CTRL-S (Insert mode) is mapped to |vim.lsp.buf.signature_help()|\n-- \"an\" and \"in\" (Visual and Operator-pending mode) are mapped to outer and inner incremental\n-  selections, respectively, using |vim.lsp.buf.selection_range()|",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2822574165",
            "id": 2822574165,
            "line": 89,
            "node_id": "PRRC_kwDOAPphoM6oPRBV",
            "original_commit_id": "155c15463b92747e460852ba8f247156d3a15856",
            "original_line": 82,
            "original_position": 14,
            "original_start_line": 81,
            "path": "runtime/doc/lsp.txt",
            "position": 14,
            "pull_request_review_id": 3820149704,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2822574165/reactions"
            },
            "side": "LEFT",
            "start_line": 88,
            "start_side": "LEFT",
            "subject_type": "line",
            "updated_at": "2026-02-18T14:13:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2822574165",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2824391909"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824391909"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nv_an\t\t\tSelects [count]th parent node.\n```",
            "commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "created_at": "2026-02-18T20:50:17Z",
            "diff_hunk": "@@ -607,6 +607,27 @@ Injection queries are currently run over the entire buffer, which can be slow\n for large buffers. To disable injections for, e.g.,  `c`, just place an\n empty `queries/c/injections.scm` file in your 'runtimepath'.\n \n+==============================================================================\n+DEFAULTS                                                 *treesitter-defaults*\n+\n+\t\t\t\t\t\t\t*v_an*\n+v_an\t\t\tSelects parent node.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2824391909",
            "id": 2824391909,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6oWMzl",
            "original_commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "original_line": 614,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/doc/treesitter.txt",
            "position": 1,
            "pull_request_review_id": 3822162879,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824391909/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-18T20:50:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824391909",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2824428892"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824428892"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nv_]n\t\t\tSelects [count]th next node.\n```",
            "commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "created_at": "2026-02-18T20:59:02Z",
            "diff_hunk": "@@ -607,6 +607,27 @@ Injection queries are currently run over the entire buffer, which can be slow\n for large buffers. To disable injections for, e.g.,  `c`, just place an\n empty `queries/c/injections.scm` file in your 'runtimepath'.\n \n+==============================================================================\n+DEFAULTS                                                 *treesitter-defaults*\n+\n+\t\t\t\t\t\t\t*v_an*\n+v_an\t\t\tSelects parent node.\n+\n+\t\t\tIf buffer has no treesitter parser,\n+\t\t\tfalls back to |vim.lsp.buf.selection_range()|.\n+\n+\t\t\t\t\t\t\t*v_in*\n+v_in\t\t\tSelects (either previous or first) child node.\n+\n+\t\t\tIf buffer has no treesitter parser,\n+\t\t\tfalls back to |vim.lsp.buf.selection_range()|.\n+\n+\t\t\t\t\t\t\t*v_]n*\n+v_]n\t\t\tSelects next node.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2824428892",
            "id": 2824428892,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6oWV1c",
            "original_commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "original_line": 626,
            "original_position": 20,
            "original_start_line": null,
            "path": "runtime/doc/treesitter.txt",
            "position": 1,
            "pull_request_review_id": 3822198698,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824428892/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-18T20:59:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824428892",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2824431113"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824431113"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nv_[n\t\t\tSelects [count]th previous node.\n```",
            "commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "created_at": "2026-02-18T20:59:27Z",
            "diff_hunk": "@@ -607,6 +607,27 @@ Injection queries are currently run over the entire buffer, which can be slow\n for large buffers. To disable injections for, e.g.,  `c`, just place an\n empty `queries/c/injections.scm` file in your 'runtimepath'.\n \n+==============================================================================\n+DEFAULTS                                                 *treesitter-defaults*\n+\n+\t\t\t\t\t\t\t*v_an*\n+v_an\t\t\tSelects parent node.\n+\n+\t\t\tIf buffer has no treesitter parser,\n+\t\t\tfalls back to |vim.lsp.buf.selection_range()|.\n+\n+\t\t\t\t\t\t\t*v_in*\n+v_in\t\t\tSelects (either previous or first) child node.\n+\n+\t\t\tIf buffer has no treesitter parser,\n+\t\t\tfalls back to |vim.lsp.buf.selection_range()|.\n+\n+\t\t\t\t\t\t\t*v_]n*\n+v_]n\t\t\tSelects next node.\n+\n+\t\t\t\t\t\t\t*v_[n*\n+v_[n\t\t\tSelects previous node.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2824431113",
            "id": 2824431113,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6oWWYJ",
            "original_commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "original_line": 629,
            "original_position": 23,
            "original_start_line": null,
            "path": "runtime/doc/treesitter.txt",
            "position": 1,
            "pull_request_review_id": 3822200866,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824431113/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-18T20:59:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824431113",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2824438926"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824438926"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nv_in\t\t\tSelects [count]th previous (or first) child node.\n```",
            "commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "created_at": "2026-02-18T21:01:06Z",
            "diff_hunk": "@@ -607,6 +607,27 @@ Injection queries are currently run over the entire buffer, which can be slow\n for large buffers. To disable injections for, e.g.,  `c`, just place an\n empty `queries/c/injections.scm` file in your 'runtimepath'.\n \n+==============================================================================\n+DEFAULTS                                                 *treesitter-defaults*\n+\n+\t\t\t\t\t\t\t*v_an*\n+v_an\t\t\tSelects parent node.\n+\n+\t\t\tIf buffer has no treesitter parser,\n+\t\t\tfalls back to |vim.lsp.buf.selection_range()|.\n+\n+\t\t\t\t\t\t\t*v_in*\n+v_in\t\t\tSelects (either previous or first) child node.",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2824438926",
            "id": 2824438926,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6oWYSO",
            "original_commit_id": "ae7fce11e5ee89fbdb52db357c0430d5a9b7e4aa",
            "original_line": 620,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/doc/treesitter.txt",
            "position": 1,
            "pull_request_review_id": 3822208897,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824438926/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-18T21:01:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2824438926",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2835266103"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835266103"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\nlocal function node_normalize_up(node, parent_chain)\n```",
            "commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "created_at": "2026-02-20T21:59:14Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_upp(node, parent_chain)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2835266103",
            "id": 2835266103,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6o_ro3",
            "original_commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "original_line": 265,
            "original_position": 265,
            "original_start_line": null,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3834390960,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835266103/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-20T22:00:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835266103",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2835269291"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835269291"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n  node = node_normalize_up(node, parent_chain)\n```",
            "commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "created_at": "2026-02-20T21:59:57Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_upp(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)\n+  local cursor_other_end_of_visual = false\n+\n+  if vim.fn.mode() == 'v' then\n+    local vcol, vrow = vim.fn.col('v'), vim.fn.line('v')\n+    local dcol, dline = vim.fn.col('.'), vim.fn.line('.')\n+    if vrow > dline or (vrow == dline and vcol > dcol) then\n+      cursor_other_end_of_visual = true\n+    end\n+  end\n+\n+  vim.api.nvim_win_set_cursor(0, { rows + 1, cols })\n+  vim.api.nvim_feedkeys(vim.keycode('<C-\\\\><C-n>v'), 'nx', true)\n+\n+  if not pcall(vim.api.nvim_win_set_cursor, 0, { rowe + 1, cole - 1 }) then\n+    vim.api.nvim_win_set_cursor(0, { rowe, #vim.fn.getline(rowe) })\n+  end\n+\n+  if cursor_other_end_of_visual then\n+    vim.api.nvim_feedkeys('o', 'nx', true)\n+  end\n+end\n+\n+--- @return Range4\n+local function get_selection()\n+  local pos1 = vim.fn.getpos('v')\n+  local pos2 = vim.fn.getpos('.')\n+  if pos1[2] > pos2[2] or (pos1[2] == pos2[2] and pos1[3] > pos2[3]) then\n+    --- @type Range4,Range4\n+    pos1, pos2 = pos2, pos1\n+  end\n+  local range = { pos1[2] - 1, pos1[3] - 1, pos2[2] - 1, pos2[3] }\n+\n+  if range[4] == #vim.fn.getline(range[3] + 1) + 1 then\n+    range[3] = range[3] + 1\n+    range[4] = 0\n+  end\n+\n+  return range\n+end\n+\n+local function get_parent_from_range(range)\n+  local node, parent_chain = get_node(range)\n+\n+  if node == false then\n+    return (assert(parent_chain[1]))\n+  end\n+\n+  if not node then\n+    return\n+  end\n+\n+  if not range_is_same(range, node_range(node)) then\n+    return node\n+  end\n+\n+  node = node_normalize_upp(node, parent_chain)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2835269291",
            "id": 2835269291,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6o_sar",
            "original_commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "original_line": 431,
            "original_position": 431,
            "original_start_line": null,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3834390960,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835269291/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-20T22:00:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835269291",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2835271224"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835271224"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n  node = node_normalize_up(node, parent_chain)\n```",
            "commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "created_at": "2026-02-20T22:00:25Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_upp(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)\n+  local cursor_other_end_of_visual = false\n+\n+  if vim.fn.mode() == 'v' then\n+    local vcol, vrow = vim.fn.col('v'), vim.fn.line('v')\n+    local dcol, dline = vim.fn.col('.'), vim.fn.line('.')\n+    if vrow > dline or (vrow == dline and vcol > dcol) then\n+      cursor_other_end_of_visual = true\n+    end\n+  end\n+\n+  vim.api.nvim_win_set_cursor(0, { rows + 1, cols })\n+  vim.api.nvim_feedkeys(vim.keycode('<C-\\\\><C-n>v'), 'nx', true)\n+\n+  if not pcall(vim.api.nvim_win_set_cursor, 0, { rowe + 1, cole - 1 }) then\n+    vim.api.nvim_win_set_cursor(0, { rowe, #vim.fn.getline(rowe) })\n+  end\n+\n+  if cursor_other_end_of_visual then\n+    vim.api.nvim_feedkeys('o', 'nx', true)\n+  end\n+end\n+\n+--- @return Range4\n+local function get_selection()\n+  local pos1 = vim.fn.getpos('v')\n+  local pos2 = vim.fn.getpos('.')\n+  if pos1[2] > pos2[2] or (pos1[2] == pos2[2] and pos1[3] > pos2[3]) then\n+    --- @type Range4,Range4\n+    pos1, pos2 = pos2, pos1\n+  end\n+  local range = { pos1[2] - 1, pos1[3] - 1, pos2[2] - 1, pos2[3] }\n+\n+  if range[4] == #vim.fn.getline(range[3] + 1) + 1 then\n+    range[3] = range[3] + 1\n+    range[4] = 0\n+  end\n+\n+  return range\n+end\n+\n+local function get_parent_from_range(range)\n+  local node, parent_chain = get_node(range)\n+\n+  if node == false then\n+    return (assert(parent_chain[1]))\n+  end\n+\n+  if not node then\n+    return\n+  end\n+\n+  if not range_is_same(range, node_range(node)) then\n+    return node\n+  end\n+\n+  node = node_normalize_upp(node, parent_chain)\n+\n+  local parent = node_get_parent_no_normalize(node, parent_chain)\n+\n+  if parent then\n+    if\n+      history.bufnr ~= vim.api.nvim_get_current_buf()\n+      or history.changedtick ~= vim.b.changedtick\n+      or history.current_node_id ~= node_id(node)\n+    then\n+      history = {\n+        bufnr = vim.api.nvim_get_current_buf(),\n+        changedtick = vim.b.changedtick,\n+      }\n+    end\n+    table.insert(history, node)\n+    history.current_node_id = node_id(parent)\n+\n+    return parent\n+  end\n+end\n+\n+local function get_child_from_range(range)\n+  local node, alternative_child_nodes = get_node(range)\n+\n+  if node == false then\n+    return (assert(alternative_child_nodes[1]))\n+  end\n+\n+  if not node then\n+    return\n+  end\n+\n+  node = node_normalize_down(node)\n+\n+  if not range_is_same(range, node_range(node)) then\n+    history = {}\n+\n+    local smallest_node = get_node_contained_in_range(range, node)\n+    if smallest_node then\n+      return smallest_node\n+    end\n+\n+    return node\n+  end\n+\n+  if\n+    history.bufnr == vim.api.nvim_get_current_buf()\n+    and history.changedtick == vim.b.changedtick\n+    and history.current_node_id == node_id(node)\n+  then\n+    --- @type vim.treesitter.select.node\n+    local child = table.remove(history)\n+    if child then\n+      history.current_node_id = node_id(child)\n+\n+      return child\n+    end\n+  end\n+  history = {}\n+\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if not node_is_size_0(child) then\n+      return child\n+    end\n+  end\n+\n+  return node\n+end\n+\n+--- @param prev boolean\n+local function get_sibling_from_range(range, prev)\n+  local node, parent_chain = get_node(range)\n+  if not node then\n+    return\n+  end\n+\n+  node = node_normalize_upp(node, parent_chain)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2835271224",
            "id": 2835271224,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6o_s44",
            "original_commit_id": "bcca1c79aa040af19216d24a0525aee3fdde58f8",
            "original_line": 508,
            "original_position": 508,
            "original_start_line": null,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3834390960,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835271224/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-20T22:00:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2835271224",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2836393379"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393379"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n  local srow, scol, erow, ecol = Range.unpack4(range)\n```",
            "commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "created_at": "2026-02-21T17:33:14Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_up(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2836393379",
            "id": 2836393379,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6pD-2j",
            "original_commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "original_line": 375,
            "original_position": 375,
            "original_start_line": null,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3835729107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393379/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-21T17:40:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393379",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2836393700"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393700"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n  vim.api.nvim_win_set_cursor(0, { srow + 1, scol })\n```",
            "commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "created_at": "2026-02-21T17:33:42Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_up(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)\n+  local cursor_other_end_of_visual = false\n+\n+  if vim.fn.mode() == 'v' then\n+    local vcol, vrow = vim.fn.col('v'), vim.fn.line('v')\n+    local dcol, dline = vim.fn.col('.'), vim.fn.line('.')\n+    if vrow > dline or (vrow == dline and vcol > dcol) then\n+      cursor_other_end_of_visual = true\n+    end\n+  end\n+\n+  vim.api.nvim_win_set_cursor(0, { rows + 1, cols })",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2836393700",
            "id": 2836393700,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6pD-7k",
            "original_commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "original_line": 386,
            "original_position": 386,
            "original_start_line": null,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3835729107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393700/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2026-02-21T17:40:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836393700",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2836394224"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836394224"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\n  if not pcall(vim.api.nvim_win_set_cursor, 0, { erow + 1, ecol - 1 }) then\n    vim.api.nvim_win_set_cursor(0, { erow, #vim.fn.getline(erow) })\n```",
            "commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "created_at": "2026-02-21T17:34:28Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_up(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)\n+  local cursor_other_end_of_visual = false\n+\n+  if vim.fn.mode() == 'v' then\n+    local vcol, vrow = vim.fn.col('v'), vim.fn.line('v')\n+    local dcol, dline = vim.fn.col('.'), vim.fn.line('.')\n+    if vrow > dline or (vrow == dline and vcol > dcol) then\n+      cursor_other_end_of_visual = true\n+    end\n+  end\n+\n+  vim.api.nvim_win_set_cursor(0, { rows + 1, cols })\n+  vim.api.nvim_feedkeys(vim.keycode('<C-\\\\><C-n>v'), 'nx', true)\n+\n+  if not pcall(vim.api.nvim_win_set_cursor, 0, { rowe + 1, cole - 1 }) then\n+    vim.api.nvim_win_set_cursor(0, { rowe, #vim.fn.getline(rowe) })",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2836394224",
            "id": 2836394224,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6pD_Dw",
            "original_commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "original_line": 390,
            "original_position": 390,
            "original_start_line": 389,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3835729107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836394224/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-21T17:40:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836394224",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36993#discussion_r2836397395"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36993"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836397395"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "What's `d`? `cline`/`ccol` instead?",
            "commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "created_at": "2026-02-21T17:38:30Z",
            "diff_hunk": "@@ -0,0 +1,583 @@\n+local Range = require('vim.treesitter._range')\n+\n+--- This is (currently only) used for saving what child one is in when doing\n+--- `select_parent` so that if they later `select_child` on the parent-node,\n+--- they get back to the child-node they were in instead of the parents first\n+--- child-node.\n+---\n+--- @type {[integer]:vim.treesitter.select.node,[any]:any}\n+local history = {\n+  --- @type integer?\n+  bufnr = nil,\n+\n+  --- @type integer?\n+  changedtick = nil,\n+\n+  --- @type string?\n+  current_node_id = nil,\n+}\n+\n+--- The reason for a wrapper around `TSNode` is because we need to store the\n+--- information about which tstree-range they are in (as a tstree may be\n+--- disjointed), where region is the return value of\n+--- `TSTree:included_ranges(false)` with next to eachother ranges combined\n+--- (e.g. {{0,0,1,1},{1,1,2,2}} -> {{0,0,2,2}}).\n+---\n+--- @class vim.treesitter.select.node\n+--- @field node TSNode\n+--- @field top vim.treesitter.select.node.top\n+\n+--- @class vim.treesitter.select.node.top: vim.treesitter.select.node\n+--- @field ltree vim.treesitter.LanguageTree\n+--- @field region Range4\n+\n+local M = {}\n+\n+--- @param node vim.treesitter.select.node\n+--- @return string\n+local function node_id(node)\n+  return ('%s:%s'):format(table.concat({ unpack(node.top.region) }, ':'), node.node:id())\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @return Range4?\n+local function range_intersection(r1, r2)\n+  if not Range.intercepts(r1, r2) then\n+    return\n+  end\n+\n+  local rs = Range.cmp_pos.le(r1[1], r1[2], r2[1], r2[2]) and r2 or r1\n+  local re = Range.cmp_pos.ge(r1[3], r1[4], r2[3], r2[4]) and r2 or r1\n+  return { rs[1], rs[2], re[3], re[4] }\n+end\n+\n+--- @param r1 Range4\n+--- @param r2 Range4\n+--- @boolean\n+local function range_is_same(r1, r2)\n+  local srow_1, scol_1, erow_1, ecol_1 = Range.unpack4(r1)\n+  local srow_2, scol_2, erow_2, ecol_2 = Range.unpack4(r2)\n+  return srow_1 == srow_2 and scol_1 == scol_2 and erow_1 == erow_2 and ecol_1 == ecol_2\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return Range4\n+local function node_range(node)\n+  local node_range_ = { node.node:range() }\n+\n+  return range_intersection(node.top.region, node_range_) or { 0, 0, 0, 0 }\n+end\n+\n+--- @param node1 vim.treesitter.select.node\n+--- @param node2 vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_same_range(node1, node2)\n+  return range_is_same(node_range(node1), node_range(node2))\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return boolean\n+local function node_is_size_0(node)\n+  local srow, scol, erow, ecol = Range.unpack4(node_range(node))\n+  return srow == erow and scol == ecol\n+end\n+\n+--- @param tsnode TSNode\n+--- @param relative vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function create_node(tsnode, relative)\n+  assert(tsnode:tree():root():equal(relative.top.node))\n+\n+  --- @type vim.treesitter.select.node\n+  return {\n+    node = tsnode,\n+    top = relative.top,\n+  }\n+end\n+\n+--- @param tree TSTree\n+--- @return Range4[]\n+local function tree_get_ranges(tree)\n+  --- @type Range4[]\n+  local regions = {}\n+  for _, tree_range in ipairs(tree:included_ranges(false)) do\n+    local prev_region = regions[#regions]\n+\n+    if prev_region and prev_region[3] == tree_range[1] and prev_region[4] == tree_range[2] then\n+      regions[#regions] = { prev_region[1], prev_region[2], tree_range[3], tree_range[4] }\n+    else\n+      table.insert(regions, tree_range)\n+    end\n+  end\n+  return regions\n+end\n+\n+--- @param tree TSTree\n+--- @param region Range4\n+--- @param ltree vim.treesitter.LanguageTree\n+--- @return vim.treesitter.select.node.top\n+local function create_top_node(tree, region, ltree)\n+  --- @type vim.treesitter.select.node.top\n+  local self = {\n+    node = tree:root(),\n+    top = {} --[[@as any]],\n+    ltree = ltree,\n+    region = region,\n+  }\n+  self.top = self\n+  return self\n+end\n+\n+--- @param node1 vim.treesitter.select.node.top\n+--- @param node2 vim.treesitter.select.node.top\n+--- @return boolean\n+local function top_node_is_higher_priority(node1, node2)\n+  local srow1, scol1, erow1, ecol1 = Range.unpack4(node_range(node1))\n+  local srow2, scol2, erow2, ecol2 = Range.unpack4(node_range(node2))\n+\n+  if M.TEST_SWITCH_PRIORITY then\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.lt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.lt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() > node2.ltree:lang()\n+    end\n+    return node1.node:id() > node2.node:id()\n+  else\n+    if Range.cmp_pos.ne(srow1, scol1, srow2, scol2) then\n+      return Range.cmp_pos.gt(srow1, scol1, srow2, scol2)\n+    elseif Range.cmp_pos.ne(erow1, ecol1, erow2, ecol2) then\n+      return Range.cmp_pos.gt(erow1, ecol1, erow2, ecol2)\n+    elseif node1.ltree:lang() ~= node2.ltree:lang() then\n+      return node1.ltree:lang() < node2.ltree:lang()\n+    end\n+    return node1.node:id() < node2.node:id()\n+  end\n+end\n+\n+--- @param range Range4\n+--- @param top_node vim.treesitter.select.node.top?\n+--- @param parent_chain vim.treesitter.select.node[]?\n+--- @return vim.treesitter.select.node|false|nil nil: no parser, false: outside of root-node\n+--- @return vim.treesitter.select.node[] either `parent_chain` or `alternative_nodes`\n+local function get_node(range, top_node, parent_chain)\n+  parent_chain = parent_chain or {}\n+\n+  if not top_node then\n+    local parser = vim.treesitter.get_parser(nil, nil, { error = false })\n+    if not parser then\n+      return nil, {}\n+    end\n+\n+    local tree = assert(parser:parse(range))[1]\n+    top_node = create_top_node(tree, assert(tree:included_ranges(false)[1]), parser)\n+\n+    if not Range.contains(node_range(top_node), range) then\n+      return false, { top_node } --[[alternative_nodes]]\n+    end\n+  end\n+\n+  assert(Range.contains(node_range(top_node), range))\n+\n+  --- @param node vim.treesitter.select.node|vim.treesitter.select.node.top\n+  --- @return vim.treesitter.select.node|vim.treesitter.select.node.top\n+  local function node_ignore_overlapped_handle_injection(node)\n+    for _, child in pairs(top_node.ltree:children()) do\n+      for _, child_tree in ipairs(child:trees()) do\n+        for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+          local child_root_node_range = { child_tree:root():range() }\n+          local child_range = range_intersection(child_region, child_root_node_range)\n+\n+          local child_top_node = create_top_node(child_tree, child_region, child)\n+          if\n+            child_range\n+            and Range.contains(child_range, range)\n+            and (\n+              not node.ltree\n+              or top_node_is_higher_priority(\n+                node --[[@as vim.treesitter.select.node.top]],\n+                child_top_node\n+              )\n+            )\n+          then\n+            return node_ignore_overlapped_handle_injection(child_top_node)\n+          elseif child_range and Range.intercepts(node_range(node), child_range) then\n+            local child_parent_tsnode =\n+              assert(top_node.node:named_descendant_for_range(unpack(child_range)))\n+\n+            if\n+              (not node.ltree and vim.treesitter.is_ancestor(child_parent_tsnode, node.node))\n+              or (\n+                node.ltree\n+                and top_node_is_higher_priority(\n+                  node --[[@as vim.treesitter.select.node.top]],\n+                  child_top_node\n+                )\n+              )\n+            then\n+              return create_node(child_parent_tsnode, top_node)\n+            end\n+          end\n+        end\n+      end\n+    end\n+\n+    return node\n+  end\n+\n+  local tsnode = assert(top_node.node:named_descendant_for_range(unpack(range)))\n+  local node = create_node(tsnode, top_node)\n+\n+  node = node_ignore_overlapped_handle_injection(node)\n+  if node.ltree then\n+    local root_node_range = { node.node:range() }\n+    local tree_range = node.top.region\n+    local actual_range = assert(range_intersection(tree_range, root_node_range))\n+    local parent_tsnode = assert(top_node.node:named_descendant_for_range(unpack(actual_range)))\n+    table.insert(parent_chain, create_node(parent_tsnode, top_node))\n+\n+    --- @cast node vim.treesitter.select.node.top\n+    return get_node(range, node, parent_chain), parent_chain\n+  end\n+  --- @cast node vim.treesitter.select.node\n+\n+  return node, parent_chain\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @param parent_chain vim.treesitter.select.node[]\n+--- @nodiscard\n+--- @return vim.treesitter.select.node?\n+--- @return vim.treesitter.select.node.top?\n+local function node_get_parent_no_normalize(node, parent_chain)\n+  local parent = node.node:parent()\n+  if parent then\n+    return create_node(parent, node)\n+  end\n+\n+  return table.remove(parent_chain)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_up(node, parent_chain)\n+  while true do\n+    local parent = node_get_parent_no_normalize(node, parent_chain)\n+    if parent and node_is_same_range(parent, node) then\n+      node = parent\n+    else\n+      table.insert(parent_chain, parent)\n+\n+      return node\n+    end\n+  end\n+  --- @diagnostic disable-next-line: missing-return\n+end\n+\n+--- @param nodes vim.treesitter.select.node[]\n+--- @param node vim.treesitter.select.node.top\n+local function insert_remove_overlapped(nodes, node)\n+  local n = 1\n+  while nodes[n] do\n+    if Range.intercepts(node_range(nodes[n]), node_range(node)) then\n+      if\n+        not nodes\n+          [n] --[[@as any]]\n+          .ltree\n+        or top_node_is_higher_priority(nodes[n] --[[@as vim.treesitter.select.node.top]], node)\n+      then\n+        table.remove(nodes, n)\n+      else\n+        return\n+      end\n+    else\n+      local nrow, ncol, _, _ = Range.unpack4(node_range(nodes[n]))\n+      local _, _, erow, ecol = Range.unpack4(node_range(node))\n+      if Range.cmp_pos.le(erow, ecol, nrow, ncol) then\n+        table.insert(nodes, n, node)\n+        return\n+      end\n+\n+      n = n + 1\n+    end\n+  end\n+\n+  table.insert(nodes, node)\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node[]\n+local function node_get_children_no_normalize(node)\n+  --- @param child_ TSNode\n+  --- @return vim.treesitter.select.node\n+  local children = vim.tbl_map(function(child_)\n+    return create_node(child_, node)\n+  end, node.node:named_children())\n+\n+  node.top.ltree:parse(node_range(node))\n+\n+  for _, child in pairs(node.top.ltree:children()) do\n+    for _, child_tree in ipairs(child:trees()) do\n+      for _, child_region in ipairs(tree_get_ranges(child_tree)) do\n+        local child_root_node_range = { child_tree:root():range() }\n+        local child_range = range_intersection(child_region, child_root_node_range)\n+\n+        if child_range and Range.contains(node_range(node), child_range) then\n+          local child_parent_tsnode =\n+            assert(node.top.node:named_descendant_for_range(unpack(child_range)))\n+\n+          if node.node:equal(child_parent_tsnode) then\n+            local child_node = create_top_node(child_tree, child_region, child)\n+\n+            insert_remove_overlapped(children, child_node)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  return children\n+end\n+\n+--- @param range Range4\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node?\n+local function get_node_contained_in_range(range, node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if Range.contains(range, node_range(child)) and not node_is_size_0(child) then\n+      return child\n+    elseif Range.intercepts(range, node_range(child)) and not node_is_size_0(child) then\n+      local smallest_node = get_node_contained_in_range(range, child)\n+\n+      if smallest_node then\n+        return smallest_node\n+      end\n+    end\n+  end\n+end\n+\n+--- @param node vim.treesitter.select.node\n+--- @return vim.treesitter.select.node\n+local function node_normalize_down(node)\n+  for _, child in ipairs(node_get_children_no_normalize(node)) do\n+    if node_is_same_range(node, child) then\n+      return node_normalize_down(child)\n+    end\n+  end\n+\n+  return node\n+end\n+\n+local function visual_select(range)\n+  assert(type(range) == 'table')\n+  local rows, cols, rowe, cole = Range.unpack4(range)\n+  local cursor_other_end_of_visual = false\n+\n+  if vim.fn.mode() == 'v' then\n+    local vcol, vrow = vim.fn.col('v'), vim.fn.line('v')\n+    local dcol, dline = vim.fn.col('.'), vim.fn.line('.')\n+    if vrow > dline or (vrow == dline and vcol > dcol) then",
            "html_url": "https://github.com/neovim/neovim/pull/36993#discussion_r2836397395",
            "id": 2836397395,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6pD_1T",
            "original_commit_id": "9fbba3d12e1ef02861893564a9a720786e9920db",
            "original_line": 381,
            "original_position": 381,
            "original_start_line": 380,
            "path": "runtime/lua/vim/treesitter/_select.lua",
            "position": 1,
            "pull_request_review_id": 3835729107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836397395/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2026-02-21T17:40:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2836397395",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "> Better injection handling (don't full-parse the whole thing)\r\n\r\nFor the MVP (first implementation), we could just restrict to the top-level tree (so injected code is selected as a single node, which would be useful in many situations already).\r\n\r\nPossible future additions:\r\n*  we might wish to also add selection for locals `@scope` (TBD).\r\n* can these be (additionally) exposed through text objects, for count and general motions? (might be an option for next/previous node)",
            "created_at": "2025-12-16T16:25:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3661382379",
            "id": 3661382379,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7aPELr",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3661382379/reactions"
            },
            "updated_at": "2025-12-16T16:40:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3661382379",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "What about [n and ]n for previous and next node? They don't currently have a default in Neovim (though Unimpaired uses them for context). \r\n\r\nThis opens up ideas like [N and ]N for first and last node in the current level, as well as [Ctrl-n and ]Ctrl-n for some other mapping.\r\n\r\nAlso wondering about the fallback for child node selection. I put the module into my config and played around with it. Let's say I have this code block:\r\n\r\n```lua\r\nvim.keymap.set({ \"x\", \"o\" }, \"in\", function()\r\n    if vim.treesitter.get_parser(nil, nil, { error = false }) then\r\n        for _ = 1, vim.v.count1 do\r\n            require(\"nvim-incselect\").select_child()\r\n        end\r\n    else\r\n        vim.lsp.buf.selection_range(-vim.v.count1)\r\n    end\r\nend, { desc = \"Select child treesitter node or inner incremental lsp selections\" })\r\n```\r\n\r\nI make a charwise visual selection from the c in the first count1 to the c at the end of desc, then press ``in``. The selection will jump to ``{\"x\", \"o\"}``. \r\n\r\nOr if I start at the r in ``require`` and go to the closing paren at the end of ``(-vim.v.count1)``, the selection will go to ``vim.treesitter.get_parser(nil, nil, { error = false })``\r\n\r\nSince ``an`` on an un-fitted visual selection selects the smallest node that wholly contains the visual selection, it seems like ``in`` on an un-fitted visual selection should select the first or biggest node that is wholly within the visual selection. Or, if that's not possible, fall back to the parent behavior (giving more consistent feedback to the user if their selection is not in a node).\r\n\r\nIf this fallback behavior were added to ``in``, it might also  remove the need for the grN mapping, since the user could press ``vin`` anywhere from normal mode and get the smallest fitted selection.",
            "created_at": "2025-12-19T05:16:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3673573551",
            "id": 3673573551,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7a9kiv",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3673573551/reactions"
            },
            "updated_at": "2025-12-19T06:46:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3673573551",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62523234?v=4",
                "events_url": "https://api.github.com/users/mikejmcguirk/events{/privacy}",
                "followers_url": "https://api.github.com/users/mikejmcguirk/followers",
                "following_url": "https://api.github.com/users/mikejmcguirk/following{/other_user}",
                "gists_url": "https://api.github.com/users/mikejmcguirk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mikejmcguirk",
                "id": 62523234,
                "login": "mikejmcguirk",
                "node_id": "MDQ6VXNlcjYyNTIzMjM0",
                "organizations_url": "https://api.github.com/users/mikejmcguirk/orgs",
                "received_events_url": "https://api.github.com/users/mikejmcguirk/received_events",
                "repos_url": "https://api.github.com/users/mikejmcguirk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mikejmcguirk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mikejmcguirk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mikejmcguirk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "The updated ``vin`` behavior feels really good.\r\n\r\nShouldn't the [n and ]n mappings should be the other way around though?",
            "created_at": "2025-12-20T03:55:35Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3677344192",
            "id": 3677344192,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7bL9HA",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3677344192/reactions"
            },
            "updated_at": "2025-12-20T03:55:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3677344192",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62523234?v=4",
                "events_url": "https://api.github.com/users/mikejmcguirk/events{/privacy}",
                "followers_url": "https://api.github.com/users/mikejmcguirk/followers",
                "following_url": "https://api.github.com/users/mikejmcguirk/following{/other_user}",
                "gists_url": "https://api.github.com/users/mikejmcguirk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mikejmcguirk",
                "id": 62523234,
                "login": "mikejmcguirk",
                "node_id": "MDQ6VXNlcjYyNTIzMjM0",
                "organizations_url": "https://api.github.com/users/mikejmcguirk/orgs",
                "received_events_url": "https://api.github.com/users/mikejmcguirk/received_events",
                "repos_url": "https://api.github.com/users/mikejmcguirk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mikejmcguirk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mikejmcguirk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mikejmcguirk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@altermo I assume this is ready for review? Can you comment on why you went with the Helix implementation instead of porting the nvim-treesitter module (which is significantly smaller)? What are the differences (advantages)?\r\n\r\nAlso, can the local cache (`history`) be replaced with `vim._memoize`? If not, why not?",
            "created_at": "2026-01-08T11:33:33Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3723462792",
            "id": 3723462792,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d74iI",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723462792/reactions"
            },
            "updated_at": "2026-01-08T11:33:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723462792",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "It is ready for review.\r\n\r\nTo _my knowledge_ there is no difference: I have never used the nvim-treesitter module, while I know mostly how helix's works, so I went with what I know... (most of the code is not part of helix's implementation, and if I went with only helix's then it would probably be the same length as the nvim-treesitter module)\r\n\r\n`history` is not for cache, but instead for QoL: if you goto parent and then goto child, get back to the child you were on instead of the parents first child (though this Qol could be considered to disruptive).",
            "created_at": "2026-01-08T12:43:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3723710129",
            "id": 3723710129,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d806x",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723710129/reactions"
            },
            "updated_at": "2026-01-08T12:43:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723710129",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Well, the point is that nvim-treesitter has no special handling of injected trees, so I'm curious why/how this is needed here.\r\n\r\nPersonally, I would prefer for the first implementation to be as minimal as possible, and then to add improvements incrementally if and when they are (reasonably) requested. In any case, this \"QoL\" behavior should be documented, both in the code and as a note in the docs. This is very important for future maintenance (see \"Chesterton's Fence\").",
            "created_at": "2026-01-08T13:33:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3723903155",
            "id": 3723903155,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d9kCz",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723903155/reactions"
            },
            "updated_at": "2026-01-08T13:33:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3723903155",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Because of markdown, as it uses `injection.combined` for html (which include `<!-- -->`). (and other places, but it was in markdown where if the text contained two far apart comments, then the incremental selection broke.)\r\nI thought about not having injections working at all, but that would cause problems in markdown (because of `markdown_inline`). (and other places...)\r\n(So basically, if the implementation was minimal, then I would _bug_|_fix_ about it not having injection handling, and if the injection handling was minimal, then I would _bug_|_fix_ about markdown being broken...)",
            "created_at": "2026-01-08T14:46:13Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3724203378",
            "id": 3724203378,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d-tVy",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724203378/reactions"
            },
            "updated_at": "2026-01-08T14:46:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724203378",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "And this didn't work in nvim-treesitter's implementation? (If it didn't, I wonder why there haven't been any issue reports about this...)",
            "created_at": "2026-01-08T14:49:59Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3724219432",
            "id": 3724219432,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d-xQo",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724219432/reactions"
            },
            "updated_at": "2026-01-08T14:49:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724219432",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "After looking through the implementation, I realized that it's not at all like helix's at all: it only actually implement select-parent, and select-child is just select previous selection (so for example running select-child(`node_decremental`) alone does nothing), and select-parent mostly works fine when there are disjointed trees.",
            "created_at": "2026-01-08T15:10:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3724308532",
            "id": 3724308532,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d_HA0",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724308532/reactions"
            },
            "updated_at": "2026-01-08T15:10:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724308532",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Thank you, that is helpful (and the reason I kept asking). Then the added complexity seems worth it.",
            "created_at": "2026-01-08T15:17:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3724342520",
            "id": 3724342520,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7d_PT4",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724342520/reactions"
            },
            "updated_at": "2026-01-08T15:17:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3724342520",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "As this is mostly a treesitter feat, wouldn't it be better to place this under `runtime/lua/vim/treesitter` instead of a \"top-level\" private module in `runtime/lua/vim`?",
            "created_at": "2026-01-09T00:30:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3726535207",
            "id": 3726535207,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7eHmon",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3726535207/reactions"
            },
            "updated_at": "2026-01-09T00:30:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3726535207",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/23235841?v=4",
                "events_url": "https://api.github.com/users/yochem/events{/privacy}",
                "followers_url": "https://api.github.com/users/yochem/followers",
                "following_url": "https://api.github.com/users/yochem/following{/other_user}",
                "gists_url": "https://api.github.com/users/yochem/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/yochem",
                "id": 23235841,
                "login": "yochem",
                "node_id": "MDQ6VXNlcjIzMjM1ODQx",
                "organizations_url": "https://api.github.com/users/yochem/orgs",
                "received_events_url": "https://api.github.com/users/yochem/received_events",
                "repos_url": "https://api.github.com/users/yochem/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/yochem/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/yochem/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/yochem",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "You can just name it `_select` then (or `incremental_selection`).",
            "created_at": "2026-01-09T09:06:54Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3727946401",
            "id": 3727946401,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7eM_Kh",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3727946401/reactions"
            },
            "updated_at": "2026-01-09T09:06:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3727946401",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@justinmk I think this is a valuable (and self-contained) feature that would be nice to have for 0.12, and I'm happy with the implementation, but I won't merge this until you've had a chance to review the API.",
            "created_at": "2026-02-03T10:30:58Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3840482486",
            "id": 3840482486,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7k6Ry2",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3840482486/reactions"
            },
            "updated_at": "2026-02-03T17:13:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3840482486",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@justinmk friendly ping to make sure this is on your radar.",
            "created_at": "2026-02-18T11:23:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3920257819",
            "id": 3920257819,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7pqmMb",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3920257819/reactions"
            },
            "updated_at": "2026-02-18T11:23:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3920257819",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "It would be much cleaner to move the count logic from the key mappings to `_select.lua`, and call `visual_selection()`, with all its side-effects, only once. The current implementation would e.g. pollute [visual history](https://github.com/neovim/neovim/issues/22587), if ever added.",
            "created_at": "2026-02-18T20:46:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/36993#issuecomment-3923125533",
            "id": 3923125533,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
            "node_id": "IC_kwDOAPphoM7p1iUd",
            "performed_via_github_app": null,
            "pin": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3923125533/reactions"
            },
            "updated_at": "2026-02-18T20:56:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3923125533",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/17800844?v=4",
                "events_url": "https://api.github.com/users/ggandor/events{/privacy}",
                "followers_url": "https://api.github.com/users/ggandor/followers",
                "following_url": "https://api.github.com/users/ggandor/following{/other_user}",
                "gists_url": "https://api.github.com/users/ggandor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ggandor",
                "id": 17800844,
                "login": "ggandor",
                "node_id": "MDQ6VXNlcjE3ODAwODQ0",
                "organizations_url": "https://api.github.com/users/ggandor/orgs",
                "received_events_url": "https://api.github.com/users/ggandor/received_events",
                "repos_url": "https://api.github.com/users/ggandor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ggandor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ggandor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ggandor",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/36993/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/36993/commits",
    "created_at": "2025-12-16T12:28:41Z",
    "diff_url": "https://github.com/neovim/neovim/pull/36993.diff",
    "draft": false,
    "head": {
        "label": "altermo:treeincsel",
        "ref": "treeincsel",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/altermo/neovim-fork/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/altermo/neovim-fork/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/altermo/neovim-fork/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/altermo/neovim-fork/branches{/branch}",
            "clone_url": "https://github.com/altermo/neovim-fork.git",
            "collaborators_url": "https://api.github.com/repos/altermo/neovim-fork/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/altermo/neovim-fork/comments{/number}",
            "commits_url": "https://api.github.com/repos/altermo/neovim-fork/commits{/sha}",
            "compare_url": "https://api.github.com/repos/altermo/neovim-fork/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/altermo/neovim-fork/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/altermo/neovim-fork/contributors",
            "created_at": "2023-09-13T06:55:17Z",
            "default_branch": "DONT-USE-THIS-AS-SOURCE-WHEN-CREATING-NEW-BRANCH",
            "deployments_url": "https://api.github.com/repos/altermo/neovim-fork/deployments",
            "description": null,
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/altermo/neovim-fork/downloads",
            "events_url": "https://api.github.com/repos/altermo/neovim-fork/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/altermo/neovim-fork/forks",
            "full_name": "altermo/neovim-fork",
            "git_commits_url": "https://api.github.com/repos/altermo/neovim-fork/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/altermo/neovim-fork/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/altermo/neovim-fork/git/tags{/sha}",
            "git_url": "git://github.com/altermo/neovim-fork.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_pull_requests": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/altermo/neovim-fork/hooks",
            "html_url": "https://github.com/altermo/neovim-fork",
            "id": 690927347,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/altermo/neovim-fork/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/altermo/neovim-fork/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/altermo/neovim-fork/issues{/number}",
            "keys_url": "https://api.github.com/repos/altermo/neovim-fork/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/altermo/neovim-fork/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/altermo/neovim-fork/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/altermo/neovim-fork/merges",
            "milestones_url": "https://api.github.com/repos/altermo/neovim-fork/milestones{/number}",
            "mirror_url": null,
            "name": "neovim-fork",
            "node_id": "R_kgDOKS628w",
            "notifications_url": "https://api.github.com/repos/altermo/neovim-fork/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo",
                "user_view_type": "public"
            },
            "private": false,
            "pull_request_creation_policy": "all",
            "pulls_url": "https://api.github.com/repos/altermo/neovim-fork/pulls{/number}",
            "pushed_at": "2026-02-22T01:57:07Z",
            "releases_url": "https://api.github.com/repos/altermo/neovim-fork/releases{/id}",
            "size": 356966,
            "ssh_url": "git@github.com:altermo/neovim-fork.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/altermo/neovim-fork/stargazers",
            "statuses_url": "https://api.github.com/repos/altermo/neovim-fork/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/altermo/neovim-fork/subscribers",
            "subscription_url": "https://api.github.com/repos/altermo/neovim-fork/subscription",
            "svn_url": "https://github.com/altermo/neovim-fork",
            "tags_url": "https://api.github.com/repos/altermo/neovim-fork/tags",
            "teams_url": "https://api.github.com/repos/altermo/neovim-fork/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/altermo/neovim-fork/git/trees{/sha}",
            "updated_at": "2024-08-28T08:54:17Z",
            "url": "https://api.github.com/repos/altermo/neovim-fork",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "334624a08e6c97f67f3941cbd63a5a837fd28686",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
            "events_url": "https://api.github.com/users/altermo/events{/privacy}",
            "followers_url": "https://api.github.com/users/altermo/followers",
            "following_url": "https://api.github.com/users/altermo/following{/other_user}",
            "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/altermo",
            "id": 107814000,
            "login": "altermo",
            "node_id": "U_kgDOBm0ccA",
            "organizations_url": "https://api.github.com/users/altermo/orgs",
            "received_events_url": "https://api.github.com/users/altermo/received_events",
            "repos_url": "https://api.github.com/users/altermo/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/altermo",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/36993",
    "id": 3106166402,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36993",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "Nvim defaults for options, colorscheme/theme, autocmds/events, etc.",
            "id": 103777064,
            "name": "defaults",
            "node_id": "MDU6TGFiZWwxMDM3NzcwNjQ=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/defaults"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": "",
            "id": 1799626557,
            "name": "treesitter",
            "node_id": "MDU6TGFiZWwxNzk5NjI2NTU3",
            "url": "https://api.github.com/repos/neovim/neovim/labels/treesitter"
        }
    ],
    "locked": false,
    "merge_commit_sha": "cde5181694a2931b5c932c77eded780562fa9abc",
    "merged_at": null,
    "milestone": {
        "closed_at": null,
        "closed_issues": 258,
        "created_at": "2024-05-16T14:11:54Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
            "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
            "followers_url": "https://api.github.com/users/justinmk/followers",
            "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
            "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/justinmk",
            "id": 1359421,
            "login": "justinmk",
            "node_id": "MDQ6VXNlcjEzNTk0MjE=",
            "organizations_url": "https://api.github.com/users/justinmk/orgs",
            "received_events_url": "https://api.github.com/users/justinmk/received_events",
            "repos_url": "https://api.github.com/users/justinmk/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/justinmk",
            "user_view_type": "public"
        },
        "description": "",
        "due_on": "2026-03-14T00:00:00Z",
        "html_url": "https://github.com/neovim/neovim/milestone/43",
        "id": 11063573,
        "labels_url": "https://api.github.com/repos/neovim/neovim/milestones/43/labels",
        "node_id": "MI_kwDOAPphoM4AqNEV",
        "number": 43,
        "open_issues": 51,
        "state": "open",
        "title": "0.12",
        "updated_at": "2026-02-23T14:54:57Z",
        "url": "https://api.github.com/repos/neovim/neovim/milestones/43"
    },
    "node_id": "PR_kwDOAPphoM65JFaC",
    "number": 36993,
    "patch_url": "https://github.com/neovim/neovim/pull/36993.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
            "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
            "followers_url": "https://api.github.com/users/bfredl/followers",
            "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
            "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/bfredl",
            "id": 1363104,
            "login": "bfredl",
            "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
            "organizations_url": "https://api.github.com/users/bfredl/orgs",
            "received_events_url": "https://api.github.com/users/bfredl/received_events",
            "repos_url": "https://api.github.com/users/bfredl/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/bfredl",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
            "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
            "followers_url": "https://api.github.com/users/gpanders/followers",
            "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
            "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/gpanders",
            "id": 8965202,
            "login": "gpanders",
            "node_id": "MDQ6VXNlcjg5NjUyMDI=",
            "organizations_url": "https://api.github.com/users/gpanders/orgs",
            "received_events_url": "https://api.github.com/users/gpanders/received_events",
            "repos_url": "https://api.github.com/users/gpanders/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/gpanders",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
            "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
            "followers_url": "https://api.github.com/users/lewis6991/followers",
            "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
            "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/lewis6991",
            "id": 7904185,
            "login": "lewis6991",
            "node_id": "MDQ6VXNlcjc5MDQxODU=",
            "organizations_url": "https://api.github.com/users/lewis6991/orgs",
            "received_events_url": "https://api.github.com/users/lewis6991/received_events",
            "repos_url": "https://api.github.com/users/lewis6991/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/lewis6991",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
            "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
            "followers_url": "https://api.github.com/users/ribru17/followers",
            "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
            "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ribru17",
            "id": 55766287,
            "login": "ribru17",
            "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
            "organizations_url": "https://api.github.com/users/ribru17/orgs",
            "received_events_url": "https://api.github.com/users/ribru17/received_events",
            "repos_url": "https://api.github.com/users/ribru17/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ribru17",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
            "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
            "followers_url": "https://api.github.com/users/wookayin/followers",
            "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
            "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/wookayin",
            "id": 1009873,
            "login": "wookayin",
            "node_id": "MDQ6VXNlcjEwMDk4NzM=",
            "organizations_url": "https://api.github.com/users/wookayin/orgs",
            "received_events_url": "https://api.github.com/users/wookayin/received_events",
            "repos_url": "https://api.github.com/users/wookayin/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/wookayin",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/36993/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/334624a08e6c97f67f3941cbd63a5a837fd28686",
    "title": "feat(treesitter): incremental selection",
    "updated_at": "2026-02-22T01:57:09Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/36993",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
        "events_url": "https://api.github.com/users/altermo/events{/privacy}",
        "followers_url": "https://api.github.com/users/altermo/followers",
        "following_url": "https://api.github.com/users/altermo/following{/other_user}",
        "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/altermo",
        "id": 107814000,
        "login": "altermo",
        "node_id": "U_kgDOBm0ccA",
        "organizations_url": "https://api.github.com/users/altermo/orgs",
        "received_events_url": "https://api.github.com/users/altermo/received_events",
        "repos_url": "https://api.github.com/users/altermo/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/altermo",
        "user_view_type": "public"
    }
}