{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/27097/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27097/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/27097"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/27097"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27097/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/08e4d99e5dec99e3f7c965ba0a5915601842ea26"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5189,
            "forks_count": 5189,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1744,
            "open_issues_count": 1744,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-02-06T01:17:01Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 252434,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 73474,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-02-06T00:27:03Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 73474,
            "watchers_count": 73474,
            "web_commit_signoff_required": false
        },
        "sha": "cc197d04fc36a6ee4219f20772a7b39dd976edfd",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "**The reasoning behind the rewrite**\r\n1. Some neovim-specific decorations (mainly extmarks and treesitter) don't get handled by TOhtml.vim.\r\n2. TOhtml.vim is written in Vim script, and to not make it slow, they needed to write some hard-to-understand code, and lua is so much faster, that there is not much need to use magic to write fast code.\r\n3. TOhtml.vim is not updated that often (typically once every few years) so there's no need to worry about rewriting every new feature of TOhtml.vim in lua.\r\n\r\n**What this rewrite is not**\r\nAs @clason described, this rewrite needs not to be a full rewrite of `TOhtml.vim` (with all the features), so it is not.\r\n\r\n**What this rewrite is**\r\nThis rewrite has the purpose of creating a plugin which can convert a vim window with all it's decorations to html.\r\n\r\n**The visual things that still don't work**\r\n+ LSP semantic tokens that are not on the screen\r\n+ Highlighted folds\r\n+ More complex internal statuscol (number+relativenumer+{foldcolumn or signcolumn})\r\n+ Right aligned extmarks\r\n+ Extmarks' hl_mode\r\n+ Spell\r\n+ Priority for specific decorations\r\n+ Less used highlight attributes (font, special color, reverse, underdouble, blend, ...)\r\n\r\nRelated:\r\n+ https://github.com/neovim/neovim/issues/21629",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1460359266"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460359266"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think it's end_row + 1 here. Treesitter range is end-exclusive",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-20T10:36:03Z",
            "diff_hunk": "@@ -0,0 +1,473 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'\n+\n+---@class tohtml.state\n+---@field bufnr number\n+---@field background string\n+---@field foreground string\n+---@field title string|false\n+---@field start_row number\n+---@field end_row number\n+---@field use_css boolean\n+---@field font string\n+---@class tohtml.opt\n+---@field title? string|false\n+---@field start_row? number\n+---@field end_row? number\n+---@field use_css? boolean\n+---@class tohtml.styletable\n+---@field highlights table<number,tohtml.highlight>\n+---@field [number] tohtml.line\n+---@class tohtml.line\n+---@field [number] tohtml.cell?\n+---@class tohtml.cell\n+---@field [1]   number[] start\n+---@field [2]   number[] close\n+---@field [3] string[][] virt_text\n+---@field [4]   number[] hide\n+---@class tohtml.highlight\n+---@field bold? boolean\n+---@field italic? boolean\n+---@field underline? boolean\n+---@field color? {fg:string?,bg:string?}\n+---@field name? string\n+\n+local M = {}\n+---@param tbl table<''|any,nil|any>\n+---@return table<''|any,any>\n+function M.trim(tbl)\n+  for k, v in pairs(tbl) do\n+    if v == '' then\n+      tbl[k] = nil\n+    end\n+  end\n+  return tbl\n+end\n+---@generic T\n+---@param tbl table<T,table|nil>\n+---@param key T\n+---@return table\n+function M.fill(tbl, key)\n+  if tbl[key] == nil then\n+    tbl[key] = { {}, {}, {}, {} }\n+  end\n+  return tbl[key]\n+end\n+---@param state tohtml.state\n+---@return tohtml.styletable\n+function M.generate_styletable(state)\n+  ---@type tohtml.styletable\n+  local styletable = { highlights = {} }\n+  for row = 1, state.end_row + 1 do\n+    styletable[row] = {}\n+  end\n+  return styletable\n+end\n+---@param styletable tohtml.styletable\n+---@param id number\n+---@param state tohtml.state\n+function M.extend_highlight(styletable, id, state)\n+  if styletable.highlights[id] then\n+    return\n+  end\n+  if not state.use_css then\n+    styletable.highlights[id] = M.trim({\n+      color = M.trim({\n+        fg = vim.fn.synIDattr(id, 'fg#'),\n+        bg = vim.fn.synIDattr(id, 'bg#'),\n+      }),\n+      underline = vim.fn.synIDattr(id, 'underline'),\n+      bold = vim.fn.synIDattr(id, 'bold'),\n+      italic = vim.fn.synIDattr(id, 'italic'),\n+    })\n+  else\n+    styletable.highlights[id] = {\n+      name = vim.fn.synIDattr(id, 'name'),\n+    }\n+  end\n+end\n+---@param styletable tohtml.styletable\n+---@param state tohtml.state\n+function M.styletable_syntax(styletable, state)\n+  local bufnr = state.bufnr\n+  vim.api.nvim_buf_call(bufnr, function()\n+    local start_row = state.start_row\n+    for row_offset, line in ipairs(styletable) do\n+      row_offset = row_offset - 1\n+      local prev_id = 0\n+      for col = 1, #line - 1 do\n+        local id = vim.fn.synID(start_row + row_offset, col, 1)\n+        id = vim.fn.synIDtrans(id)\n+        if id ~= prev_id then\n+          if prev_id ~= 0 then\n+            table.insert(line[col][2], prev_id)\n+          end\n+          prev_id = id\n+          if id ~= 0 then\n+            M.extend_highlight(styletable, id, state)\n+            table.insert(M.fill(line, col)[1], id)\n+          end\n+        end\n+      end\n+      if prev_id ~= 0 then\n+        table.insert(M.fill(line, #line)[2], prev_id)\n+      end\n+    end\n+  end)\n+end\n+---@param styletable tohtml.styletable\n+---@param state tohtml.state\n+function M.styletable_treesitter(styletable, state)\n+  ---TODO(altermo) get highlighted of injected trees after, which have not been on screen\n+  local bufnr = state.bufnr\n+  ---@diagnostic disable-next-line: undefined-field\n+  local buf_highlighter = vim.treesitter.highlighter.active[bufnr]\n+  if not buf_highlighter then\n+    return\n+  end\n+  local start_row = state.start_row - 1\n+  local end_row = state.end_row - 1\n+  buf_highlighter.tree:for_each_tree(function(tstree, tree)\n+    ---@cast tree LanguageTree\n+    if not tstree then\n+      return\n+    end\n+    local root = tstree:root()\n+    local q = buf_highlighter:get_query(tree:lang())\n+    ---@type Query?\n+    local query = q:query()\n+    if not query then\n+      return\n+    end\n+    for capture, node, metadata in\n+      query:iter_captures(root, buf_highlighter.bufnr, start_row, end_row)",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1460359266",
            "id": 1460359266,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XC1Bi",
            "original_commit_id": "e5fa93384b138595a7c2daeb29aa11522a5666ff",
            "original_line": 147,
            "original_position": 147,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1834657487,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460359266/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-20T10:41:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460359266",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/29790821?v=4",
                "events_url": "https://api.github.com/users/lucario387/events{/privacy}",
                "followers_url": "https://api.github.com/users/lucario387/followers",
                "following_url": "https://api.github.com/users/lucario387/following{/other_user}",
                "gists_url": "https://api.github.com/users/lucario387/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lucario387",
                "id": 29790821,
                "login": "lucario387",
                "node_id": "MDQ6VXNlcjI5NzkwODIx",
                "organizations_url": "https://api.github.com/users/lucario387/orgs",
                "received_events_url": "https://api.github.com/users/lucario387/received_events",
                "repos_url": "https://api.github.com/users/lucario387/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lucario387/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lucario387/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lucario387"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1460360784"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460360784"
                }
            },
            "author_association": "MEMBER",
            "body": "Seconding @lucario387's comment, it should be clear whether this is zero-based and/or past-to-end convention. See #26631",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-20T10:39:02Z",
            "diff_hunk": "@@ -0,0 +1,473 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'\n+\n+---@class tohtml.state\n+---@field bufnr number\n+---@field background string\n+---@field foreground string\n+---@field title string|false\n+---@field start_row number\n+---@field end_row number",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1460360784",
            "id": 1460360784,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XC1ZQ",
            "original_commit_id": "e5fa93384b138595a7c2daeb29aa11522a5666ff",
            "original_line": 14,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1834657807,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460360784/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-20T10:39:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460360784",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1460361346"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361346"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n\r\n---@class tohtml.opt\r\n```\r\n\r\n(and similarly for others too)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-20T10:40:03Z",
            "diff_hunk": "@@ -0,0 +1,473 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'\n+\n+---@class tohtml.state\n+---@field bufnr number\n+---@field background string\n+---@field foreground string\n+---@field title string|false\n+---@field start_row number\n+---@field end_row number\n+---@field use_css boolean\n+---@field font string\n+---@class tohtml.opt",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1460361346",
            "id": 1460361346,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XC1iC",
            "original_commit_id": "e5fa93384b138595a7c2daeb29aa11522a5666ff",
            "original_line": 20,
            "original_position": 17,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1834657855,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361346/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-20T11:49:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361346",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1460361674"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361674"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n\r\n---@generic T\r\n```\r\netc. Please use whitespaces and blank lines appropriately everywhere. I know it's a nit comment that is *unfair* for a draft PR, but commenting this early because these aren't enforced by Stylua.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-20T10:40:35Z",
            "diff_hunk": "@@ -0,0 +1,473 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'\n+\n+---@class tohtml.state\n+---@field bufnr number\n+---@field background string\n+---@field foreground string\n+---@field title string|false\n+---@field start_row number\n+---@field end_row number\n+---@field use_css boolean\n+---@field font string\n+---@class tohtml.opt\n+---@field title? string|false\n+---@field start_row? number\n+---@field end_row? number\n+---@field use_css? boolean\n+---@class tohtml.styletable\n+---@field highlights table<number,tohtml.highlight>\n+---@field [number] tohtml.line\n+---@class tohtml.line\n+---@field [number] tohtml.cell?\n+---@class tohtml.cell\n+---@field [1]   number[] start\n+---@field [2]   number[] close\n+---@field [3] string[][] virt_text\n+---@field [4]   number[] hide\n+---@class tohtml.highlight\n+---@field bold? boolean\n+---@field italic? boolean\n+---@field underline? boolean\n+---@field color? {fg:string?,bg:string?}\n+---@field name? string\n+\n+local M = {}\n+---@param tbl table<''|any,nil|any>\n+---@return table<''|any,any>\n+function M.trim(tbl)\n+  for k, v in pairs(tbl) do\n+    if v == '' then\n+      tbl[k] = nil\n+    end\n+  end\n+  return tbl\n+end\n+---@generic T",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1460361674",
            "id": 1460361674,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XC1nK",
            "original_commit_id": "e5fa93384b138595a7c2daeb29aa11522a5666ff",
            "original_line": 181,
            "original_position": 50,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1834657855,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361674/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-20T11:50:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1460361674",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1461097769"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461097769"
                }
            },
            "author_association": "MEMBER",
            "body": "Do we use this pattern in Lua plugins? Most of the code should live in a module that is not loaded until `require()`.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-21T20:11:04Z",
            "diff_hunk": "@@ -0,0 +1,770 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1461097769",
            "id": 1461097769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XFpUp",
            "original_commit_id": "fb9392af8859b58c6c4f376f7bde15af3ff40370",
            "original_line": 1,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1835425895,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461097769/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-21T20:11:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461097769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1461100117"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461100117"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yeah, but I have it this way for ease of convenience. I'll move the functions to the right files when I'm done with the features.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-21T20:16:15Z",
            "diff_hunk": "@@ -0,0 +1,770 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1461100117",
            "id": 1461100117,
            "in_reply_to_id": 1461097769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XFp5V",
            "original_commit_id": "fb9392af8859b58c6c4f376f7bde15af3ff40370",
            "original_line": 1,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1835426511,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461100117/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-21T20:16:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461100117",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1461827399"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461827399"
                }
            },
            "author_association": "MEMBER",
            "body": "Should live somewhere in `/lua` (which is the \"`autoload` at home\" for Lua functions).  There's really no need for this to be in `/plugin` and sourced on every startup).",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-22T12:59:11Z",
            "diff_hunk": "@@ -0,0 +1,770 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1461827399",
            "id": 1461827399,
            "in_reply_to_id": 1461097769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XIbdH",
            "original_commit_id": "fb9392af8859b58c6c4f376f7bde15af3ff40370",
            "original_line": 1,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1836412757,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461827399/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-22T12:59:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1461827399",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465255250"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465255250"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Okay, I moved the functions to lua/tohtml.lua",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T16:52:21Z",
            "diff_hunk": "@@ -0,0 +1,770 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465255250",
            "id": 1465255250,
            "in_reply_to_id": 1461097769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XVgVS",
            "original_commit_id": "fb9392af8859b58c6c4f376f7bde15af3ff40370",
            "original_line": 1,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1841913388,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465255250/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T16:52:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465255250",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465267205"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465267205"
                }
            },
            "author_association": "MEMBER",
            "body": "Final location still TBD; we don't like having a lot of unrelated top-level scripts ;)\r\n\r\nBut this is much closer to how it'll have to be in the end.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T16:58:42Z",
            "diff_hunk": "@@ -0,0 +1,770 @@\n+--- Neovim plugin for converting a syntax highlighted file to HTML.\n+\n+if vim.g.loaded_2html_plugin then",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465267205",
            "id": 1465267205,
            "in_reply_to_id": 1461097769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XVjQF",
            "original_commit_id": "fb9392af8859b58c6c4f376f7bde15af3ff40370",
            "original_line": 1,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1841926199,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465267205/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T16:58:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465267205",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465275469"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465275469"
                }
            },
            "author_association": "MEMBER",
            "body": "Why this specific value? It should just be 0 or 1 (**if** we want to keep legacy conventions for Lua modules, which I'm not convinced about).\r\n\r\n(Note that these are just general guidances; I know this PR is still draft, and if you're incrementally converting from the legacy plugin, this is OK. I just want you to be clear as early as possible about our expectations for the final product. And to be perfectly: it is **not** a 1:1 translation of the old plugin just in Lua; it should have a much smaller API surface and be focused on the goal of providing a printable format via browsers.)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T17:03:42Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465275469",
            "id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XVlRN",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1841936265,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465275469/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T17:03:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465275469",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465401840"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465401840"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It was that value because `TOhtml` used that format.\r\n\r\nI have updated and set it to `true` (because `plugin/man.lua` does it that way)\r\n\r\nAlso, I have removed the options that remove specific decorations (like conceal).",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T18:48:57Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465401840",
            "id": 1465401840,
            "in_reply_to_id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XWEHw",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1842139936,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465401840/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T18:48:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465401840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465405282"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465405282"
                }
            },
            "author_association": "MEMBER",
            "body": "Right; I just want to make it clear that we don't consider `TOhtml` to be a good model for... basically, anything ;)\r\n\r\nWe'd love to have the basic functionality with none of the legacy baggage. (Which should make your job easier as well, since you can just skip any of the more byzantine parts of the code...)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T18:52:24Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465405282",
            "id": 1465405282,
            "in_reply_to_id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XWE9i",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1842145574,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465405282/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T18:52:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465405282",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465435371"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465435371"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "So, should multi-window diffs be supported? (That's basically the last major feature thing that I'm planning to add)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T19:23:01Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465435371",
            "id": 1465435371,
            "in_reply_to_id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XWMTr",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1842195481,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465435371/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T19:23:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465435371",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465448515"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465448515"
                }
            },
            "author_association": "MEMBER",
            "body": "Certainly not needed for a first PR. (In fact, I would have stopped to take stock much earlier...)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T19:36:33Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465448515",
            "id": 1465448515,
            "in_reply_to_id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XWPhD",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1842218603,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465448515/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T19:36:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465448515",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1465449309"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465449309"
                }
            },
            "author_association": "MEMBER",
            "body": "All this makes it sound like I want to discourage you -- I don't, we really appreciate your efforts!",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-24T19:37:29Z",
            "diff_hunk": "@@ -0,0 +1,58 @@\n+if vim.g.loaded_2html_plugin then\n+  return\n+end\n+vim.g.loaded_2html_plugin = 'nvim10.0_v1'",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1465449309",
            "id": 1465449309,
            "in_reply_to_id": 1465275469,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XWPtd",
            "original_commit_id": "8a812ddfc8909c60e2fae6d61fbbd2dff0fc110b",
            "original_line": 4,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1842219975,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465449309/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-24T19:37:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1465449309",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466063724"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466063724"
                }
            },
            "author_association": "MEMBER",
            "body": "Syntax files are just normal scripts, they can be in Lua as well. So no reason for this nesting dance.\r\n\r\nBut, really, why is this file even needed? All we need is a Lua module that can be `require`d (and possibly -- but not necessarily! -- a small `plugin` file that defines a user command).\r\n\r\nAgain, the end result should (must) be significantly simpler than TOhtml's Rube Goldberg machine. So before you port _anything_, ask yourself (or us) \"is this really needed?\"",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:15:08Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466063724",
            "id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYlts",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843197357,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466063724/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:15:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466063724",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466070092"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466070092"
                }
            },
            "author_association": "MEMBER",
            "body": "can't all this be moved to the `tohtml.lua` module? all this file should do (if anything at all) is define a convenience user command for `lua vim.tohtml(curwin, {write = false})` (or somesuch).",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:20:09Z",
            "diff_hunk": "@@ -0,0 +1,22 @@\n+if vim.g.loaded_2html_plugin ~= nil then\n+  return\n+end\n+vim.g.loaded_2html_plugin = true\n+\n+vim.api.nvim_create_user_command('TOhtml', function(params)\n+  local winnr = vim.api.nvim_get_current_win()\n+  ---@type string\n+  local args = params.args\n+  local html = require('tohtml').win_to_html(winnr)\n+  if args == '-' then\n+    for _, line in ipairs(html) do\n+      vim.api.nvim_out_write(line .. '\\n')\n+    end\n+  elseif args == '' then\n+    local outfile = vim.fn.tempname() .. '.html'\n+    vim.fn.writefile(html, outfile)\n+    vim.cmd.split(outfile)\n+  else\n+    vim.fn.writefile(html, args)\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466070092",
            "id": 1466070092,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYnRM",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 21,
            "original_position": 21,
            "original_start_line": 7,
            "path": "runtime/plugin/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1843207592,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466070092/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-01-25T09:20:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466070092",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466077134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466077134"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "?\r\nDidn't you say (in [a previous comment](https://github.com/neovim/neovim/pull/27097#issuecomment-1902061805)):\r\n> I think it's OK to keep the syntax file (and even preferable; makes syncing with Vim runtime slightly easier).\r\n\r\nThe reason why it's `.vim` is to make `:runtime! syntax/2html.vim` work (which is what the docs say you should use).",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:25:31Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466077134",
            "id": 1466077134,
            "in_reply_to_id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYo_O",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843218631,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466077134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:25:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466077134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466088533"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466088533"
                }
            },
            "author_association": "MEMBER",
            "body": "It's OK to keep it _unchanged_ (because we don't maintain it). But my comment forgot that this was supposed to be the entrance point, which makes zero sense (already in Vim, and is unacceptable in Neovim). In this case, the file should be removed and the docs should be changed.\r\n\r\nAgain, we want the functionality, not the interface (which is horrible even by legacy standards). We want\r\n* `:lua vim.tohtml()` (or `lua require('tohtml').convert()` or some variant thereof, tbd)\r\n* `:TOhtml` \r\nand nothing else as interface.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:33:49Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466088533",
            "id": 1466088533,
            "in_reply_to_id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYrxV",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843236054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466088533/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:37:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466088533",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466090348"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466090348"
                }
            },
            "author_association": "MEMBER",
            "body": "(I'm sorry I didn't check this before, I thought that was an actual syntax file meant to style the produced HTML buffer.)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:35:14Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466090348",
            "id": 1466090348,
            "in_reply_to_id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYsNs",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843238876,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466090348/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:37:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466090348",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466098436"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466098436"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Then it's easier to remove it.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:41:14Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466098436",
            "id": 1466098436,
            "in_reply_to_id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYuME",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843251025,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466098436/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:41:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466098436",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1466105439"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466105439"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes, since it's the main script, it _should_ be removed. My earlier comment was wrong, I apologize.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-25T09:46:39Z",
            "diff_hunk": "@@ -1,2068 +1,5 @@\n-\" Vim syntax support file\n-\" Maintainer: Ben Fritz <fritzophrenic@gmail.com>\n-\" Last Change: 2023 Sep 05\n-\"\n-\" Additional contributors:\n-\"\n-\"             Original by Bram Moolenaar <Bram@vim.org>\n-\"             Modified by David Ne\\v{c}as (Yeti) <yeti@physics.muni.cz>\n-\"             XHTML support by Panagiotis Issaris <takis@lumumba.luc.ac.be>\n-\"             Made w3 compliant by Edd Barrett <vext01@gmail.com>\n-\"             Added html_font. Edd Barrett <vext01@gmail.com>\n-\"             Progress bar based off code from \"progressbar widget\" plugin by\n-\"               Andreas Politz, heavily modified:\n-\"               http://www.vim.org/scripts/script.php?script_id=2006\n-\"\n-\"             See Mercurial change logs for more!\n-\n-\" Transform a file into HTML, using the current syntax highlighting.\n-\n-\" this file uses line continuations\n-let s:cpo_sav = &cpo\n-let s:ls  = &ls\n-let s:ei_sav = &eventignore\n-set cpo&vim\n-\n-\" HTML filetype can take a while to load/highlight if the destination file\n-\" already exists.\n-set eventignore+=FileType\n-\n-let s:end=line('$')\n-\n-\" Font\n-if exists(\"g:html_font\")\n-  if type(g:html_font) == type([])\n-    let s:htmlfont = \"'\".. join(g:html_font,\"','\") .. \"', monospace\"\n-  else\n-    let s:htmlfont = \"'\".. g:html_font .. \"', monospace\"\n-  endif\n-else\n-  let s:htmlfont = \"monospace\"\n-endif\n-\n-let s:settings = tohtml#GetUserSettings()\n-\n-if s:settings.use_xhtml\n-  let s:html5 = 0\n-elseif s:settings.use_css && !s:settings.no_pre\n-  let s:html5 = 1\n-else\n-  let s:html5 = 0\n-endif\n-\n-if !exists('s:FOLDED_ID')\n-  let s:FOLDED_ID  = hlID(\"Folded\")     | lockvar s:FOLDED_ID\n-  let s:FOLD_C_ID  = hlID(\"FoldColumn\") | lockvar s:FOLD_C_ID\n-  let s:LINENR_ID  = hlID('LineNr')     | lockvar s:LINENR_ID\n-  let s:DIFF_D_ID  = hlID(\"DiffDelete\") | lockvar s:DIFF_D_ID\n-  let s:DIFF_A_ID  = hlID(\"DiffAdd\")    | lockvar s:DIFF_A_ID\n-  let s:DIFF_C_ID  = hlID(\"DiffChange\") | lockvar s:DIFF_C_ID\n-  let s:DIFF_T_ID  = hlID(\"DiffText\")   | lockvar s:DIFF_T_ID\n-  let s:CONCEAL_ID = hlID('Conceal')    | lockvar s:CONCEAL_ID\n-endif\n-\n-\" Whitespace\n-if s:settings.pre_wrap\n-  let s:whitespace = \"white-space: pre-wrap; \"\n-else\n-  let s:whitespace = \"\"\n-endif\n-\n-if !empty(s:settings.prevent_copy)\n-  if s:settings.no_invalid\n-    \" User has decided they don't want invalid markup. Still works in\n-    \" OpenOffice, and for text editors, but when pasting into Microsoft Word the\n-    \" input elements get pasted too and they cannot be deleted (at least not\n-    \" easily).\n-    let s:unselInputType = \"\"\n-  else\n-    \" Prevent from copy-pasting the input elements into Microsoft Word where\n-    \" they cannot be deleted easily by deliberately inserting invalid markup.\n-    let s:unselInputType = \" type='invalid_input_type'\"\n-  endif\n-endif\n-\n-\" When gui colors are not supported, we can only guess the colors.\n-\" TODO - is this true anymore? Is there a way to ask the terminal what colors\n-\" each number means or read them from some file?\n-if &termguicolors || has(\"gui_running\")\n-  let s:whatterm = \"gui\"\n-else\n-  let s:whatterm = \"cterm\"\n-  if &t_Co == 8\n-    let s:cterm_color = {\n-\t    \\   0: \"#808080\", 1: \"#ff6060\", 2: \"#00ff00\", 3: \"#ffff00\",\n-\t    \\   4: \"#8080ff\", 5: \"#ff40ff\", 6: \"#00ffff\", 7: \"#ffffff\"\n-\t    \\ }\n-  else\n-    let s:cterm_color = {\n-\t    \\   0: \"#000000\", 1: \"#c00000\", 2: \"#008000\", 3: \"#804000\", \n-\t    \\   4: \"#0000c0\", 5: \"#c000c0\", 6: \"#008080\", 7: \"#c0c0c0\", \n-\t    \\   8: \"#808080\", 9: \"#ff6060\", 10: \"#00ff00\", 11: \"#ffff00\",\n-\t    \\   12: \"#8080ff\", 13: \"#ff40ff\", 14: \"#00ffff\", 15: \"#ffffff\"\n-\t    \\ }\n-\n-    \" Colors for 88 and 256 come from xterm.\n-    if &t_Co == 88\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00008b\", 18: \"#0000cd\", 19: \"#0000ff\",\n-\t    \\   20: \"#008b00\", 21: \"#008b8b\", 22: \"#008bcd\", 23: \"#008bff\",\n-\t    \\   24: \"#00cd00\", 25: \"#00cd8b\", 26: \"#00cdcd\", 27: \"#00cdff\",\n-\t    \\   28: \"#00ff00\", 29: \"#00ff8b\", 30: \"#00ffcd\", 31: \"#00ffff\",\n-\t    \\   32: \"#8b0000\", 33: \"#8b008b\", 34: \"#8b00cd\", 35: \"#8b00ff\",\n-\t    \\   36: \"#8b8b00\", 37: \"#8b8b8b\", 38: \"#8b8bcd\", 39: \"#8b8bff\",\n-\t    \\   40: \"#8bcd00\", 41: \"#8bcd8b\", 42: \"#8bcdcd\", 43: \"#8bcdff\",\n-\t    \\   44: \"#8bff00\", 45: \"#8bff8b\", 46: \"#8bffcd\", 47: \"#8bffff\",\n-\t    \\   48: \"#cd0000\", 49: \"#cd008b\", 50: \"#cd00cd\", 51: \"#cd00ff\",\n-\t    \\   52: \"#cd8b00\", 53: \"#cd8b8b\", 54: \"#cd8bcd\", 55: \"#cd8bff\",\n-\t    \\   56: \"#cdcd00\", 57: \"#cdcd8b\", 58: \"#cdcdcd\", 59: \"#cdcdff\",\n-\t    \\   60: \"#cdff00\", 61: \"#cdff8b\", 62: \"#cdffcd\", 63: \"#cdffff\",\n-\t    \\   64: \"#ff0000\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#ff008b\", 66: \"#ff00cd\", 67: \"#ff00ff\", 68: \"#ff8b00\",\n-\t    \\   69: \"#ff8b8b\", 70: \"#ff8bcd\", 71: \"#ff8bff\", 72: \"#ffcd00\",\n-\t    \\   73: \"#ffcd8b\", 74: \"#ffcdcd\", 75: \"#ffcdff\", 76: \"#ffff00\",\n-\t    \\   77: \"#ffff8b\", 78: \"#ffffcd\", 79: \"#ffffff\", 80: \"#2e2e2e\",\n-\t    \\   81: \"#5c5c5c\", 82: \"#737373\", 83: \"#8b8b8b\", 84: \"#a2a2a2\",\n-\t    \\   85: \"#b9b9b9\", 86: \"#d0d0d0\", 87: \"#e7e7e7\"\n-\t    \\ })\n-    elseif &t_Co == 256\n-      call extend(s:cterm_color, {\n-\t    \\   16: \"#000000\", 17: \"#00005f\", 18: \"#000087\", 19: \"#0000af\",\n-\t    \\   20: \"#0000d7\", 21: \"#0000ff\", 22: \"#005f00\", 23: \"#005f5f\",\n-\t    \\   24: \"#005f87\", 25: \"#005faf\", 26: \"#005fd7\", 27: \"#005fff\",\n-\t    \\   28: \"#008700\", 29: \"#00875f\", 30: \"#008787\", 31: \"#0087af\",\n-\t    \\   32: \"#0087d7\", 33: \"#0087ff\", 34: \"#00af00\", 35: \"#00af5f\",\n-\t    \\   36: \"#00af87\", 37: \"#00afaf\", 38: \"#00afd7\", 39: \"#00afff\",\n-\t    \\   40: \"#00d700\", 41: \"#00d75f\", 42: \"#00d787\", 43: \"#00d7af\",\n-\t    \\   44: \"#00d7d7\", 45: \"#00d7ff\", 46: \"#00ff00\", 47: \"#00ff5f\",\n-\t    \\   48: \"#00ff87\", 49: \"#00ffaf\", 50: \"#00ffd7\", 51: \"#00ffff\",\n-\t    \\   52: \"#5f0000\", 53: \"#5f005f\", 54: \"#5f0087\", 55: \"#5f00af\",\n-\t    \\   56: \"#5f00d7\", 57: \"#5f00ff\", 58: \"#5f5f00\", 59: \"#5f5f5f\",\n-\t    \\   60: \"#5f5f87\", 61: \"#5f5faf\", 62: \"#5f5fd7\", 63: \"#5f5fff\",\n-\t    \\   64: \"#5f8700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   65: \"#5f875f\", 66: \"#5f8787\", 67: \"#5f87af\", 68: \"#5f87d7\",\n-\t    \\   69: \"#5f87ff\", 70: \"#5faf00\", 71: \"#5faf5f\", 72: \"#5faf87\",\n-\t    \\   73: \"#5fafaf\", 74: \"#5fafd7\", 75: \"#5fafff\", 76: \"#5fd700\",\n-\t    \\   77: \"#5fd75f\", 78: \"#5fd787\", 79: \"#5fd7af\", 80: \"#5fd7d7\",\n-\t    \\   81: \"#5fd7ff\", 82: \"#5fff00\", 83: \"#5fff5f\", 84: \"#5fff87\",\n-\t    \\   85: \"#5fffaf\", 86: \"#5fffd7\", 87: \"#5fffff\", 88: \"#870000\",\n-\t    \\   89: \"#87005f\", 90: \"#870087\", 91: \"#8700af\", 92: \"#8700d7\",\n-\t    \\   93: \"#8700ff\", 94: \"#875f00\", 95: \"#875f5f\", 96: \"#875f87\",\n-\t    \\   97: \"#875faf\", 98: \"#875fd7\", 99: \"#875fff\", 100: \"#878700\",\n-\t    \\   101: \"#87875f\", 102: \"#878787\", 103: \"#8787af\", 104: \"#8787d7\",\n-\t    \\   105: \"#8787ff\", 106: \"#87af00\", 107: \"#87af5f\", 108: \"#87af87\",\n-\t    \\   109: \"#87afaf\", 110: \"#87afd7\", 111: \"#87afff\", 112: \"#87d700\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   113: \"#87d75f\", 114: \"#87d787\", 115: \"#87d7af\", 116: \"#87d7d7\",\n-\t    \\   117: \"#87d7ff\", 118: \"#87ff00\", 119: \"#87ff5f\", 120: \"#87ff87\",\n-\t    \\   121: \"#87ffaf\", 122: \"#87ffd7\", 123: \"#87ffff\", 124: \"#af0000\",\n-\t    \\   125: \"#af005f\", 126: \"#af0087\", 127: \"#af00af\", 128: \"#af00d7\",\n-\t    \\   129: \"#af00ff\", 130: \"#af5f00\", 131: \"#af5f5f\", 132: \"#af5f87\",\n-\t    \\   133: \"#af5faf\", 134: \"#af5fd7\", 135: \"#af5fff\", 136: \"#af8700\",\n-\t    \\   137: \"#af875f\", 138: \"#af8787\", 139: \"#af87af\", 140: \"#af87d7\",\n-\t    \\   141: \"#af87ff\", 142: \"#afaf00\", 143: \"#afaf5f\", 144: \"#afaf87\",\n-\t    \\   145: \"#afafaf\", 146: \"#afafd7\", 147: \"#afafff\", 148: \"#afd700\",\n-\t    \\   149: \"#afd75f\", 150: \"#afd787\", 151: \"#afd7af\", 152: \"#afd7d7\",\n-\t    \\   153: \"#afd7ff\", 154: \"#afff00\", 155: \"#afff5f\", 156: \"#afff87\",\n-\t    \\   157: \"#afffaf\", 158: \"#afffd7\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   159: \"#afffff\", 160: \"#d70000\", 161: \"#d7005f\", 162: \"#d70087\",\n-\t    \\   163: \"#d700af\", 164: \"#d700d7\", 165: \"#d700ff\", 166: \"#d75f00\",\n-\t    \\   167: \"#d75f5f\", 168: \"#d75f87\", 169: \"#d75faf\", 170: \"#d75fd7\",\n-\t    \\   171: \"#d75fff\", 172: \"#d78700\", 173: \"#d7875f\", 174: \"#d78787\",\n-\t    \\   175: \"#d787af\", 176: \"#d787d7\", 177: \"#d787ff\", 178: \"#d7af00\",\n-\t    \\   179: \"#d7af5f\", 180: \"#d7af87\", 181: \"#d7afaf\", 182: \"#d7afd7\",\n-\t    \\   183: \"#d7afff\", 184: \"#d7d700\", 185: \"#d7d75f\", 186: \"#d7d787\",\n-\t    \\   187: \"#d7d7af\", 188: \"#d7d7d7\", 189: \"#d7d7ff\", 190: \"#d7ff00\",\n-\t    \\   191: \"#d7ff5f\", 192: \"#d7ff87\", 193: \"#d7ffaf\", 194: \"#d7ffd7\",\n-\t    \\   195: \"#d7ffff\", 196: \"#ff0000\", 197: \"#ff005f\", 198: \"#ff0087\",\n-\t    \\   199: \"#ff00af\", 200: \"#ff00d7\", 201: \"#ff00ff\", 202: \"#ff5f00\",\n-\t    \\   203: \"#ff5f5f\", 204: \"#ff5f87\"\n-\t    \\ })\n-      call extend(s:cterm_color, {\n-\t    \\   205: \"#ff5faf\", 206: \"#ff5fd7\", 207: \"#ff5fff\", 208: \"#ff8700\",\n-\t    \\   209: \"#ff875f\", 210: \"#ff8787\", 211: \"#ff87af\", 212: \"#ff87d7\",\n-\t    \\   213: \"#ff87ff\", 214: \"#ffaf00\", 215: \"#ffaf5f\", 216: \"#ffaf87\",\n-\t    \\   217: \"#ffafaf\", 218: \"#ffafd7\", 219: \"#ffafff\", 220: \"#ffd700\",\n-\t    \\   221: \"#ffd75f\", 222: \"#ffd787\", 223: \"#ffd7af\", 224: \"#ffd7d7\",\n-\t    \\   225: \"#ffd7ff\", 226: \"#ffff00\", 227: \"#ffff5f\", 228: \"#ffff87\",\n-\t    \\   229: \"#ffffaf\", 230: \"#ffffd7\", 231: \"#ffffff\", 232: \"#080808\",\n-\t    \\   233: \"#121212\", 234: \"#1c1c1c\", 235: \"#262626\", 236: \"#303030\",\n-\t    \\   237: \"#3a3a3a\", 238: \"#444444\", 239: \"#4e4e4e\", 240: \"#585858\",\n-\t    \\   241: \"#626262\", 242: \"#6c6c6c\", 243: \"#767676\", 244: \"#808080\",\n-\t    \\   245: \"#8a8a8a\", 246: \"#949494\", 247: \"#9e9e9e\", 248: \"#a8a8a8\",\n-\t    \\   249: \"#b2b2b2\", 250: \"#bcbcbc\", 251: \"#c6c6c6\", 252: \"#d0d0d0\",\n-\t    \\   253: \"#dadada\", 254: \"#e4e4e4\", 255: \"#eeeeee\"\n-\t    \\ })\n-    endif\n-  endif\n-endif\n-\n-\" Return good color specification: in GUI no transformation is done, in\n-\" terminal return RGB values of known colors and empty string for unknown\n-if s:whatterm == \"gui\"\n-  function! s:HtmlColor(color)\n-    return a:color\n-  endfun\n-else\n-  function! s:HtmlColor(color)\n-    if has_key(s:cterm_color, a:color)\n-      return s:cterm_color[a:color]\n-    else\n-      return \"\"\n-    endif\n-  endfun\n-endif\n-\n-\" Find out the background and foreground color for use later\n-let s:fgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"fg#\", s:whatterm))\n-let s:bgc = s:HtmlColor(synIDattr(hlID(\"Normal\")->synIDtrans(), \"bg#\", s:whatterm))\n-if s:fgc == \"\"\n-  let s:fgc = ( &background == \"dark\" ? \"#ffffff\" : \"#000000\" )\n-endif\n-if s:bgc == \"\"\n-  let s:bgc = ( &background == \"dark\" ? \"#000000\" : \"#ffffff\" )\n-endif\n-\n-if !s:settings.use_css\n-  \" Return opening HTML tag for given highlight id\n-  function! s:HtmlOpening(id, extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"inverse\")\n-      \" For inverse, we always must set both colors (and exchange them)\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      let a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. ( x != \"\" ? x : s:fgc ) .. '\">'\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      let a = a .. '<font color=\"' .. ( x != \"\" ? x : s:bgc ) .. '\">'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\"\n-\tlet a = a .. '<span '..a:extra_attrs..'style=\"background-color: ' .. x .. '\">'\n-      elseif !empty(a:extra_attrs)\n-\tlet a = a .. '<span '..a:extra_attrs..'>'\n-      endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '<font color=\"' .. x .. '\">' | endif\n-    endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"<b>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"<i>\" | endif\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"<u>\" | endif\n-    return a\n-  endfun\n-\n-  \" Return closing HTML tag for given highlight id\n-  function! s:HtmlClosing(id, has_extra_attrs)\n-    let a = \"\"\n-    let translated_ID = synIDtrans(a:id)\n-    if synIDattr(translated_ID, \"underline\") | let a = a .. \"</u>\" | endif\n-    if synIDattr(translated_ID, \"italic\") | let a = a .. \"</i>\" | endif\n-    if synIDattr(translated_ID, \"bold\") | let a = a .. \"</b>\" | endif\n-    if synIDattr(translated_ID, \"inverse\")\n-      let a = a .. '</font></span>'\n-    else\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-      if x != \"\" | let a = a .. '</font>' | endif\n-      let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-      if x != \"\" || a:has_extra_attrs | let a = a .. '</span>' | endif\n-    endif\n-    return a\n-  endfun\n-endif\n-\n-\" Use a different function for formatting based on user options. This way we\n-\" can avoid a lot of logic during the actual execution.\n-\"\n-\" Build the function line by line containing only what is needed for the options\n-\" in use for maximum code sharing with minimal branch logic for greater speed.\n-\"\n-\" Note, 'exec' commands do not recognize line continuations, so must concatenate\n-\" lines rather than continue them.\n-if s:settings.use_css\n-  \" save CSS to a list of rules to add to the output at the end of processing\n-\n-  \" first, get the style names we need\n-  let s:wrapperfunc_lines = []\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, make_unselectable, unformatted)\n-\t\n-\t  let l:style_name = synIDattr(a:style_id, \"name\", s:whatterm)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  let l:diff_style_name = synIDattr(a:diff_style_id, \"name\", s:whatterm)\n-    ENDLET\n-\n-    \" Add normal groups and diff groups to separate lists so we can order them to\n-    \" allow diff highlight to override normal highlight\n-\n-    \" if primary style IS a diff style, grab it from the diff cache instead\n-    \" (always succeeds because we pre-populate it)\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if a:style_id == s:DIFF_D_ID || a:style_id == s:DIFF_A_ID || a:style_id == s:DIFF_C_ID || a:style_id == s:DIFF_T_ID\n-\t    let l:saved_style = get(s:diffstylelist,a:style_id)\n-\t  else\n-    ENDLET\n-  endif\n-\n-  \" get primary style info from cache or build it on the fly if not found\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    let l:saved_style = get(s:stylelist,a:style_id)\n-\t    if type(l:saved_style) == type(0)\n-\t      unlet l:saved_style\n-\t      let l:saved_style = s:CSS1(a:style_id)\n-\t      if l:saved_style != \"\"\n-\t        let l:saved_style = \".\" .. l:style_name .. \" { \" .. l:saved_style .. \"}\"\n-\t      endif\n-\t      let s:stylelist[a:style_id] = l:saved_style\n-\t    endif\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-    ENDLET\n-  endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" Build the wrapper tags around the text. It turns out that caching these\n-  \" gives pretty much zero performance gain and adds a lot of logic.\n-\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\n-\t  if l:saved_style == \"\" && empty(a:extra_attrs)\n-  ENDLET\n-  if &diff\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    if a:diff_style_id <= 0\n-    ENDLET\n-  endif\n-  \" no surroundings if neither primary nor diff style has any info\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      return a:text\n-  ENDLET\n-  if &diff\n-    \" no primary style, but diff style\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t    else\n-\t      return '<span class=\"' ..l:diff_style_name .. '\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  \" Ignore this comment, just bypassing a highlighting issue: if\n-\n-  \" open tag for non-empty primary style\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  else\n-  ENDLET\n-  \" non-empty primary style. handle either empty or non-empty diff style.\n-  \"\n-  \" separate the two classes by a space to apply them both if there is a diff\n-  \" style name, unless the primary style is empty, then just use the diff style\n-  \" name\n-  let s:diffstyle =\n-\t  \\ (&diff ? '(a:diff_style_id <= 0 ? \"\" : \" \" .. l:diff_style_name)..'\n-\t  \\        : '')\n-  if s:settings.prevent_copy == \"\"\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\">'..a:text..\"</span>\"\n-    ENDLET\n-  else\n-\n-    \" New method: use generated content in the CSS. The only thing needed here\n-    \" is a span with no content, with an attribute holding the desired text.\n-    \"\n-    \" Old method: use an <input> element when text is unsectable. This is still\n-    \" used in conditional comments for Internet Explorer, where the new method\n-    \" doesn't work.\n-    \"\n-    \" Wrap the <input> in a <span> to allow fixing the stupid bug in some fonts\n-    \" which cause browsers to display a 1px gap between lines when these\n-    \" <input>s have a background color (maybe not really a bug, this isn't\n-    \" well-defined)\n-    \"\n-    \" use strwidth, because we care only about how many character boxes are\n-    \" needed to size the input, we don't care how many characters (including\n-    \" separately counted composing chars, from strchars()) or bytes (from\n-    \" len())the string contains. strdisplaywidth() is not needed because none of\n-    \" the unselectable groups can contain tab characters (fold column, fold\n-    \" text, line number).\n-    \"\n-    \" Note, if maxlength property needs to be added in the future, it will need\n-    \" to use strchars(), because HTML specifies that the maxlength parameter\n-    \" uses the number of unique codepoints for its limit.\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t    if a:make_unselectable\n-\t      let return_span = \"<span \"..a:extra_attrs..'class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'all'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= \" data-\" .. l:style_name .. '-content=\"'..a:text..'\"'\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t      let return_span ..= '>'\n-    ENDLET\n-    if s:settings.use_input_for_pc !=# 'none'\n-      call add(s:wrapperfunc_lines, [])\n-      let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      let return_span ..=   '<input'..s:unselInputType..' class=\"' .. l:style_name ..{s:diffstyle}'\"'\n-\t      let return_span ..=   ' value=\"'..substitute(a:unformatted,'\\s\\+$',\"\",\"\")..'\"'\n-\t      let return_span ..=   \" onselect='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onmousedown='this.blur(); return false;'\"\n-\t      let return_span ..=   \" onclick='this.blur(); return false;'\"\n-\t      let return_span ..=   \" readonly='readonly'\"\n-\t      let return_span ..=   ' size=\"'..strwidth(a:unformatted)..'\"'\n-\t      let return_span ..=   (s:settings.use_xhtml ? '/>' : '>')\n-      ENDLET\n-    endif\n-    call add(s:wrapperfunc_lines, [])\n-    let s:wrapperfunc_lines[-1] =<< trim eval ENDLET\n-\t      return return_span..'</span>'\n-\t    else\n-\t      return \"<span \"..a:extra_attrs..'class=\"' .. l:style_name .. {s:diffstyle}'\">'..a:text..\"</span>\"\n-\t    endif\n-    ENDLET\n-  endif\n-  call add(s:wrapperfunc_lines, [])\n-  let s:wrapperfunc_lines[-1] =<< trim ENDLET\n-\t  endif\n-\tendfun\n-  ENDLET\n-else\n-  \" Non-CSS method just needs the wrapper.\n-  \"\n-  \" Functions used to get opening/closing automatically return null strings if\n-  \" no styles exist.\n-  if &diff\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  if a:diff_style_id <= 0\n-\t    let l:diff_opening = s:HtmlOpening(a:diff_style_id, \"\")\n-\t    let l:diff_closing = s:HtmlClosing(a:diff_style_id, 0)\n-\t  else\n-\t    let l:diff_opening = \"\"\n-\t    let l:diff_closing = \"\"\n-\t  endif\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..l:diff_opening..a:text..l:diff_closing..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  else\n-    let s:wrapperfunc_lines =<< trim ENDLET\n-\tfunction! s:BuildStyleWrapper(style_id, diff_style_id, extra_attrs, text, unusedarg, unusedarg2)\n-\t  return s:HtmlOpening(a:style_id, a:extra_attrs)..a:text..s:HtmlClosing(a:style_id, !empty(a:extra_attrs))\n-\tendfun\n-    ENDLET\n-  endif\n-endif\n-\n-\" create the function we built line by line above\n-exec join(flatten(s:wrapperfunc_lines), \"\\n\")\n-\n-let s:diff_mode = &diff\n-\n-\" Return HTML valid characters enclosed in a span of class style_name with\n-\" unprintable characters expanded and double spaces replaced as necessary.\n-\"\n-\" TODO: eliminate unneeded logic like done for BuildStyleWrapper\n-function! s:HtmlFormat(text, style_id, diff_style_id, extra_attrs, make_unselectable)\n-  \" Replace unprintable characters\n-  let unformatted = strtrans(a:text)\n-\n-  let formatted = unformatted\n-\n-  \" Replace the reserved html characters\n-  let formatted = substitute(formatted, '&', '\\&amp;',  'g')\n-  let formatted = substitute(formatted, '<', '\\&lt;',   'g')\n-  let formatted = substitute(formatted, '>', '\\&gt;',   'g')\n-  let formatted = substitute(formatted, '\"', '\\&quot;', 'g')\n-  \" &apos; is not valid in HTML but it is in XHTML, so just use the numeric\n-  \" reference for it instead. Needed because it could appear in quotes\n-  \" especially if unselectable regions is turned on.\n-  let formatted = substitute(formatted, '\"', '\\&#0039;', 'g')\n-\n-  \" Replace a \"form feed\" character with HTML to do a page break\n-  \" TODO: need to prevent this in unselectable areas? Probably it should never\n-  \" BE in an unselectable area...\n-  let formatted = substitute(formatted, \"\\x0c\", '<hr class=\"PAGE-BREAK\">', 'g')\n-\n-  \" Replace double spaces, leading spaces, and trailing spaces if needed\n-  if ' ' != s:HtmlSpace\n-    let formatted = substitute(formatted, '  ', s:HtmlSpace .. s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, '^ ', s:HtmlSpace, 'g')\n-    let formatted = substitute(formatted, ' \\+$', s:HtmlSpace, 'g')\n-  endif\n-\n-  \" Enclose in the correct format\n-  return s:BuildStyleWrapper(a:style_id, a:diff_style_id, a:extra_attrs, formatted, a:make_unselectable, unformatted)\n-endfun\n-\n-\" set up functions to call HtmlFormat in certain ways based on whether the\n-\" element is supposed to be unselectable or not\n-if s:settings.prevent_copy =~# 'n'\n-  if s:settings.number_lines\n-    if s:settings.line_ids\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\tif a:lnr > 0\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 1)\n-\telse\n-\t  return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-\tendif\n-      endfun\n-    else\n-      function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-      endfun\n-    endif\n-  elseif s:settings.line_ids\n-    \" if lines are not being numbered the only reason this function gets called\n-    \" is to put the line IDs on each line; \"text\" will be empty but lnr will\n-    \" always be non-zero, however we don't want to use the <input> because that\n-    \" won't work as nice for empty text\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-    endfun\n-  endif\n-else\n-  if s:settings.line_ids\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      if a:lnr > 0\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, 'id=\"'..(exists('g:html_diff_win_num') ? 'W'..g:html_diff_win_num : \"\")..'L'..a:lnr..s:settings.id_suffix..'\" ', 0)\n-      else\n-\treturn s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-      endif\n-    endfun\n-  else\n-    function! s:HtmlFormat_n(text, style_id, diff_style_id, lnr)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-    endfun\n-  endif\n-endif\n-if s:settings.prevent_copy =~# 'd'\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-  endfun\n-else\n-  function! s:HtmlFormat_d(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 'f'\n-  if s:settings.use_input_for_pc ==# 'none'\n-    \" Simply space-pad to the desired width inside the generated content (note\n-    \" that the FoldColumn definition includes a whitespace:pre rule)\n-    function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-      return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"' data-FoldColumn-content='\".\n-\t    \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t    \\ \"'></a>\"\n-    endfun\n-    function! s:FoldColumn_fill()\n-      return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 1)\n-    endfun\n-  else\n-    \" Note the <input> elements for fill spaces will have a single space for\n-    \" content, to allow active cursor CSS selection to work.\n-    \"\n-    \" Wrap the whole thing in a span for the 1px padding workaround for gaps.\n-    \"\n-    \" Build the function line by line containing only what is needed for the\n-    \" options in use for maximum code sharing with minimal branch logic for\n-    \" greater speed.\n-    \"\n-    \" Note, 'exec' commands do not recognize line continuations, so must\n-    \" concatenate lines rather than continue them.\n-    let s:build_fun_lines = []\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-\t    let l:input_open = \"<input readonly='readonly'\"..s:unselInputType\n-\t    let l:input_open ..= \" onselect='this.blur(); return false;'\"\n-\t    let l:input_open ..= \" onmousedown='this.blur(); \"..a:click..\" return false;'\"\n-\t    let l:input_open ..= \" onclick='return false;' size='\"\n-\t    let l:input_open ..= string(a:len + (empty(a:char2) ? 0 : 1) + a:numfill) .. \"' \"\n-\t    let l:common_attrs = \"class='FoldColumn' value='\"\n-\t    let l:input_close = (s:settings.use_xhtml ? \"' />\" : \"'>\")\n-\t    let l:return_span = \"<span class='\"..a:class..\"'>\"\n-\t    let l:return_span ..= l:input_open..l:common_attrs..repeat(a:char, a:len)..(a:char2)\n-\t    let l:return_span ..= l:input_close\n-    ENDLET\n-    if s:settings.use_input_for_pc ==# 'fallback'\n-      call add(s:build_fun_lines, [])\n-      let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"<a href='#' class='FoldColumn' onclick='\"..a:click..\"'\"\n-\t    let l:return_span ..= \" data-FoldColumn-content='\"\n-\t    let l:return_span ..= repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill)\n-\t    let l:return_span ..= \"'></a>\"\n-      ENDLET\n-    endif\n-    call add(s:build_fun_lines, [])\n-    let s:build_fun_lines[-1] =<< trim ENDLET\n-\t    let l:return_span ..= \"</span>\"\n-\t    return l:return_span\n-\t  endfun\n-    ENDLET\n-    \" create the function we built line by line above\n-    exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-    function! s:FoldColumn_fill()\n-      return s:FoldColumn_build(' ', s:foldcolumn, 0, '', 'FoldColumn', '')\n-    endfun\n-  endif\n-else\n-  \" For normal fold columns, simply space-pad to the desired width (note that\n-  \" the FoldColumn definition includes a whitespace:pre rule)\n-  function! s:FoldColumn_build(char, len, numfill, char2, class, click)\n-    return \"<a href='#' class='\"..a:class..\"' onclick='\"..a:click..\"'>\".\n-\t  \\ repeat(a:char, a:len)..a:char2..repeat(' ', a:numfill).\n-\t  \\ \"</a>\"\n-  endfun\n-  function! s:FoldColumn_fill()\n-    return s:HtmlFormat(repeat(' ', s:foldcolumn), s:FOLD_C_ID, 0, \"\", 0)\n-  endfun\n-endif\n-if s:settings.prevent_copy =~# 't'\n-  \" put an extra empty span at the end for dynamic folds, so the linebreak can\n-  \" be surrounded. Otherwise do it as normal.\n-  \"\n-  \" TODO: isn't there a better way to do this, than placing it here and using a\n-  \" substitute later?\n-  if s:settings.dynamic_folds\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1) .\n-\t    \\ s:HtmlFormat(\"\", a:style_id, 0, \"\", 0)\n-    endfun\n-  else\n-    function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-      return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 1)\n-    endfun\n-  endif\n-else\n-  function! s:HtmlFormat_t(text, style_id, diff_style_id)\n-    return s:HtmlFormat(a:text, a:style_id, a:diff_style_id, \"\", 0)\n-  endfun\n-endif\n-\n-\" Return CSS style describing given highlight id (can be empty)\n-function! s:CSS1(id)\n-  let a = \"\"\n-  let translated_ID = synIDtrans(a:id)\n-  if synIDattr(translated_ID, \"inverse\")\n-    \" For inverse, we always must set both colors (and exchange them)\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    let a = a .. \"color: \" .. ( x != \"\" ? x : s:bgc ) .. \"; \"\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    let a = a .. \"background-color: \" .. ( x != \"\" ? x : s:fgc ) .. \"; \"\n-  else\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"fg#\", s:whatterm))\n-    if x != \"\" | let a = a .. \"color: \" .. x .. \"; \" | endif\n-    let x = s:HtmlColor(synIDattr(translated_ID, \"bg#\", s:whatterm))\n-    if x != \"\"\n-      let a = a .. \"background-color: \" .. x .. \"; \"\n-      \" stupid hack because almost every browser seems to have at least one font\n-      \" which shows 1px gaps between lines which have background\n-      let a = a .. \"padding-bottom: 1px; \"\n-    elseif (translated_ID == s:FOLDED_ID || translated_ID == s:LINENR_ID || translated_ID == s:FOLD_C_ID) && !empty(s:settings.prevent_copy)\n-      \" input elements default to a different color than the rest of the page\n-      let a = a .. \"background-color: \" .. s:bgc .. \"; \"\n-    endif\n-  endif\n-  if synIDattr(translated_ID, \"bold\") | let a = a .. \"font-weight: bold; \" | endif\n-  if synIDattr(translated_ID, \"italic\") | let a = a .. \"font-style: italic; \" | endif\n-  if synIDattr(translated_ID, \"underline\") | let a = a .. \"text-decoration: underline; \" | endif\n-  return a\n-endfun\n-\n-if s:settings.dynamic_folds\n-  \" compares two folds as stored in our list of folds\n-  \" A fold is \"less\" than another if it starts at an earlier line number,\n-  \" or ends at a later line number, ties broken by fold level\n-  function! s:FoldCompare(f1, f2)\n-    if a:f1.firstline != a:f2.firstline\n-      \" put it before if it starts earlier\n-      return a:f1.firstline - a:f2.firstline\n-    elseif a:f1.lastline != a:f2.lastline\n-      \" put it before if it ends later\n-      return a:f2.lastline - a:f1.lastline\n-    else\n-      \" if folds begin and end on the same lines, put lowest fold level first\n-      return a:f1.level - a:f2.level\n-    endif\n-  endfunction\n-\n-endif\n-\n-\n-\" Set some options to make it work faster.\n-\" Don't report changes for :substitute, there will be many of them.\n-\" Don't change other windows; turn off scroll bind temporarily\n-let s:old_title = &title\n-let s:old_icon = &icon\n-let s:old_et = &l:et\n-let s:old_bind = &l:scrollbind\n-let s:old_report = &report\n-let s:old_search = @/\n-let s:old_more = &more\n-set notitle noicon\n-setlocal et\n-set nomore\n-set report=1000000\n-setlocal noscrollbind\n-\n-if exists(':ownsyntax') && exists('w:current_syntax')\n-  let s:current_syntax = w:current_syntax\n-elseif exists('b:current_syntax')\n-  let s:current_syntax = b:current_syntax\n-else\n-  let s:current_syntax = 'none'\n-endif\n-\n-if s:current_syntax == ''\n-  let s:current_syntax = 'none'\n-endif\n-\n-\" If the user is sourcing this script directly then the plugin version isn't\n-\" known because the main plugin script didn't load. In the usual case where the\n-\" user still has the full Vim runtime installed, or has this full plugin\n-\" installed in a package or something, then we can extract the version from the\n-\" main plugin file at it's usual spot relative to this file. Otherwise the user\n-\" is assembling their runtime piecemeal and we have no idea what versions of\n-\" other files may be present so don't even try to make a guess or assume the\n-\" presence of other specific files with specific meaning.\n-\"\n-\" We don't want to actually source the main plugin file here because the user\n-\" may have a good reason not to (e.g. they define their own TOhtml command or\n-\" something).\n-\"\n-\" If this seems way too complicated and convoluted, it is. Probably I should\n-\" have put the version information in the autoload file from the start. But the\n-\" version has been in the global variable for so long that changing it could\n-\" break a lot of user scripts.\n-if exists(\"g:loaded_2html_plugin\")\n-  let s:pluginversion = g:loaded_2html_plugin\n-else\n-  if !exists(\"g:unloaded_tohtml_plugin\")\n-    let s:main_plugin_path = expand(\"<sfile>:p:h:h\")..\"/plugin/tohtml.vim\"\n-    if filereadable(s:main_plugin_path)\n-      let s:lines = readfile(s:main_plugin_path, \"\", 20)\n-      call filter(s:lines, 'v:val =~ \"loaded_2html_plugin = \"')\n-      if empty(s:lines)\n-\tlet g:unloaded_tohtml_plugin = \"unknown\"\n-      else\n-\tlet g:unloaded_tohtml_plugin = substitute(s:lines[0], '.*loaded_2html_plugin = \\([''\"]\\)\\(\\%(\\1\\@!.\\)\\+\\)\\1', '\\2', '')\n-      endif\n-      unlet s:lines\n-    else\n-      let g:unloaded_tohtml_plugin = \"unknown\"\n-    endif\n-    unlet s:main_plugin_path\n-  endif\n-  let s:pluginversion = g:unloaded_tohtml_plugin\n-endif\n-\n-\" Split window to create a buffer with the HTML file.\n-let s:orgbufnr = winbufnr(0)\n-let s:origwin_stl = &l:stl\n-if expand(\"%\") == \"\"\n-  if exists('g:html_diff_win_num')\n-    exec 'new Untitled_win'..g:html_diff_win_num..'.'.(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  else\n-    exec 'new Untitled.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-  endif\n-else\n-  exec 'new %.'..(s:settings.use_xhtml ? 'xhtml' : 'html')\n-endif\n-\n-\" Resize the new window to very small in order to make it draw faster\n-let s:old_winheight = winheight(0)\n-let s:old_winfixheight = &l:winfixheight\n-if s:old_winheight > 2\n-  resize 1 \" leave enough room to view one line at a time\n-  norm! G\n-  norm! zt\n-endif\n-setlocal winfixheight\n-\n-let s:newwin_stl = &l:stl\n-\n-\" on the new window, set the least time-consuming fold method\n-let s:old_fen = &foldenable\n-setlocal foldmethod=manual\n-setlocal nofoldenable\n-\n-let s:newwin = winnr()\n-let s:orgwin = bufwinnr(s:orgbufnr)\n-\n-setlocal modifiable\n-%d\n-let s:old_paste = &paste\n-set paste\n-let s:old_magic = &magic\n-set magic\n-\n-\" set the fileencoding to match the charset we'll be using\n-let &l:fileencoding=s:settings.vim_encoding\n-\n-\" According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte\n-\" order mark is highly recommend on the web when using multibyte encodings. But,\n-\" it is not a good idea to include it on UTF-8 files. Otherwise, let Vim\n-\" determine when it is actually inserted.\n-if s:settings.vim_encoding == 'utf-8'\n-  setlocal nobomb\n-else\n-  setlocal bomb\n-endif\n-\n-let s:lines = []\n-\n-if s:settings.use_xhtml\n-  if s:settings.encoding != \"\"\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\" encoding=\\\"\" .. s:settings.encoding .. \"\\\"?>\")\n-  else\n-    call add(s:lines, \"<?xml version=\\\"1.0\\\"?>\")\n-  endif\n-  let s:tag_close = ' />'\n-else\n-  let s:tag_close = '>'\n-endif\n-\n-let s:HtmlSpace = ' '\n-let s:LeadingSpace = ' '\n-let s:HtmlEndline = ''\n-if s:settings.no_pre\n-  let s:HtmlEndline = '<br' .. s:tag_close\n-  let s:LeadingSpace = s:settings.use_xhtml ? '&#160;' : '&nbsp;'\n-  let s:HtmlSpace = '\\' .. s:LeadingSpace\n-endif\n-\n-\" HTML header, with the title and generator ;-). Left free space for the CSS,\n-\" to be filled at the end.\n-if !s:settings.no_doc\n-  call extend(s:lines, [\n-\t\\ \"<html>\",\n-\t\\ \"<head>\"])\n-  \" include encoding as close to the top as possible, but only if not already\n-  \" contained in XML information (to avoid haggling over content type)\n-  if s:settings.encoding != \"\" && !s:settings.use_xhtml\n-    if s:html5\n-      call add(s:lines, '<meta charset=\"' .. s:settings.encoding .. '\"' .. s:tag_close)\n-    else\n-      call add(s:lines, \"<meta http-equiv=\\\"content-type\\\" content=\\\"text/html; charset=\" .. s:settings.encoding .. '\"' .. s:tag_close)\n-    endif\n-  endif\n-  call extend(s:lines, [\n-\t\\ (\"<title>\"..expand(\"%:p:~\")..\"</title>\"),\n-\t\\ (\"<meta name=\\\"Generator\\\" content=\\\"Vim/\"..v:version/100..\".\"..v:version%100..'\"'..s:tag_close),\n-\t\\ (\"<meta name=\\\"plugin-version\\\" content=\\\"\"..s:pluginversion..'\"'..s:tag_close)\n-\t\\ ])\n-  call add(s:lines, '<meta name=\"syntax\" content=\"'..s:current_syntax..'\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"settings\" content=\"'..\n-\t\\ join(filter(keys(s:settings),'s:settings[v:val]'),',')..\n-\t\\ ',prevent_copy='..s:settings.prevent_copy..\n-\t\\ ',use_input_for_pc='..s:settings.use_input_for_pc..\n-\t\\ '\"'..s:tag_close)\n-  call add(s:lines, '<meta name=\"colorscheme\" content=\"'..\n-\t\\ (exists('g:colors_name')\n-\t\\ ? g:colors_name\n-\t\\ : 'none').. '\"'..s:tag_close)\n-\n-  if s:settings.use_css\n-    call extend(s:lines, [\n-\t  \\ \"<style\" .. (s:html5 ? \"\" : \" type=\\\"text/css\\\"\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? \"\" : \"<!--\"])\n-    let s:ieonly = []\n-    if s:settings.dynamic_folds\n-      if s:settings.hover_unfold\n-\t\" if we are doing hover_unfold, use css 2 with css 1 fallback for IE6\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \"\",\n-\t      \\ \"body * { margin: 0; padding: 0; }\", \"\",\n-\t      \\ \".open-fold   > span.Folded { display: none;  }\",\n-\t      \\ \".open-fold   > .fulltext   { display: inline; }\",\n-\t      \\ \".closed-fold > .fulltext   { display: none;  }\",\n-\t      \\ \".closed-fold > span.Folded { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".open-fold   > .toggle-open   { display: none;   }\",\n-\t      \\ \".open-fold   > .toggle-closed { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold > .toggle-closed { display: none;   }\",\n-\t      \\ \"\", \"\",\n-\t      \\ '/* opening a fold while hovering won''t be supported by IE6 and other',\n-\t      \\ \"similar browsers, but it should fail gracefully. */\",\n-\t      \\ \".closed-fold:hover > .fulltext      { display: inline; }\",\n-\t      \\ \".closed-fold:hover > .toggle-filler { display: none; }\",\n-\t      \\ \".closed-fold:hover > .Folded        { display: none; }\"])\n-\t\" TODO: IE6 is REALLY old and I can't even test it anymore. Maybe we\n-\t\" should remove this? Leave it in for now, it was working at one point,\n-\t\" and doesn't affect any modern browsers. Even newer IE versions should\n-\t\" support the above code and ignore the following.\n-\tlet s:ieonly = [\n-\t      \\ \"<!--[if lt IE 7]><style type=\\\"text/css\\\">\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\ \"</style>\",\n-\t      \\ \"<![endif]-->\",\n-\t      \\]\n-      else\n-\t\" if we aren't doing hover_unfold, use CSS 1 only\n-\tcall extend(s:lines, [\n-\t      \\ \".FoldColumn { text-decoration: none; white-space: pre; }\",\n-\t      \\ \".open-fold   .fulltext      { display: inline; }\",\n-\t      \\ \".open-fold   span.Folded    { display: none; }\",\n-\t      \\ \".open-fold   .toggle-open   { display: none; }\",\n-\t      \\ \".open-fold   .toggle-closed { display: inline; }\",\n-\t      \\ \"\",\n-\t      \\ \".closed-fold .fulltext      { display: none; }\",\n-\t      \\ \".closed-fold span.Folded    { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-open   { display: inline; }\",\n-\t      \\ \".closed-fold .toggle-closed { display: none; }\",\n-\t      \\])\n-      endif\n-    endif\n-    \" else we aren't doing any dynamic folding, no need for any special rules\n-\n-    call extend(s:lines, [\n-\t    \\ s:settings.use_xhtml ? \"\" : '-->',\n-\t    \\ \"</style>\",\n-\t    \\])\n-    call extend(s:lines, s:ieonly)\n-    unlet s:ieonly\n-  endif\n-\n-  let s:uses_script = s:settings.dynamic_folds || s:settings.line_ids\n-\n-  \" insert script tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"<script\" .. (s:html5 ? \"\" : \" type='text/javascript'\") .. \">\",\n-\t  \\ s:settings.use_xhtml ? '//<![CDATA[' : \"<!--\"])\n-  endif\n-\n-  \" insert javascript to toggle folds open and closed\n-  if s:settings.dynamic_folds\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"function toggleFold(objID)\",\n-\t  \\ \"{\",\n-\t  \\ \"  var fold;\",\n-\t  \\ \"  fold = document.getElementById(objID);\",\n-\t  \\ \"  if (fold.className == 'closed-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'open-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"  else if (fold.className == 'open-fold')\",\n-\t  \\ \"  {\",\n-\t  \\ \"    fold.className = 'closed-fold';\",\n-\t  \\ \"  }\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  if s:settings.line_ids\n-    \" insert javascript to get IDs from line numbers, and to open a fold before\n-    \" jumping to any lines contained therein\n-    call extend(s:lines, [\n-\t  \\ \"\",\n-\t  \\ \"/* function to open any folds containing a jumped-to line before jumping to it */\",\n-\t  \\ \"function JumpToLine()\",\n-\t  \\ \"{\",\n-\t  \\ \"  var lineNum;\",\n-\t  \\ \"  lineNum = window.location.hash;\",\n-\t  \\ \"  lineNum = lineNum.substr(1); /* strip off '#' */\",\n-\t  \\ \"\",\n-\t  \\ \"  if (lineNum.indexOf('L') == -1) {\",\n-\t  \\ \"    lineNum = 'L'+lineNum;\",\n-\t  \\ \"  }\",\n-\t  \\ \"  var lineElem = document.getElementById(lineNum);\"\n-\t  \\ ])\n-\n-    if s:settings.dynamic_folds\n-      call extend(s:lines, [\n-\t    \\ \"\",\n-\t    \\ \"  /* navigate upwards in the DOM tree to open all folds containing the line */\",\n-\t    \\ \"  var node = lineElem;\",\n-\t    \\ \"  while (node && node.id != 'vimCodeElement\"..s:settings.id_suffix..\"')\",\n-\t    \\ \"  {\",\n-\t    \\ \"    if (node.className == 'closed-fold')\",\n-\t    \\ \"    {\",\n-\t    \\ \"      node.className = 'open-fold';\",\n-\t    \\ \"    }\",\n-\t    \\ \"    node = node.parentNode;\",\n-\t    \\ \"  }\",\n-\t    \\ ])\n-    endif\n-    call extend(s:lines, [\n-\t  \\ \"  /* Always jump to new location even if the line was hidden inside a fold, or\",\n-\t  \\ \"   * we corrected the raw number to a line ID.\",\n-\t  \\ \"   */\",\n-\t  \\ \"  if (lineElem) {\",\n-\t  \\ \"    lineElem.scrollIntoView(true);\",\n-\t  \\ \"  }\",\n-\t  \\ \"  return true;\",\n-\t  \\ \"}\",\n-\t  \\ \"if ('onhashchange' in window) {\",\n-\t  \\ \"  window.onhashchange = JumpToLine;\",\n-\t  \\ \"}\"\n-\t  \\ ])\n-  endif\n-\n-  \" insert script closing tag if needed\n-  if s:uses_script\n-    call extend(s:lines, [\n-\t  \\ '',\n-\t  \\ s:settings.use_xhtml ? '//]]>' : '-->',\n-\t  \\ \"</script>\"\n-\t  \\ ])\n-  endif\n-\n-  call extend(s:lines, [\"</head>\",\n-\t\\ \"<body\"..(s:settings.line_ids ? \" onload='JumpToLine();'\" : \"\")..\">\"])\n-endif\n-\n-if s:settings.no_pre\n-  \" if we're not using CSS we use a font tag which can't have a div inside\n-  if s:settings.use_css\n-    call extend(s:lines, [\"<div id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"<pre id='vimCodeElement\" .. s:settings.id_suffix .. \"'>\"])\n-endif\n-\n-exe s:orgwin .. \"wincmd w\"\n-\n-\" caches of style data\n-\" initialize to include line numbers if using them\n-if s:settings.number_lines\n-  let s:stylelist = { s:LINENR_ID : \".LineNr { \" .. s:CSS1( s:LINENR_ID ) .. \"}\" }\n-else\n-  let s:stylelist = {}\n-endif\n-let s:diffstylelist = {\n-      \\   s:DIFF_A_ID : \".DiffAdd { \" .. s:CSS1( s:DIFF_A_ID ) .. \"}\",\n-      \\   s:DIFF_C_ID : \".DiffChange { \" .. s:CSS1( s:DIFF_C_ID ) .. \"}\",\n-      \\   s:DIFF_D_ID : \".DiffDelete { \" .. s:CSS1( s:DIFF_D_ID ) .. \"}\",\n-      \\   s:DIFF_T_ID : \".DiffText { \" .. s:CSS1( s:DIFF_T_ID ) .. \"}\"\n-      \\ }\n-\n-\" set up progress bar in the status line\n-if !s:settings.no_progress\n-  \" ProgressBar Indicator\n-  let s:progressbar={}\n-\n-  \" Progressbar specific functions\n-\n-  func! s:SetProgbarColor()\n-    if hlID(\"TOhtmlProgress\") != 0\n-      hi! link TOhtmlProgress_auto TOhtmlProgress\n-    elseif hlID(\"TOhtmlProgress_auto\")==0 ||\n-       \\ !exists(\"s:last_colors_name\") || !exists(\"g:colors_name\") ||\n-       \\ g:colors_name != s:last_colors_name\n-      let s:last_colors_name = exists(\"g:colors_name\") ? g:colors_name : \"none\"\n-\n-      let l:diffatr = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-      let l:stlatr = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? \"fg#\" : \"bg#\"\n-\n-      let l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), l:diffatr, s:whatterm)\n-      let l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), l:stlatr, s:whatterm)\n-\n-      if \"\" == l:progbar_color\n-\tlet l:progbar_color = synIDattr(hlID(\"DiffDelete\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-      if \"\" == l:stl_color\n-\tlet l:stl_color = synIDattr(hlID(\"StatusLine\")->synIDtrans(), \"reverse\", s:whatterm) ? s:fgc : s:bgc\n-      endif\n-\n-      if l:progbar_color == l:stl_color\n-\tif s:whatterm == 'cterm'\n-\t  if l:progbar_color >= (&t_Co/2)\n-\t    let l:progbar_color-=1\n-\t  else\n-\t    let l:progbar_color+=1\n-\t  endif\n-\telse\n-\t  let l:rgb = map(matchlist(l:progbar_color, '#\\zs\\x\\x\\ze\\(\\x\\x\\)\\(\\x\\x\\)')[:2], 'str2nr(v:val, 16)')\n-\t  let l:avg = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t  if l:avg >= 128\n-\t    let l:avg_new = l:avg\n-\t    while l:avg - l:avg_new < 0x15\n-\t      let l:rgb = map(l:rgb, 'v:val * 3 / 4')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  else\n-\t    let l:avg_new = l:avg\n-\t    while l:avg_new - l:avg < 0x15\n-\t      let l:rgb = map(l:rgb, 'min([max([v:val, 4]) * 5 / 4, 255])')\n-\t      let l:avg_new = (l:rgb[0] + l:rgb[1] + l:rgb[2])/3\n-\t    endwhile\n-\t  endif\n-\t  let l:progbar_color = printf(\"#%02x%02x%02x\", l:rgb[0], l:rgb[1], l:rgb[2])\n-\tendif\n-\techomsg \"diff detected progbar color set to\" l:progbar_color\n-      endif\n-      exe \"hi TOhtmlProgress_auto\" s:whatterm..\"bg=\"..l:progbar_color\n-    endif\n-  endfun\n-\n-  func! s:ProgressBar(title, max_value, winnr)\n-    let pgb=copy(s:progressbar)\n-    let pgb.title = a:title..' '\n-    let pgb.max_value = a:max_value\n-    let pgb.winnr = a:winnr\n-    let pgb.cur_value = 0\n-\n-    let pgb.items = { 'title'   : { 'color' : 'Statusline' },\n-\t  \\'bar'     : { 'color' : 'Statusline' , 'fillcolor' : 'TOhtmlProgress_auto' , 'bg' : 'Statusline' } ,\n-\t  \\'counter' : { 'color' : 'Statusline' } }\n-    let pgb.last_value = 0\n-    let pgb.needs_redraw = 0\n-    \" Note that you must use len(split) instead of len() if you want to use \n-    \" unicode in title.\n-    \"\n-    \" Subtract 3 for spacing around the title.\n-    \" Subtract 4 for the percentage display.\n-    \" Subtract 2 for spacing before this.\n-    \" Subtract 2 more for the '|' on either side of the progress bar\n-    let pgb.subtractedlen=len(split(pgb.title, '\\zs'))+3+4+2+2\n-    let pgb.max_len = 0\n-    set laststatus=2\n-    return pgb\n-  endfun\n-\n-  \" Function: progressbar.calculate_ticks() {{{1\n-  func! s:progressbar.calculate_ticks(pb_len)\n-    if a:pb_len<=0\n-      let pb_len = 100\n-    else\n-      let pb_len = a:pb_len\n-    endif\n-    let self.progress_ticks = map(range(pb_len+1), \"v:val * self.max_value / pb_len\")\n-  endfun\n-\n-  \"Function: progressbar.paint()\n-  func! s:progressbar.paint()\n-    \" Recalculate widths.\n-    let max_len = winwidth(self.winnr)\n-    let pb_len = 0\n-    \" always true on first call because of initial value of self.max_len\n-    if max_len != self.max_len\n-      let self.max_len = max_len\n-\n-      \" Progressbar length\n-      let pb_len = max_len - self.subtractedlen\n-\n-      call self.calculate_ticks(pb_len)\n-\n-      let self.needs_redraw = 1\n-      let cur_value = 0\n-      let self.pb_len = pb_len\n-    else\n-      \" start searching at the last found index to make the search for the\n-      \" appropriate tick value normally take 0 or 1 comparisons\n-      let cur_value = self.last_value\n-      let pb_len = self.pb_len\n-    endif\n-\n-    let cur_val_max = pb_len > 0 ? pb_len : 100\n-\n-    \" find the current progress bar position based on precalculated thresholds\n-    while cur_value < cur_val_max && self.cur_value > self.progress_ticks[cur_value]\n-      let cur_value += 1\n-    endwhile\n-\n-    \" update progress bar\n-    if self.last_value != cur_value || self.needs_redraw || self.cur_value == self.max_value\n-      let self.needs_redraw = 1\n-      let self.last_value = cur_value\n-\n-      let t_color  = self.items.title.color\n-      let b_fcolor = self.items.bar.fillcolor\n-      let b_color  = self.items.bar.color\n-      let c_color  = self.items.counter.color\n-\n-      let stl =  \"%#\".t_color.\"#%-( \".self.title.\" %)\".\n-\t    \\\"%#\".b_color.\"#\".\n-\t    \\(pb_len>0 ?\n-\t    \\\t('|%#'.b_fcolor.\"#%-(\".repeat(\" \",cur_value).\"%)\".\n-\t    \\\t '%#'.b_color.\"#\".repeat(\" \",pb_len-cur_value).\"|\"):\n-\t    \\\t('')).\n-\t    \\\"%=%#\".c_color.\"#%( \".printf(\"%3.d \",100*self.cur_value/self.max_value).\"%% %)\"\n-      call setwinvar(self.winnr, '&stl', stl)\n-    endif\n-  endfun\n-\n-  func! s:progressbar.incr( ... )\n-    let self.cur_value += (a:0 ? a:1 : 1)\n-    \" if we were making a general-purpose progress bar, we'd need to limit to a\n-    \" lower limit as well, but since we always increment with a positive value\n-    \" in this script, we only need limit the upper value\n-    let self.cur_value = (self.cur_value > self.max_value ? self.max_value : self.cur_value)\n-    call self.paint()\n-  endfun\n-  \" }}}\n-  if s:settings.dynamic_folds\n-    \" to process folds we make two passes through each line\n-    let s:pgb = s:ProgressBar(\"Processing folds:\", line('$')*2, s:orgwin)\n-  endif\n-\n-  call s:SetProgbarColor()\n-endif\n-\n-let s:build_fun_lines = []\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-    func! s:Add_diff_fill(lnum)\n-      let l:filler = diff_filler(a:lnum)\n-      if l:filler > 0\n-\tlet l:to_insert = l:filler\n-\twhile l:to_insert > 0\n-\t  let l:new = repeat(s:difffillchar, 3)\n-\n-\t  if l:to_insert > 2 && l:to_insert < l:filler && !s:settings.whole_filler\n-\t    let l:new = l:new .. \" \" .. l:filler .. \" inserted lines \"\n-\t    let l:to_insert = 2\n-\t  endif\n-ENDLET\n-call add(s:build_fun_lines, [])\n-if !s:settings.no_pre\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" HTML line wrapping is off--go ahead and fill to the margin\n-\t  \" TODO: what about when CSS wrapping is turned on?\n-\t  let l:new = l:new .. repeat(s:difffillchar, &columns - strlen(l:new) - s:margin)\n-  ENDLET\n-else\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  let l:new = l:new .. repeat(s:difffillchar, 3)\n-  ENDLET\n-endif\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tlet l:new = s:HtmlFormat_d(l:new, s:DIFF_D_ID, 0)\n-ENDLET\n-if s:settings.number_lines\n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  \" Indent if line numbering is on. Indent gets style of line number\n-\t  \" column.\n-\t  let l:new = s:HtmlFormat_n(repeat(' ', s:margin), s:LINENR_ID, 0, 0) .. l:new\n-  ENDLET\n-endif\n-if s:settings.dynamic_folds && !s:settings.no_foldcolumn \n-  call add(s:build_fun_lines, [])\n-  let s:build_fun_lines[-1] =<< trim ENDLET\n-\t  if s:foldcolumn > 0\n-\t    \" Indent for foldcolumn if there is one. Assume it's empty, there should\n-\t    \" not be a fold for deleted lines in diff mode.\n-\t    let l:new = s:FoldColumn_fill() .. l:new\n-\t  endif\n-  ENDLET\n-endif\n-\" Ignore this comment, just bypassing a highlighting issue: if\n-call add(s:build_fun_lines, [])\n-let s:build_fun_lines[-1] =<< trim ENDLET\n-\tcall add(s:lines, l:new..s:HtmlEndline)\n-\tlet l:to_insert = l:to_insert - 1\n-      endwhile\n-    endif\n-  endfun\n-ENDLET\n-exec join(flatten(s:build_fun_lines), \"\\n\")\n-\n-\" First do some preprocessing for dynamic folding. Do this for the entire file\n-\" so we don't accidentally start within a closed fold or something.\n-let s:allfolds = []\n-\n-if s:settings.dynamic_folds\n-  let s:lnum = 1\n-  let s:end = line('$')\n-  \" save the fold text and set it to the default so we can find fold levels\n-  let s:foldtext_save = &foldtext\n-  setlocal foldtext&\n-\n-  \" we will set the foldcolumn in the html to the greater of the maximum fold\n-  \" level and the current foldcolumn setting\n-  let s:foldcolumn = &foldcolumn\n-\n-  \" get all info needed to describe currently closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      \" store fold info for later use\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      call add(s:allfolds, s:newfold)\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" close all folds to get info for originally open folds\n-  silent! %foldclose!\n-  let s:lnum = 1\n-\n-  \" the originally open folds will be all folds we encounter that aren't\n-  \" already in the list of closed folds\n-  while s:lnum <= s:end\n-    if foldclosed(s:lnum) == s:lnum\n-      \" default fold text has '+-' and then a number of dashes equal to fold\n-      \" level, so subtract 2 from index of first non-dash after the dashes\n-      \" in order to get the fold level of the current fold\n-      let s:level = match(foldtextresult(s:lnum), '+-*\\zs[^-]') - 2\n-      let s:newfold = {'firstline': s:lnum, 'lastline': foldclosedend(s:lnum), 'level': s:level,'type': \"closed-fold\"}\n-      \" only add the fold if we don't already have it\n-      if empty(s:allfolds) || index(s:allfolds, s:newfold) == -1\n-\tlet s:newfold.type = \"open-fold\"\n-\tcall add(s:allfolds, s:newfold)\n-      endif\n-      \" open the fold so we can find any contained folds\n-      execute s:lnum..\"foldopen\"\n-    else\n-      if !s:settings.no_progress\n-\tcall s:pgb.incr()\n-\tif s:pgb.needs_redraw\n-\t  redrawstatus\n-\t  let s:pgb.needs_redraw = 0\n-\tendif\n-      endif\n-      let s:lnum = s:lnum + 1\n-    endif\n-  endwhile\n-\n-  \" sort the folds so that we only ever need to look at the first item in the\n-  \" list of folds\n-  call sort(s:allfolds, \"s:FoldCompare\")\n-\n-  let &l:foldtext = s:foldtext_save\n-  unlet s:foldtext_save\n-\n-  \" close all folds again so we can get the fold text as we go\n-  silent! %foldclose!\n-\n-  \" Go through and remove folds we don't need to (or cannot) process in the\n-  \" current conversion range\n-  \"\n-  \" If a fold is removed which contains other folds, which are included, we need\n-  \" to adjust the level of the included folds as used by the conversion logic\n-  \" (avoiding special cases is good)\n-  \"\n-  \" Note any time we remove a fold, either all of the included folds are in it,\n-  \" or none of them, because we only remove a fold if neither its start nor its\n-  \" end are within the conversion range.\n-  let leveladjust = 0\n-  for afold in s:allfolds\n-    let removed = 0\n-    if exists(\"g:html_start_line\") && exists(\"g:html_end_line\")\n-      if afold.firstline < g:html_start_line\n-\tif afold.lastline <= g:html_end_line && afold.lastline >= g:html_start_line\n-\t  \" if a fold starts before the range to convert but stops within the\n-\t  \" range, we need to include it. Make it start on the first converted\n-\t  \" line.\n-\t  let afold.firstline = g:html_start_line\n-\telse\n-\t  \" if the fold lies outside the range or the start and stop enclose\n-\t  \" the entire range, don't bother parsing it\n-\t  call remove(s:allfolds, index(s:allfolds, afold))\n-\t  let removed = 1\n-\t  if afold.lastline > g:html_end_line\n-\t    let leveladjust += 1\n-\t  endif\n-\tendif\n-      elseif afold.firstline > g:html_end_line\n-\t\" If the entire fold lies outside the range we need to remove it.\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    elseif exists(\"g:html_start_line\")\n-      if afold.firstline < g:html_start_line\n-\t\" if there is no last line, but there is a first line, the end of the\n-\t\" fold will always lie within the region of interest, so keep it\n-\tlet afold.firstline = g:html_start_line\n-      endif\n-    elseif exists(\"g:html_end_line\")\n-      \" if there is no first line we default to the first line in the buffer so\n-      \" the fold start will always be included if the fold itself is included.\n-      \" If however the entire fold lies outside the range we need to remove it.\n-      if afold.firstline > g:html_end_line\n-\tcall remove(s:allfolds, index(s:allfolds, afold))\n-\tlet removed = 1\n-      endif\n-    endif\n-    if !removed\n-      let afold.level -= leveladjust\n-      if afold.level+1 > s:foldcolumn\n-\tlet s:foldcolumn = afold.level+1\n-      endif\n-    endif\n-  endfor\n-\n-  \" if we've removed folds containing the conversion range from processing,\n-  \" getting foldtext as we go won't know to open the removed folds, so the\n-  \" foldtext would be wrong; open them now.\n-  \"\n-  \" Note that only when a start and an end line is specified will a fold\n-  \" containing the current range ever be removed.\n-  while leveladjust > 0\n-    exe g:html_start_line..\"foldopen\"\n-    let leveladjust -= 1\n-  endwhile\n-endif\n-\n-\" Now loop over all lines in the original text to convert to html.\n-\" Use html_start_line and html_end_line if they are set.\n-if exists(\"g:html_start_line\")\n-  let s:lnum = html_start_line\n-  if s:lnum < 1 || s:lnum > line(\"$\")\n-    let s:lnum = 1\n-  endif\n-else\n-  let s:lnum = 1\n-endif\n-if exists(\"g:html_end_line\")\n-  let s:end = html_end_line\n-  if s:end < s:lnum || s:end > line(\"$\")\n-    let s:end = line(\"$\")\n-  endif\n-else\n-  let s:end = line(\"$\")\n-endif\n-\n-\" stack to keep track of all the folds containing the current line\n-let s:foldstack = []\n-\n-if !s:settings.no_progress\n-  let s:pgb = s:ProgressBar(\"Processing lines:\", s:end - s:lnum + 1, s:orgwin)\n-endif\n-\n-if s:settings.number_lines\n-  let s:margin = strlen(s:end) + 1\n-else\n-  let s:margin = 0\n-endif\n-\n-if has('folding') && !s:settings.ignore_folding\n-  let s:foldfillchar = &fillchars[matchend(&fillchars, 'fold:')]\n-  if s:foldfillchar == ''\n-    let s:foldfillchar = '-'\n-  endif\n-endif\n-let s:difffillchar = &fillchars[matchend(&fillchars, 'diff:')]\n-if s:difffillchar == ''\n-  let s:difffillchar = '-'\n-endif\n-\n-let s:foldId = 0\n-\n-if !s:settings.expand_tabs\n-  \" If keeping tabs, add them to printable characters so we keep them when\n-  \" formatting text (strtrans() doesn't replace printable chars)\n-  let s:old_isprint = &isprint\n-  setlocal isprint+=9\n-endif\n-\n-while s:lnum <= s:end\n-\n-  \" If there are filler lines for diff mode, show these above the line.\n-  call s:Add_diff_fill(s:lnum)\n-\n-  \" Start the line with the line number.\n-  if s:settings.number_lines\n-    let s:numcol = repeat(' ', s:margin - 1 - strlen(s:lnum)) .. s:lnum .. ' '\n-  endif\n-\n-  let s:new = \"\"\n-\n-  if has('folding') && !s:settings.ignore_folding && foldclosed(s:lnum) > -1 && !s:settings.dynamic_folds\n-    \"\n-    \" This is the beginning of a folded block (with no dynamic folding)\n-    let s:new = foldtextresult(s:lnum)\n-    if !s:settings.no_pre\n-      \" HTML line wrapping is off--go ahead and fill to the margin\n-      let s:new = s:new .. repeat(s:foldfillchar, &columns - strlen(s:new))\n-    endif\n-\n-    \" put numcol in a separate group for sake of unselectable text\n-    let s:new = (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, s:lnum): \"\") .. s:HtmlFormat_t(s:new, s:FOLDED_ID, 0)\n-\n-    \" Skip to the end of the fold\n-    let s:new_lnum = foldclosedend(s:lnum)\n-\n-    if !s:settings.no_progress\n-      call s:pgb.incr(s:new_lnum - s:lnum)\n-    endif\n-\n-    let s:lnum = s:new_lnum\n-\n-  else\n-    \"\n-    \" A line that is not folded, or doing dynamic folding.\n-    \"\n-    let s:line = getline(s:lnum)\n-    let s:len = strlen(s:line)\n-\n-    if s:settings.dynamic_folds\n-      \" First insert a closing for any open folds that end on this line\n-      while !empty(s:foldstack) && get(s:foldstack,0).lastline == s:lnum-1\n-\tlet s:new = s:new..\"</span></span>\"\n-\tcall remove(s:foldstack, 0)\n-      endwhile\n-\n-      \" Now insert an opening for any new folds that start on this line\n-      let s:firstfold = 1\n-      while !empty(s:allfolds) && get(s:allfolds,0).firstline == s:lnum\n-\tlet s:foldId = s:foldId + 1\n-\tlet s:new ..= \"<span id='\"\n-\tlet s:new ..= (exists('g:html_diff_win_num') ? \"win\"..g:html_diff_win_num : \"\")\n-\tlet s:new ..= \"fold\"..s:foldId..s:settings.id_suffix..\"' class='\"..s:allfolds[0].type..\"'>\"\n-\n-\n-\t\" Unless disabled, add a fold column for the opening line of a fold.\n-\t\"\n-\t\" Note that dynamic folds require using css so we just use css to take\n-\t\" care of the leading spaces rather than using &nbsp; in the case of\n-\t\" html_no_pre to make it easier\n-\tif !s:settings.no_foldcolumn\n-\t  \" add fold column that can open the new fold\n-\t  if s:allfolds[0].level > 1 && s:firstfold\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:allfolds[0].level - 1, 0, \"\",\n-\t\t  \\ 'toggle-open FoldColumn','javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  \" add the filler spaces separately from the '+' char so that it can be\n-\t  \" shown/hidden separately during a hover unfold\n-\t  let s:new = s:new .. s:FoldColumn_build(\"+\", 1, 0, \"\",\n-\t\t\\ 'toggle-open FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  \" If this is not the last fold we're opening on this line, we need\n-\t  \" to keep the filler spaces hidden if the fold is opened by mouse\n-\t  \" hover. If it is the last fold to open in the line, we shouldn't hide\n-\t  \" them, so don't apply the toggle-filler class.\n-\t  let s:new = s:new .. s:FoldColumn_build(\" \", 1, s:foldcolumn - s:allfolds[0].level - 1, \"\",\n-\t\t\\ 'toggle-open FoldColumn'.. (get(s:allfolds, 1, {'firstline': 0}).firstline == s:lnum ?\" toggle-filler\" :\"\"),\n-\t\t\\ 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\n-\t  \" add fold column that can close the new fold\n-\t  \" only add extra blank space if we aren't opening another fold on the\n-\t  \" same line\n-\t  if get(s:allfolds, 1, {'firstline': 0}).firstline != s:lnum\n-\t    let s:extra_space = s:foldcolumn - s:allfolds[0].level\n-\t  else\n-\t    let s:extra_space = 0\n-\t  endif\n-\t  if s:firstfold\n-\t    \" the first fold in a line has '|' characters from folds opened in\n-\t    \" previous lines, before the '-' for this fold\n-\t    let s:new ..= s:FoldColumn_build('|', s:allfolds[0].level - 1, s:extra_space, '-',\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  else\n-\t    \" any subsequent folds in the line only add a single '-'\n-\t    let s:new = s:new .. s:FoldColumn_build(\"-\", 1, s:extra_space, \"\",\n-\t\t  \\ 'toggle-closed FoldColumn', 'javascript:toggleFold(\"fold'..s:foldId..s:settings.id_suffix..'\");')\n-\t  endif\n-\t  let s:firstfold = 0\n-\tendif\n-\n-\t\" Add fold text, moving the span ending to the next line so collapsing\n-\t\" of folds works correctly.\n-\t\" Put numcol in a separate group for sake of unselectable text.\n-\tlet s:new = s:new .. (s:settings.number_lines ? s:HtmlFormat_n(s:numcol, s:FOLDED_ID, 0, 0) : \"\") .. substitute(s:HtmlFormat_t(foldtextresult(s:lnum), s:FOLDED_ID, 0), '</span>', s:HtmlEndline..'\\n\\0', '')\n-\tlet s:new = s:new .. \"<span class='fulltext'>\"\n-\n-\t\" open the fold now that we have the fold text to allow retrieval of\n-\t\" fold text for subsequent folds\n-\texecute s:lnum..\"foldopen\"\n-\tcall insert(s:foldstack, remove(s:allfolds,0))\n-\tlet s:foldstack[0].id = s:foldId\n-      endwhile\n-\n-      \" Unless disabled, add a fold column for other lines.\n-      \"\n-      \" Note that dynamic folds require using css so we just use css to take\n-      \" care of the leading spaces rather than using &nbsp; in the case of\n-      \" html_no_pre to make it easier\n-      if !s:settings.no_foldcolumn\n-\tif empty(s:foldstack)\n-\t  \" add the empty foldcolumn for unfolded lines if there is a fold\n-\t  \" column at all\n-\t  if s:foldcolumn > 0\n-\t    let s:new = s:new .. s:FoldColumn_fill()\n-\t  endif\n-\telse\n-\t  \" add the fold column for folds not on the opening line\n-\t  if get(s:foldstack, 0).firstline < s:lnum\n-\t    let s:new = s:new .. s:FoldColumn_build('|', s:foldstack[0].level, s:foldcolumn - s:foldstack[0].level, \"\",\n-\t\t  \\ 'FoldColumn', 'javascript:toggleFold(\"fold'..s:foldstack[0].id..s:settings.id_suffix..'\");')\n-\t  endif\n-\tendif\n-      endif\n-    endif\n-\n-    \" Now continue with the unfolded line text\n-    if s:settings.number_lines\n-      let s:new = s:new .. s:HtmlFormat_n(s:numcol, s:LINENR_ID, 0, s:lnum)\n-    elseif s:settings.line_ids\n-      let s:new = s:new .. s:HtmlFormat_n(\"\", s:LINENR_ID, 0, s:lnum)\n-    endif\n-\n-    \" Get the diff attribute, if any.\n-    let s:diffattr = diff_hlID(s:lnum, 1)\n-\n-    \" initialize conceal info to act like not concealed, just in case\n-    let s:concealinfo = [0, '']\n-\n-    \" Loop over each character in the line\n-    let s:col = 1\n-\n-    \" most of the time we won't use the diff_id, initialize to zero\n-    let s:diff_id = 0\n-\n-    while s:col <= s:len || (s:col == 1 && s:diffattr)\n-      let s:startcol = s:col \" The start column for processing text\n-      if !s:settings.ignore_conceal && has('conceal')\n-\tlet s:concealinfo = synconcealed(s:lnum, s:col)\n-      endif\n-      if !s:settings.ignore_conceal && s:concealinfo[0]\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in the match sequence number (ending\n-\t\" the specific concealed region) or until there are no more concealed\n-\t\" characters.\n-\twhile s:col <= s:len && s:concealinfo == synconcealed(s:lnum, s:col) | let s:col = s:col + 1 | endwhile\n-      elseif s:diffattr\n-\tlet s:diff_id = diff_hlID(s:lnum, s:col)\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in hlID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1)\n-\t      \\   && s:diff_id == diff_hlID(s:lnum, s:col) |\n-\t      \\     let s:col = s:col + 1 |\n-\t      \\ endwhile\n-\tif s:len < &columns && !s:settings.no_pre\n-\t  \" Add spaces at the end of the raw text line to extend the changed\n-\t  \" line to the full width.\n-\t  let s:line = s:line .. repeat(' ', &columns - virtcol([s:lnum, s:len]) - s:margin)\n-\t  let s:len = &columns\n-\tendif\n-      else\n-\tlet s:id = synID(s:lnum, s:col, 1)\n-\tlet s:col = s:col + 1\n-\t\" Speed loop (it's small - that's the trick)\n-\t\" Go along till we find a change in synID\n-\twhile s:col <= s:len && s:id == synID(s:lnum, s:col, 1) | let s:col = s:col + 1 | endwhile\n-      endif\n-\n-      if s:settings.ignore_conceal || !s:concealinfo[0]\n-\t\" Expand tabs if needed\n-\tlet s:expandedtab = strpart(s:line, s:startcol - 1, s:col - s:startcol)\n-\tif s:settings.expand_tabs\n-\t  let s:offset = 0\n-\t  let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  let s:tablist = exists(\"+vts\") ? split(&vts,',') : []\n-\t  if empty(s:tablist)\n-\t    let s:tablist = [ &ts ]\n-\t  endif\n-\t  let s:tabidx = 0\n-\t  let s:tabwidth = 0\n-\t  while s:idx >= 0\n-\t    if s:startcol + s:idx == 1\n-\t      let s:i = s:tablist[0]\n-\t    else\n-\t      \" Get the character, which could be multiple bytes, which falls\n-\t      \" immediately before the found tab. Extract it by matching a\n-\t      \" character just prior to the column where the tab matches.\n-\t      \" We'll use this to get the byte index of the character\n-\t      \" immediately preceding the tab, so we can then look up the\n-\t      \" virtual column that character appears in, to determine how\n-\t      \" much of the current tabstop has been used up.\n-\t      if s:idx == 0\n-\t\t\" if the found tab is the first character in the text being\n-\t\t\" processed, we need to get the character prior to the text,\n-\t\t\" given by startcol.\n-\t\tlet s:prevc = matchstr(s:line, '.\\%' .. (s:startcol + s:offset) .. 'c')\n-\t      else\n-\t\t\" Otherwise, the byte index of the tab into s:expandedtab is\n-\t\t\" given by s:idx.\n-\t\tlet s:prevc = matchstr(s:expandedtab, '.\\%' .. (s:idx + 1) .. 'c')\n-\t      endif\n-\t      let s:vcol = virtcol([s:lnum, s:startcol + s:idx + s:offset - len(s:prevc)])\n-\n-\t      \" find the tabstop interval to use for the tab we just found. Keep\n-\t      \" adding tabstops (which could be variable) until we would exceed\n-\t      \" the virtual screen position of the start of the found tab.\n-\t      while s:vcol >= s:tabwidth + s:tablist[s:tabidx]\n-\t\tlet s:tabwidth += s:tablist[s:tabidx]\n-\t\tif s:tabidx < len(s:tablist)-1\n-\t\t  let s:tabidx = s:tabidx+1\n-\t\tendif\n-\t      endwhile\n-\t      let s:i = s:tablist[s:tabidx] - (s:vcol - s:tabwidth)\n-\t    endif\n-\t    \" update offset to keep the index within the line corresponding to\n-\t    \" actual tab characters instead of replaced spaces; s:idx reflects\n-\t    \" replaced spaces in s:expandedtab, s:offset cancels out all but\n-\t    \" the tab character itself.\n-\t    let s:offset -= s:i - 1\n-\t    let s:expandedtab = substitute(s:expandedtab, '\\t', repeat(' ', s:i), '')\n-\t    let s:idx = stridx(s:expandedtab, \"\\t\")\n-\t  endwhile\n-\tend\n-\n-\t\" get the highlight group name to use\n-\tlet s:id = synIDtrans(s:id)\n-      else\n-\t\" use Conceal highlighting for concealed text\n-\tlet s:id = s:CONCEAL_ID\n-\tlet s:expandedtab = s:concealinfo[1]\n-      endif\n-\n-      \" Output the text with the same synID, with class set to the highlight ID\n-      \" name, unless it has been concealed completely.\n-      if strlen(s:expandedtab) > 0\n-\tlet s:new = s:new .. s:HtmlFormat(s:expandedtab,  s:id, s:diff_id, \"\", 0)\n-      endif\n-    endwhile\n-  endif\n-\n-  call extend(s:lines, split(s:new..s:HtmlEndline, '\\n', 1))\n-  if !s:settings.no_progress && s:pgb.needs_redraw\n-    redrawstatus\n-    let s:pgb.needs_redraw = 0\n-  endif\n-  let s:lnum = s:lnum + 1\n-\n-  if !s:settings.no_progress\n-    call s:pgb.incr()\n-  endif\n-endwhile\n-\n-\" Diff filler is returned based on what needs inserting *before* the given line.\n-\" So to get diff filler at the end of the buffer, we need to use last line + 1\n-call s:Add_diff_fill(s:end+1)\n-\n-if s:settings.dynamic_folds\n-  \" finish off any open folds\n-  while !empty(s:foldstack)\n-    let s:lines[-1]..=\"</span></span>\"\n-    call remove(s:foldstack, 0)\n-  endwhile\n-\n-  \" add fold column to the style list if not already there\n-  let s:id = s:FOLD_C_ID\n-  if !has_key(s:stylelist, s:id)\n-    let s:stylelist[s:id] = '.FoldColumn { ' .. s:CSS1(s:id) .. '}'\n-  endif\n-endif\n-\n-if s:settings.no_pre\n-  if !s:settings.use_css\n-    \" Close off the font tag that encapsulates the whole <body>\n-    call extend(s:lines, [\"</font>\"])\n-  else\n-    call extend(s:lines, [\"</div>\"])\n-  endif\n-else\n-  call extend(s:lines, [\"</pre>\"])\n-endif\n-if !s:settings.no_doc\n-  call extend(s:lines, [\"</body>\", \"</html>\"])\n-endif\n-\n-exe s:newwin .. \"wincmd w\"\n-call setline(1, s:lines)\n-unlet s:lines\n-\n-\" Mangle modelines so Vim doesn't try to use HTML text as a modeline if editing\n-\" this file in the future; need to do this after generating all the text in case\n-\" the modeline text has different highlight groups which all turn out to be\n-\" stripped from the final output.\n-%s!\\v(%(^|\\s+)%([Vv]i%(m%([<=>]?\\d+)?)?|ex)):!\\1\\&#0058;!ge\n-\n-\" The generated HTML is admittedly ugly and takes a LONG time to fold.\n-\" Make sure the user doesn't do syntax folding when loading a generated file,\n-\" using a modeline.\n-if !s:settings.no_modeline\n-  call append(line('$'), \"<!-- vim: set foldmethod=manual : -->\")\n-endif\n-\n-\" Now, when we finally know which, we define the colors and styles\n-if s:settings.use_css && !s:settings.no_doc\n-  1;/<style\\>/+1\n-\n-  \" Normal/global attributes\n-  if s:settings.no_pre\n-    call append('.', \"body { color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; font-family: \".. s:htmlfont ..\"; }\")\n-    +\n-  else\n-    call append('.', \"pre { \" .. s:whitespace .. \"font-family: \".. s:htmlfont ..\"; color: \" .. s:fgc .. \"; background-color: \" .. s:bgc .. \"; }\")\n-    +\n-    yank\n-    put\n-    execute \"normal! ^cwbody\\e\"\n-    \" body should not have the wrap formatting, only the pre section\n-    if s:whitespace != ''\n-      exec 's#'..s:whitespace\n-    endif\n-  endif\n-  \" fix browser inconsistencies (sometimes within the same browser) of different\n-  \" default font size for different elements\n-  call append('.', '* { font-size: 1em; }')\n-  +\n-  \" if we use any input elements for unselectable content, make sure they look\n-  \" like normal text\n-  if !empty(s:settings.prevent_copy)\n-    if s:settings.use_input_for_pc !=# \"none\"\n-      call append('.', 'input { border: none; margin: 0; padding: 0; font-family: '..s:htmlfont..'; }')\n-      +\n-      \" ch units for browsers which support them, em units for a somewhat\n-      \" reasonable fallback.\n-      for w in range(1, 20, 1)\n-\tcall append('.', [\n-\t      \\ \"input[size='\"..w..\"'] { width: \"..w..\"em; width: \"..w..\"ch; }\"\n-\t      \\ ])\n-\t+\n-      endfor\n-    endif\n-\n-    if s:settings.use_input_for_pc !=# 'all'\n-      let s:unselectable_styles = []\n-      if s:settings.prevent_copy =~# 'f'\n-\tcall add(s:unselectable_styles, 'FoldColumn')\n-      endif\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall add(s:unselectable_styles, 'LineNr')\n-      endif\n-      if s:settings.prevent_copy =~# 't' && !s:settings.ignore_folding\n-\tcall add(s:unselectable_styles, 'Folded')\n-      endif\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall add(s:unselectable_styles, 'DiffDelete')\n-      endif\n-      if s:settings.use_input_for_pc !=# 'none'\n-\tcall append('.', [\n-\t      \\ '/* Note: IE does not support @supports conditionals, but also does not fully support',\n-\t      \\ '   \"content:\" with custom content, so we *want* the check to fail */',\n-\t      \\ '@supports ( content: attr(data-custom-content) ) {'\n-\t      \\ ])\n-\t+3\n-      endif\n-      \" The line number column inside the foldtext is styled just like the fold\n-      \" text in Vim, but it should use the prevent_copy settings of line number\n-      \" rather than fold text. Apply the prevent_copy styles to foldtext\n-      \" specifically for line numbers, which always come after the fold column,\n-      \" or at the beginning of the line.\n-      if s:settings.prevent_copy =~# 'n' && !s:settings.ignore_folding\n-\tcall append('.', [\n-\t      \\ '  .FoldColumn + .Folded, .Folded:first-child { user-select: none; }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { content: attr(data-Folded-content); }',\n-\t      \\ '  .FoldColumn + [data-Folded-content]::before, [data-Folded-content]:first-child::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  .FoldColumn + span[data-Folded-content]::before, [data-Folded-content]:first-child::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endif\n-      for s:style_name in s:unselectable_styles\n-\tcall append('.', [\n-\t      \\ '  .'..s:style_name..' { user-select: none; }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { content: attr(data-'..s:style_name..'-content); }',\n-\t      \\ '  [data-'..s:style_name..'-content]::before { padding-bottom: 1px; display: inline-block; /* match the 1-px padding of standard items with background */ }',\n-\t      \\ '  span[data-'..s:style_name..'-content]::before { cursor: default; }',\n-\t      \\ ])\n-\t+4\n-      endfor\n-      if s:settings.use_input_for_pc !=# 'none'\n-\t\" Note, the extra '}' is to match the \"@supports\" above\n-\tcall append('.', [\n-\t      \\ '  input { display: none; }',\n-\t      \\ '}'\n-\t      \\ ])\n-\t+2\n-      endif\n-      unlet s:unselectable_styles\n-    endif\n-\n-    \" Fix mouse cursor shape for the fallback <input> method of uncopyable text\n-    if s:settings.use_input_for_pc !=# 'none'\n-      if s:settings.prevent_copy =~# 'f'\n-\t\" Make the cursor show active fold columns as active areas, and empty fold\n-\t\" columns as not interactive.\n-\tcall append('.', ['input.FoldColumn { cursor: pointer; }',\n-\t      \\ 'input.FoldColumn[value=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t      \\ ])\n-\t+2\n-\tif s:settings.use_input_for_pc !=# 'all'\n-\t  call append('.', [\n-\t\t\\ 'a[data-FoldColumn-content=\"'..repeat(' ', s:foldcolumn)..'\"] { cursor: default; }'\n-\t\t\\ ])\n-\t  +1\n-\tend\n-      endif\n-      \" make line number column show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'n'\n-\tcall append('.', 'input.LineNr { cursor: default; }')\n-\t+\n-      endif\n-      \" make fold text and line number column within fold text show as\n-      \" non-interactive if not selectable\n-      if (s:settings.prevent_copy =~# 'n' || s:settings.prevent_copy =~# 't') && !s:settings.ignore_folding\n-\tcall append('.', 'input.Folded { cursor: default; }')\n-\t+\n-      endif\n-      \" make diff filler show as non-interactive if not selectable\n-      if s:settings.prevent_copy =~# 'd'\n-\tcall append('.', 'input.DiffDelete { cursor: default; }')\n-\t+\n-      endif\n-    endif\n-  endif\n-endif\n-\n-if !s:settings.use_css && !s:settings.no_doc\n-  \" For Netscape 4, set <body> attributes too, though, strictly speaking, it's\n-  \" incorrect.\n-  execute '%s:<body\\([^>]*\\):<body bgcolor=\"' .. s:bgc .. '\" text=\"' .. s:fgc .. '\"\\1>\\r<font face=\"'.. s:htmlfont ..'\"'\n-endif\n-\n-\" Gather attributes for all other classes. Do diff first so that normal\n-\" highlight groups are inserted before it.\n-if s:settings.use_css && !s:settings.no_doc\n-  if s:diff_mode\n-    call append('.', filter(map(keys(s:diffstylelist), \"s:diffstylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-  if !empty(s:stylelist)\n-    call append('.', filter(map(keys(s:stylelist), \"s:stylelist[v:val]\"), 'v:val != \"\"'))\n-  endif\n-endif\n-\n-\" Add hyperlinks\n-if !s:settings.no_links\n-  %s+\\(https\\=://\\S\\{-}\\)\\(\\([.,;:}]\\=\\(\\s\\|$\\)\\)\\|[\\\\\"'<>]\\|&gt;\\|&lt;\\|&quot;\\)+<a href=\"\\1\">\\1</a>\\2+ge\n-endif\n-\n-\" The DTD\n-if !s:settings.no_doc\n-  if s:settings.use_xhtml\n-    exe \"normal! gg$a\\n<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\"\n-  elseif s:html5\n-    exe \"normal! gg0i<!DOCTYPE html>\\n\"\n-  else\n-    exe \"normal! gg0i<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\" \\\"http://www.w3.org/TR/html4/loose.dtd\\\">\\n\"\n-  endif\n-endif\n-\n-if s:settings.use_xhtml && !s:settings.no_doc\n-  exe \"normal! gg/<html/e\\na xmlns=\\\"http://www.w3.org/1999/xhtml\\\"\\e\"\n-endif\n-\n-\" Cleanup\n-%s:\\s\\+$::e\n-\n-\" Restore old settings (new window first)\n-\"\n-\" Don't bother restoring foldmethod in case it was syntax because the markup is\n-\" so weirdly formatted it can take a LONG time.\n-let &l:foldenable = s:old_fen\n-let &report = s:old_report\n-let &title = s:old_title\n-let &icon = s:old_icon\n-let &paste = s:old_paste\n-let &magic = s:old_magic\n-let @/ = s:old_search\n-let &more = s:old_more\n-\n-\" switch to original window to restore those settings\n-exe s:orgwin .. \"wincmd w\"\n-\n-if !s:settings.expand_tabs\n-  let &l:isprint = s:old_isprint\n-endif\n-let &l:stl = s:origwin_stl\n-let &l:et = s:old_et\n-let &l:scrollbind = s:old_bind\n-\n-\" and back to the new window again to end there\n-exe s:newwin .. \"wincmd w\"\n-\n-let &l:stl = s:newwin_stl\n-exec 'resize' s:old_winheight\n-let &l:winfixheight = s:old_winfixheight\n-\n-let &ls=s:ls\n-let &eventignore=s:ei_sav\n-\n-\" Save a little bit of memory (worth doing?)\n-unlet s:htmlfont s:whitespace\n-unlet s:old_et s:old_paste s:old_icon s:old_report s:old_title s:old_search\n-unlet s:old_magic s:old_more s:old_fen s:old_winheight\n-unlet! s:old_isprint\n-unlet s:whatterm s:stylelist s:diffstylelist s:lnum s:end s:margin s:fgc s:bgc s:old_winfixheight\n-unlet! s:col s:id s:attr s:len s:line s:new s:expandedtab s:concealinfo s:diff_mode\n-unlet! s:orgwin s:newwin s:orgbufnr s:idx s:i s:offset s:ls s:ei_sav s:origwin_stl\n-unlet! s:newwin_stl s:current_syntax\n-if !v:profiling\n-  delfunc s:HtmlColor\n-  delfunc s:HtmlFormat\n-  delfunc s:CSS1\n-  delfunc s:BuildStyleWrapper\n-  if !s:settings.use_css\n-    delfunc s:HtmlOpening\n-    delfunc s:HtmlClosing\n-  endif\n-  if s:settings.dynamic_folds\n-    delfunc s:FoldCompare\n-  endif\n-\n-  if !s:settings.no_progress\n-    delfunc s:ProgressBar\n-    delfunc s:progressbar.paint\n-    delfunc s:progressbar.incr\n-    unlet s:pgb s:progressbar\n-  endif\n-\n-  delfunc s:Add_diff_fill\n-endif\n-\n-unlet! s:new_lnum s:diffattr s:difffillchar s:foldfillchar s:HtmlSpace s:diffstyle\n-unlet! s:LeadingSpace s:HtmlEndline s:firstfold s:numcol s:foldcolumn\n-unlet! s:wrapperfunc_lines s:build_fun_lines\n-unlet s:foldstack s:allfolds s:foldId s:settings\n-\n-let &cpo = s:cpo_sav\n-unlet! s:cpo_sav\n-\n-\" Make sure any patches will probably use consistent indent\n-\"   vim: ts=8 sw=2 sts=2 noet\n+lua << EOF",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1466105439",
            "id": 1466105439,
            "in_reply_to_id": 1466063724,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XYv5f",
            "original_commit_id": "aa1a0309ce9c61f93c3cd69e012abbe4c8a03539",
            "original_line": 1,
            "original_position": 2069,
            "original_start_line": null,
            "path": "runtime/syntax/2html.vim",
            "position": null,
            "pull_request_review_id": 1843262472,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466105439/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-25T09:46:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1466105439",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473083677"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473083677"
                }
            },
            "author_association": "MEMBER",
            "body": "Wouldn't it make more sense for this to return a string? Then the user can write it to a file if they wish.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:08:48Z",
            "diff_hunk": "@@ -4308,4 +4308,29 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winnr}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473083677",
            "id": 1473083677,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzXkd",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 4315,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1854198735,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473083677/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:08:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473083677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473084941"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473084941"
                }
            },
            "author_association": "MEMBER",
            "body": "The Nvim API generally works with `winid`'s over `winnr`'s.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:09:42Z",
            "diff_hunk": "@@ -4308,4 +4308,29 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winnr}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*\n+    Converts a window to HTML.\n+\n+    Converts a window to HTML, including diffs and folds. Opens a slit window\n+    containing the converted HTML.                           *convert-to-HTML*\n+\n+    Can also be converted with `:TOhtml` .                           *:TOhtml*\n+\n+    Parameters: ~\n+       {winnr}    (`number?`) Defaults to current window.",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473084941",
            "id": 1473084941,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzX4N",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 4324,
            "original_position": 17,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1854200787,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473084941/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:09:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473084941",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473086329"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473086329"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- @field width? integer\r\n```\r\n\r\nAlways use `integer` where it makes sense.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:10:38Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473086329",
            "id": 1473086329,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzYN5",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 26,
            "original_position": 26,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473086329/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:25:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473086329",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473089500"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473089500"
                }
            },
            "author_association": "MEMBER",
            "body": "Please insert linebreaks in between classes. I initially thought this was one large class.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:12:46Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473089500",
            "id": 1473089500,
            "line": 41,
            "node_id": "PRRC_kwDOAPphoM5XzY_c",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 41,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": 41,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473089500/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473089500",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473091159"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473091159"
                }
            },
            "author_association": "MEMBER",
            "body": "What are the type of these?",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:13:50Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473091159",
            "id": 1473091159,
            "line": 174,
            "node_id": "PRRC_kwDOAPphoM5XzZZX",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 174,
            "original_position": 60,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": 174,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473091159/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473091159",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473094527"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473094527"
                }
            },
            "author_association": "MEMBER",
            "body": "I think it might be better to pull these tables out as named constants.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:14:59Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil\n+\n+--- @param colorstr string\n+--- @return string\n+local function cterm_to_hex(colorstr)\n+  if colorstr:sub(1, 1) == '#' then\n+    return colorstr\n+  end\n+  assert(colorstr ~= '')\n+  local color = tonumber(colorstr)\n+  assert(color and 0 <= color and color <= 255)\n+  if cterm_color_cache[color] then\n+    return cterm_color_cache[color]\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]4;%d*;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write(('\\027]4;%s;?\\027\\\\'):format(color))\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if hex then\n+    cterm_color_cache[color] = hex\n+  else\n+    --If the terminal didn't respond, set the colors to a fallback value\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal colors, using fallback\")\n+    local t_Co = tonumber(vim.api.nvim_eval('&t_Co'))\n+    if t_Co == 8 then\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+    else\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#000000\", \"#c00000\", \"#008000\", \"#804000\",\n+        \"#0000c0\", \"#c000c0\", \"#008080\", \"#c0c0c0\",\n+        \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+      if t_Co == 88 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00008b\", \"#0000cd\", \"#0000ff\",",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473094527",
            "id": 1473094527,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzaN_",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 119,
            "original_position": 112,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473094527/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473094527",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473097925"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473097925"
                }
            },
            "author_association": "MEMBER",
            "body": "Can this be pulled out into a more generic function like `query_terminal()`?",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:16:48Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil\n+\n+--- @param colorstr string\n+--- @return string\n+local function cterm_to_hex(colorstr)\n+  if colorstr:sub(1, 1) == '#' then\n+    return colorstr\n+  end\n+  assert(colorstr ~= '')\n+  local color = tonumber(colorstr)\n+  assert(color and 0 <= color and color <= 255)\n+  if cterm_color_cache[color] then\n+    return cterm_color_cache[color]\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]4;%d*;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write(('\\027]4;%s;?\\027\\\\'):format(color))\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if hex then\n+    cterm_color_cache[color] = hex\n+  else\n+    --If the terminal didn't respond, set the colors to a fallback value\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal colors, using fallback\")\n+    local t_Co = tonumber(vim.api.nvim_eval('&t_Co'))\n+    if t_Co == 8 then\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+    else\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#000000\", \"#c00000\", \"#008000\", \"#804000\",\n+        \"#0000c0\", \"#c000c0\", \"#008080\", \"#c0c0c0\",\n+        \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+      if t_Co == 88 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00008b\", \"#0000cd\", \"#0000ff\",\n+          \"#008b00\", \"#008b8b\", \"#008bcd\", \"#008bff\",\n+          \"#00cd00\", \"#00cd8b\", \"#00cdcd\", \"#00cdff\",\n+          \"#00ff00\", \"#00ff8b\", \"#00ffcd\", \"#00ffff\",\n+          \"#8b0000\", \"#8b008b\", \"#8b00cd\", \"#8b00ff\",\n+          \"#8b8b00\", \"#8b8b8b\", \"#8b8bcd\", \"#8b8bff\",\n+          \"#8bcd00\", \"#8bcd8b\", \"#8bcdcd\", \"#8bcdff\",\n+          \"#8bff00\", \"#8bff8b\", \"#8bffcd\", \"#8bffff\",\n+          \"#cd0000\", \"#cd008b\", \"#cd00cd\", \"#cd00ff\",\n+          \"#cd8b00\", \"#cd8b8b\", \"#cd8bcd\", \"#cd8bff\",\n+          \"#cdcd00\", \"#cdcd8b\", \"#cdcdcd\", \"#cdcdff\",\n+          \"#cdff00\", \"#cdff8b\", \"#cdffcd\", \"#cdffff\",\n+          \"#ff0000\", \"#ff008b\", \"#ff00cd\", \"#ff00ff\",\n+          \"#ff8b00\", \"#ff8b8b\", \"#ff8bcd\", \"#ff8bff\",\n+          \"#ffcd00\", \"#ffcd8b\", \"#ffcdcd\", \"#ffcdff\",\n+          \"#ffff00\", \"#ffff8b\", \"#ffffcd\", \"#ffffff\",\n+          \"#2e2e2e\", \"#5c5c5c\", \"#737373\", \"#8b8b8b\",\n+          \"#a2a2a2\", \"#b9b9b9\", \"#d0d0d0\", \"#e7e7e7\",\n+        })\n+      elseif t_Co == 256 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00005f\", \"#000087\", \"#0000af\",\n+          \"#0000d7\", \"#0000ff\", \"#005f00\", \"#005f5f\",\n+          \"#005f87\", \"#005faf\", \"#005fd7\", \"#005fff\",\n+          \"#008700\", \"#00875f\", \"#008787\", \"#0087af\",\n+          \"#0087d7\", \"#0087ff\", \"#00af00\", \"#00af5f\",\n+          \"#00af87\", \"#00afaf\", \"#00afd7\", \"#00afff\",\n+          \"#00d700\", \"#00d75f\", \"#00d787\", \"#00d7af\",\n+          \"#00d7d7\", \"#00d7ff\", \"#00ff00\", \"#00ff5f\",\n+          \"#00ff87\", \"#00ffaf\", \"#00ffd7\", \"#00ffff\",\n+          \"#5f0000\", \"#5f005f\", \"#5f0087\", \"#5f00af\",\n+          \"#5f00d7\", \"#5f00ff\", \"#5f5f00\", \"#5f5f5f\",\n+          \"#5f5f87\", \"#5f5faf\", \"#5f5fd7\", \"#5f5fff\",\n+          \"#5f8700\", \"#5f875f\", \"#5f8787\", \"#5f87af\",\n+          \"#5f87d7\", \"#5f87ff\", \"#5faf00\", \"#5faf5f\",\n+          \"#5faf87\", \"#5fafaf\", \"#5fafd7\", \"#5fafff\",\n+          \"#5fd700\", \"#5fd75f\", \"#5fd787\", \"#5fd7af\",\n+          \"#5fd7d7\", \"#5fd7ff\", \"#5fff00\", \"#5fff5f\",\n+          \"#5fff87\", \"#5fffaf\", \"#5fffd7\", \"#5fffff\",\n+          \"#870000\", \"#87005f\", \"#870087\", \"#8700af\",\n+          \"#8700d7\", \"#8700ff\", \"#875f00\", \"#875f5f\",\n+          \"#875f87\", \"#875faf\", \"#875fd7\", \"#875fff\",\n+          \"#878700\", \"#87875f\", \"#878787\", \"#8787af\",\n+          \"#8787d7\", \"#8787ff\", \"#87af00\", \"#87af5f\",\n+          \"#87af87\", \"#87afaf\", \"#87afd7\", \"#87afff\",\n+          \"#87d700\", \"#87d75f\", \"#87d787\", \"#87d7af\",\n+          \"#87d7d7\", \"#87d7ff\", \"#87ff00\", \"#87ff5f\",\n+          \"#87ff87\", \"#87ffaf\", \"#87ffd7\", \"#87ffff\",\n+          \"#af0000\", \"#af005f\", \"#af0087\", \"#af00af\",\n+          \"#af00d7\", \"#af00ff\", \"#af5f00\", \"#af5f5f\",\n+          \"#af5f87\", \"#af5faf\", \"#af5fd7\", \"#af5fff\",\n+          \"#af8700\", \"#af875f\", \"#af8787\", \"#af87af\",\n+          \"#af87d7\", \"#af87ff\", \"#afaf00\", \"#afaf5f\",\n+          \"#afaf87\", \"#afafaf\", \"#afafd7\", \"#afafff\",\n+          \"#afd700\", \"#afd75f\", \"#afd787\", \"#afd7af\",\n+          \"#afd7d7\", \"#afd7ff\", \"#afff00\", \"#afff5f\",\n+          \"#afff87\", \"#afffaf\", \"#afffd7\", \"#afffff\",\n+          \"#d70000\", \"#d7005f\", \"#d70087\", \"#d700af\",\n+          \"#d700d7\", \"#d700ff\", \"#d75f00\", \"#d75f5f\",\n+          \"#d75f87\", \"#d75faf\", \"#d75fd7\", \"#d75fff\",\n+          \"#d78700\", \"#d7875f\", \"#d78787\", \"#d787af\",\n+          \"#d787d7\", \"#d787ff\", \"#d7af00\", \"#d7af5f\",\n+          \"#d7af87\", \"#d7afaf\", \"#d7afd7\", \"#d7afff\",\n+          \"#d7d700\", \"#d7d75f\", \"#d7d787\", \"#d7d7af\",\n+          \"#d7d7d7\", \"#d7d7ff\", \"#d7ff00\", \"#d7ff5f\",\n+          \"#d7ff87\", \"#d7ffaf\", \"#d7ffd7\", \"#d7ffff\",\n+          \"#ff0000\", \"#ff005f\", \"#ff0087\", \"#ff00af\",\n+          \"#ff00d7\", \"#ff00ff\", \"#ff5f00\", \"#ff5f5f\",\n+          \"#ff5f87\", \"#ff5faf\", \"#ff5fd7\", \"#ff5fff\",\n+          \"#ff8700\", \"#ff875f\", \"#ff8787\", \"#ff87af\",\n+          \"#ff87d7\", \"#ff87ff\", \"#ffaf00\", \"#ffaf5f\",\n+          \"#ffaf87\", \"#ffafaf\", \"#ffafd7\", \"#ffafff\",\n+          \"#ffd700\", \"#ffd75f\", \"#ffd787\", \"#ffd7af\",\n+          \"#ffd7d7\", \"#ffd7ff\", \"#ffff00\", \"#ffff5f\",\n+          \"#ffff87\", \"#ffffaf\", \"#ffffd7\", \"#ffffff\",\n+          \"#080808\", \"#121212\", \"#1c1c1c\", \"#262626\",\n+          \"#303030\", \"#3a3a3a\", \"#444444\", \"#4e4e4e\",\n+          \"#585858\", \"#626262\", \"#6c6c6c\", \"#767676\",\n+          \"#808080\", \"#8a8a8a\", \"#949494\", \"#9e9e9e\",\n+          \"#a8a8a8\", \"#b2b2b2\", \"#bcbcbc\", \"#c6c6c6\",\n+          \"#d0d0d0\", \"#dadada\", \"#e4e4e4\", \"#eeeeee\",\n+        })\n+      end\n+    end\n+  end\n+  return cterm_color_cache[color]\n+end\n+\n+--- @return string\n+local function get_background_color()\n+  local bg = vim.fn.synIDattr(vim.fn.hlID('Normal'), 'bg#')\n+  if bg ~= '' then\n+    return cterm_to_hex(bg)\n+  end\n+  if background_color_cache then\n+    return background_color_cache\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]11;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write('\\027]11;?\\027\\\\')\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473097925",
            "id": 1473097925,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzbDF",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 240,
            "original_position": 224,
            "original_start_line": 212,
            "path": "runtime/lua/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473097925/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473097925",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473101162"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473101162"
                }
            },
            "author_association": "MEMBER",
            "body": "This function is quite a handful. Can it be broken down.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:19:08Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil\n+\n+--- @param colorstr string\n+--- @return string\n+local function cterm_to_hex(colorstr)\n+  if colorstr:sub(1, 1) == '#' then\n+    return colorstr\n+  end\n+  assert(colorstr ~= '')\n+  local color = tonumber(colorstr)\n+  assert(color and 0 <= color and color <= 255)\n+  if cterm_color_cache[color] then\n+    return cterm_color_cache[color]\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]4;%d*;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write(('\\027]4;%s;?\\027\\\\'):format(color))\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if hex then\n+    cterm_color_cache[color] = hex\n+  else\n+    --If the terminal didn't respond, set the colors to a fallback value\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal colors, using fallback\")\n+    local t_Co = tonumber(vim.api.nvim_eval('&t_Co'))\n+    if t_Co == 8 then\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+    else\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#000000\", \"#c00000\", \"#008000\", \"#804000\",\n+        \"#0000c0\", \"#c000c0\", \"#008080\", \"#c0c0c0\",\n+        \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+      if t_Co == 88 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00008b\", \"#0000cd\", \"#0000ff\",\n+          \"#008b00\", \"#008b8b\", \"#008bcd\", \"#008bff\",\n+          \"#00cd00\", \"#00cd8b\", \"#00cdcd\", \"#00cdff\",\n+          \"#00ff00\", \"#00ff8b\", \"#00ffcd\", \"#00ffff\",\n+          \"#8b0000\", \"#8b008b\", \"#8b00cd\", \"#8b00ff\",\n+          \"#8b8b00\", \"#8b8b8b\", \"#8b8bcd\", \"#8b8bff\",\n+          \"#8bcd00\", \"#8bcd8b\", \"#8bcdcd\", \"#8bcdff\",\n+          \"#8bff00\", \"#8bff8b\", \"#8bffcd\", \"#8bffff\",\n+          \"#cd0000\", \"#cd008b\", \"#cd00cd\", \"#cd00ff\",\n+          \"#cd8b00\", \"#cd8b8b\", \"#cd8bcd\", \"#cd8bff\",\n+          \"#cdcd00\", \"#cdcd8b\", \"#cdcdcd\", \"#cdcdff\",\n+          \"#cdff00\", \"#cdff8b\", \"#cdffcd\", \"#cdffff\",\n+          \"#ff0000\", \"#ff008b\", \"#ff00cd\", \"#ff00ff\",\n+          \"#ff8b00\", \"#ff8b8b\", \"#ff8bcd\", \"#ff8bff\",\n+          \"#ffcd00\", \"#ffcd8b\", \"#ffcdcd\", \"#ffcdff\",\n+          \"#ffff00\", \"#ffff8b\", \"#ffffcd\", \"#ffffff\",\n+          \"#2e2e2e\", \"#5c5c5c\", \"#737373\", \"#8b8b8b\",\n+          \"#a2a2a2\", \"#b9b9b9\", \"#d0d0d0\", \"#e7e7e7\",\n+        })\n+      elseif t_Co == 256 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00005f\", \"#000087\", \"#0000af\",\n+          \"#0000d7\", \"#0000ff\", \"#005f00\", \"#005f5f\",\n+          \"#005f87\", \"#005faf\", \"#005fd7\", \"#005fff\",\n+          \"#008700\", \"#00875f\", \"#008787\", \"#0087af\",\n+          \"#0087d7\", \"#0087ff\", \"#00af00\", \"#00af5f\",\n+          \"#00af87\", \"#00afaf\", \"#00afd7\", \"#00afff\",\n+          \"#00d700\", \"#00d75f\", \"#00d787\", \"#00d7af\",\n+          \"#00d7d7\", \"#00d7ff\", \"#00ff00\", \"#00ff5f\",\n+          \"#00ff87\", \"#00ffaf\", \"#00ffd7\", \"#00ffff\",\n+          \"#5f0000\", \"#5f005f\", \"#5f0087\", \"#5f00af\",\n+          \"#5f00d7\", \"#5f00ff\", \"#5f5f00\", \"#5f5f5f\",\n+          \"#5f5f87\", \"#5f5faf\", \"#5f5fd7\", \"#5f5fff\",\n+          \"#5f8700\", \"#5f875f\", \"#5f8787\", \"#5f87af\",\n+          \"#5f87d7\", \"#5f87ff\", \"#5faf00\", \"#5faf5f\",\n+          \"#5faf87\", \"#5fafaf\", \"#5fafd7\", \"#5fafff\",\n+          \"#5fd700\", \"#5fd75f\", \"#5fd787\", \"#5fd7af\",\n+          \"#5fd7d7\", \"#5fd7ff\", \"#5fff00\", \"#5fff5f\",\n+          \"#5fff87\", \"#5fffaf\", \"#5fffd7\", \"#5fffff\",\n+          \"#870000\", \"#87005f\", \"#870087\", \"#8700af\",\n+          \"#8700d7\", \"#8700ff\", \"#875f00\", \"#875f5f\",\n+          \"#875f87\", \"#875faf\", \"#875fd7\", \"#875fff\",\n+          \"#878700\", \"#87875f\", \"#878787\", \"#8787af\",\n+          \"#8787d7\", \"#8787ff\", \"#87af00\", \"#87af5f\",\n+          \"#87af87\", \"#87afaf\", \"#87afd7\", \"#87afff\",\n+          \"#87d700\", \"#87d75f\", \"#87d787\", \"#87d7af\",\n+          \"#87d7d7\", \"#87d7ff\", \"#87ff00\", \"#87ff5f\",\n+          \"#87ff87\", \"#87ffaf\", \"#87ffd7\", \"#87ffff\",\n+          \"#af0000\", \"#af005f\", \"#af0087\", \"#af00af\",\n+          \"#af00d7\", \"#af00ff\", \"#af5f00\", \"#af5f5f\",\n+          \"#af5f87\", \"#af5faf\", \"#af5fd7\", \"#af5fff\",\n+          \"#af8700\", \"#af875f\", \"#af8787\", \"#af87af\",\n+          \"#af87d7\", \"#af87ff\", \"#afaf00\", \"#afaf5f\",\n+          \"#afaf87\", \"#afafaf\", \"#afafd7\", \"#afafff\",\n+          \"#afd700\", \"#afd75f\", \"#afd787\", \"#afd7af\",\n+          \"#afd7d7\", \"#afd7ff\", \"#afff00\", \"#afff5f\",\n+          \"#afff87\", \"#afffaf\", \"#afffd7\", \"#afffff\",\n+          \"#d70000\", \"#d7005f\", \"#d70087\", \"#d700af\",\n+          \"#d700d7\", \"#d700ff\", \"#d75f00\", \"#d75f5f\",\n+          \"#d75f87\", \"#d75faf\", \"#d75fd7\", \"#d75fff\",\n+          \"#d78700\", \"#d7875f\", \"#d78787\", \"#d787af\",\n+          \"#d787d7\", \"#d787ff\", \"#d7af00\", \"#d7af5f\",\n+          \"#d7af87\", \"#d7afaf\", \"#d7afd7\", \"#d7afff\",\n+          \"#d7d700\", \"#d7d75f\", \"#d7d787\", \"#d7d7af\",\n+          \"#d7d7d7\", \"#d7d7ff\", \"#d7ff00\", \"#d7ff5f\",\n+          \"#d7ff87\", \"#d7ffaf\", \"#d7ffd7\", \"#d7ffff\",\n+          \"#ff0000\", \"#ff005f\", \"#ff0087\", \"#ff00af\",\n+          \"#ff00d7\", \"#ff00ff\", \"#ff5f00\", \"#ff5f5f\",\n+          \"#ff5f87\", \"#ff5faf\", \"#ff5fd7\", \"#ff5fff\",\n+          \"#ff8700\", \"#ff875f\", \"#ff8787\", \"#ff87af\",\n+          \"#ff87d7\", \"#ff87ff\", \"#ffaf00\", \"#ffaf5f\",\n+          \"#ffaf87\", \"#ffafaf\", \"#ffafd7\", \"#ffafff\",\n+          \"#ffd700\", \"#ffd75f\", \"#ffd787\", \"#ffd7af\",\n+          \"#ffd7d7\", \"#ffd7ff\", \"#ffff00\", \"#ffff5f\",\n+          \"#ffff87\", \"#ffffaf\", \"#ffffd7\", \"#ffffff\",\n+          \"#080808\", \"#121212\", \"#1c1c1c\", \"#262626\",\n+          \"#303030\", \"#3a3a3a\", \"#444444\", \"#4e4e4e\",\n+          \"#585858\", \"#626262\", \"#6c6c6c\", \"#767676\",\n+          \"#808080\", \"#8a8a8a\", \"#949494\", \"#9e9e9e\",\n+          \"#a8a8a8\", \"#b2b2b2\", \"#bcbcbc\", \"#c6c6c6\",\n+          \"#d0d0d0\", \"#dadada\", \"#e4e4e4\", \"#eeeeee\",\n+        })\n+      end\n+    end\n+  end\n+  return cterm_color_cache[color]\n+end\n+\n+--- @return string\n+local function get_background_color()\n+  local bg = vim.fn.synIDattr(vim.fn.hlID('Normal'), 'bg#')\n+  if bg ~= '' then\n+    return cterm_to_hex(bg)\n+  end\n+  if background_color_cache then\n+    return background_color_cache\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]11;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write('\\027]11;?\\027\\\\')\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if not hex or not hex:match('#%x%x%x%x%x%x') then\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal background colors, using fallback\")\n+    hex = vim.o.background == 'light' and '#ffffff' or '#000000'\n+  end\n+  background_color_cache = hex\n+  return hex\n+end\n+\n+--- @return string\n+local function get_foreground_color()\n+  local fg = vim.fn.synIDattr(vim.fn.hlID('Normal'), 'fg#')\n+  if fg ~= '' then\n+    return cterm_to_hex(fg)\n+  end\n+  if foreground_color_cache then\n+    return foreground_color_cache\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]10;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write('\\027]10;?\\027\\\\')\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if not hex or not hex:match('#%x%x%x%x%x%x') then\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal foreground colors, using fallback\")\n+    hex = vim.o.background == 'light' and '#000000' or '#ffffff'\n+  end\n+  foreground_color_cache = hex\n+  return hex\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param field number\n+--- @param val any\n+local function _style_line_insert(style_line, col, field, val)\n+  if style_line[col] == nil then\n+    style_line[col] = { {}, {}, {}, {} }\n+  end\n+  table.insert(style_line[col][field], val)\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param val any[]\n+local function style_line_insert_overlay_char(style_line, col, val)\n+  _style_line_insert(style_line, col, 4, val)\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param val any[]\n+local function style_line_insert_virt_text(style_line, col, val)\n+  _style_line_insert(style_line, col, 3, val)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param hl string|number|nil\n+--- @return nil|number\n+local function register_hl(state, hl)\n+  if type(hl) == 'nil' then\n+    return\n+  elseif type(hl) == 'string' then\n+    hl = vim.fn.hlID(hl)\n+    assert(hl ~= 0)\n+  end\n+  hl = vim.fn.synIDtrans(hl)\n+  if not state.highlights_name[hl] then\n+    local name = vim.fn.synIDattr(hl, 'name')\n+    assert(name ~= '')\n+    state.highlights_name[hl] = name\n+  end\n+  return hl\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param start_row number (1-index)\n+--- @param start_col number (1-index)\n+--- @param end_row number (1-index)\n+--- @param end_col number (1-index)\n+--- @param conceal_text string\n+--- @param hl_group string|number?\n+local function styletable_insert_conceal(\n+  state,\n+  start_row,\n+  start_col,\n+  end_row,\n+  end_col,\n+  conceal_text,\n+  hl_group\n+)\n+  assert(state.opt.conceallevel > 0)\n+  local styletable = state.style\n+  if start_col == end_col and start_row == end_row then\n+    return\n+  end\n+  if state.opt.conceallevel == 1 and conceal_text == '' then\n+    conceal_text = vim.opt_local.listchars:get().conceal or ' '\n+  end\n+  local hlid = register_hl(state, hl_group)\n+  if vim.wo[state.winnr].conceallevel ~= 3 then\n+    _style_line_insert(styletable[start_row], start_col, 3, { conceal_text, hlid })\n+  end\n+  _style_line_insert(styletable[start_row], start_col, 1, HIDE_ID)\n+  _style_line_insert(styletable[end_row], end_col, 2, HIDE_ID)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param start_row number (1-index)\n+--- @param start_col number (1-index)\n+--- @param end_row number (1-index)\n+--- @param end_col number (1-index)\n+--- @param hl_group string|number|nil\n+local function styletable_insert_range(state, start_row, start_col, end_row, end_col, hl_group)\n+  if start_col == end_col and start_row == end_row or not hl_group then\n+    return\n+  end\n+  local styletable = state.style\n+  _style_line_insert(styletable[start_row], start_col, 1, hl_group)\n+  _style_line_insert(styletable[end_row], end_col, 2, hl_group)\n+end\n+\n+--- @param bufnr number\n+--- @return vim.tohtml.styletable\n+local function generate_styletable(bufnr)\n+  --- @type vim.tohtml.styletable\n+  local styletable = {}\n+  for row = 1, vim.api.nvim_buf_line_count(bufnr) + 1 do\n+    styletable[row] = { virt_lines = {}, pre_text = {} }\n+  end\n+  return styletable\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_syntax(state)\n+  for row = 1, state.buflen do\n+    local prev_id = 0\n+    local prev_col = nil\n+    for col = 1, #vim.fn.getline(row) + 1 do\n+      local hlid = vim.fn.synID(row, col, 1)\n+      hlid = hlid == 0 and 0 or assert(register_hl(state, hlid))\n+      if hlid ~= prev_id then\n+        if prev_id ~= 0 then\n+          styletable_insert_range(state, row, assert(prev_col), row, col, prev_id)\n+        end\n+        prev_col = col\n+        prev_id = hlid\n+      end\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_diff(state)\n+  local styletable = state.style\n+  for row = 1, state.buflen do\n+    local style_line = styletable[row]\n+    local filler = vim.fn.diff_filler(row)\n+    if filler ~= 0 then\n+      local fill = (vim.opt_local.fillchars:get().diff or '-')\n+      table.insert(\n+        style_line.virt_lines,\n+        { { fill:rep(state.width), register_hl(state, 'DiffDelete') } }\n+      )\n+    end\n+    if row == state.buflen + 1 then\n+      break\n+    end\n+    local prev_id = 0\n+    local prev_col = nil\n+    for col = 1, #vim.fn.getline(row) do\n+      local hlid = vim.fn.diff_hlID(row, col)\n+      hlid = hlid == 0 and 0 or assert(register_hl(state, hlid))\n+      if hlid ~= prev_id then\n+        if prev_id ~= 0 then\n+          styletable_insert_range(state, row, assert(prev_col), row, col, prev_id)\n+        end\n+        prev_col = col\n+        prev_id = hlid\n+      end\n+    end\n+    if prev_id ~= 0 then\n+      styletable_insert_range(state, row, assert(prev_col), row, #vim.fn.getline(row) + 1, prev_id)\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_treesitter(state)\n+  local bufnr = state.bufnr\n+  local buf_highlighter = vim.treesitter.highlighter.active[bufnr]\n+  if not buf_highlighter then\n+    return\n+  end\n+  buf_highlighter.tree:parse(true)\n+  buf_highlighter.tree:for_each_tree(function(tstree, tree)\n+    --- @cast tree LanguageTree\n+    if not tstree then\n+      return\n+    end\n+    local root = tstree:root()\n+    local q = buf_highlighter:get_query(tree:lang())\n+    --- @type Query?\n+    local query = q:query()\n+    if not query then\n+      return\n+    end\n+    for capture, node, metadata in query:iter_captures(root, buf_highlighter.bufnr, 0, state.buflen) do\n+      local srow, scol, erow, ecol = node:range()\n+      --- @diagnostic disable-next-line: invisible\n+      local c = q._query.captures[capture]\n+      if c ~= nil then\n+        local hlid = register_hl(state, '@' .. c .. '.' .. tree:lang())\n+        if metadata.conceal and state.opt.conceallevel ~= 0 then\n+          styletable_insert_conceal(state, srow + 1, scol + 1, erow + 1, ecol + 1, metadata.conceal)\n+        end\n+        styletable_insert_range(state, srow + 1, scol + 1, erow + 1, ecol + 1, hlid)\n+      end\n+    end\n+  end)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+--- @param namespaces table<number,string>\n+local function _styletable_extmarks_highlight(state, extmark, namespaces)\n+  if not extmark[4].hl_group then\n+    return\n+  end\n+  ---TODO(altermo) LSP semantic tokens (and some other extmarks) are only\n+  ---generated in visible lines, and not in the whole buffer.\n+  if (namespaces[extmark[4].ns_id] or ''):find('vim_lsp_semantic_tokens') then\n+    vim.notify_once('Info(TOhtml): lsp semantic tokens are not supported, html may be incorrect')\n+    return\n+  end\n+  local srow, scol, erow, ecol =\n+    extmark[2], extmark[3], extmark[4].end_row or extmark[2], extmark[4].end_col or extmark[3]\n+  if scol == ecol and srow == erow then\n+    return\n+  end\n+  local hlid = register_hl(state, extmark[4].hl_group)\n+  styletable_insert_range(state, srow + 1, scol + 1, erow + 1, ecol + 1, hlid)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_virt_text(state, extmark)\n+  if not extmark[4].virt_text then\n+    return\n+  end\n+  local styletable = state.style\n+  --- @type number,number\n+  local row, col = extmark[2], extmark[3]\n+  if\n+    extmark[4].virt_text_pos == 'inline'\n+    or extmark[4].virt_text_pos == 'eol'\n+    or extmark[4].virt_text_pos == 'overlay'\n+  then\n+    if extmark[4].virt_text_pos == 'eol' then\n+      style_line_insert_virt_text(styletable[row + 1], #vim.fn.getline(row + 1) + 1, { ' ' })\n+    end\n+    local virt_text_len = 0\n+    for _, i in\n+      ipairs(extmark[4].virt_text --[[@as (string[][])]])\n+    do\n+      local hlid = register_hl(state, i[2])\n+      if extmark[4].virt_text_pos == 'eol' then\n+        style_line_insert_virt_text(\n+          styletable[row + 1],\n+          #vim.fn.getline(row + 1) + 1,\n+          { i[1], hlid }\n+        )\n+      else\n+        style_line_insert_virt_text(styletable[row + 1], col + 1, { i[1], hlid })\n+      end\n+      virt_text_len = virt_text_len + #i[1]\n+    end\n+    if extmark[4].virt_text_pos == 'overlay' then\n+      styletable_insert_range(state, row + 1, col + 1, row + 1, col + virt_text_len + 1, HIDE_ID)\n+    end\n+  end\n+  local not_supported = {\n+    virt_text_pos = 'right_align',\n+    hl_mode = 'blend',\n+    hl_group = 'combine',\n+  }\n+  for opt, val in ipairs(not_supported) do\n+    if extmark[4][opt] == val then\n+      vim.notify_once(\n+        ('Info(TOhtml): extmark.%s=\"%s\" is not supported, html may be incorrect'):format(opt, val)\n+      )\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_virt_lines(state, extmark)\n+  ---TODO(altermo) if the fold start is equal to virt_line start then the fold hides the virt_line\n+  if not extmark[4].virt_lines then\n+    return\n+  end\n+  --- @type number\n+  local row = extmark[2] + (extmark[4].virt_lines_above and 1 or 2)\n+  for _, line in\n+    ipairs(extmark[4].virt_lines --[[@as (string[][][])]])\n+  do\n+    local virt_line = {}\n+    for _, i in ipairs(line) do\n+      local hlid = register_hl(state, i[2])\n+      table.insert(virt_line, { i[1], hlid })\n+    end\n+    table.insert(state.style[row].virt_lines, virt_line)\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_conceal(state, extmark)\n+  if not extmark[4].conceal or state.opt.conceallevel == 0 then\n+    return\n+  end\n+  local srow, scol, erow, ecol =\n+    extmark[2], extmark[3], extmark[4].end_row or extmark[2], extmark[4].end_col or extmark[3]\n+  styletable_insert_conceal(\n+    state,\n+    srow + 1,\n+    scol + 1,\n+    erow + 1,\n+    ecol + 1,\n+    extmark[4].conceal,\n+    extmark[4].hl_group or 'Conceal'\n+  )\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_extmarks(state)\n+  --TODO(altermo) extmarks may have col/row which is outside of the buffer, which could cause an error\n+  local bufnr = state.bufnr\n+  local extmarks = vim.api.nvim_buf_get_extmarks(bufnr, -1, 0, -1, { details = true })\n+  local namespaces = vim.tbl_add_reverse_lookup(vim.api.nvim_get_namespaces())\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_highlight(state, v, namespaces)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_conceal(state, v)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_virt_text(state, v)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_virt_lines(state, v)\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_folds(state)\n+  local styletable = state.style\n+  local has_folded = false\n+  for row = 1, state.buflen do\n+    if vim.fn.foldclosed(row) > 0 then\n+      has_folded = true\n+      styletable[row].hide = true\n+    end\n+    if vim.fn.foldclosed(row) == row then\n+      local hlid = register_hl(state, 'Folded')\n+      ---TODO(altermo): Is there a way to get highlighted foldtext?\n+      local foldtext = vim.fn.foldtextresult(row)\n+      foldtext = foldtext .. (vim.opt.fillchars:get().fold or ''):rep(state.width - #foldtext)\n+      table.insert(styletable[row].virt_lines, { { foldtext, hlid } })\n+    end\n+  end\n+  if has_folded and type(({ pcall(vim.api.nvim_eval, vim.o.foldtext) })[2]) == 'table' then\n+    vim.notify_once(\n+      'Info(TOhtml): foldtext returning a table is half supported, html may be incorrect'\n+    )\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_conceal(state)\n+  local bufnr = state.bufnr\n+  vim.api.nvim_buf_call(bufnr, function()\n+    for row = 1, state.buflen do\n+      --- @type table<number,{[1]:number,[2]:number,[3]:string}>\n+      local conceals = {}\n+      local line_len_exclusive = #vim.fn.getline(row) + 1\n+      for col = 1, line_len_exclusive do\n+        --- @type number,string,number\n+        local is_concealed, conceal, hlid = unpack(vim.fn.synconcealed(row, col) --[[@as table]])\n+        if is_concealed == 0 then\n+          assert(true)\n+        elseif not conceals[hlid] then\n+          conceals[hlid] = { col, math.min(col + 1, line_len_exclusive), conceal }\n+        else\n+          conceals[hlid][2] = math.min(col + 1, line_len_exclusive)\n+        end\n+      end\n+      for _, v in pairs(conceals) do\n+        styletable_insert_conceal(state, row, v[1], row, v[2], v[3], 'Conceal')\n+      end\n+    end\n+  end)\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_match(state)\n+  for _, match in\n+    ipairs(vim.fn.getmatches(state.winnr) --[[@as (table[])]])\n+  do\n+    local hlid = register_hl(state, match.group)\n+    local function range(srow, scol, erow, ecol)\n+      if match.group == 'Conceal' and state.opt.conceallevel ~= 0 then\n+        styletable_insert_conceal(state, srow, scol, erow, ecol, match.conceal or '', hlid)\n+      else\n+        styletable_insert_range(state, srow, scol, erow, ecol, hlid)\n+      end\n+    end\n+    if match.pos1 then\n+      for key, v in\n+        pairs(match --[[@as (table<string,number[]>)]])\n+      do\n+        if not key:match('^pos(%d+)$') then\n+          assert(true)\n+        elseif #v == 1 then\n+          range(v[1], 1, v[1], #vim.fn.getline(v[1]) + 1)\n+        else\n+          range(v[1], v[2], v[1], v[3] + v[2])\n+        end\n+      end\n+    else\n+      for _, v in\n+        ipairs(vim.fn.matchbufline(state.bufnr, match.pattern, 1, '$') --[[@as (table[])]])\n+      do\n+        range(v.lnum, v.byteidx + 1, v.lnum, v.byteidx + 1 + #v.text)\n+      end\n+    end\n+  end\n+end\n+\n+--- Requires state.conf.number_lines to be set to true\n+--- @param state vim.tohtml.state\n+local function styletable_statuscolumn(state)\n+  if not state.conf.number_lines then\n+    return\n+  end\n+  local statuscolumn = state.opt.statuscolumn\n+  if statuscolumn == '' then\n+    --TODO(altermo): This is wrong, if for example if 'number' and 'foldcolumn=2' then it\n+    --wont have the correct whitespace in the correct location\n+    --The task: figure out the internal algorithm for the statuscolumn and rewrite it to\n+    --the 'statuscolum' format\n+    if state.opt.relativenumber then\n+      if state.opt.number then\n+        statuscolumn =\n+          '%C%s%{v:lnum!=line(\".\")?repeat(\" \",&numberwidth-len(v:relnum)).v:relnum:v:lnum}'\n+      else\n+        statuscolumn = '%C%s%{repeat(\" \",&numberwidth-len(v:relnum)).v:relnum}'\n+      end\n+    else\n+      statuscolumn = '%C%s%{repeat(\" \",&numberwidth-len(v:lnum)).v:lnum}'\n+    end\n+  end\n+  local minwidth = 0\n+  local signcolumn = state.opt.signcolumn\n+  if state.opt.number or state.opt.relativenumber then\n+    minwidth = minwidth + state.opt.numberwidth\n+    if signcolumn == 'number' then\n+      signcolumn = 'no'\n+    end\n+  end\n+  if signcolumn == 'number' then\n+    signcolumn = 'auto'\n+  end\n+  if signcolumn ~= 'no' then\n+    local max = tonumber(signcolumn:match('^%w-:(%d)')) or 1\n+    if signcolumn:match('^auto') then\n+      --- @type table<number,number>\n+      local signcount = {}\n+      for _, extmark in\n+        ipairs(vim.api.nvim_buf_get_extmarks(state.bufnr, -1, 0, -1, { details = true }))\n+      do\n+        if extmark[4].sign_text then\n+          signcount[extmark[2]] = (signcount[extmark[2]] or 0) + 1\n+        end\n+      end\n+      local maxsigns = 0\n+      for _, v in pairs(signcount) do\n+        if v > maxsigns then\n+          maxsigns = v\n+        end\n+      end\n+      minwidth = minwidth + math.min(maxsigns, max) * 2\n+    else\n+      minwidth = minwidth + max * 2\n+    end\n+  end\n+  local foldcolumn = state.opt.foldcolumn\n+  if foldcolumn ~= '0' then\n+    if foldcolumn:match('^auto') then\n+      local max = tonumber(foldcolumn:match('^%w-:(%d)')) or 1\n+      local maxfold = 0\n+      vim.api.nvim_buf_call(state.bufnr, function()\n+        for row = 1, vim.api.nvim_buf_line_count(state.bufnr) do\n+          local foldlevel = vim.fn.foldlevel(row)\n+          if foldlevel > maxfold then\n+            maxfold = foldlevel\n+          end\n+        end\n+      end)\n+      minwidth = minwidth + math.min(maxfold, max)\n+    else\n+      minwidth = minwidth + tonumber(foldcolumn)\n+    end\n+  end\n+  --- @type table<number,any>\n+  local statuses = {}\n+  for row = 1, state.buflen do\n+    local status = vim.api.nvim_eval_statusline(\n+      statuscolumn,\n+      { winid = state.winnr, use_statuscol_lnum = row, highlights = true }\n+    )\n+    local width = vim.api.nvim_strwidth(status.str)\n+    if width > minwidth then\n+      minwidth = width\n+    end\n+    table.insert(statuses, status)\n+    --- @type string\n+  end\n+  for row, status in pairs(statuses) do\n+    --- @type string\n+    local str = status.str\n+    --- @type table[]\n+    local hls = status.highlights\n+    for k, v in ipairs(hls) do\n+      local text = str:sub(v.start + 1, hls[k + 1] and hls[k + 1].start or nil)\n+      if k == #hls then\n+        text = text .. (' '):rep(minwidth - vim.api.nvim_strwidth(str))\n+      end\n+      if text ~= '' then\n+        local hlid = register_hl(state, v.group)\n+        local virt_text = { text, hlid }\n+        table.insert(state.style[row].pre_text, virt_text)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_listchars(state)\n+  if not state.opt.list then\n+    return\n+  end\n+  --- @return string\n+  local function utf8_sub(str, i, j)\n+    return vim.fn.strcharpart(str, i - 1, j and j - i + 1 or nil)\n+  end\n+  local len = vim.api.nvim_strwidth\n+  --- @type table<string,string>\n+  local listchars = vim.opt_local.listchars:get()\n+  local ids = setmetatable({}, {\n+    __index = function(t, k)\n+      rawset(t, k, register_hl(state, k))\n+      return rawget(t, k)\n+    end,\n+  })\n+  if listchars.eol then\n+    for row = 1, state.buflen do\n+      local style_line = state.style[row]\n+      style_line_insert_overlay_char(\n+        style_line,\n+        #vim.fn.getline(row) + 1,\n+        { listchars.eol, ids.NonText }\n+      )\n+    end\n+  end\n+  if listchars.tab and state.tabstop then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, '\\t', 1, '$') --[[@as (table[])]])\n+    do\n+      --- @type number\n+      local tablen = #state.tabstop\n+        - ((vim.fn.virtcol({ match.lnum, match.byteidx }, false, state.winnr)) % #state.tabstop)\n+      --- @type string?\n+      local text\n+      if len(listchars.tab) == 3 then\n+        if tablen == 1 then\n+          text = utf8_sub(listchars.tab, 3, 3)\n+        else\n+          text = utf8_sub(listchars.tab, 1, 1)\n+            .. utf8_sub(listchars.tab, 2, 2):rep(tablen - 2)\n+            .. utf8_sub(listchars.tab, 3, 3)\n+        end\n+      else\n+        text = utf8_sub(listchars.tab, 1, 1) .. utf8_sub(listchars.tab, 2, 2):rep(tablen - 1)\n+      end\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { text, ids.Whitespace }\n+      )\n+    end\n+  end\n+  if listchars.space then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, ' ', 1, '$') --[[@as (table[])]])\n+    do\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { listchars.space, ids.Whitespace }\n+      )\n+    end\n+  end\n+  if listchars.multispace then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[  \\+]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = utf8_sub(listchars.multispace:rep(len(match.text)), 1, len(match.text))\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.lead or listchars.leadmultispace then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[^ \\+]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = ''\n+      if len(match.text) == 1 or not listchars.leadmultispace then\n+        if listchars.lead then\n+          text = listchars.lead:rep(len(match.text))\n+        end\n+      elseif listchars.leadmultispace then\n+        text = utf8_sub(listchars.leadmultispace:rep(len(match.text)), 1, len(match.text))\n+      end\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.trail then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[ \\+$]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = listchars.trail:rep(len(match.text))\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.nbsp then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, '\\xe2\\x80\\xaf\\\\|\\xa0', 1, '$') --[[@as (table[])]])\n+    do\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { listchars.nbsp, ids.Whitespace }\n+      )\n+      for i = 2, #match.text do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { '', ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+end\n+\n+--- @param name string\n+--- @return string\n+local function highlight_name_to_class_name(name)\n+  return (name:gsub('%.', '-'):gsub('@', '-'))\n+end\n+\n+--- @param name string\n+--- @return string\n+local function name_to_tag(name)\n+  return '<span class=\"' .. highlight_name_to_class_name(name) .. '\">'\n+end\n+\n+--- @param _ string\n+--- @return string\n+local function name_to_closetag(_)\n+  return '</span>'\n+end\n+\n+--- @param str string\n+--- @param tabstop string|false?\n+--- @return string\n+local function html_escape(str, tabstop)\n+  str = str:gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;'):gsub('\"', '&quot;')\n+  if tabstop then\n+    --- @type string\n+    str = str:gsub('\\t', tabstop)\n+  end\n+  return str\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state.global\n+local function extend_style(out, state)\n+  table.insert(out, '<style>')\n+  table.insert(out, ('* {font-family: %s}'):format(state.font))\n+  table.insert(\n+    out,\n+    ('body {background-color: %s; color: %s}'):format(state.background, state.foreground)\n+  )\n+  for hlid, name in pairs(state.highlights_name) do\n+    --TODO(altermo) use local namespace (instead of global 0)\n+    local fg = vim.fn.synIDattr(hlid, 'fg#')\n+    local bg = vim.fn.synIDattr(hlid, 'bg#')\n+    local c = {\n+      color = fg ~= '' and cterm_to_hex(fg) or nil,\n+      ['background-color'] = bg ~= '' and cterm_to_hex(bg) or nil,\n+      ['font-style'] = vim.fn.synIDattr(hlid, 'italic') ~= '' and 'italic' or nil,\n+      ['font-weight'] = vim.fn.synIDattr(hlid, 'bold') ~= '' and 'bold' or nil,\n+      ['text-decoration-line'] = vim.fn.synIDattr(hlid, 'underline') ~= '' and 'underline' or nil,\n+    }\n+    local attrs = {}\n+    for attr, val in pairs(c) do\n+      table.insert(attrs, attr .. ': ' .. val)\n+    end\n+    table.insert(\n+      out,\n+      '.' .. highlight_name_to_class_name(name) .. ' {' .. table.concat(attrs, '; ') .. '}'\n+    )\n+  end\n+  table.insert(out, '</style>')\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state.global\n+local function extend_head(out, state)\n+  table.insert(out, '<head>')\n+  table.insert(out, '<meta charset=\"UTF-8\">')\n+  if state.title ~= false then\n+    table.insert(out, ('<title>%s</title>'):format(state.title))\n+  end\n+  local colorscheme = vim.api.nvim_exec2('colorscheme', { output = true }).output\n+  table.insert(\n+    out,\n+    ('<meta name=\"colorscheme\" content=\"%s\"></meta>'):format(html_escape(colorscheme))\n+  )\n+  extend_style(out, state)\n+  table.insert(out, '</head>')\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state\n+local function extend_pre(out, state)",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473101162",
            "id": 1473101162,
            "line": 1104,
            "node_id": "PRRC_kwDOAPphoM5Xzb1q",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 1104,
            "original_position": 998,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": 1104,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473101162/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473101162",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473104900"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473104900"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- @type fun(state: vim.tohtml.state)[]\r\n```\r\n\r\nIt looks like all these functions have the same signature.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:20:56Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil\n+\n+--- @param colorstr string\n+--- @return string\n+local function cterm_to_hex(colorstr)\n+  if colorstr:sub(1, 1) == '#' then\n+    return colorstr\n+  end\n+  assert(colorstr ~= '')\n+  local color = tonumber(colorstr)\n+  assert(color and 0 <= color and color <= 255)\n+  if cterm_color_cache[color] then\n+    return cterm_color_cache[color]\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]4;%d*;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write(('\\027]4;%s;?\\027\\\\'):format(color))\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if hex then\n+    cterm_color_cache[color] = hex\n+  else\n+    --If the terminal didn't respond, set the colors to a fallback value\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal colors, using fallback\")\n+    local t_Co = tonumber(vim.api.nvim_eval('&t_Co'))\n+    if t_Co == 8 then\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+    else\n+      -- stylua: ignore\n+      cterm_color_cache = {\n+        [0] = \"#000000\", \"#c00000\", \"#008000\", \"#804000\",\n+        \"#0000c0\", \"#c000c0\", \"#008080\", \"#c0c0c0\",\n+        \"#808080\", \"#ff6060\", \"#00ff00\", \"#ffff00\",\n+        \"#8080ff\", \"#ff40ff\", \"#00ffff\", \"#ffffff\",\n+      }\n+      if t_Co == 88 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00008b\", \"#0000cd\", \"#0000ff\",\n+          \"#008b00\", \"#008b8b\", \"#008bcd\", \"#008bff\",\n+          \"#00cd00\", \"#00cd8b\", \"#00cdcd\", \"#00cdff\",\n+          \"#00ff00\", \"#00ff8b\", \"#00ffcd\", \"#00ffff\",\n+          \"#8b0000\", \"#8b008b\", \"#8b00cd\", \"#8b00ff\",\n+          \"#8b8b00\", \"#8b8b8b\", \"#8b8bcd\", \"#8b8bff\",\n+          \"#8bcd00\", \"#8bcd8b\", \"#8bcdcd\", \"#8bcdff\",\n+          \"#8bff00\", \"#8bff8b\", \"#8bffcd\", \"#8bffff\",\n+          \"#cd0000\", \"#cd008b\", \"#cd00cd\", \"#cd00ff\",\n+          \"#cd8b00\", \"#cd8b8b\", \"#cd8bcd\", \"#cd8bff\",\n+          \"#cdcd00\", \"#cdcd8b\", \"#cdcdcd\", \"#cdcdff\",\n+          \"#cdff00\", \"#cdff8b\", \"#cdffcd\", \"#cdffff\",\n+          \"#ff0000\", \"#ff008b\", \"#ff00cd\", \"#ff00ff\",\n+          \"#ff8b00\", \"#ff8b8b\", \"#ff8bcd\", \"#ff8bff\",\n+          \"#ffcd00\", \"#ffcd8b\", \"#ffcdcd\", \"#ffcdff\",\n+          \"#ffff00\", \"#ffff8b\", \"#ffffcd\", \"#ffffff\",\n+          \"#2e2e2e\", \"#5c5c5c\", \"#737373\", \"#8b8b8b\",\n+          \"#a2a2a2\", \"#b9b9b9\", \"#d0d0d0\", \"#e7e7e7\",\n+        })\n+      elseif t_Co == 256 then\n+        -- stylua: ignore\n+        vim.list_extend(cterm_color_cache, {\n+          \"#000000\", \"#00005f\", \"#000087\", \"#0000af\",\n+          \"#0000d7\", \"#0000ff\", \"#005f00\", \"#005f5f\",\n+          \"#005f87\", \"#005faf\", \"#005fd7\", \"#005fff\",\n+          \"#008700\", \"#00875f\", \"#008787\", \"#0087af\",\n+          \"#0087d7\", \"#0087ff\", \"#00af00\", \"#00af5f\",\n+          \"#00af87\", \"#00afaf\", \"#00afd7\", \"#00afff\",\n+          \"#00d700\", \"#00d75f\", \"#00d787\", \"#00d7af\",\n+          \"#00d7d7\", \"#00d7ff\", \"#00ff00\", \"#00ff5f\",\n+          \"#00ff87\", \"#00ffaf\", \"#00ffd7\", \"#00ffff\",\n+          \"#5f0000\", \"#5f005f\", \"#5f0087\", \"#5f00af\",\n+          \"#5f00d7\", \"#5f00ff\", \"#5f5f00\", \"#5f5f5f\",\n+          \"#5f5f87\", \"#5f5faf\", \"#5f5fd7\", \"#5f5fff\",\n+          \"#5f8700\", \"#5f875f\", \"#5f8787\", \"#5f87af\",\n+          \"#5f87d7\", \"#5f87ff\", \"#5faf00\", \"#5faf5f\",\n+          \"#5faf87\", \"#5fafaf\", \"#5fafd7\", \"#5fafff\",\n+          \"#5fd700\", \"#5fd75f\", \"#5fd787\", \"#5fd7af\",\n+          \"#5fd7d7\", \"#5fd7ff\", \"#5fff00\", \"#5fff5f\",\n+          \"#5fff87\", \"#5fffaf\", \"#5fffd7\", \"#5fffff\",\n+          \"#870000\", \"#87005f\", \"#870087\", \"#8700af\",\n+          \"#8700d7\", \"#8700ff\", \"#875f00\", \"#875f5f\",\n+          \"#875f87\", \"#875faf\", \"#875fd7\", \"#875fff\",\n+          \"#878700\", \"#87875f\", \"#878787\", \"#8787af\",\n+          \"#8787d7\", \"#8787ff\", \"#87af00\", \"#87af5f\",\n+          \"#87af87\", \"#87afaf\", \"#87afd7\", \"#87afff\",\n+          \"#87d700\", \"#87d75f\", \"#87d787\", \"#87d7af\",\n+          \"#87d7d7\", \"#87d7ff\", \"#87ff00\", \"#87ff5f\",\n+          \"#87ff87\", \"#87ffaf\", \"#87ffd7\", \"#87ffff\",\n+          \"#af0000\", \"#af005f\", \"#af0087\", \"#af00af\",\n+          \"#af00d7\", \"#af00ff\", \"#af5f00\", \"#af5f5f\",\n+          \"#af5f87\", \"#af5faf\", \"#af5fd7\", \"#af5fff\",\n+          \"#af8700\", \"#af875f\", \"#af8787\", \"#af87af\",\n+          \"#af87d7\", \"#af87ff\", \"#afaf00\", \"#afaf5f\",\n+          \"#afaf87\", \"#afafaf\", \"#afafd7\", \"#afafff\",\n+          \"#afd700\", \"#afd75f\", \"#afd787\", \"#afd7af\",\n+          \"#afd7d7\", \"#afd7ff\", \"#afff00\", \"#afff5f\",\n+          \"#afff87\", \"#afffaf\", \"#afffd7\", \"#afffff\",\n+          \"#d70000\", \"#d7005f\", \"#d70087\", \"#d700af\",\n+          \"#d700d7\", \"#d700ff\", \"#d75f00\", \"#d75f5f\",\n+          \"#d75f87\", \"#d75faf\", \"#d75fd7\", \"#d75fff\",\n+          \"#d78700\", \"#d7875f\", \"#d78787\", \"#d787af\",\n+          \"#d787d7\", \"#d787ff\", \"#d7af00\", \"#d7af5f\",\n+          \"#d7af87\", \"#d7afaf\", \"#d7afd7\", \"#d7afff\",\n+          \"#d7d700\", \"#d7d75f\", \"#d7d787\", \"#d7d7af\",\n+          \"#d7d7d7\", \"#d7d7ff\", \"#d7ff00\", \"#d7ff5f\",\n+          \"#d7ff87\", \"#d7ffaf\", \"#d7ffd7\", \"#d7ffff\",\n+          \"#ff0000\", \"#ff005f\", \"#ff0087\", \"#ff00af\",\n+          \"#ff00d7\", \"#ff00ff\", \"#ff5f00\", \"#ff5f5f\",\n+          \"#ff5f87\", \"#ff5faf\", \"#ff5fd7\", \"#ff5fff\",\n+          \"#ff8700\", \"#ff875f\", \"#ff8787\", \"#ff87af\",\n+          \"#ff87d7\", \"#ff87ff\", \"#ffaf00\", \"#ffaf5f\",\n+          \"#ffaf87\", \"#ffafaf\", \"#ffafd7\", \"#ffafff\",\n+          \"#ffd700\", \"#ffd75f\", \"#ffd787\", \"#ffd7af\",\n+          \"#ffd7d7\", \"#ffd7ff\", \"#ffff00\", \"#ffff5f\",\n+          \"#ffff87\", \"#ffffaf\", \"#ffffd7\", \"#ffffff\",\n+          \"#080808\", \"#121212\", \"#1c1c1c\", \"#262626\",\n+          \"#303030\", \"#3a3a3a\", \"#444444\", \"#4e4e4e\",\n+          \"#585858\", \"#626262\", \"#6c6c6c\", \"#767676\",\n+          \"#808080\", \"#8a8a8a\", \"#949494\", \"#9e9e9e\",\n+          \"#a8a8a8\", \"#b2b2b2\", \"#bcbcbc\", \"#c6c6c6\",\n+          \"#d0d0d0\", \"#dadada\", \"#e4e4e4\", \"#eeeeee\",\n+        })\n+      end\n+    end\n+  end\n+  return cterm_color_cache[color]\n+end\n+\n+--- @return string\n+local function get_background_color()\n+  local bg = vim.fn.synIDattr(vim.fn.hlID('Normal'), 'bg#')\n+  if bg ~= '' then\n+    return cterm_to_hex(bg)\n+  end\n+  if background_color_cache then\n+    return background_color_cache\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]11;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write('\\027]11;?\\027\\\\')\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if not hex or not hex:match('#%x%x%x%x%x%x') then\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal background colors, using fallback\")\n+    hex = vim.o.background == 'light' and '#ffffff' or '#000000'\n+  end\n+  background_color_cache = hex\n+  return hex\n+end\n+\n+--- @return string\n+local function get_foreground_color()\n+  local fg = vim.fn.synIDattr(vim.fn.hlID('Normal'), 'fg#')\n+  if fg ~= '' then\n+    return cterm_to_hex(fg)\n+  end\n+  if foreground_color_cache then\n+    return foreground_color_cache\n+  end\n+  --- @type string?\n+  local hex\n+  vim.api.nvim_create_autocmd('TermResponse', {\n+    once = true,\n+    callback = function(args)\n+      --- @type string\n+      hex = '#'\n+        .. table.concat({ args.data:match('\\027%]10;rgb:(%w%w)%w%w/(%w%w)%w%w/(%w%w)%w%w') })\n+    end,\n+  })\n+  --- @see https://invisible-island.net/xterm/ctlseqs/ctlseqs.html#h3-Operating-System-Commands\n+  io.stdout:write('\\027]10;?\\027\\\\')\n+  vim.wait(100, function()\n+    return hex and true or false\n+  end)\n+  if not hex or not hex:match('#%x%x%x%x%x%x') then\n+    vim.notify_once(\"Info(TOhtml): Couldn't get terminal foreground colors, using fallback\")\n+    hex = vim.o.background == 'light' and '#000000' or '#ffffff'\n+  end\n+  foreground_color_cache = hex\n+  return hex\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param field number\n+--- @param val any\n+local function _style_line_insert(style_line, col, field, val)\n+  if style_line[col] == nil then\n+    style_line[col] = { {}, {}, {}, {} }\n+  end\n+  table.insert(style_line[col][field], val)\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param val any[]\n+local function style_line_insert_overlay_char(style_line, col, val)\n+  _style_line_insert(style_line, col, 4, val)\n+end\n+\n+--- @param style_line vim.tohtml.line\n+--- @param col number (1-index)\n+--- @param val any[]\n+local function style_line_insert_virt_text(style_line, col, val)\n+  _style_line_insert(style_line, col, 3, val)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param hl string|number|nil\n+--- @return nil|number\n+local function register_hl(state, hl)\n+  if type(hl) == 'nil' then\n+    return\n+  elseif type(hl) == 'string' then\n+    hl = vim.fn.hlID(hl)\n+    assert(hl ~= 0)\n+  end\n+  hl = vim.fn.synIDtrans(hl)\n+  if not state.highlights_name[hl] then\n+    local name = vim.fn.synIDattr(hl, 'name')\n+    assert(name ~= '')\n+    state.highlights_name[hl] = name\n+  end\n+  return hl\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param start_row number (1-index)\n+--- @param start_col number (1-index)\n+--- @param end_row number (1-index)\n+--- @param end_col number (1-index)\n+--- @param conceal_text string\n+--- @param hl_group string|number?\n+local function styletable_insert_conceal(\n+  state,\n+  start_row,\n+  start_col,\n+  end_row,\n+  end_col,\n+  conceal_text,\n+  hl_group\n+)\n+  assert(state.opt.conceallevel > 0)\n+  local styletable = state.style\n+  if start_col == end_col and start_row == end_row then\n+    return\n+  end\n+  if state.opt.conceallevel == 1 and conceal_text == '' then\n+    conceal_text = vim.opt_local.listchars:get().conceal or ' '\n+  end\n+  local hlid = register_hl(state, hl_group)\n+  if vim.wo[state.winnr].conceallevel ~= 3 then\n+    _style_line_insert(styletable[start_row], start_col, 3, { conceal_text, hlid })\n+  end\n+  _style_line_insert(styletable[start_row], start_col, 1, HIDE_ID)\n+  _style_line_insert(styletable[end_row], end_col, 2, HIDE_ID)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param start_row number (1-index)\n+--- @param start_col number (1-index)\n+--- @param end_row number (1-index)\n+--- @param end_col number (1-index)\n+--- @param hl_group string|number|nil\n+local function styletable_insert_range(state, start_row, start_col, end_row, end_col, hl_group)\n+  if start_col == end_col and start_row == end_row or not hl_group then\n+    return\n+  end\n+  local styletable = state.style\n+  _style_line_insert(styletable[start_row], start_col, 1, hl_group)\n+  _style_line_insert(styletable[end_row], end_col, 2, hl_group)\n+end\n+\n+--- @param bufnr number\n+--- @return vim.tohtml.styletable\n+local function generate_styletable(bufnr)\n+  --- @type vim.tohtml.styletable\n+  local styletable = {}\n+  for row = 1, vim.api.nvim_buf_line_count(bufnr) + 1 do\n+    styletable[row] = { virt_lines = {}, pre_text = {} }\n+  end\n+  return styletable\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_syntax(state)\n+  for row = 1, state.buflen do\n+    local prev_id = 0\n+    local prev_col = nil\n+    for col = 1, #vim.fn.getline(row) + 1 do\n+      local hlid = vim.fn.synID(row, col, 1)\n+      hlid = hlid == 0 and 0 or assert(register_hl(state, hlid))\n+      if hlid ~= prev_id then\n+        if prev_id ~= 0 then\n+          styletable_insert_range(state, row, assert(prev_col), row, col, prev_id)\n+        end\n+        prev_col = col\n+        prev_id = hlid\n+      end\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_diff(state)\n+  local styletable = state.style\n+  for row = 1, state.buflen do\n+    local style_line = styletable[row]\n+    local filler = vim.fn.diff_filler(row)\n+    if filler ~= 0 then\n+      local fill = (vim.opt_local.fillchars:get().diff or '-')\n+      table.insert(\n+        style_line.virt_lines,\n+        { { fill:rep(state.width), register_hl(state, 'DiffDelete') } }\n+      )\n+    end\n+    if row == state.buflen + 1 then\n+      break\n+    end\n+    local prev_id = 0\n+    local prev_col = nil\n+    for col = 1, #vim.fn.getline(row) do\n+      local hlid = vim.fn.diff_hlID(row, col)\n+      hlid = hlid == 0 and 0 or assert(register_hl(state, hlid))\n+      if hlid ~= prev_id then\n+        if prev_id ~= 0 then\n+          styletable_insert_range(state, row, assert(prev_col), row, col, prev_id)\n+        end\n+        prev_col = col\n+        prev_id = hlid\n+      end\n+    end\n+    if prev_id ~= 0 then\n+      styletable_insert_range(state, row, assert(prev_col), row, #vim.fn.getline(row) + 1, prev_id)\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_treesitter(state)\n+  local bufnr = state.bufnr\n+  local buf_highlighter = vim.treesitter.highlighter.active[bufnr]\n+  if not buf_highlighter then\n+    return\n+  end\n+  buf_highlighter.tree:parse(true)\n+  buf_highlighter.tree:for_each_tree(function(tstree, tree)\n+    --- @cast tree LanguageTree\n+    if not tstree then\n+      return\n+    end\n+    local root = tstree:root()\n+    local q = buf_highlighter:get_query(tree:lang())\n+    --- @type Query?\n+    local query = q:query()\n+    if not query then\n+      return\n+    end\n+    for capture, node, metadata in query:iter_captures(root, buf_highlighter.bufnr, 0, state.buflen) do\n+      local srow, scol, erow, ecol = node:range()\n+      --- @diagnostic disable-next-line: invisible\n+      local c = q._query.captures[capture]\n+      if c ~= nil then\n+        local hlid = register_hl(state, '@' .. c .. '.' .. tree:lang())\n+        if metadata.conceal and state.opt.conceallevel ~= 0 then\n+          styletable_insert_conceal(state, srow + 1, scol + 1, erow + 1, ecol + 1, metadata.conceal)\n+        end\n+        styletable_insert_range(state, srow + 1, scol + 1, erow + 1, ecol + 1, hlid)\n+      end\n+    end\n+  end)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+--- @param namespaces table<number,string>\n+local function _styletable_extmarks_highlight(state, extmark, namespaces)\n+  if not extmark[4].hl_group then\n+    return\n+  end\n+  ---TODO(altermo) LSP semantic tokens (and some other extmarks) are only\n+  ---generated in visible lines, and not in the whole buffer.\n+  if (namespaces[extmark[4].ns_id] or ''):find('vim_lsp_semantic_tokens') then\n+    vim.notify_once('Info(TOhtml): lsp semantic tokens are not supported, html may be incorrect')\n+    return\n+  end\n+  local srow, scol, erow, ecol =\n+    extmark[2], extmark[3], extmark[4].end_row or extmark[2], extmark[4].end_col or extmark[3]\n+  if scol == ecol and srow == erow then\n+    return\n+  end\n+  local hlid = register_hl(state, extmark[4].hl_group)\n+  styletable_insert_range(state, srow + 1, scol + 1, erow + 1, ecol + 1, hlid)\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_virt_text(state, extmark)\n+  if not extmark[4].virt_text then\n+    return\n+  end\n+  local styletable = state.style\n+  --- @type number,number\n+  local row, col = extmark[2], extmark[3]\n+  if\n+    extmark[4].virt_text_pos == 'inline'\n+    or extmark[4].virt_text_pos == 'eol'\n+    or extmark[4].virt_text_pos == 'overlay'\n+  then\n+    if extmark[4].virt_text_pos == 'eol' then\n+      style_line_insert_virt_text(styletable[row + 1], #vim.fn.getline(row + 1) + 1, { ' ' })\n+    end\n+    local virt_text_len = 0\n+    for _, i in\n+      ipairs(extmark[4].virt_text --[[@as (string[][])]])\n+    do\n+      local hlid = register_hl(state, i[2])\n+      if extmark[4].virt_text_pos == 'eol' then\n+        style_line_insert_virt_text(\n+          styletable[row + 1],\n+          #vim.fn.getline(row + 1) + 1,\n+          { i[1], hlid }\n+        )\n+      else\n+        style_line_insert_virt_text(styletable[row + 1], col + 1, { i[1], hlid })\n+      end\n+      virt_text_len = virt_text_len + #i[1]\n+    end\n+    if extmark[4].virt_text_pos == 'overlay' then\n+      styletable_insert_range(state, row + 1, col + 1, row + 1, col + virt_text_len + 1, HIDE_ID)\n+    end\n+  end\n+  local not_supported = {\n+    virt_text_pos = 'right_align',\n+    hl_mode = 'blend',\n+    hl_group = 'combine',\n+  }\n+  for opt, val in ipairs(not_supported) do\n+    if extmark[4][opt] == val then\n+      vim.notify_once(\n+        ('Info(TOhtml): extmark.%s=\"%s\" is not supported, html may be incorrect'):format(opt, val)\n+      )\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_virt_lines(state, extmark)\n+  ---TODO(altermo) if the fold start is equal to virt_line start then the fold hides the virt_line\n+  if not extmark[4].virt_lines then\n+    return\n+  end\n+  --- @type number\n+  local row = extmark[2] + (extmark[4].virt_lines_above and 1 or 2)\n+  for _, line in\n+    ipairs(extmark[4].virt_lines --[[@as (string[][][])]])\n+  do\n+    local virt_line = {}\n+    for _, i in ipairs(line) do\n+      local hlid = register_hl(state, i[2])\n+      table.insert(virt_line, { i[1], hlid })\n+    end\n+    table.insert(state.style[row].virt_lines, virt_line)\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+--- @param extmark {[1]:number,[2]:number,[3]:number,[4]:vim.api.keyset.set_extmark|any}\n+local function _styletable_extmarks_conceal(state, extmark)\n+  if not extmark[4].conceal or state.opt.conceallevel == 0 then\n+    return\n+  end\n+  local srow, scol, erow, ecol =\n+    extmark[2], extmark[3], extmark[4].end_row or extmark[2], extmark[4].end_col or extmark[3]\n+  styletable_insert_conceal(\n+    state,\n+    srow + 1,\n+    scol + 1,\n+    erow + 1,\n+    ecol + 1,\n+    extmark[4].conceal,\n+    extmark[4].hl_group or 'Conceal'\n+  )\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_extmarks(state)\n+  --TODO(altermo) extmarks may have col/row which is outside of the buffer, which could cause an error\n+  local bufnr = state.bufnr\n+  local extmarks = vim.api.nvim_buf_get_extmarks(bufnr, -1, 0, -1, { details = true })\n+  local namespaces = vim.tbl_add_reverse_lookup(vim.api.nvim_get_namespaces())\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_highlight(state, v, namespaces)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_conceal(state, v)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_virt_text(state, v)\n+  end\n+  for _, v in ipairs(extmarks) do\n+    _styletable_extmarks_virt_lines(state, v)\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_folds(state)\n+  local styletable = state.style\n+  local has_folded = false\n+  for row = 1, state.buflen do\n+    if vim.fn.foldclosed(row) > 0 then\n+      has_folded = true\n+      styletable[row].hide = true\n+    end\n+    if vim.fn.foldclosed(row) == row then\n+      local hlid = register_hl(state, 'Folded')\n+      ---TODO(altermo): Is there a way to get highlighted foldtext?\n+      local foldtext = vim.fn.foldtextresult(row)\n+      foldtext = foldtext .. (vim.opt.fillchars:get().fold or ''):rep(state.width - #foldtext)\n+      table.insert(styletable[row].virt_lines, { { foldtext, hlid } })\n+    end\n+  end\n+  if has_folded and type(({ pcall(vim.api.nvim_eval, vim.o.foldtext) })[2]) == 'table' then\n+    vim.notify_once(\n+      'Info(TOhtml): foldtext returning a table is half supported, html may be incorrect'\n+    )\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_conceal(state)\n+  local bufnr = state.bufnr\n+  vim.api.nvim_buf_call(bufnr, function()\n+    for row = 1, state.buflen do\n+      --- @type table<number,{[1]:number,[2]:number,[3]:string}>\n+      local conceals = {}\n+      local line_len_exclusive = #vim.fn.getline(row) + 1\n+      for col = 1, line_len_exclusive do\n+        --- @type number,string,number\n+        local is_concealed, conceal, hlid = unpack(vim.fn.synconcealed(row, col) --[[@as table]])\n+        if is_concealed == 0 then\n+          assert(true)\n+        elseif not conceals[hlid] then\n+          conceals[hlid] = { col, math.min(col + 1, line_len_exclusive), conceal }\n+        else\n+          conceals[hlid][2] = math.min(col + 1, line_len_exclusive)\n+        end\n+      end\n+      for _, v in pairs(conceals) do\n+        styletable_insert_conceal(state, row, v[1], row, v[2], v[3], 'Conceal')\n+      end\n+    end\n+  end)\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_match(state)\n+  for _, match in\n+    ipairs(vim.fn.getmatches(state.winnr) --[[@as (table[])]])\n+  do\n+    local hlid = register_hl(state, match.group)\n+    local function range(srow, scol, erow, ecol)\n+      if match.group == 'Conceal' and state.opt.conceallevel ~= 0 then\n+        styletable_insert_conceal(state, srow, scol, erow, ecol, match.conceal or '', hlid)\n+      else\n+        styletable_insert_range(state, srow, scol, erow, ecol, hlid)\n+      end\n+    end\n+    if match.pos1 then\n+      for key, v in\n+        pairs(match --[[@as (table<string,number[]>)]])\n+      do\n+        if not key:match('^pos(%d+)$') then\n+          assert(true)\n+        elseif #v == 1 then\n+          range(v[1], 1, v[1], #vim.fn.getline(v[1]) + 1)\n+        else\n+          range(v[1], v[2], v[1], v[3] + v[2])\n+        end\n+      end\n+    else\n+      for _, v in\n+        ipairs(vim.fn.matchbufline(state.bufnr, match.pattern, 1, '$') --[[@as (table[])]])\n+      do\n+        range(v.lnum, v.byteidx + 1, v.lnum, v.byteidx + 1 + #v.text)\n+      end\n+    end\n+  end\n+end\n+\n+--- Requires state.conf.number_lines to be set to true\n+--- @param state vim.tohtml.state\n+local function styletable_statuscolumn(state)\n+  if not state.conf.number_lines then\n+    return\n+  end\n+  local statuscolumn = state.opt.statuscolumn\n+  if statuscolumn == '' then\n+    --TODO(altermo): This is wrong, if for example if 'number' and 'foldcolumn=2' then it\n+    --wont have the correct whitespace in the correct location\n+    --The task: figure out the internal algorithm for the statuscolumn and rewrite it to\n+    --the 'statuscolum' format\n+    if state.opt.relativenumber then\n+      if state.opt.number then\n+        statuscolumn =\n+          '%C%s%{v:lnum!=line(\".\")?repeat(\" \",&numberwidth-len(v:relnum)).v:relnum:v:lnum}'\n+      else\n+        statuscolumn = '%C%s%{repeat(\" \",&numberwidth-len(v:relnum)).v:relnum}'\n+      end\n+    else\n+      statuscolumn = '%C%s%{repeat(\" \",&numberwidth-len(v:lnum)).v:lnum}'\n+    end\n+  end\n+  local minwidth = 0\n+  local signcolumn = state.opt.signcolumn\n+  if state.opt.number or state.opt.relativenumber then\n+    minwidth = minwidth + state.opt.numberwidth\n+    if signcolumn == 'number' then\n+      signcolumn = 'no'\n+    end\n+  end\n+  if signcolumn == 'number' then\n+    signcolumn = 'auto'\n+  end\n+  if signcolumn ~= 'no' then\n+    local max = tonumber(signcolumn:match('^%w-:(%d)')) or 1\n+    if signcolumn:match('^auto') then\n+      --- @type table<number,number>\n+      local signcount = {}\n+      for _, extmark in\n+        ipairs(vim.api.nvim_buf_get_extmarks(state.bufnr, -1, 0, -1, { details = true }))\n+      do\n+        if extmark[4].sign_text then\n+          signcount[extmark[2]] = (signcount[extmark[2]] or 0) + 1\n+        end\n+      end\n+      local maxsigns = 0\n+      for _, v in pairs(signcount) do\n+        if v > maxsigns then\n+          maxsigns = v\n+        end\n+      end\n+      minwidth = minwidth + math.min(maxsigns, max) * 2\n+    else\n+      minwidth = minwidth + max * 2\n+    end\n+  end\n+  local foldcolumn = state.opt.foldcolumn\n+  if foldcolumn ~= '0' then\n+    if foldcolumn:match('^auto') then\n+      local max = tonumber(foldcolumn:match('^%w-:(%d)')) or 1\n+      local maxfold = 0\n+      vim.api.nvim_buf_call(state.bufnr, function()\n+        for row = 1, vim.api.nvim_buf_line_count(state.bufnr) do\n+          local foldlevel = vim.fn.foldlevel(row)\n+          if foldlevel > maxfold then\n+            maxfold = foldlevel\n+          end\n+        end\n+      end)\n+      minwidth = minwidth + math.min(maxfold, max)\n+    else\n+      minwidth = minwidth + tonumber(foldcolumn)\n+    end\n+  end\n+  --- @type table<number,any>\n+  local statuses = {}\n+  for row = 1, state.buflen do\n+    local status = vim.api.nvim_eval_statusline(\n+      statuscolumn,\n+      { winid = state.winnr, use_statuscol_lnum = row, highlights = true }\n+    )\n+    local width = vim.api.nvim_strwidth(status.str)\n+    if width > minwidth then\n+      minwidth = width\n+    end\n+    table.insert(statuses, status)\n+    --- @type string\n+  end\n+  for row, status in pairs(statuses) do\n+    --- @type string\n+    local str = status.str\n+    --- @type table[]\n+    local hls = status.highlights\n+    for k, v in ipairs(hls) do\n+      local text = str:sub(v.start + 1, hls[k + 1] and hls[k + 1].start or nil)\n+      if k == #hls then\n+        text = text .. (' '):rep(minwidth - vim.api.nvim_strwidth(str))\n+      end\n+      if text ~= '' then\n+        local hlid = register_hl(state, v.group)\n+        local virt_text = { text, hlid }\n+        table.insert(state.style[row].pre_text, virt_text)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param state vim.tohtml.state\n+local function styletable_listchars(state)\n+  if not state.opt.list then\n+    return\n+  end\n+  --- @return string\n+  local function utf8_sub(str, i, j)\n+    return vim.fn.strcharpart(str, i - 1, j and j - i + 1 or nil)\n+  end\n+  local len = vim.api.nvim_strwidth\n+  --- @type table<string,string>\n+  local listchars = vim.opt_local.listchars:get()\n+  local ids = setmetatable({}, {\n+    __index = function(t, k)\n+      rawset(t, k, register_hl(state, k))\n+      return rawget(t, k)\n+    end,\n+  })\n+  if listchars.eol then\n+    for row = 1, state.buflen do\n+      local style_line = state.style[row]\n+      style_line_insert_overlay_char(\n+        style_line,\n+        #vim.fn.getline(row) + 1,\n+        { listchars.eol, ids.NonText }\n+      )\n+    end\n+  end\n+  if listchars.tab and state.tabstop then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, '\\t', 1, '$') --[[@as (table[])]])\n+    do\n+      --- @type number\n+      local tablen = #state.tabstop\n+        - ((vim.fn.virtcol({ match.lnum, match.byteidx }, false, state.winnr)) % #state.tabstop)\n+      --- @type string?\n+      local text\n+      if len(listchars.tab) == 3 then\n+        if tablen == 1 then\n+          text = utf8_sub(listchars.tab, 3, 3)\n+        else\n+          text = utf8_sub(listchars.tab, 1, 1)\n+            .. utf8_sub(listchars.tab, 2, 2):rep(tablen - 2)\n+            .. utf8_sub(listchars.tab, 3, 3)\n+        end\n+      else\n+        text = utf8_sub(listchars.tab, 1, 1) .. utf8_sub(listchars.tab, 2, 2):rep(tablen - 1)\n+      end\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { text, ids.Whitespace }\n+      )\n+    end\n+  end\n+  if listchars.space then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, ' ', 1, '$') --[[@as (table[])]])\n+    do\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { listchars.space, ids.Whitespace }\n+      )\n+    end\n+  end\n+  if listchars.multispace then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[  \\+]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = utf8_sub(listchars.multispace:rep(len(match.text)), 1, len(match.text))\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.lead or listchars.leadmultispace then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[^ \\+]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = ''\n+      if len(match.text) == 1 or not listchars.leadmultispace then\n+        if listchars.lead then\n+          text = listchars.lead:rep(len(match.text))\n+        end\n+      elseif listchars.leadmultispace then\n+        text = utf8_sub(listchars.leadmultispace:rep(len(match.text)), 1, len(match.text))\n+      end\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.trail then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, [[ \\+$]], 1, '$') --[[@as (table[])]])\n+    do\n+      local text = listchars.trail:rep(len(match.text))\n+      for i = 1, len(text) do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { utf8_sub(text, i, i), ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+  if listchars.nbsp then\n+    for _, match in\n+      ipairs(vim.fn.matchbufline(state.bufnr, '\\xe2\\x80\\xaf\\\\|\\xa0', 1, '$') --[[@as (table[])]])\n+    do\n+      style_line_insert_overlay_char(\n+        state.style[match.lnum],\n+        match.byteidx + 1,\n+        { listchars.nbsp, ids.Whitespace }\n+      )\n+      for i = 2, #match.text do\n+        style_line_insert_overlay_char(\n+          state.style[match.lnum],\n+          match.byteidx + i,\n+          { '', ids.Whitespace }\n+        )\n+      end\n+    end\n+  end\n+end\n+\n+--- @param name string\n+--- @return string\n+local function highlight_name_to_class_name(name)\n+  return (name:gsub('%.', '-'):gsub('@', '-'))\n+end\n+\n+--- @param name string\n+--- @return string\n+local function name_to_tag(name)\n+  return '<span class=\"' .. highlight_name_to_class_name(name) .. '\">'\n+end\n+\n+--- @param _ string\n+--- @return string\n+local function name_to_closetag(_)\n+  return '</span>'\n+end\n+\n+--- @param str string\n+--- @param tabstop string|false?\n+--- @return string\n+local function html_escape(str, tabstop)\n+  str = str:gsub('&', '&amp;'):gsub('<', '&lt;'):gsub('>', '&gt;'):gsub('\"', '&quot;')\n+  if tabstop then\n+    --- @type string\n+    str = str:gsub('\\t', tabstop)\n+  end\n+  return str\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state.global\n+local function extend_style(out, state)\n+  table.insert(out, '<style>')\n+  table.insert(out, ('* {font-family: %s}'):format(state.font))\n+  table.insert(\n+    out,\n+    ('body {background-color: %s; color: %s}'):format(state.background, state.foreground)\n+  )\n+  for hlid, name in pairs(state.highlights_name) do\n+    --TODO(altermo) use local namespace (instead of global 0)\n+    local fg = vim.fn.synIDattr(hlid, 'fg#')\n+    local bg = vim.fn.synIDattr(hlid, 'bg#')\n+    local c = {\n+      color = fg ~= '' and cterm_to_hex(fg) or nil,\n+      ['background-color'] = bg ~= '' and cterm_to_hex(bg) or nil,\n+      ['font-style'] = vim.fn.synIDattr(hlid, 'italic') ~= '' and 'italic' or nil,\n+      ['font-weight'] = vim.fn.synIDattr(hlid, 'bold') ~= '' and 'bold' or nil,\n+      ['text-decoration-line'] = vim.fn.synIDattr(hlid, 'underline') ~= '' and 'underline' or nil,\n+    }\n+    local attrs = {}\n+    for attr, val in pairs(c) do\n+      table.insert(attrs, attr .. ': ' .. val)\n+    end\n+    table.insert(\n+      out,\n+      '.' .. highlight_name_to_class_name(name) .. ' {' .. table.concat(attrs, '; ') .. '}'\n+    )\n+  end\n+  table.insert(out, '</style>')\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state.global\n+local function extend_head(out, state)\n+  table.insert(out, '<head>')\n+  table.insert(out, '<meta charset=\"UTF-8\">')\n+  if state.title ~= false then\n+    table.insert(out, ('<title>%s</title>'):format(state.title))\n+  end\n+  local colorscheme = vim.api.nvim_exec2('colorscheme', { output = true }).output\n+  table.insert(\n+    out,\n+    ('<meta name=\"colorscheme\" content=\"%s\"></meta>'):format(html_escape(colorscheme))\n+  )\n+  extend_style(out, state)\n+  table.insert(out, '</head>')\n+end\n+\n+--- @param out string[]\n+--- @param state vim.tohtml.state\n+local function extend_pre(out, state)\n+  local styletable = state.style\n+  table.insert(out, '<pre>')\n+  local hide_count = 0\n+  --- @type number[]\n+  local stack = {}\n+  local function loop(row)\n+    local style_line = styletable[row]\n+    if style_line.hide and (styletable[row - 1] or {}).hide then\n+      return\n+    end\n+    --Possible improvement (altermo):\n+    --Instead of looping over all the buffer characters per line,\n+    --why not loop over all the style_line cells,\n+    --and then calculating the amount of text.\n+    for _, virt_line in ipairs(style_line.virt_lines) do\n+      local virt_s = ''\n+      for _, v in ipairs(virt_line) do\n+        if v[2] then\n+          virt_s = virt_s .. (name_to_tag(state.highlights_name[v[2]]))\n+        end\n+        virt_s = virt_s .. v[1]\n+        if v[2] then\n+          --- @type string\n+          virt_s = virt_s .. (name_to_closetag(state.highlights_name[v[2]]))\n+        end\n+      end\n+      table.insert(out, virt_s)\n+    end\n+    if style_line.hide then\n+      return\n+    end\n+    local line = vim.api.nvim_buf_get_lines(state.bufnr, row - 1, row, false)[1] or ''\n+    local s = ''\n+    for _, pre_text in ipairs(style_line.pre_text) do\n+      if pre_text[2] then\n+        s = s .. (name_to_tag(state.highlights_name[pre_text[2]]))\n+      end\n+      s = s .. (html_escape(pre_text[1], state.tabstop))\n+      if pre_text[2] then\n+        --- @type string\n+        s = s .. (name_to_closetag(state.highlights_name[pre_text[2]]))\n+      end\n+    end\n+    for col = 1, #line + 1 do\n+      local cell = style_line[col]\n+      --- @type table\n+      local char\n+      if cell then\n+        for i = #cell[2], 1, -1 do\n+          local hlid = cell[2][i]\n+          if hlid < 0 then\n+            if hlid == HIDE_ID then\n+              hide_count = hide_count - 1\n+            end\n+          else\n+            --- @type number?\n+            local index\n+            for idx = #stack, 1, -1 do\n+              s = s .. (name_to_closetag(state.highlights_name[stack[idx]]))\n+              if stack[idx] == hlid then\n+                index = idx\n+                break\n+              end\n+            end\n+            assert(index, 'a coles tag which has no corresponding open tag')\n+            for idx = index + 1, #stack do\n+              s = s .. (name_to_tag(state.highlights_name[stack[idx]]))\n+            end\n+            table.remove(stack, index)\n+          end\n+        end\n+        for _, hlid in ipairs(cell[1]) do\n+          if hlid < 0 then\n+            if hlid == HIDE_ID then\n+              hide_count = hide_count + 1\n+            end\n+          else\n+            table.insert(stack, hlid)\n+            s = s .. (name_to_tag(state.highlights_name[hlid]))\n+          end\n+        end\n+        for _, v in ipairs(cell[3]) do\n+          if v[2] then\n+            s = s .. (name_to_tag(state.highlights_name[v[2]]))\n+          end\n+          s = s .. (html_escape(v[1], state.tabstop))\n+          if v[2] then\n+            s = s .. (name_to_closetag(state.highlights_name[v[2]]))\n+          end\n+        end\n+        char = cell[4][#cell[4]]\n+      end\n+      if col == #line + 1 and not char then\n+        break\n+      end\n+      if hide_count == 0 then\n+        char = char\n+          or { vim.api.nvim_buf_get_text(state.bufnr, row - 1, col - 1, row - 1, col, {})[1] }\n+        if char[2] then\n+          s = s .. name_to_tag(state.highlights_name[char[2]])\n+        end\n+        s = s .. html_escape(char[1], state.tabstop)\n+        if char[2] then\n+          s = s .. name_to_closetag(state.highlights_name[char[2]])\n+        end\n+      end\n+    end\n+    table.insert(out, s)\n+  end\n+  for row = 1, state.buflen + 1 do\n+    loop(row)\n+  end\n+  assert(#stack == 0, 'an open html tag was never closed')\n+  table.insert(out, '</pre>')\n+end\n+\n+--- @param out string[]\n+--- @param fn fun()\n+local function extend_body(out, fn)\n+  table.insert(out, '<body style=\"display: flex\">')\n+  fn()\n+  table.insert(out, '</body>')\n+end\n+\n+--- @param out string[]\n+--- @param fn fun()\n+local function extend_html(out, fn)\n+  table.insert(out, '<!DOCTYPE html>')\n+  table.insert(out, '<html>')\n+  fn()\n+  table.insert(out, '</html>')\n+end\n+\n+--- @param winnr number\n+--- @param global_state vim.tohtml.state.global\n+--- @return vim.tohtml.state\n+local function global_state_to_state(winnr, global_state)\n+  local bufnr = vim.api.nvim_win_get_buf(winnr)\n+  local opt = global_state.conf\n+  local width = opt.width or vim.bo[bufnr].textwidth\n+  if not width or width < 1 then\n+    width = vim.api.nvim_win_get_width(winnr)\n+  end\n+  local state = setmetatable({\n+    winnr = winnr == 0 and vim.api.nvim_get_current_win() or winnr,\n+    opt = vim.wo[winnr],\n+    style = generate_styletable(bufnr),\n+    bufnr = bufnr,\n+    tabstop = (' '):rep(vim.bo[bufnr].tabstop),\n+    width = width,\n+    buflen = vim.api.nvim_buf_line_count(bufnr),\n+  }, { __index = global_state })\n+  return state --[[@as vim.tohtml.state]]\n+end\n+\n+--- @param opt vim.tohtml.opt\n+--- @param title? string\n+--- @return vim.tohtml.state.global\n+local function opt_to_global_state(opt, title)\n+  local fonts = {}\n+  if opt.font then\n+    fonts = type(opt.font) == 'string' and { opt.font } or opt.font --[[@as (string[])]]\n+  elseif vim.o.guifont:match('^[^:]+') then\n+    table.insert(fonts, vim.o.guifont:match('^[^:]+'))\n+  end\n+  table.insert(fonts, 'monospace')\n+  --- @type vim.tohtml.state.global\n+  local state = {\n+    background = get_background_color(),\n+    foreground = get_foreground_color(),\n+    title = opt.title or title or false,\n+    font = table.concat(fonts, ','),\n+    highlights_name = {},\n+    conf = opt,\n+  }\n+  return state\n+end\n+\n+--- @type function[]",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473104900",
            "id": 1473104900,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5XzcwE",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 1184,
            "original_position": 1177,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": null,
            "pull_request_review_id": 1854202924,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473104900/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:24:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473104900",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473133154"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473133154"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "`string?`\r\nAdded the type hints to code. (If it's that you're after)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:39:45Z",
            "diff_hunk": "@@ -0,0 +1,1263 @@\n+---@defgroup vim.tohtml\n+\n+-- The HTML conversion script is different from Vim's one. If you want to use\n+-- Vim's TOhtml converter, download it from the vim GitHub repo.\n+-- Here are the Vim files related to this functionality:\n+-- - https://github.com/vim/vim/blob/master/runtime/syntax/2html.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/autoload/tohtml.vim\n+-- - https://github.com/vim/vim/blob/master/runtime/plugin/tohtml.vim\n+--\n+-- Main differences between this and the vim version:\n+-- - No \"ignore some visual thing\" settings (just set the right Vim option)\n+-- - No support for legacy web engines\n+-- - No support for legacy encoding (supports only UTF-8)\n+-- - No interactive webpage\n+-- - No specifying the internal html (no XHTML, no use_css=false)\n+-- - No multiwindow diffs\n+-- - No ranges\n+--\n+-- Remarks:\n+-- - Not all visuals are supported, so it may differ.\n+\n+--- @class vim.tohtml.opt\n+--- @field title? string|false\n+--- @field number_lines? boolean\n+--- @field font? string[]|string\n+--- @field width? number\n+--- @class vim.tohtml.state.global\n+--- @field background string\n+--- @field foreground string\n+--- @field title string|false\n+--- @field font string\n+--- @field highlights_name table<number,string>\n+--- @field conf vim.tohtml.opt\n+--- @class vim.tohtml.state:vim.tohtml.state.global\n+--- @field style vim.tohtml.styletable\n+--- @field tabstop string|false\n+--- @field opt vim.wo\n+--- @field winnr number\n+--- @field bufnr number\n+--- @field width number\n+--- @field buflen number\n+--- @class vim.tohtml.styletable\n+--- @field [number] vim.tohtml.line (number: (1-index, exclusive))\n+--- @class vim.tohtml.line\n+--- @field virt_lines {[number]:{[1]:string,[2]:number}[]}\n+--- @field pre_text string[][]\n+--- @field hide? boolean\n+--- @field [number] vim.tohtml.cell? (number: (1-index, exclusive))\n+--- @class vim.tohtml.cell\n+--- @field [1] number[] start\n+--- @field [2] number[] close\n+--- @field [3]  any[][] virt_text\n+--- @field [4]  any[][] overlay_text\n+\n+local HIDE_ID = -1\n+\n+--- @type table<number,string>\n+local cterm_color_cache = {}\n+local background_color_cache = nil\n+local foreground_color_cache = nil",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473133154",
            "id": 1473133154,
            "in_reply_to_id": 1473091159,
            "line": 174,
            "node_id": "PRRC_kwDOAPphoM5Xzjpi",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 174,
            "original_position": 60,
            "original_start_line": null,
            "path": "runtime/lua/tohtml.lua",
            "position": 174,
            "pull_request_review_id": 1854282559,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473133154/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T16:39:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473133154",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1473138659"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473138659"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "That should then be another function, as this function is designed to be the same as `:TOhtml`.\r\n\r\nSo I added another function that does this (but it returns a list of strings).",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-01-31T16:43:40Z",
            "diff_hunk": "@@ -4308,4 +4308,29 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winnr}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1473138659",
            "id": 1473138659,
            "in_reply_to_id": 1473083677,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Xzk_j",
            "original_commit_id": "55affa23d4e7d3adaec6a89b071d7c8de9f7ce9d",
            "original_line": 4315,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1854291015,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473138659/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-31T17:07:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1473138659",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474028649"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474028649"
                }
            },
            "author_association": "MEMBER",
            "body": "This is not a proper tag. Can we do `vim.tohtml.tohtml()`? Also, `vim.tohtml` or `tohtml`?",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T08:44:59Z",
            "diff_hunk": "@@ -4308,4 +4308,46 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winid}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474028649",
            "id": 1474028649,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X2-Rp",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 4315,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1855868398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474028649/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T08:52:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474028649",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474029605"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474029605"
                }
            },
            "author_association": "MEMBER",
            "body": "also here",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T08:45:31Z",
            "diff_hunk": "@@ -4308,4 +4308,46 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winid}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*\n+    Converts a window to HTML.\n+\n+    Converts a window to HTML, including diffs and folds. Opens a slit window\n+    containing the converted HTML.                           *convert-to-HTML*\n+\n+    Can also be converted with `:TOhtml` .                           *:TOhtml*\n+\n+    Parameters: ~\n+       {winid}    (`integer?`) Defaults to current window.\n+       {outfile}  (`string?`) Defaults to a temp file.\n+       {opt}      (`table?`) Optional parameters.\n+                    title (string): Title of the html (defaults to buffer\n+                     name)\n+                    number_lines (boolean): Show line numbers (defaults to\n+                     `false`)\n+                    font (string|string[]): Fonts to use (defaults to\n+                     `guifont`)\n+                    width (integer): Width of the html (defaults to\n+                     'textwidth' or window width)\n+\n+tohtml_lines({winid}, {opt})                  *require\"tohtml\".tohtml_lines()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474029605",
            "id": 1474029605,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X2-gl",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 4336,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1855868398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474029605/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T08:52:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474029605",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474030821"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474030821"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  have been removed. Some Nvim-specific features were added, such as treesitter support.\r\n```\r\n(with linewrap & whitespace changes)",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T08:46:14Z",
            "diff_hunk": "@@ -116,6 +116,9 @@ The following changes may require adaptations in user config or plugins.\n   upstream tree-sitter and Helix to make it easier to share queries. The full\n   list is documented in |treesitter-highlight-groups|.\n \n+ |:TOhtml| has been totally rewritten in Lua. Many legacy and (what we deem)\n+  unnecessary options have been removed and some of the less used features\n+  have been removed. Some features were adder like treesitter support.",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474030821",
            "id": 1474030821,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X2-zl",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 121,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 1855868398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474030821/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T08:52:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474030821",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474034787"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474034787"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  it('highlight attributes generated', function()\r\n```",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T08:48:28Z",
            "diff_hunk": "@@ -0,0 +1,349 @@\n+local Screen = require('test.functional.ui.screen')\n+local helpers = require('test.functional.helpers')(after_each)\n+\n+local clear = helpers.clear\n+local exec = helpers.exec\n+local exec_lua = helpers.exec_lua\n+local eq = helpers.eq\n+local fn = helpers.fn\n+local api = helpers.api\n+local insert = helpers.insert\n+\n+local function html_syntax_match()\n+  local styles =\n+    vim.split(api.nvim_exec2([[/<style>/+,/<\\/style>/-p]], { output = true }).output, '\\n')\n+  local attrnames = {\n+    ['font%-weight: bold'] = 'bold',\n+    ['text%-decoration%-line: [^;]*underline'] = 'underline',\n+    ['font%-style: italic'] = 'italic',\n+    ['text%-decoration%-line: [^;]*line%-through'] = 'strikethrough',\n+  }\n+  local hls = {}\n+  for _, style in ipairs(styles) do\n+    local attr = {}\n+    for match, attrname in pairs(attrnames) do\n+      if style:find(match) then\n+        ---@type boolean\n+        attr[attrname] = true\n+      end\n+    end\n+    attr.bg = style:match('background%-color: #(%x+)')\n+    if attr.bg then\n+      attr.bg = tonumber(attr.bg, 16)\n+    end\n+    attr.fg = style:match('[^%-]color: #(%x+)')\n+    if attr.fg then\n+      attr.fg = tonumber(attr.fg, 16)\n+    end\n+    if style:match('^%.(%w+)') then\n+      ---@type table\n+      hls[style:match('^%.(%w+)')] = attr\n+    end\n+  end\n+  local whitelist = {\n+    'fg',\n+    'bg',\n+    --'sp',\n+    --'blend',\n+    'bold',\n+    --'standout',\n+    'underline',\n+    --'undercurl',\n+    --'underdouble',\n+    --'underdotted',\n+    --'underdashed',\n+    'strikethrough',\n+    'italic',\n+    --'reverse',\n+    --'nocombine',\n+  }\n+  for name, attrs_old in\n+    pairs(api.nvim_get_hl(0, { link = true }) --[[@as table<string,table>]])\n+  do\n+    ---@type table\n+    local other = hls[name:gsub('%.', '-'):gsub('@', '-')]\n+    if other then\n+      local attrs = {}\n+      for _, attrname in ipairs(whitelist) do\n+        ---@type table\n+        attrs[attrname] = attrs_old[attrname]\n+      end\n+      eq(attrs, other)\n+    end\n+  end\n+  return hls\n+end\n+\n+local function html_to_extmarks()\n+  local buf = api.nvim_get_current_buf()\n+  local ns = api.nvim_create_namespace 'test-namespace'\n+  api.nvim_buf_clear_namespace(buf, ns, 0, -1)\n+  exec 'silent! norm! ggd/^<pre>$\\rddG3dk'\n+  local stack = {}\n+  exec [[set filetype=]]\n+  exec [[silent! %s/<//g]]\n+  exec [[silent! %s/&quot;/\"/g]]\n+  exec [[silent! %s/&amp;/\\&/g]]\n+  exec [[silent! %s/&gt;/>/g]]\n+  exec [[silent! %s/&lt;/</g]]\n+  for _, match in\n+    ipairs(\n+      fn.matchbufline(buf, [[span class=\"\\([^\"]\\+\\)\">\\|/span>]], 1, '$', { submatches = true }) --[[@as (table[])]]\n+    )\n+  do\n+    if match.text == '/span>' then\n+      local val = table.remove(stack)\n+      api.nvim_buf_set_extmark(buf, ns, val.lnum - 1, val.byteidx, {\n+        hl_group = val.submatches[1],\n+        end_row = match.lnum - 1,\n+        end_col = match.byteidx,\n+      })\n+    else\n+      table.insert(stack, match)\n+    end\n+  end\n+  exec [[silent! %s/\\/span>//g]]\n+  exec [[silent! %s/span[^>]*>//g]]\n+end\n+\n+---@param screen test.functional.ui.screen\n+---@param func function?\n+local function run_tohtml_and_assert(screen, func)\n+  exec('norm! ggO-;')\n+  exec('norm! gg0f;:\\r')\n+  screen:sleep(10)\n+  local snapshot = { grid = screen:get_snapshot().grid, attr_ids = screen:get_snapshot().attr_ids }\n+  do\n+    (func or exec)('TOhtml')\n+  end\n+  exec('only')\n+  html_syntax_match()\n+  html_to_extmarks()\n+  exec('norm! gg0f;:\\r')\n+  screen:sleep(10)\n+  eq(snapshot, { grid = screen:get_snapshot().grid, attr_ids = screen:get_snapshot().attr_ids })\n+end\n+\n+describe(':TOhtml', function()\n+  --- @type test.functional.ui.screen\n+  local screen\n+  before_each(function()\n+    clear({ args = { '--clean' } })\n+    screen = Screen.new(80, 80)\n+    screen:attach({ term_name = 'xterm' })\n+    exec('colorscheme default')\n+  end)\n+\n+  it('expected internal html generated', function()\n+    insert([[line]])\n+    exec('set termguicolors')\n+    local bg = fn.synIDattr(fn.hlID('Normal'), 'bg#', 'gui')\n+    local fg = fn.synIDattr(fn.hlID('Normal'), 'fg#', 'gui')\n+    exec_lua [[require'tohtml'.tohtml(0,nil,{title='title',font='dumyfont'})]]\n+    local out_file = api.nvim_buf_get_name(api.nvim_get_current_buf())\n+    eq({\n+      '<!DOCTYPE html>',\n+      '<html>',\n+      '<head>',\n+      '<meta charset=\"UTF-8\">',\n+      '<title>title</title>',\n+      ('<meta name=\"colorscheme\" content=\"%s\"></meta>'):format(api.nvim_get_var('colors_name')),\n+      '<style>',\n+      '* {font-family: dumyfont,monospace}',\n+      ('body {background-color: %s; color: %s}'):format(bg, fg),\n+      '</style>',\n+      '</head>',\n+      '<body style=\"display: flex\">',\n+      '<pre>',\n+      'line',\n+      '',\n+      '</pre>',\n+      '</body>',\n+      '</html>',\n+    }, fn.readfile(out_file))\n+  end)\n+\n+  it('highlgith attributes generated', function()",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474034787",
            "id": 1474034787,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X2_xj",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 166,
            "original_position": 166,
            "original_start_line": null,
            "path": "test/functional/plugin/tohtml_spec.lua",
            "position": null,
            "pull_request_review_id": 1855868398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474034787/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T08:52:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474034787",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474044842"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474044842"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this text can be significantly shortened; no need to give rationale here.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T08:53:42Z",
            "diff_hunk": "@@ -116,6 +116,9 @@ The following changes may require adaptations in user config or plugins.\n   upstream tree-sitter and Helix to make it easier to share queries. The full\n   list is documented in |treesitter-highlight-groups|.\n \n+ |:TOhtml| has been totally rewritten in Lua. Many legacy and (what we deem)\n+  unnecessary options have been removed and some of the less used features\n+  have been removed. Some features were adder like treesitter support.",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474044842",
            "id": 1474044842,
            "in_reply_to_id": 1474030821,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X3COq",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 121,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 1855897239,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474044842/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T08:53:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474044842",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474084409"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474084409"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "tohtml is more of an external plugin so `tohtml` instead of `vim.tohtml`.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T09:17:08Z",
            "diff_hunk": "@@ -4308,4 +4308,46 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: vim.tohtml                                            *vim.tohtml*\n+\n+tohtml({winid}, {outfile}, {opt})                   *require\"tohtml\".tohtml()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474084409",
            "id": 1474084409,
            "in_reply_to_id": 1474028649,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X3L45",
            "original_commit_id": "5f75ef4b3d210582d019652c58b875a9e971d336",
            "original_line": 4315,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1855960050,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474084409/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T09:17:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474084409",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27097#discussion_r1474137219"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27097"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474137219"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think we need two functions here, one should be enough. Adding a light wrapper that just writes to a file isn't worth extra surface area IMO.\r\n\r\nFrom what I understand, the goal is provide a `:Tohtml` ex command. If so, the ex command should take an output file name as an argument, and internally use `vim.tohtml()` which just outputs a string.",
            "commit_id": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
            "created_at": "2024-02-01T09:47:30Z",
            "diff_hunk": "@@ -4308,4 +4308,46 @@ vim.text.hexencode({str})                               *vim.text.hexencode()*\n     Return: ~\n         (`string`) Hex encoded string\n \n+\n+==============================================================================\n+Lua module: tohtml                                                    *tohtml*\n+\n+tohtml({winid}, {outfile}, {opt})                            *tohtml.tohtml()*\n+    Converts a window to HTML.\n+\n+    Converts a window to HTML, including diffs and folds. Opens a slit window\n+    containing the converted HTML.                           *convert-to-HTML*\n+\n+    Can also be converted with `:TOhtml` .                           *:TOhtml*\n+\n+    Parameters: ~\n+       {winid}    (`integer?`) Defaults to current window.\n+       {outfile}  (`string?`) Defaults to a temp file.\n+       {opt}      (`table?`) Optional parameters.\n+                    title (string): Title of the html (defaults to buffer\n+                     name)\n+                    number_lines (boolean): Show line numbers (defaults to\n+                     `false`)\n+                    font (string|string[]): Fonts to use (defaults to\n+                     `guifont`)\n+                    width (integer): Width of the html (defaults to\n+                     'textwidth' or window width)\n+\n+tohtml_lines({winid}, {opt})                           *tohtml.tohtml_lines()*",
            "html_url": "https://github.com/neovim/neovim/pull/27097#discussion_r1474137219",
            "id": 1474137219,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5X3YyD",
            "original_commit_id": "7c7080cc4c8912adc7126e71eea28406c93e834a",
            "original_line": 4336,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1856031918,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474137219/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-01T09:47:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1474137219",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "> Question to the Neovim maintainer: Do we need to support everything that TOhtml.vim does?\r\n\r\nIdeally, yes. The assumption should be that the output is exactly what's seen on the screen. But it's ok not to support everything in a first MVP that can be merged, if the design is such that it _can_ be added in followup PRs.\r\n\r\nThis also implies that we don't need to support every feature and option from the legacy `:TOhtml` (which users can still install as a plugin if they pine for the good old days). Focus on the primary use case (hardcopy/offline viewing), and only implement what is needed for that. (This is an opportunity for simplification and better maintainability, importantly.)\r\n\r\nSpecifically:\r\n\r\n1. linking URLs would be good but not needed for an MVP;\r\n2. no progress bar (Lua is hopefully fast enough that you don't need one);\r\n3. no interactivity/lots of settings (just set the right Vim options _before_ `:TOhtml`, which gives you a preview for free);\r\n4. no legacy web engines, no legacy encodings (Neovim is utf-8 only).",
            "created_at": "2024-01-20T09:40:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1902038669",
            "id": 1902038669,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5xXs6N",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902038669/reactions"
            },
            "updated_at": "2024-01-24T17:04:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902038669",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "What about features such as a progress bar and linking URLs (and interactive folding)?",
            "created_at": "2024-01-20T09:42:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1902038988",
            "id": 1902038988,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5xXs_M",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902038988/reactions"
            },
            "updated_at": "2024-01-20T09:48:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902038988",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I think it's OK to keep the syntax file (and even preferable; makes syncing with Vim runtime slightly easier).",
            "created_at": "2024-01-20T10:41:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1902061805",
            "id": 1902061805,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5xXyjt",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902061805/reactions"
            },
            "updated_at": "2024-01-20T10:41:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1902061805",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Let me apologize: I started with drive-by comments and didn't consider myself the primary reviewer of this PR; as such I wasn't aware quite how bad the legacy `:TOhtml` is. Now that I have a better idea, I strongly suggest that we take a break from porting features and first discuss the interface we want to have in Neovim, starting from _our_ main goal: enabling `:Hardcopy`.\r\n\r\n@justinmk @lewis6991 @gpanders ",
            "created_at": "2024-01-25T09:42:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1909766174",
            "id": 1909766174,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5x1Lge",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909766174/reactions"
            },
            "updated_at": "2024-01-25T09:42:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909766174",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Regarding semantic tokens: there's `vim.lsp.semantic_tokens.force_refresh()`, which could be extended to force a (re)draw of the _whole_ buffer. Otherwise we would have to do it manually (using internal functions).",
            "created_at": "2024-01-25T10:08:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1909809081",
            "id": 1909809081,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5x1V-5",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909809081/reactions"
            },
            "updated_at": "2024-01-25T10:08:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909809081",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Injected trees that were not highlighted by the treesitter-highlighter\r\n\r\nI think you can just force a full reparse (`parser:parse(true)`) in the `tohtml` function; as this is run on-demand and expected to block, this fine in this case.",
            "created_at": "2024-01-25T11:18:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1909952935",
            "id": 1909952935,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5x15Gn",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909952935/reactions"
            },
            "updated_at": "2024-01-25T11:18:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1909952935",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> starting from _our_ main goal: enabling `:Hardcopy`.\r\n\r\nYes, exactly. Initially we just need something that produces _some sort of printable document_ (HTML is likely the most useful). And the work (this PR) to get presentation information from a buffer, will obviously be useful for other purposes later, so keep that in mind :) ",
            "created_at": "2024-01-26T23:37:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/27097#issuecomment-1912829684",
            "id": 1912829684,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
            "node_id": "IC_kwDOAPphoM5yA3b0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1912829684/reactions"
            },
            "updated_at": "2024-01-26T23:37:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1912829684",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/27097/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/27097/commits",
    "created_at": "2024-01-20T09:37:32Z",
    "diff_url": "https://github.com/neovim/neovim/pull/27097.diff",
    "draft": false,
    "head": {
        "label": "altermo:tohtml-in-lua",
        "ref": "tohtml-in-lua",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/altermo/neovim-fork/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/altermo/neovim-fork/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/altermo/neovim-fork/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/altermo/neovim-fork/branches{/branch}",
            "clone_url": "https://github.com/altermo/neovim-fork.git",
            "collaborators_url": "https://api.github.com/repos/altermo/neovim-fork/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/altermo/neovim-fork/comments{/number}",
            "commits_url": "https://api.github.com/repos/altermo/neovim-fork/commits{/sha}",
            "compare_url": "https://api.github.com/repos/altermo/neovim-fork/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/altermo/neovim-fork/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/altermo/neovim-fork/contributors",
            "created_at": "2023-09-13T06:55:17Z",
            "default_branch": "DONT-USE-THIS-AS-SOURCE-WHEN-CREATING-NEW-BRANCH",
            "deployments_url": "https://api.github.com/repos/altermo/neovim-fork/deployments",
            "description": null,
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/altermo/neovim-fork/downloads",
            "events_url": "https://api.github.com/repos/altermo/neovim-fork/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/altermo/neovim-fork/forks",
            "full_name": "altermo/neovim-fork",
            "git_commits_url": "https://api.github.com/repos/altermo/neovim-fork/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/altermo/neovim-fork/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/altermo/neovim-fork/git/tags{/sha}",
            "git_url": "git://github.com/altermo/neovim-fork.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/altermo/neovim-fork/hooks",
            "html_url": "https://github.com/altermo/neovim-fork",
            "id": 690927347,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/altermo/neovim-fork/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/altermo/neovim-fork/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/altermo/neovim-fork/issues{/number}",
            "keys_url": "https://api.github.com/repos/altermo/neovim-fork/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/altermo/neovim-fork/labels{/name}",
            "language": null,
            "languages_url": "https://api.github.com/repos/altermo/neovim-fork/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/altermo/neovim-fork/merges",
            "milestones_url": "https://api.github.com/repos/altermo/neovim-fork/milestones{/number}",
            "mirror_url": null,
            "name": "neovim-fork",
            "node_id": "R_kgDOKS628w",
            "notifications_url": "https://api.github.com/repos/altermo/neovim-fork/notifications{?since,all,participating}",
            "open_issues": 1,
            "open_issues_count": 1,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
                "events_url": "https://api.github.com/users/altermo/events{/privacy}",
                "followers_url": "https://api.github.com/users/altermo/followers",
                "following_url": "https://api.github.com/users/altermo/following{/other_user}",
                "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/altermo",
                "id": 107814000,
                "login": "altermo",
                "node_id": "U_kgDOBm0ccA",
                "organizations_url": "https://api.github.com/users/altermo/orgs",
                "received_events_url": "https://api.github.com/users/altermo/received_events",
                "repos_url": "https://api.github.com/users/altermo/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/altermo"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/altermo/neovim-fork/pulls{/number}",
            "pushed_at": "2024-02-05T17:19:10Z",
            "releases_url": "https://api.github.com/repos/altermo/neovim-fork/releases{/id}",
            "size": 245987,
            "ssh_url": "git@github.com:altermo/neovim-fork.git",
            "stargazers_count": 1,
            "stargazers_url": "https://api.github.com/repos/altermo/neovim-fork/stargazers",
            "statuses_url": "https://api.github.com/repos/altermo/neovim-fork/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/altermo/neovim-fork/subscribers",
            "subscription_url": "https://api.github.com/repos/altermo/neovim-fork/subscription",
            "svn_url": "https://github.com/altermo/neovim-fork",
            "tags_url": "https://api.github.com/repos/altermo/neovim-fork/tags",
            "teams_url": "https://api.github.com/repos/altermo/neovim-fork/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/altermo/neovim-fork/git/trees{/sha}",
            "updated_at": "2023-11-15T07:57:27Z",
            "url": "https://api.github.com/repos/altermo/neovim-fork",
            "visibility": "public",
            "watchers": 1,
            "watchers_count": 1,
            "web_commit_signoff_required": false
        },
        "sha": "08e4d99e5dec99e3f7c965ba0a5915601842ea26",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
            "events_url": "https://api.github.com/users/altermo/events{/privacy}",
            "followers_url": "https://api.github.com/users/altermo/followers",
            "following_url": "https://api.github.com/users/altermo/following{/other_user}",
            "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/altermo",
            "id": 107814000,
            "login": "altermo",
            "node_id": "U_kgDOBm0ccA",
            "organizations_url": "https://api.github.com/users/altermo/orgs",
            "received_events_url": "https://api.github.com/users/altermo/received_events",
            "repos_url": "https://api.github.com/users/altermo/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/altermo"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/27097",
    "id": 1688162680,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27097",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "funtime",
            "id": 120251370,
            "name": "runtime",
            "node_id": "MDU6TGFiZWwxMjAyNTEzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/runtime"
        }
    ],
    "locked": false,
    "merge_commit_sha": "894dc7a7994353796041429d8aa2ac9ed4e9f4da",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5kn1F4",
    "number": 27097,
    "patch_url": "https://github.com/neovim/neovim/pull/27097.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/27097/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/08e4d99e5dec99e3f7c965ba0a5915601842ea26",
    "title": "feat!: rewrite TOhtml in lua",
    "updated_at": "2024-02-02T22:29:45Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/27097",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/107814000?v=4",
        "events_url": "https://api.github.com/users/altermo/events{/privacy}",
        "followers_url": "https://api.github.com/users/altermo/followers",
        "following_url": "https://api.github.com/users/altermo/following{/other_user}",
        "gists_url": "https://api.github.com/users/altermo/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/altermo",
        "id": 107814000,
        "login": "altermo",
        "node_id": "U_kgDOBm0ccA",
        "organizations_url": "https://api.github.com/users/altermo/orgs",
        "received_events_url": "https://api.github.com/users/altermo/received_events",
        "repos_url": "https://api.github.com/users/altermo/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/altermo/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/altermo/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/altermo"
    }
}