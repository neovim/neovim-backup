{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/27339/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27339/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/27339"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/27339"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27339/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5495,
            "forks_count": 5495,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1766,
            "open_issues_count": 1766,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-07-08T22:41:26Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 277808,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 79943,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-07-09T01:46:42Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 79943,
            "watchers_count": 79943,
            "web_commit_signoff_required": false
        },
        "sha": "8ba73f0e4cc6c82032a348a1d6c8d794ed150fd7",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "Closes #25714\r\n\r\nThis PR introduces `vim.lsp.completion` with the goal of supporting the completion behaviours (snippet expansion, execution of commands, application of text edits) specified by LSP.\r\n\r\nTo enable completions for a given buffer and client, users should call `vim.lsp.completion.enable(true, client_id, bufnr, opts)`. Currently the options parameter includes the `autotrigger` property, which when set will request completions after a trigger character has been typed.\r\n\r\nThis PR also sets new default keymaps for the snippet navigation:\r\n- `<Tab>` will jump to the next tabstop if the snippet is active and jumpable forwards.\r\n- `<S-Tab>` will jump to the previous tabstop if the snippet is active and jumpable backwards.\r\n\r\nIf these keys are being used in other keymaps, they will be restored once the snippet session ends.",
    "closed_at": "2024-05-28T17:39:30Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1493820152"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493820152"
                }
            },
            "author_association": "MEMBER",
            "body": "Reluctant to add \"attach to client\" (or \"attach to completion\") as yet another way to extend the LSP client. There are already so many ways: start, callbacks, protocol handlers (local and global).\r\n\r\n> Make it opt-in via a `vim.lsp.completion.attach(client, bufnr, [opts])` method\r\n\r\nIf we enabled it by default, then it could be _opt-out_, by documenting how to delete the `CompleteDone` handler. Any problem with that?\r\n\r\nAlternatively, for _opt-in_ behavior, we could document how to define a `CompleteDone` handler that calls a function we provide. \r\n",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-02-18T18:22:54Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1493820152",
            "id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ZCeL4",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 1887302138,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493820152/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-18T18:25:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493820152",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1493835482"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493835482"
                }
            },
            "author_association": "MEMBER",
            "body": "I think I prefer opt-in, at least while we develop this feature and make sure it has everything we want/need of core LSP completion.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-02-18T20:05:46Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1493835482",
            "id": 1493835482,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ZCh7a",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 1887317085,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493835482/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-18T20:05:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1493835482",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1494923283"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1494923283"
                }
            },
            "author_association": "MEMBER",
            "body": "These are only needed when we want to trigger completion when deleting. `lsp_compl` makes this configurable, but I think we should just always enable it here (?). WDYT?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-02-19T18:41:28Z",
            "diff_hunk": "@@ -0,0 +1,128 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle) end\n+\n+local function text_changed_p_cb() end\n+\n+local function text_changed_i_cb() end\n+\n+local function insert_leave_cb() end\n+\n+local function complete_done_cb() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      pcall(M.trigger_completion)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)\n+  bufnr = (bufnr == 0 and vim.api.nvim_get_current_buf()) or bufnr\n+\n+  if not buf_handles[bufnr] then\n+    buf_handles[bufnr] = { clients = {}, triggers = {} }\n+\n+    -- Attach to buffer events.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, buf)\n+        buf_handles[buf] = nil\n+      end,\n+      on_reload = function(_, buf)\n+        M.attach(client_id, buf)\n+      end,\n+    })\n+\n+    -- Set up autocommands.\n+    local group =\n+      vim.api.nvim_create_augroup(string.format('vim/lsp/completion-%d', bufnr), { clear = true })\n+    vim.api.nvim_create_autocmd('InsertCharPre', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = function()\n+        insert_char_pre_cb(buf_handles[bufnr])\n+      end,\n+    })\n+    vim.api.nvim_create_autocmd('TextChangedP', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = function()\n+        text_changed_p_cb()\n+      end,\n+    })\n+    vim.api.nvim_create_autocmd('TextChangedI', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = function()\n+        text_changed_i_cb()\n+      end,\n+    })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1494923283",
            "id": 1494923283,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ZGrgT",
            "original_commit_id": "0d2340935bea14217f4c98755899a330da76d8a2",
            "original_line": 679,
            "original_position": 82,
            "original_start_line": 69,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 1889009848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1494923283/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-02-19T18:41:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1494923283",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1515390941"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515390941"
                }
            },
            "author_association": "MEMBER",
            "body": "[`lsp_compl`](https://github.com/mfussenegger/nvim-lsp-compl/blob/512abbbf40ca98e50b69f70a45e73496adfcc3ee/lua/lsp_compl.lua#L875) also includes `'detail'` and `'documentation'` here, but I'm unsure of doing that since there's actually no support for fetching that when resolving a completion item. If not present in the original completion request, those just default to an empty string.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T02:20:40Z",
            "diff_hunk": "@@ -744,14 +744,15 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,\n           commitCharactersSupport = false,\n           preselectSupport = false,\n           deprecatedSupport = false,\n           documentationFormat = { protocol.MarkupKind.Markdown, protocol.MarkupKind.PlainText },\n+          resolveSupport = {",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1515390941",
            "id": 1515390941,
            "line": 746,
            "node_id": "PRRC_kwDOAPphoM5aUwfd",
            "original_commit_id": "894946c5cb7a2d5afb15322772d43d244dd5a7f4",
            "original_line": 746,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 13,
            "pull_request_review_id": 1921277647,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515390941/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-03-07T02:20:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515390941",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1515426713"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515426713"
                }
            },
            "author_association": "MEMBER",
            "body": "I've made the feature enabled by default, documenting how to disable it if desired. Lmk what you think @justinmk :)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T03:09:45Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1515426713",
            "id": 1515426713,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5aU5OZ",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 1921358458,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515426713/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-03-07T03:09:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515426713",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1515685683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515685683"
                }
            },
            "author_association": "MEMBER",
            "body": "I think it's possible to use `client._exec_cmd` here instead (it's still private, so lsp_compl isn't using it)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T07:44:10Z",
            "diff_hunk": "@@ -273,4 +381,396 @@ function M.omnifunc(findstart, base)\n   return -2\n end\n \n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client vim.lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if not lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd] then\n+    client.commands[trigger_completion_cmd] = function()\n+      pcall(M.trigger_completion)\n+    end\n+  end\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer(completion_timer)\n+\n+      -- Calling vim.fn.complete while pumvisible will trigger `CompleteDone` for the active completion window,\n+      -- so we suppress it to avoid resetting the completion context.\n+      Context.suppress_completeDone = true\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger_completion)\n+      else\n+        completion_timer = new_timer(completion_timer)\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger_completion))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer(completion_timer)\n+      vim.schedule(M.trigger_completion)\n+    end)\n+  end\n+end\n+\n+local function text_changed_p_cb()\n+  Context.cursor = api.nvim_win_get_cursor(0)\n+end\n+\n+local function text_changed_i_cb()\n+  if not Context.cursor or completion_timer then\n+    return\n+  end\n+\n+  local cursor = api.nvim_win_get_cursor(0)\n+  if cursor[1] == Context.cursor[1] and cursor[2] <= Context.cursor[2] then\n+    completion_timer = new_timer(completion_timer)\n+    completion_timer:start(150, 0, vim.schedule_wrap(M.trigger_completion))\n+  elseif cursor[1] ~= Context.cursor[1] then\n+    Context.cursor = nil\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer(completion_timer)\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  if Context.suppress_completeDone then\n+    Context.suppress_completeDone = false\n+    return\n+  end\n+\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data then\n+    Context:reset()\n+    return\n+  end\n+\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and Context.expand_snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)\n+    if expand_snippet then\n+      apply_snippet(completion_item, suffix)\n+    end\n+\n+    local command = completion_item.command\n+    if command then\n+      local fn = client.commands[command.command] or lsp.commands[command.command]\n+      if fn then\n+        fn(command, { bufnr = bufnr, client_id = client_id })\n+      else\n+        local command_provider = client.server_capabilities.executeCommandProvider or {}\n+        local server_commands = command_provider.commands or {}\n+        if vim.tbl_contains(server_commands, command.command) then\n+          client.request(ms.workspace_executeCommand, {\n+            command = command.command,\n+            arguments = command.arguments,\n+          }, function() end, bufnr)\n+        else\n+          vim.notify(\n+            'Command not supported on client or server: ' .. command.command,\n+            vim.log.levels.WARN\n+          )\n+        end\n+      end\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1515685683",
            "id": 1515685683,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5aV4cz",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 562,
            "original_position": 398,
            "original_start_line": 542,
            "path": "runtime/lua/vim/lsp/_completion.lua",
            "position": null,
            "pull_request_review_id": 1921667827,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515685683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-03-07T07:55:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515685683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1515688809"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515688809"
                }
            },
            "author_association": "MEMBER",
            "body": "If we enable the snippets by default I think we've to discuss adding default keymaps for snippet navigation too, or how would users use them?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T07:47:26Z",
            "diff_hunk": "@@ -744,14 +744,15 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1515688809",
            "id": 1515688809,
            "line": 741,
            "node_id": "PRRC_kwDOAPphoM5aV5Np",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 741,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 8,
            "pull_request_review_id": 1921667827,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515688809/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-03-07T07:55:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515688809",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1515698767"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515698767"
                }
            },
            "author_association": "MEMBER",
            "body": "My rough plan would've been to instead rename `_completion.lua` to `completion.lua` and then have `vim.lsp.completion.trigger()`, `.attach()`, `.detach` and I guess `.accept_pum` also needs to be public, unless `CompleteDone` gets extended with a property indicating if the entries got exhaused or if one was explicitly selected with ctrl-y \r\n\r\nIf we go for opt-out instead of opt-in it also opens the question of how to configure the options (trigger characters, later on maybe the debounce interval, if backspace should re-trigger, and maybe server-side fuzzy search support)\r\n\r\n",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T07:55:29Z",
            "diff_hunk": "@@ -1026,6 +1029,14 @@ function lsp.omnifunc(findstart, base)\n   return vim.lsp._completion.omnifunc(findstart, base)\n end\n \n+--- Detaches a client from the given buffer to stop requesting LSP completions.\n+---\n+--- @param client_id integer\n+--- @param bufnr integer\n+function lsp.detach_completion(client_id, bufnr)\n+  vim.lsp._completion.detach(client_id, bufnr)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1515698767",
            "id": 1515698767,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5aV7pP",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 1006,
            "original_position": 35,
            "original_start_line": 1032,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 1921667827,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515698767/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-03-07T07:55:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1515698767",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1516540050"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1516540050"
                }
            },
            "author_association": "MEMBER",
            "body": "This function is mostly called in \"scheduled\" fashion (via `vim.shedule()` or after `vim.schedule_wrap()`). Usually it should be possible to do single `schedule_wrap()` after defining function instead of all other scheduling in place.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-07T17:16:37Z",
            "diff_hunk": "@@ -273,4 +381,396 @@ function M.omnifunc(findstart, base)\n   return -2\n end\n \n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client vim.lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if not lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd] then\n+    client.commands[trigger_completion_cmd] = function()\n+      pcall(M.trigger_completion)\n+    end\n+  end\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer(completion_timer)\n+\n+      -- Calling vim.fn.complete while pumvisible will trigger `CompleteDone` for the active completion window,\n+      -- so we suppress it to avoid resetting the completion context.\n+      Context.suppress_completeDone = true\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger_completion)\n+      else\n+        completion_timer = new_timer(completion_timer)\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger_completion))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer(completion_timer)\n+      vim.schedule(M.trigger_completion)\n+    end)\n+  end\n+end\n+\n+local function text_changed_p_cb()\n+  Context.cursor = api.nvim_win_get_cursor(0)\n+end\n+\n+local function text_changed_i_cb()\n+  if not Context.cursor or completion_timer then\n+    return\n+  end\n+\n+  local cursor = api.nvim_win_get_cursor(0)\n+  if cursor[1] == Context.cursor[1] and cursor[2] <= Context.cursor[2] then\n+    completion_timer = new_timer(completion_timer)\n+    completion_timer:start(150, 0, vim.schedule_wrap(M.trigger_completion))\n+  elseif cursor[1] ~= Context.cursor[1] then\n+    Context.cursor = nil\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer(completion_timer)\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  if Context.suppress_completeDone then\n+    Context.suppress_completeDone = false\n+    return\n+  end\n+\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data then\n+    Context:reset()\n+    return\n+  end\n+\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and Context.expand_snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)\n+    if expand_snippet then\n+      apply_snippet(completion_item, suffix)\n+    end\n+\n+    local command = completion_item.command\n+    if command then\n+      local fn = client.commands[command.command] or lsp.commands[command.command]\n+      if fn then\n+        fn(command, { bufnr = bufnr, client_id = client_id })\n+      else\n+        local command_provider = client.server_capabilities.executeCommandProvider or {}\n+        local server_commands = command_provider.commands or {}\n+        if vim.tbl_contains(server_commands, command.command) then\n+          client.request(ms.workspace_executeCommand, {\n+            command = command.command,\n+            arguments = command.arguments,\n+          }, function() end, bufnr)\n+        else\n+          vim.notify(\n+            'Command not supported on client or server: ' .. command.command,\n+            vim.log.levels.WARN\n+          )\n+        end\n+      end\n+    end\n+  end\n+\n+  if completion_item.additionalTextEdits and next(completion_item.additionalTextEdits) then\n+    local suffix = clear_word()\n+    lsp.util.apply_text_edits(completion_item.additionalTextEdits, bufnr, offset_encoding)\n+    apply_snippet_and_command(suffix)\n+  elseif resolve_provider and type(completion_item) == 'table' then\n+    local changedtick = vim.b[bufnr].changedtick\n+\n+    --- @param result lsp.CompletionItem\n+    client.request(ms.completionItem_resolve, completion_item, function(err, result)\n+      if changedtick ~= vim.b[bufnr].changedtick then\n+        return\n+      end\n+\n+      local suffix = clear_word()\n+      if err then\n+        vim.notify_once(err.message, vim.log.levels.WARN)\n+      elseif result and result.additionalTextEdits then\n+        lsp.util.apply_text_edits(result.additionalTextEdits, bufnr, offset_encoding)\n+        if result.command then\n+          completion_item.command = result.command\n+        end\n+      end\n+\n+      apply_snippet_and_command(suffix)\n+    end, bufnr)\n+  else\n+    local suffix = clear_word()\n+    apply_snippet_and_command(suffix)\n+  end\n+end\n+\n+--- Trigger LSP completion in the current buffer.\n+function M.trigger_completion()",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1516540050",
            "id": 1516540050,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5aZJCS",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 597,
            "original_position": 433,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_completion.lua",
            "position": null,
            "pull_request_review_id": 1923061087,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1516540050/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-03-07T17:16:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1516540050",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1518266709"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1518266709"
                }
            },
            "author_association": "MEMBER",
            "body": "After further discussion, I think that making the feature opt-in is better for now. That will facilitate passing options (see [Mathias' comment](https://github.com/neovim/neovim/pull/27339#discussion_r1515698767)).",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-03-08T20:36:05Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1518266709",
            "id": 1518266709,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5afulV",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 1925795137,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1518266709/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-03-08T20:36:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1518266709",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581870035"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581870035"
                }
            },
            "author_association": "MEMBER",
            "body": "@lewis6991 How can I make the public stuff from this module appear in `lsp.txt`?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T17:25:31Z",
            "diff_hunk": "@@ -0,0 +1,776 @@\n+local M = {}",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581870035",
            "id": 1581870035,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5eSWvT",
            "original_commit_id": "005b88c65d195cac1c452f45dbef30f423094ace",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 1,
            "pull_request_review_id": 2026695104,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581870035/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-27T17:25:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581870035",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581899000"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581899000"
                }
            },
            "author_association": "MEMBER",
            "body": "Renamed the completion module.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T20:01:20Z",
            "diff_hunk": "@@ -1026,6 +1029,14 @@ function lsp.omnifunc(findstart, base)\n   return vim.lsp._completion.omnifunc(findstart, base)\n end\n \n+--- Detaches a client from the given buffer to stop requesting LSP completions.\n+---\n+--- @param client_id integer\n+--- @param bufnr integer\n+function lsp.detach_completion(client_id, bufnr)\n+  vim.lsp._completion.detach(client_id, bufnr)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581899000",
            "id": 1581899000,
            "in_reply_to_id": 1515698767,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eSdz4",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 1006,
            "original_position": 35,
            "original_start_line": 1032,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2026736178,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581899000/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-27T20:01:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581899000",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916020"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916020"
                }
            },
            "author_association": "MEMBER",
            "body": "would need an entry here: https://github.com/neovim/neovim/blob/32085c1e7c4936097c76970fa3639661b66c7e78/scripts/gen_vimdoc.lua#L268\r\n\r\n",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T22:26:36Z",
            "diff_hunk": "@@ -0,0 +1,776 @@\n+local M = {}",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916020",
            "id": 1581916020,
            "in_reply_to_id": 1581870035,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5eSh90",
            "original_commit_id": "005b88c65d195cac1c452f45dbef30f423094ace",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 1,
            "pull_request_review_id": 2026754760,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916020/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-27T22:26:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916020",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916925"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916925"
                }
            },
            "author_association": "MEMBER",
            "body": "> Reluctant to add \"attach to client\" (or \"attach to completion\") as yet another way to extend the LSP client. There are already so many ways: start, callbacks, protocol handlers (local and global).\r\n\r\nWas that resolved? Seems like this PR is still adding a new \"completion provider\" concept. ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T22:34:31Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916925",
            "id": 1581916925,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eSiL9",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2026755577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916925/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-27T22:34:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916925",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916966"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916966"
                }
            },
            "author_association": "MEMBER",
            "body": "> and then have `vim.lsp.completion.trigger()`, `.attach()`, `.detach` and I guess `.accept_pum` also needs to be public, \r\n\r\nThat seems like a lot. See also https://github.com/neovim/neovim/pull/27339#discussion_r1493820152\r\n\r\n> unless `CompleteDone` gets extended with a property indicating if the entries got exhausted or if one was explicitly selected with ctrl-y\r\n\r\nWould #20671 address that?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T22:35:07Z",
            "diff_hunk": "@@ -1026,6 +1029,14 @@ function lsp.omnifunc(findstart, base)\n   return vim.lsp._completion.omnifunc(findstart, base)\n end\n \n+--- Detaches a client from the given buffer to stop requesting LSP completions.\n+---\n+--- @param client_id integer\n+--- @param bufnr integer\n+function lsp.detach_completion(client_id, bufnr)\n+  vim.lsp._completion.detach(client_id, bufnr)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581916966",
            "id": 1581916966,
            "in_reply_to_id": 1515698767,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eSiMm",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 1006,
            "original_position": 35,
            "original_start_line": 1032,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2026755602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916966/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-27T22:35:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581916966",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581930059"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581930059"
                }
            },
            "author_association": "MEMBER",
            "body": "@justinmk I thought we decided that opt-in behavior was better for now. Quoting @mfussenegger:\r\n> If we go for opt-out instead of opt-in it also opens the question of how to configure the options (trigger characters, later on maybe the debounce interval, if backspace should re-trigger, and maybe server-side fuzzy search support)\r\n\r\nWe were also unsure about how to deal with completion and snippet keymaps, but I guess that's no longer relevant with the newly added defaults.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-27T23:21:43Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581930059",
            "id": 1581930059,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eSlZL",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2026775503,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581930059/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-27T23:21:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581930059",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1581992751"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581992751"
                }
            },
            "author_association": "MEMBER",
            "body": "The new tests are all passing except for this which fails here. @mfussenegger I would appreciate your wisdom here  ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T01:24:16Z",
            "diff_hunk": "@@ -278,4 +288,218 @@ describe('vim.lsp._completion', function()\n     eq('item-property-has-priority', item.data)\n     eq({ line = 1, character = 1 }, item.textEdit.range.start)\n   end)\n+\n+  it(\n+    'uses insertText as textEdit.newText if there are editRange defaults but no textEditText',\n+    function()\n+      --- @type lsp.CompletionList\n+      local completion_list = {\n+        isIncomplete = false,\n+        itemDefaults = {\n+          editRange = {\n+            start = { line = 1, character = 1 },\n+            ['end'] = { line = 1, character = 4 },\n+          },\n+          insertTextFormat = 2,\n+          data = 'foobar',\n+        },\n+        items = {\n+          {\n+            insertText = 'the-insertText',\n+            label = 'hello',\n+            data = 'item-property-has-priority',\n+          },\n+        },\n+      }\n+      local result = complete('|', completion_list)\n+      eq(1, #result.items)\n+      local text = result.items[1].user_data.nvim.lsp.completion_item.textEdit.newText\n+      eq('the-insertText', text)\n+    end\n+  )\n+end)\n+\n+describe('vim.lsp.completion: protocol', function()\n+  before_each(function()\n+    clear()\n+    exec_lua(create_server_definition)\n+    exec_lua([[\n+      _G.capture = {}\n+      vim.fn.complete = function(col, matches)\n+        _G.capture.col = col\n+        _G.capture.matches = matches\n+      end\n+    ]])\n+  end)\n+\n+  after_each(clear)\n+\n+  --- @param completion_result lsp.CompletionList\n+  --- @return integer\n+  local function create_server(completion_result)\n+    return exec_lua(\n+      [[\n+      local result = ...\n+      local server = _create_server({\n+        capabilities = {\n+          completionProvider = {\n+            triggerCharacters = { '.' }\n+          }\n+        },\n+        handlers = {\n+          ['textDocument/completion'] = function()\n+            return result\n+          end\n+        }\n+      })\n+\n+      bufnr = vim.api.nvim_get_current_buf()\n+      vim.api.nvim_win_set_buf(0, bufnr)\n+      return vim.lsp.start({ name = 'dummy', cmd = server.cmd, on_attach = function(client, bufnr)\n+        vim.lsp.completion.attach(client.id, bufnr)\n+      end})\n+    ]],\n+      completion_result\n+    )\n+  end\n+\n+  local function get_matches()\n+    return exec_lua('return _G.capture.matches')\n+  end\n+\n+  --- @param pos { [1]: integer, [2]: integer }\n+  local function trigger_completion_at_pos(pos)\n+    exec_lua(\n+      [[\n+      local win = vim.api.nvim_get_current_win()\n+      vim.api.nvim_win_set_cursor(win, ...)\n+      vim.lsp.completion.trigger_completion()\n+    ]],\n+      pos\n+    )\n+\n+    retry(nil, nil, function()\n+      return exec_lua('return _G.capture.col') ~= nil\n+    end)\n+  end\n+\n+  it('fetches completions and shows them using complete on trigger_completion', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    eq({\n+      {\n+        abbr = 'hello',\n+        dup = 1,\n+        empty = 1,\n+        icase = 1,\n+        info = '',\n+        kind = 'Unknown',\n+        menu = '',\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = 1,\n+              completion_item = {\n+                label = 'hello',\n+              },\n+            },\n+          },\n+        },\n+        word = 'hello',\n+      },\n+    }, get_matches())\n+  end)\n+\n+  it('merges results from multiple clients', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hallo',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    local matches = get_matches()\n+    eq(2, #matches)\n+    eq('hello', matches[1].word)\n+    eq('hallo', matches[2].word)\n+  end)\n+\n+  it('executes commands', function()\n+    local completion_list = {\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+          command = {\n+            arguments = { '1', '0' },\n+            command = 'dummy',\n+            title = '',\n+          },\n+        },\n+      },\n+    }\n+    local client_id = create_server(completion_list)\n+\n+    exec_lua(\n+      [[\n+      _G.called = false\n+      local client = vim.lsp.get_client_by_id(...)\n+      client.commands.dummy = function ()\n+        _G.called = true\n+      end\n+    ]],\n+      client_id\n+    )\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    exec_lua(\n+      [[\n+      local client_id, item = ...\n+      vim.v.completed_item = {\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = client_id,\n+              completion_item = item\n+            }\n+          }\n+        }\n+      }\n+\n+      vim.api.nvim_exec_autocmds('CompleteDone', { buffer = bufnr })\n+    ]],\n+      client_id,\n+      completion_list[1]\n+    )\n+\n+    local matches = get_matches()\n+    eq(1, #matches)\n+    eq('hello', matches[1].word)\n+    eq(true, exec_lua('return _G.called'))",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1581992751",
            "id": 1581992751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eS0sv",
            "original_commit_id": "facf46fdf21bafc386c8884352fa4c92245c62ab",
            "original_line": 503,
            "original_position": 278,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/completion_spec.lua",
            "position": null,
            "pull_request_review_id": 2026864953,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581992751/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T01:24:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1581992751",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582053801"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582053801"
                }
            },
            "author_association": "MEMBER",
            "body": "> Would https://github.com/neovim/neovim/pull/20671 address that?\r\n\r\nYes",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T08:04:21Z",
            "diff_hunk": "@@ -1026,6 +1029,14 @@ function lsp.omnifunc(findstart, base)\n   return vim.lsp._completion.omnifunc(findstart, base)\n end\n \n+--- Detaches a client from the given buffer to stop requesting LSP completions.\n+---\n+--- @param client_id integer\n+--- @param bufnr integer\n+function lsp.detach_completion(client_id, bufnr)\n+  vim.lsp._completion.detach(client_id, bufnr)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582053801",
            "id": 1582053801,
            "in_reply_to_id": 1515698767,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTDmp",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 1006,
            "original_position": 35,
            "original_start_line": 1032,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2026939153,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582053801/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-28T08:04:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582053801",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582193691"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582193691"
                }
            },
            "author_association": "MEMBER",
            "body": "> we decided that opt-in behavior was better for now. \r\n\r\nBut does that require exposing all these different functions, which also implies this \"attach a completion provider\" concept? \r\n\r\nMy suggestion for opt-in was:\r\n\r\n> Alternatively, for _opt-in_ behavior, we could document how to define a `CompleteDone` handler that calls a function we provide.\r\n\r\nare there problems with this approach? I would expect this to only require exposing 1 function. And no attach/detach lifecycle.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T14:42:12Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582193691",
            "id": 1582193691,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTlwb",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2027132678,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582193691/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T14:42:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582193691",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582194346"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582194346"
                }
            },
            "author_association": "MEMBER",
            "body": "I won't comment on the specific API, but don't forget that the goal here is for plugins to be able to hook into that -- both completion and snippets. \r\n\r\nAlso, we won't speedrun this into 0.10; this is getting the pieces into place for a concerted \"LSP autocompletion with snippets\" push early in the 0.11 cycle so we can iterate on the full picture.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T14:46:46Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582194346",
            "id": 1582194346,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTl6q",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2027133872,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582194346/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T14:47:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582194346",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582195631"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582195631"
                }
            },
            "author_association": "MEMBER",
            "body": "is this analogous to `complete_check` or one of the other existing complete functions? Of course, if a new name is definitely needed then the door is open for that. But otherwise it helps discoverability to draw analogs to existing precedent.\r\n\r\nIn any case the function name probably doesn't need to mention \"completion\" since it exists on the `completion` module (and that matches the pattern of many existing modules).\r\n```suggestion\r\ncheck()                 *vim.lsp.completion.check()*\r\n```",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T14:51:20Z",
            "diff_hunk": "@@ -1593,6 +1576,51 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*\n        {client_id}  (`integer`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.completion                                *lsp-completion*\n+\n+accept_pum()                                 *vim.lsp.completion.accept_pum()*\n+    Accept a completion item.\n+\n+    Return: ~\n+        (`boolean`) `true` if the item was selected.\n+\n+attach({client_id}, {bufnr})                     *vim.lsp.completion.attach()*\n+    Attaches the given client to the given buffer as a completion provider.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`) Client ID\n+       {bufnr}      (`integer`) Buffer handle, or 0 for the current buffer\n+\n+detach({client_id}, {bufnr})                     *vim.lsp.completion.detach()*\n+    Detaches a client from the given buffer to stop requesting LSP\n+    completions.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`)\n+       {bufnr}      (`integer`)\n+\n+omnifunc({findstart}, {base})                  *vim.lsp.completion.omnifunc()*\n+    Implements 'omnifunc' compatible LSP completion.\n+\n+    Parameters: ~\n+       {findstart}  (`integer`) 0 or 1, decides behavior\n+       {base}       (`integer`) findstart=0, text to match against\n+\n+    Return: ~\n+        (`integer|table`) Decided by {findstart}:\n+         findstart=0: column where the completion starts, or -2 or -3\n+         findstart=1: list of matches (actually just calls |complete()|)\n+\n+    See also: ~\n+       |complete-functions|\n+       |complete-items|\n+       |CompleteDone|\n+\n+trigger_completion()                 *vim.lsp.completion.trigger_completion()*",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582195631",
            "id": 1582195631,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTmOv",
            "original_commit_id": "facf46fdf21bafc386c8884352fa4c92245c62ab",
            "original_line": 1620,
            "original_position": 69,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2027138281,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582195631/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T14:51:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582195631",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582196073"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196073"
                }
            },
            "author_association": "MEMBER",
            "body": "(or just \"trigger\", in any case)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T14:52:23Z",
            "diff_hunk": "@@ -1593,6 +1576,51 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*\n        {client_id}  (`integer`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.completion                                *lsp-completion*\n+\n+accept_pum()                                 *vim.lsp.completion.accept_pum()*\n+    Accept a completion item.\n+\n+    Return: ~\n+        (`boolean`) `true` if the item was selected.\n+\n+attach({client_id}, {bufnr})                     *vim.lsp.completion.attach()*\n+    Attaches the given client to the given buffer as a completion provider.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`) Client ID\n+       {bufnr}      (`integer`) Buffer handle, or 0 for the current buffer\n+\n+detach({client_id}, {bufnr})                     *vim.lsp.completion.detach()*\n+    Detaches a client from the given buffer to stop requesting LSP\n+    completions.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`)\n+       {bufnr}      (`integer`)\n+\n+omnifunc({findstart}, {base})                  *vim.lsp.completion.omnifunc()*\n+    Implements 'omnifunc' compatible LSP completion.\n+\n+    Parameters: ~\n+       {findstart}  (`integer`) 0 or 1, decides behavior\n+       {base}       (`integer`) findstart=0, text to match against\n+\n+    Return: ~\n+        (`integer|table`) Decided by {findstart}:\n+         findstart=0: column where the completion starts, or -2 or -3\n+         findstart=1: list of matches (actually just calls |complete()|)\n+\n+    See also: ~\n+       |complete-functions|\n+       |complete-items|\n+       |CompleteDone|\n+\n+trigger_completion()                 *vim.lsp.completion.trigger_completion()*",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582196073",
            "id": 1582196073,
            "in_reply_to_id": 1582195631,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTmVp",
            "original_commit_id": "facf46fdf21bafc386c8884352fa4c92245c62ab",
            "original_line": 1620,
            "original_position": 69,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2027140528,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196073/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T14:52:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196073",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582196900"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196900"
                }
            },
            "author_association": "MEMBER",
            "body": "(and, yes, if we can trigger the side effects robustly through a `CompleteDone` autocommand, that would be the preferred way of course; contingent on #20671 and a good story how plugins can remove or override such default handlers)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-28T14:56:11Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582196900",
            "id": 1582196900,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eTmik",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2027141338,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 3,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196900/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-28T14:57:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582196900",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582535657"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582535657"
                }
            },
            "author_association": "MEMBER",
            "body": "Nvm, fixed!",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T04:49:23Z",
            "diff_hunk": "@@ -278,4 +288,218 @@ describe('vim.lsp._completion', function()\n     eq('item-property-has-priority', item.data)\n     eq({ line = 1, character = 1 }, item.textEdit.range.start)\n   end)\n+\n+  it(\n+    'uses insertText as textEdit.newText if there are editRange defaults but no textEditText',\n+    function()\n+      --- @type lsp.CompletionList\n+      local completion_list = {\n+        isIncomplete = false,\n+        itemDefaults = {\n+          editRange = {\n+            start = { line = 1, character = 1 },\n+            ['end'] = { line = 1, character = 4 },\n+          },\n+          insertTextFormat = 2,\n+          data = 'foobar',\n+        },\n+        items = {\n+          {\n+            insertText = 'the-insertText',\n+            label = 'hello',\n+            data = 'item-property-has-priority',\n+          },\n+        },\n+      }\n+      local result = complete('|', completion_list)\n+      eq(1, #result.items)\n+      local text = result.items[1].user_data.nvim.lsp.completion_item.textEdit.newText\n+      eq('the-insertText', text)\n+    end\n+  )\n+end)\n+\n+describe('vim.lsp.completion: protocol', function()\n+  before_each(function()\n+    clear()\n+    exec_lua(create_server_definition)\n+    exec_lua([[\n+      _G.capture = {}\n+      vim.fn.complete = function(col, matches)\n+        _G.capture.col = col\n+        _G.capture.matches = matches\n+      end\n+    ]])\n+  end)\n+\n+  after_each(clear)\n+\n+  --- @param completion_result lsp.CompletionList\n+  --- @return integer\n+  local function create_server(completion_result)\n+    return exec_lua(\n+      [[\n+      local result = ...\n+      local server = _create_server({\n+        capabilities = {\n+          completionProvider = {\n+            triggerCharacters = { '.' }\n+          }\n+        },\n+        handlers = {\n+          ['textDocument/completion'] = function()\n+            return result\n+          end\n+        }\n+      })\n+\n+      bufnr = vim.api.nvim_get_current_buf()\n+      vim.api.nvim_win_set_buf(0, bufnr)\n+      return vim.lsp.start({ name = 'dummy', cmd = server.cmd, on_attach = function(client, bufnr)\n+        vim.lsp.completion.attach(client.id, bufnr)\n+      end})\n+    ]],\n+      completion_result\n+    )\n+  end\n+\n+  local function get_matches()\n+    return exec_lua('return _G.capture.matches')\n+  end\n+\n+  --- @param pos { [1]: integer, [2]: integer }\n+  local function trigger_completion_at_pos(pos)\n+    exec_lua(\n+      [[\n+      local win = vim.api.nvim_get_current_win()\n+      vim.api.nvim_win_set_cursor(win, ...)\n+      vim.lsp.completion.trigger_completion()\n+    ]],\n+      pos\n+    )\n+\n+    retry(nil, nil, function()\n+      return exec_lua('return _G.capture.col') ~= nil\n+    end)\n+  end\n+\n+  it('fetches completions and shows them using complete on trigger_completion', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    eq({\n+      {\n+        abbr = 'hello',\n+        dup = 1,\n+        empty = 1,\n+        icase = 1,\n+        info = '',\n+        kind = 'Unknown',\n+        menu = '',\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = 1,\n+              completion_item = {\n+                label = 'hello',\n+              },\n+            },\n+          },\n+        },\n+        word = 'hello',\n+      },\n+    }, get_matches())\n+  end)\n+\n+  it('merges results from multiple clients', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hallo',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    local matches = get_matches()\n+    eq(2, #matches)\n+    eq('hello', matches[1].word)\n+    eq('hallo', matches[2].word)\n+  end)\n+\n+  it('executes commands', function()\n+    local completion_list = {\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+          command = {\n+            arguments = { '1', '0' },\n+            command = 'dummy',\n+            title = '',\n+          },\n+        },\n+      },\n+    }\n+    local client_id = create_server(completion_list)\n+\n+    exec_lua(\n+      [[\n+      _G.called = false\n+      local client = vim.lsp.get_client_by_id(...)\n+      client.commands.dummy = function ()\n+        _G.called = true\n+      end\n+    ]],\n+      client_id\n+    )\n+\n+    feed('ih')\n+    trigger_completion_at_pos({ 1, 1 })\n+\n+    exec_lua(\n+      [[\n+      local client_id, item = ...\n+      vim.v.completed_item = {\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = client_id,\n+              completion_item = item\n+            }\n+          }\n+        }\n+      }\n+\n+      vim.api.nvim_exec_autocmds('CompleteDone', { buffer = bufnr })\n+    ]],\n+      client_id,\n+      completion_list[1]\n+    )\n+\n+    local matches = get_matches()\n+    eq(1, #matches)\n+    eq('hello', matches[1].word)\n+    eq(true, exec_lua('return _G.called'))",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582535657",
            "id": 1582535657,
            "in_reply_to_id": 1581992751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eU5Pp",
            "original_commit_id": "facf46fdf21bafc386c8884352fa4c92245c62ab",
            "original_line": 503,
            "original_position": 278,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/completion_spec.lua",
            "position": null,
            "pull_request_review_id": 2027558185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582535657/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T04:49:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582535657",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582536198"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582536198"
                }
            },
            "author_association": "MEMBER",
            "body": "I'll change it to `trigger`.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T04:50:53Z",
            "diff_hunk": "@@ -1593,6 +1576,51 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*\n        {client_id}  (`integer`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.completion                                *lsp-completion*\n+\n+accept_pum()                                 *vim.lsp.completion.accept_pum()*\n+    Accept a completion item.\n+\n+    Return: ~\n+        (`boolean`) `true` if the item was selected.\n+\n+attach({client_id}, {bufnr})                     *vim.lsp.completion.attach()*\n+    Attaches the given client to the given buffer as a completion provider.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`) Client ID\n+       {bufnr}      (`integer`) Buffer handle, or 0 for the current buffer\n+\n+detach({client_id}, {bufnr})                     *vim.lsp.completion.detach()*\n+    Detaches a client from the given buffer to stop requesting LSP\n+    completions.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`)\n+       {bufnr}      (`integer`)\n+\n+omnifunc({findstart}, {base})                  *vim.lsp.completion.omnifunc()*\n+    Implements 'omnifunc' compatible LSP completion.\n+\n+    Parameters: ~\n+       {findstart}  (`integer`) 0 or 1, decides behavior\n+       {base}       (`integer`) findstart=0, text to match against\n+\n+    Return: ~\n+        (`integer|table`) Decided by {findstart}:\n+         findstart=0: column where the completion starts, or -2 or -3\n+         findstart=1: list of matches (actually just calls |complete()|)\n+\n+    See also: ~\n+       |complete-functions|\n+       |complete-items|\n+       |CompleteDone|\n+\n+trigger_completion()                 *vim.lsp.completion.trigger_completion()*",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582536198",
            "id": 1582536198,
            "in_reply_to_id": 1582195631,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eU5YG",
            "original_commit_id": "facf46fdf21bafc386c8884352fa4c92245c62ab",
            "original_line": 1620,
            "original_position": 69,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2027559082,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582536198/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T04:50:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582536198",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582546150"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582546150"
                }
            },
            "author_association": "MEMBER",
            "body": "Not sure if renaming this is a breaking change. @mfussenegger do you think we should keep this guy in the parent `lsp` module instead of having it inside the new `completion` one?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T05:15:21Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582546150",
            "id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eU7zm",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2027574829,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582546150/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T05:15:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582546150",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1582686338"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582686338"
                }
            },
            "author_association": "MEMBER",
            "body": "It is breaking, yes, so maybe keep a shim with deprecation notice in the parent module (while leaving the implementation where you put it)? If we do punt this after 0.10, this'll mean we'll have to live with it for a bit, though...",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T08:15:10Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1582686338",
            "id": 1582686338,
            "in_reply_to_id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eVeCC",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2027819477,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582686338/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T08:15:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1582686338",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1583563593"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583563593"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this needs to go through deprecation cycle as it was public.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T18:37:48Z",
            "diff_hunk": "@@ -978,23 +978,6 @@ function lsp.buf_notify(bufnr, method, params)\n   return resp\n end\n \n---- Implements 'omnifunc' compatible LSP completion.\n----\n----@see |complete-functions|\n----@see |complete-items|\n----@see |CompleteDone|\n----\n----@param findstart integer 0 or 1, decides behavior\n----@param base integer findstart=0, text to match against\n----\n----@return integer|table Decided by {findstart}:\n---- - findstart=0: column where the completion starts, or -2 or -3\n---- - findstart=1: list of matches (actually just calls |complete()|)\n-function lsp.omnifunc(findstart, base)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1583563593",
            "id": 1583563593,
            "line": 1004,
            "node_id": "PRRC_kwDOAPphoM5eY0NJ",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 1004,
            "original_position": 50,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp.lua",
            "position": 19,
            "pull_request_review_id": 2029296705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583563593/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T18:56:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583563593",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1583566717"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583566717"
                }
            },
            "author_association": "MEMBER",
            "body": "I think it's possible to remove `suppress_completeDone`, `expand_snippet` and the `accept_pum()` function once https://github.com/neovim/neovim/pull/20671 gets merged",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T18:40:27Z",
            "diff_hunk": "@@ -0,0 +1,773 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+  suppress_completeDone = false,\n+  expand_snippet = false,",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1583566717",
            "id": 1583566717,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eY099",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 38,
            "original_position": 38,
            "original_start_line": 37,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2029296705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583566717/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-29T18:56:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583566717",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1583570051"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583570051"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```\r\n\r\nThis is off-spec, we can try adding this later, together with a PR against the lsp repo to add it to the spec.\r\n",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T18:43:05Z",
            "diff_hunk": "@@ -0,0 +1,773 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+  suppress_completeDone = false,\n+  expand_snippet = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.expand_snippet = false\n+  self.isIncomplete = false\n+  self.suppress_completeDone = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client vim.lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if not lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd] then\n+    client.commands[trigger_completion_cmd] = function()\n+      pcall(M.trigger)\n+    end\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1583570051",
            "id": 1583570051,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eY1yD",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 409,
            "original_position": 409,
            "original_start_line": 397,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2029296705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583570051/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-29T18:56:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583570051",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1583574488"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583574488"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    api.nvim_create_autocmd('TextChangedP', {\r\n      group = group,\r\n      buffer = bufnr,\r\n      callback = text_changed_p_cb,\r\n    })\r\n    api.nvim_create_autocmd('TextChangedI', {\r\n      group = group,\r\n      buffer = bufnr,\r\n      callback = text_changed_i_cb,\r\n    })\r\n```\r\n\r\nThis is for the backspace-retrigger, right? If so, I think we can exclude this in the initial version.\r\nIt might not be needed if it's done generic for `complete()`. See https://github.com/neovim/neovim/pull/28558#issuecomment-2082451177",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T18:46:27Z",
            "diff_hunk": "@@ -0,0 +1,773 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+  suppress_completeDone = false,\n+  expand_snippet = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.expand_snippet = false\n+  self.isIncomplete = false\n+  self.suppress_completeDone = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client vim.lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if not lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd] then\n+    client.commands[trigger_completion_cmd] = function()\n+      pcall(M.trigger)\n+    end\n+  end\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      -- Calling vim.fn.complete while pumvisible will trigger `CompleteDone` for the active completion window,\n+      -- so we suppress it to avoid resetting the completion context.\n+      Context.suppress_completeDone = true\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function text_changed_p_cb()\n+  Context.cursor = api.nvim_win_get_cursor(0)\n+end\n+\n+local function text_changed_i_cb()\n+  if not Context.cursor or completion_timer then\n+    return\n+  end\n+\n+  local cursor = api.nvim_win_get_cursor(0)\n+  if cursor[1] == Context.cursor[1] and cursor[2] <= Context.cursor[2] then\n+    completion_timer = new_timer()\n+    completion_timer:start(150, 0, vim.schedule_wrap(M.trigger))\n+  elseif cursor[1] ~= Context.cursor[1] then\n+    Context.cursor = nil\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  if Context.suppress_completeDone then\n+    Context.suppress_completeDone = false\n+    return\n+  end\n+\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and Context.expand_snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)\n+    if expand_snippet then\n+      apply_snippet(completion_item, suffix)\n+    end\n+\n+    local command = completion_item.command\n+    if command then\n+      client:_exec_cmd(command, { bufnr = bufnr })\n+    end\n+  end\n+\n+  if completion_item.additionalTextEdits and next(completion_item.additionalTextEdits) then\n+    local suffix = clear_word()\n+    lsp.util.apply_text_edits(completion_item.additionalTextEdits, bufnr, offset_encoding)\n+    apply_snippet_and_command(suffix)\n+  elseif resolve_provider and type(completion_item) == 'table' then\n+    local changedtick = vim.b[bufnr].changedtick\n+\n+    --- @param result lsp.CompletionItem\n+    client.request(ms.completionItem_resolve, completion_item, function(err, result)\n+      if changedtick ~= vim.b[bufnr].changedtick then\n+        return\n+      end\n+\n+      local suffix = clear_word()\n+      if err then\n+        vim.notify_once(err.message, vim.log.levels.WARN)\n+      elseif result and result.additionalTextEdits then\n+        lsp.util.apply_text_edits(result.additionalTextEdits, bufnr, offset_encoding)\n+        if result.command then\n+          completion_item.command = result.command\n+        end\n+      end\n+\n+      apply_snippet_and_command(suffix)\n+    end, bufnr)\n+  else\n+    local suffix = clear_word()\n+    apply_snippet_and_command(suffix)\n+  end\n+end\n+\n+--- Trigger LSP completion in the current buffer.\n+function M.trigger()\n+  reset_timer()\n+  Context:cancel_pending()\n+\n+  local win = api.nvim_get_current_win()\n+  local bufnr = api.nvim_get_current_buf()\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(win)) --- @type integer, integer\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local clients = (buf_handles[bufnr] or {}).clients or {}\n+  local word_boundary = vim.fn.match(line_to_cursor, '\\\\k*$')\n+  local start_time = vim.uv.hrtime()\n+  Context.last_request_time = start_time\n+\n+  local cancel_request = request(clients, bufnr, win, function(responses)\n+    local end_time = vim.uv.hrtime()\n+    rtt_ms = compute_new_average((end_time - start_time) * ns_to_ms)\n+\n+    Context.pending_requests = {}\n+    Context.isIncomplete = false\n+\n+    local row_changed = api.nvim_win_get_cursor(win)[1] ~= cursor_row\n+    local mode = api.nvim_get_mode().mode\n+    if row_changed or not (mode == 'i' or mode == 'ic') then\n+      return\n+    end\n+\n+    local matches = {}\n+    local server_start_boundary --- @type integer?\n+    for client_id, response in pairs(responses) do\n+      if response.err then\n+        vim.notify_once(response.err.message, vim.log.levels.warn)\n+      end\n+\n+      local result = response.result\n+      if result then\n+        Context.isIncomplete = Context.isIncomplete or result.isIncomplete\n+        local client = lsp.get_client_by_id(client_id)\n+        local encoding = client and client.offset_encoding or 'utf-16'\n+        local client_matches\n+        client_matches, server_start_boundary = M._convert_results(\n+          line,\n+          cursor_row - 1,\n+          cursor_col,\n+          client_id,\n+          word_boundary,\n+          nil,\n+          result,\n+          encoding\n+        )\n+        vim.list_extend(matches, client_matches)\n+      end\n+    end\n+    local start_col = (server_start_boundary or word_boundary) + 1\n+    vim.fn.complete(start_col, matches)\n+  end)\n+\n+  table.insert(Context.pending_requests, cancel_request)\n+end\n+\n+--- Attaches the given client to the given buffer as a completion provider.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)\n+  bufnr = (bufnr == 0 and api.nvim_get_current_buf()) or bufnr\n+\n+  if not buf_handles[bufnr] then\n+    buf_handles[bufnr] = { clients = {}, triggers = {} }\n+\n+    -- Attach to buffer events.\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, buf)\n+        buf_handles[buf] = nil\n+      end,\n+      on_reload = function(_, buf)\n+        M.attach(client_id, buf)\n+      end,\n+    })\n+\n+    -- Set up autocommands.\n+    local group =\n+      api.nvim_create_augroup(string.format('vim/lsp/completion-%d', bufnr), { clear = true })\n+    api.nvim_create_autocmd('InsertCharPre', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = function()\n+        insert_char_pre_cb(buf_handles[bufnr])\n+      end,\n+    })\n+    api.nvim_create_autocmd('TextChangedP', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = text_changed_p_cb,\n+    })\n+    api.nvim_create_autocmd('TextChangedI', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = text_changed_i_cb,\n+    })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1583574488",
            "id": 1583574488,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eY23Y",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 679,
            "original_position": 693,
            "original_start_line": 684,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2029296705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583574488/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-04-29T18:56:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583574488",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1583589544"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583589544"
                }
            },
            "author_association": "MEMBER",
            "body": "It's currently `InsertCharPre`, `InsertLeave`, `TextChangedP`, `TextChangedI` and `CompleteDone`.\r\n(Although `TextChangedP` / `TextChangedI` might disappear, see comment below)\r\n\r\nAnd there are two independent aspects here: auto-trigger, and snippet expansion/side-effects.\r\n\r\nSnippet expansion should also be useable with the omnifunc triggered manually, and with having opted out of auto-trigger. So we'd need a way to control these two aspects individually.\r\n\r\nExposing the group name or autocmd ids feels a bit like exposing the implementation details, and might limit how we can extend the implementation later.\r\n\r\n\r\nI'd suggest to go with the `enable` / `is_enabled`.\r\nThat also gives us the option to add configuration options to the `enable` call.\r\n\r\nOr maybe I completely misunderstand the proposal here?\r\n",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-04-29T18:56:11Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1583589544",
            "id": 1583589544,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5eY6io",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2029296705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583589544/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-04-29T18:56:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1583589544",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1613244807"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613244807"
                }
            },
            "author_association": "MEMBER",
            "body": "> (and, yes, if we can trigger the side effects robustly through a `CompleteDone` autocommand, that would be the preferred way of course; contingent on #20671 and a good story how plugins can remove or override such default handlers)\r\n\r\nWhich we now can \\o/ @MariaSolOs rebase on `master`?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-24T10:21:13Z",
            "diff_hunk": "@@ -0,0 +1,93 @@\n+local M = {}\n+\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, lsp.Client>\n+--- @field triggers table<string, lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+local function complete_done() end\n+\n+--- Initializes the completion commands for the given client.\n+---\n+--- @param client lsp.Client\n+local function init_commands(client)\n+  local trigger_completion_cmd = 'editor.action.triggerSuggest'\n+\n+  -- Check if the command is in the global registry or in the client's commands.\n+  if\n+    not vim.lsp.commands[trigger_completion_cmd] and not client.commands[trigger_completion_cmd]\n+  then\n+    client.commands[trigger_completion_cmd] = function()\n+      local ok, res = pcall(M.trigger_completion)\n+      return ok and vim.NIL\n+        or vim.lsp.rpc_response_error(vim.lsp.protocol.ErrorCodes.InternalError, res)\n+    end\n+  end\n+end\n+\n+function M.trigger_completion() end\n+\n+--- TODO(mariasolos): Document.\n+---\n+--- @param client_id integer Client ID\n+--- @param bufnr integer Buffer handle, or 0 for the current buffer\n+function M.attach(client_id, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1613244807",
            "id": 1613244807,
            "in_reply_to_id": 1493820152,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gKCmH",
            "original_commit_id": "baf818cc1dbfef9bd864fd27065c050370223bf4",
            "original_line": 644,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2076498548,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613244807/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-24T10:21:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613244807",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1613387407"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613387407"
                }
            },
            "author_association": "MEMBER",
            "body": "If we do this (which I agree we should), we should set them up only within the snippet context and tear them down afterwards (to avoid conflicting with snippet _library_ plugins). Would be easier with namespaced mappings, of course, but... I don't think the overhead for this would be relevant.\r\n\r\n(Note for the sake of clarity: This suggestion is -- for now -- only for the MVP, which should be as hermetic as possible and only focus on out-of-the-box LSP autocompletion. How to expose parts of this as an API for other plugins to extend is a follow-up discussion after the bugs are ironed out and we have a complete picture; we should make use of the full 0.11 dev cycle to iterate on this.)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-24T12:15:48Z",
            "diff_hunk": "@@ -744,14 +744,15 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1613387407",
            "id": 1613387407,
            "in_reply_to_id": 1515688809,
            "line": 741,
            "node_id": "PRRC_kwDOAPphoM5gKlaP",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 741,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 8,
            "pull_request_review_id": 2076762993,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613387407/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-24T12:15:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1613387407",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614215677"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614215677"
                }
            },
            "author_association": "MEMBER",
            "body": "Not sure why but this change is because https://github.com/neovim/neovim/pull/28914 seems to have broken my test logic. If this change was intended though I'll modify the tests.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T01:09:47Z",
            "diff_hunk": "@@ -39,7 +39,8 @@ M.create_server_definition = [[\n         })\n         local handler = handlers[method]\n         if handler then\n-          handler(method, params, callback)\n+          local response, err = handler(method, params)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614215677",
            "id": 1614215677,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gNvn9",
            "original_commit_id": "01c488aa3801900572223e3042e6d41a2b39e39c",
            "original_line": 42,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/testutil.lua",
            "position": null,
            "pull_request_review_id": 2078296289,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614215677/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T01:09:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614215677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614217102"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614217102"
                }
            },
            "author_association": "MEMBER",
            "body": "@famiu after https://github.com/neovim/neovim/pull/20671 this doesn't seem to be triggering `CompleteDone` anymore. What's the right way to execute the autocommand, making sure that `v:event.reason` is `'accept'`?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T01:12:28Z",
            "diff_hunk": "@@ -278,4 +288,218 @@ describe('vim.lsp._completion', function()\n     eq('item-property-has-priority', item.data)\n     eq({ line = 1, character = 1 }, item.textEdit.range.start)\n   end)\n+\n+  it(\n+    'uses insertText as textEdit.newText if there are editRange defaults but no textEditText',\n+    function()\n+      --- @type lsp.CompletionList\n+      local completion_list = {\n+        isIncomplete = false,\n+        itemDefaults = {\n+          editRange = {\n+            start = { line = 1, character = 1 },\n+            ['end'] = { line = 1, character = 4 },\n+          },\n+          insertTextFormat = 2,\n+          data = 'foobar',\n+        },\n+        items = {\n+          {\n+            insertText = 'the-insertText',\n+            label = 'hello',\n+            data = 'item-property-has-priority',\n+          },\n+        },\n+      }\n+      local result = complete('|', completion_list)\n+      eq(1, #result.items)\n+      local text = result.items[1].user_data.nvim.lsp.completion_item.textEdit.newText\n+      eq('the-insertText', text)\n+    end\n+  )\n+end)\n+\n+describe('vim.lsp.completion: protocol', function()\n+  before_each(function()\n+    clear()\n+    exec_lua(create_server_definition)\n+    exec_lua([[\n+      _G.capture = {}\n+      vim.fn.complete = function(col, matches)\n+        _G.capture.col = col\n+        _G.capture.matches = matches\n+      end\n+    ]])\n+  end)\n+\n+  after_each(clear)\n+\n+  --- @param completion_result lsp.CompletionList\n+  --- @return integer\n+  local function create_server(completion_result)\n+    return exec_lua(\n+      [[\n+      local result = ...\n+      local server = _create_server({\n+        capabilities = {\n+          completionProvider = {\n+            triggerCharacters = { '.' }\n+          }\n+        },\n+        handlers = {\n+          ['textDocument/completion'] = function()\n+            return result\n+          end\n+        }\n+      })\n+\n+      bufnr = vim.api.nvim_get_current_buf()\n+      vim.api.nvim_win_set_buf(0, bufnr)\n+      return vim.lsp.start({ name = 'dummy', cmd = server.cmd, on_attach = function(client, bufnr)\n+        vim.lsp.completion.enable(client.id, bufnr, { autotrigger = true })\n+      end})\n+    ]],\n+      completion_result\n+    )\n+  end\n+\n+  local function get_matches()\n+    return exec_lua('return _G.capture.matches')\n+  end\n+\n+  --- @param pos { [1]: integer, [2]: integer }\n+  local function trigger_at_pos(pos)\n+    exec_lua(\n+      [[\n+      local win = vim.api.nvim_get_current_win()\n+      vim.api.nvim_win_set_cursor(win, ...)\n+      vim.lsp.completion.trigger()\n+    ]],\n+      pos\n+    )\n+\n+    retry(nil, nil, function()\n+      return exec_lua('return _G.capture.col') ~= nil\n+    end)\n+  end\n+\n+  it('fetches completions and shows them using complete on trigger', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    eq({\n+      {\n+        abbr = 'hello',\n+        dup = 1,\n+        empty = 1,\n+        icase = 1,\n+        info = '',\n+        kind = 'Unknown',\n+        menu = '',\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = 1,\n+              completion_item = {\n+                label = 'hello',\n+              },\n+            },\n+          },\n+        },\n+        word = 'hello',\n+      },\n+    }, get_matches())\n+  end)\n+\n+  it('merges results from multiple clients', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hallo',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    local matches = get_matches()\n+    eq(2, #matches)\n+    eq('hello', matches[1].word)\n+    eq('hallo', matches[2].word)\n+  end)\n+\n+  it('executes commands', function()\n+    local completion_list = {\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+          command = {\n+            arguments = { '1', '0' },\n+            command = 'dummy',\n+            title = '',\n+          },\n+        },\n+      },\n+    }\n+    local client_id = create_server(completion_list)\n+\n+    exec_lua(\n+      [[\n+      _G.called = false\n+      local client = vim.lsp.get_client_by_id(...)\n+      client.commands.dummy = function ()\n+        _G.called = true\n+      end\n+    ]],\n+      client_id\n+    )\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    exec_lua(\n+      [[\n+      local client_id, item = ...\n+      vim.v.completed_item = {\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = client_id,\n+              completion_item = item\n+            }\n+          }\n+        }\n+      }\n+\n+      vim.api.nvim_exec_autocmds('CompleteDone', { buffer = bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614217102",
            "id": 1614217102,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gNv-O",
            "original_commit_id": "01c488aa3801900572223e3042e6d41a2b39e39c",
            "original_line": 494,
            "original_position": 269,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/completion_spec.lua",
            "position": null,
            "pull_request_review_id": 2078296786,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614217102/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T01:12:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614217102",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614753937"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614753937"
                }
            },
            "author_association": "MEMBER",
            "body": "Never mind, I understand the change now and I will remove this change from the PR.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T16:03:50Z",
            "diff_hunk": "@@ -39,7 +39,8 @@ M.create_server_definition = [[\n         })\n         local handler = handlers[method]\n         if handler then\n-          handler(method, params, callback)\n+          local response, err = handler(method, params)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614753937",
            "id": 1614753937,
            "in_reply_to_id": 1614215677,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gPzCR",
            "original_commit_id": "01c488aa3801900572223e3042e6d41a2b39e39c",
            "original_line": 42,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/testutil.lua",
            "position": null,
            "pull_request_review_id": 2079070307,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614753937/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T16:03:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614753937",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614775214"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614775214"
                }
            },
            "author_association": "MEMBER",
            "body": "nvm I think it's fixed now.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T16:53:35Z",
            "diff_hunk": "@@ -278,4 +288,218 @@ describe('vim.lsp._completion', function()\n     eq('item-property-has-priority', item.data)\n     eq({ line = 1, character = 1 }, item.textEdit.range.start)\n   end)\n+\n+  it(\n+    'uses insertText as textEdit.newText if there are editRange defaults but no textEditText',\n+    function()\n+      --- @type lsp.CompletionList\n+      local completion_list = {\n+        isIncomplete = false,\n+        itemDefaults = {\n+          editRange = {\n+            start = { line = 1, character = 1 },\n+            ['end'] = { line = 1, character = 4 },\n+          },\n+          insertTextFormat = 2,\n+          data = 'foobar',\n+        },\n+        items = {\n+          {\n+            insertText = 'the-insertText',\n+            label = 'hello',\n+            data = 'item-property-has-priority',\n+          },\n+        },\n+      }\n+      local result = complete('|', completion_list)\n+      eq(1, #result.items)\n+      local text = result.items[1].user_data.nvim.lsp.completion_item.textEdit.newText\n+      eq('the-insertText', text)\n+    end\n+  )\n+end)\n+\n+describe('vim.lsp.completion: protocol', function()\n+  before_each(function()\n+    clear()\n+    exec_lua(create_server_definition)\n+    exec_lua([[\n+      _G.capture = {}\n+      vim.fn.complete = function(col, matches)\n+        _G.capture.col = col\n+        _G.capture.matches = matches\n+      end\n+    ]])\n+  end)\n+\n+  after_each(clear)\n+\n+  --- @param completion_result lsp.CompletionList\n+  --- @return integer\n+  local function create_server(completion_result)\n+    return exec_lua(\n+      [[\n+      local result = ...\n+      local server = _create_server({\n+        capabilities = {\n+          completionProvider = {\n+            triggerCharacters = { '.' }\n+          }\n+        },\n+        handlers = {\n+          ['textDocument/completion'] = function()\n+            return result\n+          end\n+        }\n+      })\n+\n+      bufnr = vim.api.nvim_get_current_buf()\n+      vim.api.nvim_win_set_buf(0, bufnr)\n+      return vim.lsp.start({ name = 'dummy', cmd = server.cmd, on_attach = function(client, bufnr)\n+        vim.lsp.completion.enable(client.id, bufnr, { autotrigger = true })\n+      end})\n+    ]],\n+      completion_result\n+    )\n+  end\n+\n+  local function get_matches()\n+    return exec_lua('return _G.capture.matches')\n+  end\n+\n+  --- @param pos { [1]: integer, [2]: integer }\n+  local function trigger_at_pos(pos)\n+    exec_lua(\n+      [[\n+      local win = vim.api.nvim_get_current_win()\n+      vim.api.nvim_win_set_cursor(win, ...)\n+      vim.lsp.completion.trigger()\n+    ]],\n+      pos\n+    )\n+\n+    retry(nil, nil, function()\n+      return exec_lua('return _G.capture.col') ~= nil\n+    end)\n+  end\n+\n+  it('fetches completions and shows them using complete on trigger', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    eq({\n+      {\n+        abbr = 'hello',\n+        dup = 1,\n+        empty = 1,\n+        icase = 1,\n+        info = '',\n+        kind = 'Unknown',\n+        menu = '',\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = 1,\n+              completion_item = {\n+                label = 'hello',\n+              },\n+            },\n+          },\n+        },\n+        word = 'hello',\n+      },\n+    }, get_matches())\n+  end)\n+\n+  it('merges results from multiple clients', function()\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+        },\n+      },\n+    })\n+    create_server({\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hallo',\n+        },\n+      },\n+    })\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    local matches = get_matches()\n+    eq(2, #matches)\n+    eq('hello', matches[1].word)\n+    eq('hallo', matches[2].word)\n+  end)\n+\n+  it('executes commands', function()\n+    local completion_list = {\n+      isIncomplete = false,\n+      items = {\n+        {\n+          label = 'hello',\n+          command = {\n+            arguments = { '1', '0' },\n+            command = 'dummy',\n+            title = '',\n+          },\n+        },\n+      },\n+    }\n+    local client_id = create_server(completion_list)\n+\n+    exec_lua(\n+      [[\n+      _G.called = false\n+      local client = vim.lsp.get_client_by_id(...)\n+      client.commands.dummy = function ()\n+        _G.called = true\n+      end\n+    ]],\n+      client_id\n+    )\n+\n+    feed('ih')\n+    trigger_at_pos({ 1, 1 })\n+\n+    exec_lua(\n+      [[\n+      local client_id, item = ...\n+      vim.v.completed_item = {\n+        user_data = {\n+          nvim = {\n+            lsp = {\n+              client_id = client_id,\n+              completion_item = item\n+            }\n+          }\n+        }\n+      }\n+\n+      vim.api.nvim_exec_autocmds('CompleteDone', { buffer = bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614775214",
            "id": 1614775214,
            "in_reply_to_id": 1614217102,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gP4Ou",
            "original_commit_id": "01c488aa3801900572223e3042e6d41a2b39e39c",
            "original_line": 494,
            "original_position": 269,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/completion_spec.lua",
            "position": null,
            "pull_request_review_id": 2079083638,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614775214/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T16:53:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614775214",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614787435"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787435"
                }
            },
            "author_association": "MEMBER",
            "body": "Done in https://github.com/neovim/neovim/pull/27339/commits/1fa63b786f7c66b2fe90dff69d6d5338e2cd841d.\r\n@clason lmk if this is what you had in mind.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T17:24:02Z",
            "diff_hunk": "@@ -744,14 +744,15 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614787435",
            "id": 1614787435,
            "in_reply_to_id": 1515688809,
            "line": 741,
            "node_id": "PRRC_kwDOAPphoM5gP7Nr",
            "original_commit_id": "0d578ab117b051d0d5b552c00310d82f3db031da",
            "original_line": 741,
            "original_position": 8,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 8,
            "pull_request_review_id": 2079090943,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787435/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T17:24:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787435",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614787892"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787892"
                }
            },
            "author_association": "MEMBER",
            "body": "Not sure of what will happen if the user has a different keymap and we delete these ones here. Also not sure if we wanted to only set these keymaps if the user enabled completion...",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T17:26:53Z",
            "diff_hunk": "@@ -101,6 +101,20 @@ local function get_extmark_range(bufnr, extmark_id)\n   return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n end\n \n+local function set_keymaps()\n+  vim.keymap.set({ 'i', 's' }, '<Tab>', function ()\n+    return vim.snippet.active({ direction = 1 }) and '<cmd>lua vim.snippet.jump(1)<cr>' or '<Tab>'\n+  end, { expr = true, silent = true })\n+  vim.keymap.set({ 'i', 's' }, '<S-Tab>', function ()\n+    return vim.snippet.active({ direction = -1 }) and '<cmd>lua vim.snippet.jump(-1)<cr>' or '<S-Tab>'\n+  end, { expr = true, silent = true })\n+end\n+\n+local function remove_keymaps()",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614787892",
            "id": 1614787892,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gP7U0",
            "original_commit_id": "1fa63b786f7c66b2fe90dff69d6d5338e2cd841d",
            "original_line": 113,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079091236,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787892/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T17:26:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614787892",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614788247"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788247"
                }
            },
            "author_association": "MEMBER",
            "body": "Good point; we'll have to save and restore them. (That's a bit more work than I envisaged but should be doable via `:h nvim_buf_get_keymap()` -- we only need one or two, after all)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T17:29:58Z",
            "diff_hunk": "@@ -101,6 +101,20 @@ local function get_extmark_range(bufnr, extmark_id)\n   return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n end\n \n+local function set_keymaps()\n+  vim.keymap.set({ 'i', 's' }, '<Tab>', function ()\n+    return vim.snippet.active({ direction = 1 }) and '<cmd>lua vim.snippet.jump(1)<cr>' or '<Tab>'\n+  end, { expr = true, silent = true })\n+  vim.keymap.set({ 'i', 's' }, '<S-Tab>', function ()\n+    return vim.snippet.active({ direction = -1 }) and '<cmd>lua vim.snippet.jump(-1)<cr>' or '<S-Tab>'\n+  end, { expr = true, silent = true })\n+end\n+\n+local function remove_keymaps()",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614788247",
            "id": 1614788247,
            "in_reply_to_id": 1614787892,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gP7aX",
            "original_commit_id": "1fa63b786f7c66b2fe90dff69d6d5338e2cd841d",
            "original_line": 113,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079091549,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788247/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T17:29:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788247",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614788477"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788477"
                }
            },
            "author_association": "MEMBER",
            "body": "(Which reminds me: you'll want to set these mappings for the buffer only.)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T17:32:11Z",
            "diff_hunk": "@@ -101,6 +101,20 @@ local function get_extmark_range(bufnr, extmark_id)\n   return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n end\n \n+local function set_keymaps()\n+  vim.keymap.set({ 'i', 's' }, '<Tab>', function ()\n+    return vim.snippet.active({ direction = 1 }) and '<cmd>lua vim.snippet.jump(1)<cr>' or '<Tab>'\n+  end, { expr = true, silent = true })\n+  vim.keymap.set({ 'i', 's' }, '<S-Tab>', function ()\n+    return vim.snippet.active({ direction = -1 }) and '<cmd>lua vim.snippet.jump(-1)<cr>' or '<S-Tab>'\n+  end, { expr = true, silent = true })\n+end\n+\n+local function remove_keymaps()",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614788477",
            "id": 1614788477,
            "in_reply_to_id": 1614787892,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gP7d9",
            "original_commit_id": "1fa63b786f7c66b2fe90dff69d6d5338e2cd841d",
            "original_line": 113,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079091785,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788477/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T17:32:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614788477",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614901681"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614901681"
                }
            },
            "author_association": "MEMBER",
            "body": "I this this is wrong since I'm not passing all the original keymap options, but if I use `keymap` as the 4th argument I get errors about `rhs` or `lhs` being invalid keys. I tried reconstructing the opts with code like `opts = { expr = keymap.expr }` but then I had errors like \"replace_keycodes needs expr to not be null\".\r\n\r\nI appreciate ideas/alternatives here. ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T21:46:48Z",
            "diff_hunk": "@@ -207,9 +213,57 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function save_keymaps(keymaps, mode)\n+    for _, keymap in ipairs(keymaps) do\n+      if (keymap.lhs or ''):lower() == jump_forward_key then\n+        self.tab_keymaps[mode] = keymap\n+      elseif (keymap.lhs or ''):lower() == jump_backward_key then\n+        self.shift_tab_keymaps[mode] = keymap\n+      end\n+    end\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key\n+    end, { expr = true, silent = true, buffer = self.bufnr })\n+  end\n+\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 'i'), 'i')\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 's'), 's')\n+  set(jump_forward_key, 1)\n+  set(jump_backward_key, -1)\n+end\n+\n+--- Restores/deletes the keymaps used for snippet navigation.\n+---\n+--- @package\n+function Session:restore_keymaps()\n+  local function restore(keymap, lhs, mode)\n+    if keymap then\n+      vim.keymap.set(mode, lhs, keymap.rhs or keymap.callback, { buffer = self.bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614901681",
            "id": 1614901681,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gQXGx",
            "original_commit_id": "635e3963004af38633ecd6a2c07bbb3a24394857",
            "original_line": 255,
            "original_position": 70,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079182421,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614901681/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T21:46:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614901681",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614903645"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614903645"
                }
            },
            "author_association": "MEMBER",
            "body": "You should use `mapset()` (with `nvim_buf_call`) for restoring a mapping. And it seems that here you can use `maparg()` to save the mappings as well, although you'll need to check if the mapping is buffer-local.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-25T21:51:19Z",
            "diff_hunk": "@@ -207,9 +213,57 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function save_keymaps(keymaps, mode)\n+    for _, keymap in ipairs(keymaps) do\n+      if (keymap.lhs or ''):lower() == jump_forward_key then\n+        self.tab_keymaps[mode] = keymap\n+      elseif (keymap.lhs or ''):lower() == jump_backward_key then\n+        self.shift_tab_keymaps[mode] = keymap\n+      end\n+    end\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key\n+    end, { expr = true, silent = true, buffer = self.bufnr })\n+  end\n+\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 'i'), 'i')\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 's'), 's')\n+  set(jump_forward_key, 1)\n+  set(jump_backward_key, -1)\n+end\n+\n+--- Restores/deletes the keymaps used for snippet navigation.\n+---\n+--- @package\n+function Session:restore_keymaps()\n+  local function restore(keymap, lhs, mode)\n+    if keymap then\n+      vim.keymap.set(mode, lhs, keymap.rhs or keymap.callback, { buffer = self.bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614903645",
            "id": 1614903645,
            "in_reply_to_id": 1614901681,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gQXld",
            "original_commit_id": "635e3963004af38633ecd6a2c07bbb3a24394857",
            "original_line": 255,
            "original_position": 70,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079184848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614903645/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-25T21:54:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614903645",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1614985910"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614985910"
                }
            },
            "author_association": "MEMBER",
            "body": "What happens if there's non-buffer-local keymap and I set the navigation mappings here? Will it just temporarily overwrite the global ones?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T01:20:15Z",
            "diff_hunk": "@@ -207,9 +213,57 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function save_keymaps(keymaps, mode)\n+    for _, keymap in ipairs(keymaps) do\n+      if (keymap.lhs or ''):lower() == jump_forward_key then\n+        self.tab_keymaps[mode] = keymap\n+      elseif (keymap.lhs or ''):lower() == jump_backward_key then\n+        self.shift_tab_keymaps[mode] = keymap\n+      end\n+    end\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key\n+    end, { expr = true, silent = true, buffer = self.bufnr })\n+  end\n+\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 'i'), 'i')\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 's'), 's')\n+  set(jump_forward_key, 1)\n+  set(jump_backward_key, -1)\n+end\n+\n+--- Restores/deletes the keymaps used for snippet navigation.\n+---\n+--- @package\n+function Session:restore_keymaps()\n+  local function restore(keymap, lhs, mode)\n+    if keymap then\n+      vim.keymap.set(mode, lhs, keymap.rhs or keymap.callback, { buffer = self.bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1614985910",
            "id": 1614985910,
            "in_reply_to_id": 1614901681,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gQrq2",
            "original_commit_id": "635e3963004af38633ecd6a2c07bbb3a24394857",
            "original_line": 255,
            "original_position": 70,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079317157,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614985910/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-26T01:20:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1614985910",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615001362"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615001362"
                }
            },
            "author_association": "MEMBER",
            "body": "Buffer-local mappings take priority over global mappings, so yes, there is no need to save and restore global mappings.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T02:18:43Z",
            "diff_hunk": "@@ -207,9 +213,57 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function save_keymaps(keymaps, mode)\n+    for _, keymap in ipairs(keymaps) do\n+      if (keymap.lhs or ''):lower() == jump_forward_key then\n+        self.tab_keymaps[mode] = keymap\n+      elseif (keymap.lhs or ''):lower() == jump_backward_key then\n+        self.shift_tab_keymaps[mode] = keymap\n+      end\n+    end\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key\n+    end, { expr = true, silent = true, buffer = self.bufnr })\n+  end\n+\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 'i'), 'i')\n+  save_keymaps(vim.api.nvim_buf_get_keymap(self.bufnr, 's'), 's')\n+  set(jump_forward_key, 1)\n+  set(jump_backward_key, -1)\n+end\n+\n+--- Restores/deletes the keymaps used for snippet navigation.\n+---\n+--- @package\n+function Session:restore_keymaps()\n+  local function restore(keymap, lhs, mode)\n+    if keymap then\n+      vim.keymap.set(mode, lhs, keymap.rhs or keymap.callback, { buffer = self.bufnr })",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615001362",
            "id": 1615001362,
            "in_reply_to_id": 1614901681,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gQvcS",
            "original_commit_id": "635e3963004af38633ecd6a2c07bbb3a24394857",
            "original_line": 255,
            "original_position": 70,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 2079340496,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615001362/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-26T02:18:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615001362",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615260596"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615260596"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this even needed if we know we are already in an active snippet context? (Not that it hurts.)",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T16:29:50Z",
            "diff_hunk": "@@ -207,9 +213,60 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function maparg(key, mode)\n+    local map = vim.fn.maparg(key, mode, false, true) --[[ @as table ]]\n+    return not vim.tbl_isempty(map) and map or nil\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615260596",
            "id": 1615260596,
            "line": 238,
            "node_id": "PRRC_kwDOAPphoM5gRuu0",
            "original_commit_id": "23d4e521b6e4f143c587042746f770075d5a8e9a",
            "original_line": 238,
            "original_position": 49,
            "original_start_line": 232,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 53,
            "pull_request_review_id": 2079695375,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615260596/reactions"
            },
            "side": "RIGHT",
            "start_line": 236,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-26T16:29:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615260596",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615263221"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615263221"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes it's needed because it's possible for the snippet to be active but not jumpable in the given direction (e.g. when modifying the last tabstop).",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T16:45:28Z",
            "diff_hunk": "@@ -207,9 +213,60 @@ function Session.new(bufnr, snippet_extmark, tabstop_data)\n     end\n   end\n \n+  self:set_keymaps()\n+\n   return self\n end\n \n+--- Sets the snippet navigation keymaps.\n+---\n+--- @package\n+function Session:set_keymaps()\n+  local function maparg(key, mode)\n+    local map = vim.fn.maparg(key, mode, false, true) --[[ @as table ]]\n+    return not vim.tbl_isempty(map) and map or nil\n+  end\n+\n+  local function set(jump_key, direction)\n+    vim.keymap.set({ 'i', 's' }, jump_key, function()\n+      return vim.snippet.active({ direction = direction })\n+          and '<cmd>lua vim.snippet.jump(' .. direction .. ')<cr>'\n+        or jump_key",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615263221",
            "id": 1615263221,
            "in_reply_to_id": 1615260596,
            "line": 238,
            "node_id": "PRRC_kwDOAPphoM5gRvX1",
            "original_commit_id": "23d4e521b6e4f143c587042746f770075d5a8e9a",
            "original_line": 238,
            "original_position": 49,
            "original_start_line": 232,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 53,
            "pull_request_review_id": 2079719427,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615263221/reactions"
            },
            "side": "RIGHT",
            "start_line": 236,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-26T16:45:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615263221",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615314435"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615314435"
                }
            },
            "author_association": "NONE",
            "body": "I run into the following issue while testing this PR, I think we need to clear the range specified by the completion_item before applying the text edit. These two videos shows behaviour with the current changes and after applying the fix respectively\r\n\r\nhttps://github.com/neovim/neovim/assets/16278108/7ae8cf1e-e455-47f5-9b72-2a39d7be7657\r\n\r\nhttps://github.com/neovim/neovim/assets/16278108/5fdaa83b-2c97-4c5e-99e5-2c801b5bb0e3\r\n\r\nThe fix I have right now is, not sure how hacky it's :D\r\n\r\n```lua\r\nlocal function apply_snippet_and_command(suffix)\r\n  if completion_item.textEdit then\r\n    vim.lsp.util.apply_text_edits(\r\n      { { newText = '', range = completion_item.textEdit.range } },\r\n      api.nvim_get_current_buf(),\r\n      'utf-16'\r\n    )\r\n  end\r\n  if expand_snippet then\r\n    apply_snippet(completion_item, suffix)\r\n  end\r\n...\r\n```\r\n\r\nI had a similar issue when I used `nvim-lsp-compl`, at the time I had a hacky solution by doing https://github.com/mfussenegger/nvim-lsp-compl/compare/master...JafarAbdi:nvim-lsp-compl:fix_textedit",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T19:26:58Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615314435",
            "id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gR74D",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2079774810,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615314435/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-26T19:26:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615314435",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/16278108?v=4",
                "events_url": "https://api.github.com/users/JafarAbdi/events{/privacy}",
                "followers_url": "https://api.github.com/users/JafarAbdi/followers",
                "following_url": "https://api.github.com/users/JafarAbdi/following{/other_user}",
                "gists_url": "https://api.github.com/users/JafarAbdi/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JafarAbdi",
                "id": 16278108,
                "login": "JafarAbdi",
                "node_id": "MDQ6VXNlcjE2Mjc4MTA4",
                "organizations_url": "https://api.github.com/users/JafarAbdi/orgs",
                "received_events_url": "https://api.github.com/users/JafarAbdi/received_events",
                "repos_url": "https://api.github.com/users/JafarAbdi/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JafarAbdi/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JafarAbdi/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JafarAbdi"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615319431"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615319431"
                }
            },
            "author_association": "MEMBER",
            "body": "@JafarAbdi I don't fully understand the issue in the first video. Isn't the completion being inserted correctly?\r\nAlso can you reproduce the issue without Copilot/auto-closing parentheses or other plugins that might also affect the completion behavior?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T20:04:12Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615319431",
            "id": 1615319431,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gR9GH",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2079778911,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615319431/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-26T20:04:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615319431",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615336097"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615336097"
                }
            },
            "author_association": "NONE",
            "body": "Sorry for the delayed response, I was debugging the issue. It's more related to clangd when [editsNearCursor](https://reviews.llvm.org/D75739) is enabled, clangd will provide completions that correct . to ->, and vice-versa. I shared a new video with the minimal configs, when I press `<c-y>` line `a.->i` should become `a->i` and `a->.get()` should become `a.get()`\r\n\r\nhttps://github.com/neovim/neovim/assets/16278108/52ab5953-0d17-47e2-a850-635b8944a6ca\r\n\r\nMimimal config to reproduce the issue `nvim --clean -u minimal.lua test.cpp`\r\n\r\n```lua\r\nlocal general_group = vim.api.nvim_create_augroup(\"GeneralCommands\", {})\r\n\r\nvim.api.nvim_create_autocmd(\"LspAttach\", {\r\n  callback = function(args)\r\n    vim.lsp.completion.enable(args.data.client_id, args.buf, { autotrigger = true })\r\n    vim.keymap.set(\"i\", \"<c-space>\", function()\r\n      vim.lsp.completion.trigger()\r\n    end, { buffer = args.buf })\r\n  end,\r\n  group = general_group,\r\n})\r\n\r\nvim.api.nvim_create_autocmd(\"FileType\", {\r\n  pattern = \"cpp\",\r\n  group = general_group,\r\n  callback = function(args)\r\n    local config = {\r\n      name = \"clangd\",\r\n      cmd = { \"clangd\", \"--completion-style=detailed\" },\r\n      handlers = {},\r\n      capabilities = vim.tbl_deep_extend(\"force\", vim.lsp.protocol.make_client_capabilities(), {\r\n        textDocument = {\r\n          completion = {\r\n            editsNearCursor = true,\r\n          },\r\n        },\r\n        offsetEncoding = { \"utf-16\" },\r\n      }),\r\n      on_attach = function(client, bufnr) end,\r\n      init_options = vim.empty_dict(),\r\n      settings = vim.empty_dict(),\r\n      root_dir = vim.fs.root(args.file, { \".git\" }),\r\n    }\r\n    vim.lsp.start(config)\r\n  end,\r\n})\r\n```",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-26T22:05:23Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615336097",
            "id": 1615336097,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gSBKh",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2079794731,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615336097/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-26T22:05:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615336097",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/16278108?v=4",
                "events_url": "https://api.github.com/users/JafarAbdi/events{/privacy}",
                "followers_url": "https://api.github.com/users/JafarAbdi/followers",
                "following_url": "https://api.github.com/users/JafarAbdi/following{/other_user}",
                "gists_url": "https://api.github.com/users/JafarAbdi/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JafarAbdi",
                "id": 16278108,
                "login": "JafarAbdi",
                "node_id": "MDQ6VXNlcjE2Mjc4MTA4",
                "organizations_url": "https://api.github.com/users/JafarAbdi/orgs",
                "received_events_url": "https://api.github.com/users/JafarAbdi/received_events",
                "repos_url": "https://api.github.com/users/JafarAbdi/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JafarAbdi/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JafarAbdi/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JafarAbdi"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615379731"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615379731"
                }
            },
            "author_association": "MEMBER",
            "body": "> ```\r\n> textDocument = {\r\n>   completion = {\r\n>     editsNearCursor = true,\r\n>   },\r\n>  },\r\n> ```\r\n\r\nHmmm I don't know, since neovim doesn't set this capability it's technically not responsible for supporting it. I also investigated more about this setting in the clang code and it [looks like an LSP extension](https://github.com/llvm/llvm-project/blob/686600b521aa3ca5fb9f015d25636067e2c5c9fa/clang-tools-extra/clangd/Protocol.h#L471-L474). The goal of this PR (and of neovim's LSP support in general) is to stick to the protocol.\r\n\r\nTagging @mfussenegger for his thoughts on this as well.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T01:13:14Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615379731",
            "id": 1615379731,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gSL0T",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2079850822,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615379731/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T01:14:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615379731",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615387547"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615387547"
                }
            },
            "author_association": "MEMBER",
            "body": "nvim-lsp-compl also includes `'detail'` and `'documentation'` here, but I think we shouldn't since we don't actually resolve these properties when missing in the unresolved completion items.\r\n\r\nAny objection @mfussenegger?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T01:35:47Z",
            "diff_hunk": "@@ -738,14 +738,16 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,\n           commitCharactersSupport = false,\n           preselectSupport = false,\n           deprecatedSupport = false,\n           documentationFormat = { constants.MarkupKind.Markdown, constants.MarkupKind.PlainText },\n+          resolveSupport = {\n+            properties = {\n+              'additionalTextEdits',",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615387547",
            "id": 1615387547,
            "line": 748,
            "node_id": "PRRC_kwDOAPphoM5gSNub",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 748,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 15,
            "pull_request_review_id": 2079862451,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615387547/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T01:35:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615387547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615512674"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615512674"
                }
            },
            "author_association": "MEMBER",
            "body": "No objection. \r\n\r\nThe idea behind including them was that servers don't have to provide the documentation if it's never displayed - reducing payloads. But if they're displayed depends on `completeopt` ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T06:02:35Z",
            "diff_hunk": "@@ -738,14 +738,16 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,\n           commitCharactersSupport = false,\n           preselectSupport = false,\n           deprecatedSupport = false,\n           documentationFormat = { constants.MarkupKind.Markdown, constants.MarkupKind.PlainText },\n+          resolveSupport = {\n+            properties = {\n+              'additionalTextEdits',",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615512674",
            "id": 1615512674,
            "in_reply_to_id": 1615387547,
            "line": 748,
            "node_id": "PRRC_kwDOAPphoM5gSsRi",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 748,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 15,
            "pull_request_review_id": 2080049871,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615512674/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T06:03:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615512674",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615515026"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615515026"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's keep it as is for the initial merge. We can then follow up on this. \r\nThe proposed change itself doesn't look too bad, so if it doesn't break other scenario I'd be open to include it - if it comes with tests and everything.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T06:05:45Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615515026",
            "id": 1615515026,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gSs2S",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2080053554,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615515026/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T06:05:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615515026",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615803795"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615803795"
                }
            },
            "author_association": "NONE",
            "body": "Fair enough, I'll try to get a better fix with tests in a follow-up PR. [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)'s users will get this behaviour since it sets `editsNearCursor` to `true`\r\n\r\nThanks @MariaSolOs for the PR!",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T09:45:47Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615803795",
            "id": 1615803795,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gTzWT",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2080523257,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615803795/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T09:45:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615803795",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/16278108?v=4",
                "events_url": "https://api.github.com/users/JafarAbdi/events{/privacy}",
                "followers_url": "https://api.github.com/users/JafarAbdi/followers",
                "following_url": "https://api.github.com/users/JafarAbdi/following{/other_user}",
                "gists_url": "https://api.github.com/users/JafarAbdi/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/JafarAbdi",
                "id": 16278108,
                "login": "JafarAbdi",
                "node_id": "MDQ6VXNlcjE2Mjc4MTA4",
                "organizations_url": "https://api.github.com/users/JafarAbdi/orgs",
                "received_events_url": "https://api.github.com/users/JafarAbdi/received_events",
                "repos_url": "https://api.github.com/users/JafarAbdi/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/JafarAbdi/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/JafarAbdi/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/JafarAbdi"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615934424"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615934424"
                }
            },
            "author_association": "MEMBER",
            "body": "disable() is redundant, and explicitly discouraged in `:help dev`. `enable(enable: boolean, ...)` is the conventional signature. this also avoids a potential \"toggle()\" function in the future. see `:help dev-pattens`\r\n\r\nin this case it could be `enable(enable: boolean, client_id, bufnr, opts)` if `client_id` and `bufnr` are always required",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T11:44:15Z",
            "diff_hunk": "@@ -1604,6 +1587,53 @@ save({lenses}, {bufnr}, {client_id})                 *vim.lsp.codelens.save()*\n        {client_id}  (`integer`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.completion                                *lsp-completion*\n+\n+*vim.lsp.completion.BufferOpts*\n+\n+    Fields: ~\n+       {autotrigger}?  (`boolean`) Whether to trigger completion\n+                        automatically. Default: false\n+\n+\n+disable({client_id}, {bufnr})                   *vim.lsp.completion.disable()*\n+    Disables completions from the given language client in the given buffer.\n+\n+    Parameters: ~\n+       {client_id}  (`integer`) Client ID\n+       {bufnr}      (`integer`) Buffer handle, or 0 for the current buffer\n+\n+enable({client_id}, {bufnr}, {opts})             *vim.lsp.completion.enable()*\n+    Enables completions from the given language client in the given buffer.",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615934424",
            "id": 1615934424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gUTPY",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 1608,
            "original_position": 78,
            "original_start_line": 1600,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2080738177,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615934424/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-27T11:46:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615934424",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1615954095"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615954095"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nlocal function on_insert_leave()\r\n  reset_timer()\r\n  Context.cursor = nil\r\n  Context:reset()\r\nend\r\n\r\nlocal function on_complete_done()\r\n```",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T11:59:03Z",
            "diff_hunk": "@@ -0,0 +1,726 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+--- @param input string Unparsed snippet\n+--- @return string # Parsed snippet if successful, else returns its input\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when a selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+--- @param item lsp.CompletionItem\n+--- @return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+--- @param result vim.lsp.CompletionResult\n+--- @return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+--- @private\n+--- @param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+--- @param prefix string prefix to filter the completion items\n+--- @param client_id integer? Client ID\n+--- @return table[]\n+--- @see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+--- @param lnum integer 0-indexed\n+--- @param line string\n+--- @param items lsp.CompletionItem[]\n+--- @param encoding string\n+--- @return integer?\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+--- @private\n+--- @param line string line content\n+--- @param lnum integer 0-indexed line number\n+--- @param cursor_col integer\n+--- @param client_id integer client ID\n+--- @param client_start_boundary integer 0-indexed word boundary\n+--- @param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+--- @param result vim.lsp.CompletionResult\n+--- @param encoding string\n+--- @return table[] matches\n+--- @return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+--- @see |complete-functions|\n+--- @see |complete-items|\n+--- @see |CompleteDone|\n+---\n+--- @param findstart integer 0 or 1, decides behavior\n+--- @param base integer findstart=0, text to match against\n+---\n+--- @return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1615954095",
            "id": 1615954095,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gUYCv",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 463,
            "original_position": 463,
            "original_start_line": 457,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": null,
            "pull_request_review_id": 2080764215,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615954095/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-27T11:59:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1615954095",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616195677"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616195677"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmmm I see. It might help with performance then...\r\n\r\nThe thing is that by setting them here servers will likely never set those properties since they expect them to be resolved, but we never actually resolve them. So I'm not sure...",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T15:34:40Z",
            "diff_hunk": "@@ -738,14 +738,16 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,\n           commitCharactersSupport = false,\n           preselectSupport = false,\n           deprecatedSupport = false,\n           documentationFormat = { constants.MarkupKind.Markdown, constants.MarkupKind.PlainText },\n+          resolveSupport = {\n+            properties = {\n+              'additionalTextEdits',",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616195677",
            "id": 1616195677,
            "in_reply_to_id": 1615387547,
            "line": 748,
            "node_id": "PRRC_kwDOAPphoM5gVTBd",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 748,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 15,
            "pull_request_review_id": 2081165502,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616195677/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T15:34:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616195677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616196641"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616196641"
                }
            },
            "author_association": "MEMBER",
            "body": "@JafarAbdi sounds good. Once this gets merged feel free to create an issue here so that we can track the follow-up work.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T15:35:55Z",
            "diff_hunk": "@@ -0,0 +1,717 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+---@param input string unparsed snippet\n+---@return string parsed snippet\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+---@param item lsp.CompletionItem\n+---@return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+---@param result vim.lsp.CompletionResult\n+---@return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+---@private\n+---@param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+---@param prefix string prefix to filter the completion items\n+---@param client_id integer? Client ID\n+---@return table[]\n+---@see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+---@param lnum integer 0-indexed\n+---@param line string\n+---@param items lsp.CompletionItem[]\n+---@param encoding string\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+---@private\n+---@param line string line content\n+---@param lnum integer 0-indexed line number\n+---@param cursor_col integer\n+---@param client_id integer client ID\n+---@param client_start_boundary integer 0-indexed word boundary\n+---@param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+---@param result vim.lsp.CompletionResult\n+---@param encoding string\n+---@return table[] matches\n+---@return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+---@see |complete-functions|\n+---@see |complete-items|\n+---@see |CompleteDone|\n+---\n+---@param findstart integer 0 or 1, decides behavior\n+---@param base integer findstart=0, text to match against\n+---\n+---@return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M.omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function insert_char_pre_cb(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function insert_leave_cb()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function complete_done_cb()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616196641",
            "id": 1616196641,
            "in_reply_to_id": 1615314435,
            "line": 506,
            "node_id": "PRRC_kwDOAPphoM5gVTQh",
            "original_commit_id": "0590b5a2f5085911a86a2b94d6726ba39b08e60b",
            "original_line": 506,
            "original_position": 505,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 506,
            "pull_request_review_id": 2081167055,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616196641/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T15:35:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616196641",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616199610"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616199610"
                }
            },
            "author_association": "MEMBER",
            "body": "If it's not necessary for the MVP, ignore them -- we can always add them later.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T15:38:38Z",
            "diff_hunk": "@@ -738,14 +738,16 @@ function protocol.make_client_capabilities()\n       completion = {\n         dynamicRegistration = false,\n         completionItem = {\n-          -- Until we can actually expand snippet, move cursor and allow for true snippet experience,\n-          -- this should be disabled out of the box.\n-          -- However, users can turn this back on if they have a snippet plugin.\n-          snippetSupport = false,\n+          snippetSupport = true,\n           commitCharactersSupport = false,\n           preselectSupport = false,\n           deprecatedSupport = false,\n           documentationFormat = { constants.MarkupKind.Markdown, constants.MarkupKind.PlainText },\n+          resolveSupport = {\n+            properties = {\n+              'additionalTextEdits',",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616199610",
            "id": 1616199610,
            "in_reply_to_id": 1615387547,
            "line": 748,
            "node_id": "PRRC_kwDOAPphoM5gVT-6",
            "original_commit_id": "c972f7a768058db03a3b770f67b8f6b56b528d00",
            "original_line": 748,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/protocol.lua",
            "position": 15,
            "pull_request_review_id": 2081172257,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616199610/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T15:38:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616199610",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616383022"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616383022"
                }
            },
            "author_association": "MEMBER",
            "body": "What is the rationale for renaming/deprecating this? It seems like needless churn for no benefit. Since `omnifunc` corresponds to an option name, the fact that its part of the `completion` module is an implementation detail (just as we also have `vim.lsp.tagfunc`).\r\n\r\nI wont die on this hill but my preference would be to leave this as-is, without deprecating, especially since there doesnt seem to be a compelling reason to move it. ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T20:50:39Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616383022",
            "id": 1616383022,
            "in_reply_to_id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gWAwu",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2081452591,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616383022/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T20:50:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616383022",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616398363"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616398363"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't really mind what we do with this. @justinmk what are your thoughts in terms of codebase conventions/organization?",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T21:25:29Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616398363",
            "id": 1616398363,
            "in_reply_to_id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gWEgb",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2081477164,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616398363/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T21:25:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616398363",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616400332"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616400332"
                }
            },
            "author_association": "MEMBER",
            "body": "To get this PR over the finish line we could keep `vim.lsp.omnifunc` undeprecated for now and rename `vim.lsp.completion.omnifunc` to `vim.lsp.completion._omnifunc` + `@nodoc`.\r\n\r\nWe can then follow up on this later - depending on the direction we want to go with it.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T21:31:41Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616400332",
            "id": 1616400332,
            "in_reply_to_id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gWE_M",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2081480005,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616400332/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T21:31:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616400332",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1616407999"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616407999"
                }
            },
            "author_association": "MEMBER",
            "body": "To be clear, the load-bearing part of my comment was \"keep a shim\", _not_ the deprecation message. I'm fully on-board with just moving the _implementation_, not the exposure point.",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-05-27T21:56:45Z",
            "diff_hunk": "@@ -50,7 +50,7 @@ listed below, if (1) the language server supports the functionality and (2)\n the options are empty or were set by the builtin runtime (ftplugin) files. The\n options are not restored when the LSP client is stopped or detached.\n \n-- 'omnifunc' is set to |vim.lsp.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger\n+- 'omnifunc' is set to |vim.lsp.completion.omnifunc()|, use |i_CTRL-X_CTRL-O| to trigger",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1616407999",
            "id": 1616407999,
            "in_reply_to_id": 1582546150,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gWG2_",
            "original_commit_id": "5527fddc5ce7d0c162ad19d49d7942221aa6d879",
            "original_line": 63,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2081491048,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616407999/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-27T21:56:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1616407999",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/27339#discussion_r1667319611"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/27339"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1667319611"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Relying on InsertLeave can be wrong, because the user can exit the insert mode with ctrl-c, which doesn't trigger InsertLeave. Example: #29581. I noticed some other runtime files use InsertLeave, and they seem to be mostly fine. But I'm not quite sure if this module's use is correct.  ",
            "commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "created_at": "2024-07-06T07:05:44Z",
            "diff_hunk": "@@ -0,0 +1,734 @@\n+local M = {}\n+\n+local api = vim.api\n+local lsp = vim.lsp\n+local protocol = lsp.protocol\n+local ms = protocol.Methods\n+\n+local rtt_ms = 50\n+local ns_to_ms = 0.000001\n+\n+--- @alias vim.lsp.CompletionResult lsp.CompletionList | lsp.CompletionItem[]\n+\n+-- TODO(mariasolos): Remove this declaration once we figure out a better way to handle\n+-- literal/anonymous types (see https://github.com/neovim/neovim/pull/27542/files#r1495259331).\n+--- @nodoc\n+--- @class lsp.ItemDefaults\n+--- @field editRange lsp.Range | { insert: lsp.Range, replace: lsp.Range } | nil\n+--- @field insertTextFormat lsp.InsertTextFormat?\n+--- @field insertTextMode lsp.InsertTextMode?\n+--- @field data any\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.BufHandle\n+--- @field clients table<integer, vim.lsp.Client>\n+--- @field triggers table<string, vim.lsp.Client[]>\n+\n+--- @type table<integer, vim.lsp.completion.BufHandle>\n+local buf_handles = {}\n+\n+--- @nodoc\n+--- @class vim.lsp.completion.Context\n+local Context = {\n+  cursor = nil, --- @type { [1]: integer, [2]: integer }?\n+  last_request_time = nil, --- @type integer?\n+  pending_requests = {}, --- @type function[]\n+  isIncomplete = false,\n+}\n+\n+--- @nodoc\n+function Context:cancel_pending()\n+  for _, cancel in ipairs(self.pending_requests) do\n+    cancel()\n+  end\n+\n+  self.pending_requests = {}\n+end\n+\n+--- @nodoc\n+function Context:reset()\n+  -- Note that the cursor isn't reset here, it needs to survive a `CompleteDone` event.\n+  self.isIncomplete = false\n+  self.last_request_time = nil\n+  self:cancel_pending()\n+end\n+\n+--- @type uv.uv_timer_t?\n+local completion_timer = nil\n+\n+--- @return uv.uv_timer_t\n+local function new_timer()\n+  return assert(vim.uv.new_timer())\n+end\n+\n+local function reset_timer()\n+  if completion_timer then\n+    completion_timer:stop()\n+    completion_timer:close()\n+  end\n+\n+  completion_timer = nil\n+end\n+\n+--- @param window integer\n+--- @param warmup integer\n+--- @return fun(sample: number): number\n+local function exp_avg(window, warmup)\n+  local count = 0\n+  local sum = 0\n+  local value = 0\n+\n+  return function(sample)\n+    if count < warmup then\n+      count = count + 1\n+      sum = sum + sample\n+      value = sum / count\n+    else\n+      local factor = 2.0 / (window + 1)\n+      value = value * (1 - factor) + sample * factor\n+    end\n+    return value\n+  end\n+end\n+local compute_new_average = exp_avg(10, 10)\n+\n+--- @return number\n+local function next_debounce()\n+  if not Context.last_request_time then\n+    return rtt_ms\n+  end\n+\n+  local ms_since_request = (vim.uv.hrtime() - Context.last_request_time) * ns_to_ms\n+  return math.max((ms_since_request - rtt_ms) * -1, 0)\n+end\n+\n+--- @param input string Unparsed snippet\n+--- @return string # Parsed snippet if successful, else returns its input\n+local function parse_snippet(input)\n+  local ok, parsed = pcall(function()\n+    return lsp._snippet_grammar.parse(input)\n+  end)\n+  return ok and tostring(parsed) or input\n+end\n+\n+--- @param item lsp.CompletionItem\n+--- @param suffix? string\n+local function apply_snippet(item, suffix)\n+  if item.textEdit then\n+    vim.snippet.expand(item.textEdit.newText .. suffix)\n+  elseif item.insertText then\n+    vim.snippet.expand(item.insertText .. suffix)\n+  end\n+end\n+\n+--- Returns text that should be inserted when a selecting completion item. The\n+--- precedence is as follows: textEdit.newText > insertText > label\n+---\n+--- See https://microsoft.github.io/language-server-protocol/specifications/specification-current/#textDocument_completion\n+---\n+--- @param item lsp.CompletionItem\n+--- @return string\n+local function get_completion_word(item)\n+  if item.textEdit ~= nil and item.textEdit.newText ~= nil and item.textEdit.newText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.textEdit.newText\n+    else\n+      return parse_snippet(item.textEdit.newText)\n+    end\n+  elseif item.insertText ~= nil and item.insertText ~= '' then\n+    if item.insertTextFormat == protocol.InsertTextFormat.PlainText then\n+      return item.insertText\n+    else\n+      return parse_snippet(item.insertText)\n+    end\n+  end\n+  return item.label\n+end\n+\n+--- Applies the given defaults to the completion item, modifying it in place.\n+---\n+--- @param item lsp.CompletionItem\n+--- @param defaults lsp.ItemDefaults?\n+local function apply_defaults(item, defaults)\n+  if not defaults then\n+    return\n+  end\n+\n+  item.insertTextFormat = item.insertTextFormat or defaults.insertTextFormat\n+  item.insertTextMode = item.insertTextMode or defaults.insertTextMode\n+  item.data = item.data or defaults.data\n+  if defaults.editRange then\n+    local textEdit = item.textEdit or {}\n+    item.textEdit = textEdit\n+    textEdit.newText = textEdit.newText or item.textEditText or item.insertText\n+    if defaults.editRange.start then\n+      textEdit.range = textEdit.range or defaults.editRange\n+    elseif defaults.editRange.insert then\n+      textEdit.insert = defaults.editRange.insert\n+      textEdit.replace = defaults.editRange.replace\n+    end\n+  end\n+end\n+\n+--- @param result vim.lsp.CompletionResult\n+--- @return lsp.CompletionItem[]\n+local function get_items(result)\n+  if result.items then\n+    -- When we have a list, apply the defaults and return an array of items.\n+    for _, item in ipairs(result.items) do\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      apply_defaults(item, result.itemDefaults)\n+    end\n+    return result.items\n+  else\n+    -- Else just return the items as they are.\n+    return result\n+  end\n+end\n+\n+--- Turns the result of a `textDocument/completion` request into vim-compatible\n+--- |complete-items|.\n+---\n+--- @private\n+--- @param result vim.lsp.CompletionResult Result of `textDocument/completion`\n+--- @param prefix string prefix to filter the completion items\n+--- @param client_id integer? Client ID\n+--- @return table[]\n+--- @see complete-items\n+function M._lsp_to_complete_items(result, prefix, client_id)\n+  local items = get_items(result)\n+  if vim.tbl_isempty(items) then\n+    return {}\n+  end\n+\n+  local function matches_prefix(item)\n+    return vim.startswith(get_completion_word(item), prefix)\n+  end\n+\n+  items = vim.tbl_filter(matches_prefix, items) --[[@as lsp.CompletionItem[]|]]\n+  table.sort(items, function(a, b)\n+    return (a.sortText or a.label) < (b.sortText or b.label)\n+  end)\n+\n+  local matches = {}\n+  for _, item in ipairs(items) do\n+    local info = ''\n+    local documentation = item.documentation\n+    if documentation then\n+      if type(documentation) == 'string' and documentation ~= '' then\n+        info = documentation\n+      elseif type(documentation) == 'table' and type(documentation.value) == 'string' then\n+        info = documentation.value\n+      else\n+        vim.notify(\n+          ('invalid documentation value %s'):format(vim.inspect(documentation)),\n+          vim.log.levels.WARN\n+        )\n+      end\n+    end\n+    local word = get_completion_word(item)\n+    table.insert(matches, {\n+      word = word,\n+      abbr = item.label,\n+      kind = protocol.CompletionItemKind[item.kind] or 'Unknown',\n+      menu = item.detail or '',\n+      info = #info > 0 and info or '',\n+      icase = 1,\n+      dup = 1,\n+      empty = 1,\n+      user_data = {\n+        nvim = {\n+          lsp = {\n+            completion_item = item,\n+            client_id = client_id,\n+          },\n+        },\n+      },\n+    })\n+  end\n+  return matches\n+end\n+\n+--- @param lnum integer 0-indexed\n+--- @param line string\n+--- @param items lsp.CompletionItem[]\n+--- @param encoding string\n+--- @return integer?\n+local function adjust_start_col(lnum, line, items, encoding)\n+  local min_start_char = nil\n+  for _, item in pairs(items) do\n+    if item.textEdit and item.textEdit.range.start.line == lnum then\n+      if min_start_char and min_start_char ~= item.textEdit.range.start.character then\n+        return nil\n+      end\n+      min_start_char = item.textEdit.range.start.character\n+    end\n+  end\n+  if min_start_char then\n+    return lsp.util._str_byteindex_enc(line, min_start_char, encoding)\n+  else\n+    return nil\n+  end\n+end\n+\n+--- @private\n+--- @param line string line content\n+--- @param lnum integer 0-indexed line number\n+--- @param cursor_col integer\n+--- @param client_id integer client ID\n+--- @param client_start_boundary integer 0-indexed word boundary\n+--- @param server_start_boundary? integer 0-indexed word boundary, based on textEdit.range.start.character\n+--- @param result vim.lsp.CompletionResult\n+--- @param encoding string\n+--- @return table[] matches\n+--- @return integer? server_start_boundary\n+function M._convert_results(\n+  line,\n+  lnum,\n+  cursor_col,\n+  client_id,\n+  client_start_boundary,\n+  server_start_boundary,\n+  result,\n+  encoding\n+)\n+  -- Completion response items may be relative to a position different than `client_start_boundary`.\n+  -- Concrete example, with lua-language-server:\n+  --\n+  -- require('plenary.asy|\n+  --                   \n+  --                    cursor_pos:                     20\n+  --                 client_start_boundary:          17\n+  --          textEdit.range.start.character: 9\n+  --                                 .newText = 'plenary.async'\n+  --                  ^^^\n+  --                  prefix (We'd remove everything not starting with `asy`,\n+  --                  so we'd eliminate the `plenary.async` result\n+  --\n+  -- `adjust_start_col` is used to prefer the language server boundary.\n+  --\n+  local candidates = get_items(result)\n+  local curstartbyte = adjust_start_col(lnum, line, candidates, encoding)\n+  if server_start_boundary == nil then\n+    server_start_boundary = curstartbyte\n+  elseif curstartbyte ~= nil and curstartbyte ~= server_start_boundary then\n+    server_start_boundary = client_start_boundary\n+  end\n+  local prefix = line:sub((server_start_boundary or client_start_boundary) + 1, cursor_col)\n+  local matches = M._lsp_to_complete_items(result, prefix, client_id)\n+  return matches, server_start_boundary\n+end\n+\n+--- Implements 'omnifunc' compatible LSP completion.\n+---\n+--- @see |complete-functions|\n+--- @see |complete-items|\n+--- @see |CompleteDone|\n+---\n+--- @param findstart integer 0 or 1, decides behavior\n+--- @param base integer findstart=0, text to match against\n+---\n+--- @return integer|table Decided by {findstart}:\n+--- - findstart=0: column where the completion starts, or -2 or -3\n+--- - findstart=1: list of matches (actually just calls |complete()|)\n+function M._omnifunc(findstart, base)\n+  vim.lsp.log.debug('omnifunc.findstart', { findstart = findstart, base = base })\n+  assert(base) -- silence luals\n+  local bufnr = api.nvim_get_current_buf()\n+  local clients = lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_completion })\n+  local remaining = #clients\n+  if remaining == 0 then\n+    return findstart == 1 and -1 or {}\n+  end\n+\n+  local win = api.nvim_get_current_win()\n+  local cursor = api.nvim_win_get_cursor(win)\n+  local lnum = cursor[1] - 1\n+  local cursor_col = cursor[2]\n+  local line = api.nvim_get_current_line()\n+  local line_to_cursor = line:sub(1, cursor_col)\n+  local client_start_boundary = vim.fn.match(line_to_cursor, '\\\\k*$') --[[@as integer]]\n+  local server_start_boundary = nil\n+  local items = {}\n+\n+  local function on_done()\n+    local mode = api.nvim_get_mode()['mode']\n+    if mode == 'i' or mode == 'ic' then\n+      vim.fn.complete((server_start_boundary or client_start_boundary) + 1, items)\n+    end\n+  end\n+\n+  local util = vim.lsp.util\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(win, client.offset_encoding)\n+    client.request(ms.textDocument_completion, params, function(err, result)\n+      if err then\n+        lsp.log.warn(err.message)\n+      end\n+      if result and vim.fn.mode() == 'i' then\n+        local matches\n+        matches, server_start_boundary = M._convert_results(\n+          line,\n+          lnum,\n+          cursor_col,\n+          client.id,\n+          client_start_boundary,\n+          server_start_boundary,\n+          result,\n+          client.offset_encoding\n+        )\n+        vim.list_extend(items, matches)\n+      end\n+      remaining = remaining - 1\n+      if remaining == 0 then\n+        vim.schedule(on_done)\n+      end\n+    end, bufnr)\n+  end\n+\n+  -- Return -2 to signal that we should continue completion so that we can\n+  -- async complete.\n+  return -2\n+end\n+\n+--- @param clients table<integer, vim.lsp.Client>\n+--- @param bufnr integer\n+--- @param win integer\n+--- @param callback fun(responses: table<integer, { err: lsp.ResponseError, result: vim.lsp.CompletionResult }>)\n+--- @return function # Cancellation function\n+local function request(clients, bufnr, win, callback)\n+  local responses = {} --- @type table<integer, { err: lsp.ResponseError, result: any }>\n+  local request_ids = {} --- @type table<integer, integer>\n+  local remaining_requests = vim.tbl_count(clients)\n+\n+  for client_id, client in pairs(clients) do\n+    local params = lsp.util.make_position_params(win, client.offset_encoding)\n+    local ok, request_id = client.request(ms.textDocument_completion, params, function(err, result)\n+      responses[client_id] = { err = err, result = result }\n+      remaining_requests = remaining_requests - 1\n+      if remaining_requests == 0 then\n+        callback(responses)\n+      end\n+    end, bufnr)\n+\n+    if ok then\n+      request_ids[client_id] = request_id\n+    end\n+  end\n+\n+  return function()\n+    for client_id, request_id in pairs(request_ids) do\n+      local client = lsp.get_client_by_id(client_id)\n+      if client then\n+        client.cancel_request(request_id)\n+      end\n+    end\n+  end\n+end\n+\n+--- @param handle vim.lsp.completion.BufHandle\n+local function on_insert_char_pre(handle)\n+  if tonumber(vim.fn.pumvisible()) == 1 then\n+    if Context.isIncomplete then\n+      reset_timer()\n+\n+      local debounce_ms = next_debounce()\n+      if debounce_ms == 0 then\n+        vim.schedule(M.trigger)\n+      else\n+        completion_timer = new_timer()\n+        completion_timer:start(debounce_ms, 0, vim.schedule_wrap(M.trigger))\n+      end\n+    end\n+\n+    return\n+  end\n+\n+  local char = api.nvim_get_vvar('char')\n+  if not completion_timer and handle.triggers[char] then\n+    completion_timer = assert(vim.uv.new_timer())\n+    completion_timer:start(25, 0, function()\n+      reset_timer()\n+      vim.schedule(M.trigger)\n+    end)\n+  end\n+end\n+\n+local function on_insert_leave()\n+  reset_timer()\n+  Context.cursor = nil\n+  Context:reset()\n+end\n+\n+local function on_complete_done()\n+  local completed_item = api.nvim_get_vvar('completed_item')\n+  if not completed_item or not completed_item.user_data or not completed_item.user_data.nvim then\n+    Context:reset()\n+    return\n+  end\n+\n+  local cursor_row, cursor_col = unpack(api.nvim_win_get_cursor(0)) --- @type integer, integer\n+  cursor_row = cursor_row - 1\n+  local completion_item = completed_item.user_data.nvim.lsp.completion_item --- @type lsp.CompletionItem\n+  local client_id = completed_item.user_data.nvim.lsp.client_id --- @type integer\n+  if not completion_item or not client_id then\n+    Context:reset()\n+    return\n+  end\n+\n+  local bufnr = api.nvim_get_current_buf()\n+  local expand_snippet = completion_item.insertTextFormat == protocol.InsertTextFormat.Snippet\n+    and (completion_item.textEdit ~= nil or completion_item.insertText ~= nil)\n+\n+  Context:reset()\n+\n+  local client = lsp.get_client_by_id(client_id)\n+  if not client then\n+    return\n+  end\n+\n+  local offset_encoding = client.offset_encoding or 'utf-16'\n+  local resolve_provider = (client.server_capabilities.completionProvider or {}).resolveProvider\n+\n+  local function clear_word()\n+    if not expand_snippet then\n+      return nil\n+    end\n+\n+    -- Remove the already inserted word.\n+    local start_char = cursor_col - #completed_item.word\n+    local line = api.nvim_buf_get_lines(bufnr, cursor_row, cursor_row + 1, true)[1]\n+    api.nvim_buf_set_text(bufnr, cursor_row, start_char, cursor_row, #line, { '' })\n+    return line:sub(cursor_col + 1)\n+  end\n+\n+  --- @param suffix? string\n+  local function apply_snippet_and_command(suffix)\n+    if expand_snippet then\n+      apply_snippet(completion_item, suffix)\n+    end\n+\n+    local command = completion_item.command\n+    if command then\n+      client:_exec_cmd(command, { bufnr = bufnr }, nil, function()\n+        vim.lsp.log.warn(\n+          string.format(\n+            'Language server `%s` does not support command `%s`. This command may require a client extension.',\n+            client.name,\n+            command.command\n+          )\n+        )\n+      end)\n+    end\n+  end\n+\n+  if completion_item.additionalTextEdits and next(completion_item.additionalTextEdits) then\n+    local suffix = clear_word()\n+    lsp.util.apply_text_edits(completion_item.additionalTextEdits, bufnr, offset_encoding)\n+    apply_snippet_and_command(suffix)\n+  elseif resolve_provider and type(completion_item) == 'table' then\n+    local changedtick = vim.b[bufnr].changedtick\n+\n+    --- @param result lsp.CompletionItem\n+    client.request(ms.completionItem_resolve, completion_item, function(err, result)\n+      if changedtick ~= vim.b[bufnr].changedtick then\n+        return\n+      end\n+\n+      local suffix = clear_word()\n+      if err then\n+        vim.notify_once(err.message, vim.log.levels.WARN)\n+      elseif result and result.additionalTextEdits then\n+        lsp.util.apply_text_edits(result.additionalTextEdits, bufnr, offset_encoding)\n+        if result.command then\n+          completion_item.command = result.command\n+        end\n+      end\n+\n+      apply_snippet_and_command(suffix)\n+    end, bufnr)\n+  else\n+    local suffix = clear_word()\n+    apply_snippet_and_command(suffix)\n+  end\n+end\n+\n+--- @class vim.lsp.completion.BufferOpts\n+--- @field autotrigger? boolean Whether to trigger completion automatically. Default: false\n+\n+--- @param client_id integer\n+---@param bufnr integer\n+---@param opts vim.lsp.completion.BufferOpts\n+local function enable_completions(client_id, bufnr, opts)\n+  if not buf_handles[bufnr] then\n+    buf_handles[bufnr] = { clients = {}, triggers = {} }\n+\n+    -- Attach to buffer events.\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, buf)\n+        buf_handles[buf] = nil\n+      end,\n+      on_reload = function(_, buf)\n+        M.enable(true, client_id, buf, opts)\n+      end,\n+    })\n+\n+    -- Set up autocommands.\n+    local group =\n+      api.nvim_create_augroup(string.format('vim/lsp/completion-%d', bufnr), { clear = true })\n+    api.nvim_create_autocmd('CompleteDone', {\n+      group = group,\n+      buffer = bufnr,\n+      callback = function()\n+        local reason = api.nvim_get_vvar('event').reason --- @type string\n+        if reason == 'accept' then\n+          on_complete_done()\n+        end\n+      end,\n+    })\n+    if opts.autotrigger then\n+      api.nvim_create_autocmd('InsertCharPre', {\n+        group = group,\n+        buffer = bufnr,\n+        callback = function()\n+          on_insert_char_pre(buf_handles[bufnr])\n+        end,\n+      })\n+      api.nvim_create_autocmd('InsertLeave', {",
            "html_url": "https://github.com/neovim/neovim/pull/27339#discussion_r1667319611",
            "id": 1667319611,
            "line": 597,
            "node_id": "PRRC_kwDOAPphoM5jYUc7",
            "original_commit_id": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
            "original_line": 597,
            "original_position": 597,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/completion.lua",
            "position": 597,
            "pull_request_review_id": 2161490143,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1667319611/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-07-06T07:05:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1667319611",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/19489738?v=4",
                "events_url": "https://api.github.com/users/tomtomjhj/events{/privacy}",
                "followers_url": "https://api.github.com/users/tomtomjhj/followers",
                "following_url": "https://api.github.com/users/tomtomjhj/following{/other_user}",
                "gists_url": "https://api.github.com/users/tomtomjhj/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tomtomjhj",
                "id": 19489738,
                "login": "tomtomjhj",
                "node_id": "MDQ6VXNlcjE5NDg5NzM4",
                "organizations_url": "https://api.github.com/users/tomtomjhj/orgs",
                "received_events_url": "https://api.github.com/users/tomtomjhj/received_events",
                "repos_url": "https://api.github.com/users/tomtomjhj/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tomtomjhj/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tomtomjhj/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tomtomjhj"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Okay the implementation is done and tests are all passing. At this point we just need to agree on whether we should enable completion by default and the structure of the public API (_so just the usual bikeshedding ;)_).\r\n\r\nNot sure if we want to do that in this PR or in a separate one. Wdyt @mfussenegger @clason @justinmk @gpanders?",
            "created_at": "2024-04-29T04:58:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2081890654",
            "id": 2081890654,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM58FyFe",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2081890654/reactions"
            },
            "updated_at": "2024-04-29T04:58:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2081890654",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I'd suggest to go with the enable / is_enabled.\r\nThat also gives us the option to add configuration options to the enable call.\r\n\r\n@mfussenegger got it, that sounds reasonable. I'll separate the functionality.\r\n\r\n> Or maybe I completely misunderstand the proposal here?\r\n\r\nNo, I was the one who misunderstood the assignment.",
            "created_at": "2024-04-30T03:32:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2084314197",
            "id": 2084314197,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM58PBxV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2084314197/reactions"
            },
            "updated_at": "2024-04-30T03:32:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2084314197",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I'd suggest to go with the `enable` / `is_enabled`.\r\n\r\n@mfussenegger what would `is_enabled` be used for?",
            "created_at": "2024-05-04T17:51:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2094325813",
            "id": 2094325813,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM581OA1",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2094325813/reactions"
            },
            "updated_at": "2024-05-07T09:51:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2094325813",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> what would `is_enabled` be used for?\r\n\r\nIt's optional, but the typical use-case is to \"toggle\". And any other (presumed) use-case where scripts want to decide behavior based on whether a feature is enabled.",
            "created_at": "2024-05-06T10:38:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2095692318",
            "id": 2095692318,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM586boe",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2095692318/reactions"
            },
            "updated_at": "2024-05-07T09:51:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2095692318",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@MariaSolOs To be clear, that is a _general_ guideline, not specifically for this PR; if toggling does not make sense (which I don't think it does here), no need to add it. (We can always add later if and when a compelling use case is presented.)",
            "created_at": "2024-05-06T10:42:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2095706157",
            "id": 2095706157,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM586fAt",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2095706157/reactions"
            },
            "updated_at": "2024-05-07T09:51:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2095706157",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> It's optional, but the typical use-case is to \"toggle\". And any other (presumed) use-case where scripts want to decide behavior based on whether a feature is enabled.\r\n\r\n@justinmk Right, I inferred this bit, but I haven't been able to come up with a scenario where someone would want to toggle completion, and I thought I was missing something.\r\n\r\n> @MariaSolOs To be clear, that is a _general_ guideline, not specifically for this PR; if toggling does not make sense (which I don't think it does here), no need to add it. (We can always add later if and when a compelling use case is presented.)\r\n\r\n@clason That clears things up indeed <3",
            "created_at": "2024-05-07T03:33:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2097381797",
            "id": 2097381797,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM59A4Gl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2097381797/reactions"
            },
            "updated_at": "2024-05-07T03:34:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2097381797",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> not a blocker: did you intend to revert your `supports_method` changes in lsp.txt ?\r\n\r\nYeah I didn't want to keep the changes in that file with stuff unrelated to this PR. I plan on doing a better review of the current LSP docs later.",
            "created_at": "2024-05-28T15:29:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/27339#issuecomment-2135531354",
            "id": 2135531354,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
            "node_id": "IC_kwDOAPphoM5_SZ9a",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2135531354/reactions"
            },
            "updated_at": "2024-05-28T15:29:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2135531354",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/27339/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/27339/commits",
    "created_at": "2024-02-04T22:15:08Z",
    "diff_url": "https://github.com/neovim/neovim/pull/27339.diff",
    "draft": false,
    "head": {
        "label": "MariaSolOs:completion",
        "ref": "completion",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/MariaSolOs/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/MariaSolOs/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/MariaSolOs/neovim/branches{/branch}",
            "clone_url": "https://github.com/MariaSolOs/neovim.git",
            "collaborators_url": "https://api.github.com/repos/MariaSolOs/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/MariaSolOs/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/MariaSolOs/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/MariaSolOs/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/MariaSolOs/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/MariaSolOs/neovim/contributors",
            "created_at": "2023-08-05T17:10:58Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/MariaSolOs/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/MariaSolOs/neovim/downloads",
            "events_url": "https://api.github.com/repos/MariaSolOs/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/MariaSolOs/neovim/forks",
            "full_name": "MariaSolOs/neovim",
            "git_commits_url": "https://api.github.com/repos/MariaSolOs/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/MariaSolOs/neovim/git/tags{/sha}",
            "git_url": "git://github.com/MariaSolOs/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/MariaSolOs/neovim/hooks",
            "html_url": "https://github.com/MariaSolOs/neovim",
            "id": 675070403,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/MariaSolOs/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/MariaSolOs/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/MariaSolOs/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/MariaSolOs/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/MariaSolOs/neovim/merges",
            "milestones_url": "https://api.github.com/repos/MariaSolOs/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOKDzBww",
            "notifications_url": "https://api.github.com/repos/MariaSolOs/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/MariaSolOs/neovim/pulls{/number}",
            "pushed_at": "2024-06-26T21:38:00Z",
            "releases_url": "https://api.github.com/repos/MariaSolOs/neovim/releases{/id}",
            "size": 269889,
            "ssh_url": "git@github.com:MariaSolOs/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/MariaSolOs/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/MariaSolOs/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/MariaSolOs/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/MariaSolOs/neovim/subscription",
            "svn_url": "https://github.com/MariaSolOs/neovim",
            "tags_url": "https://api.github.com/repos/MariaSolOs/neovim/tags",
            "teams_url": "https://api.github.com/repos/MariaSolOs/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/MariaSolOs/neovim/git/trees{/sha}",
            "updated_at": "2024-06-26T21:38:17Z",
            "url": "https://api.github.com/repos/MariaSolOs/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/27339",
    "id": 1710583780,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/27339",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        },
        {
            "color": "C5DEF5",
            "default": false,
            "description": "Nvim built-in (omni)completion",
            "id": 3214348835,
            "name": "completion",
            "node_id": "MDU6TGFiZWwzMjE0MzQ4ODM1",
            "url": "https://api.github.com/repos/neovim/neovim/labels/completion"
        },
        {
            "color": "C5DEF5",
            "default": false,
            "description": "",
            "id": 6207355257,
            "name": "snippet",
            "node_id": "LA_kwDOAPphoM8AAAABcfy5eQ",
            "url": "https://api.github.com/repos/neovim/neovim/labels/snippet"
        }
    ],
    "locked": false,
    "merge_commit_sha": "0bdd602bf974fdefc348f47bb7b9057521eb0407",
    "merged_at": "2024-05-28T17:39:30Z",
    "milestone": {
        "closed_at": null,
        "closed_issues": 36,
        "created_at": "2023-12-07T23:09:35Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
            "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
            "followers_url": "https://api.github.com/users/justinmk/followers",
            "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
            "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/justinmk",
            "id": 1359421,
            "login": "justinmk",
            "node_id": "MDQ6VXNlcjEzNTk0MjE=",
            "organizations_url": "https://api.github.com/users/justinmk/orgs",
            "received_events_url": "https://api.github.com/users/justinmk/received_events",
            "repos_url": "https://api.github.com/users/justinmk/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/justinmk"
        },
        "description": "",
        "due_on": "2024-10-31T07:00:00Z",
        "html_url": "https://github.com/neovim/neovim/milestone/41",
        "id": 10283236,
        "labels_url": "https://api.github.com/repos/neovim/neovim/milestones/41/labels",
        "node_id": "MI_kwDOAPphoM4AnOjk",
        "number": 41,
        "open_issues": 49,
        "state": "open",
        "title": "0.11",
        "updated_at": "2024-06-28T17:47:40Z",
        "url": "https://api.github.com/repos/neovim/neovim/milestones/41"
    },
    "node_id": "PR_kwDOAPphoM5l9W_k",
    "number": 27339,
    "patch_url": "https://github.com/neovim/neovim/pull/27339.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/27339/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/e6cfcaed184d4ecdc8a8638429e1bd9e1b3251dc",
    "title": "feat(lsp): completion side effects",
    "updated_at": "2024-07-06T07:05:44Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/27339",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
        "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
        "followers_url": "https://api.github.com/users/MariaSolOs/followers",
        "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
        "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/MariaSolOs",
        "id": 62502207,
        "login": "MariaSolOs",
        "node_id": "MDQ6VXNlcjYyNTAyMjA3",
        "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
        "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
        "repos_url": "https://api.github.com/users/MariaSolOs/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/MariaSolOs"
    }
}