{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/24493/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/24493/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/24493"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/24493"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/24493/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/858eef76bb621fc65c666e6c3e786e1b4a614c23"
        }
    },
    "active_lock_reason": "resolved",
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 4791,
            "forks_count": 4791,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1644,
            "open_issues_count": 1644,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2023-08-02T22:20:08Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 248042,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 67955,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2023-08-03T02:00:39Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 67955,
            "watchers_count": 67955,
            "web_commit_signoff_required": false
        },
        "sha": "c1c2a1b5dd1d73e5e97b94e6626aaac25a3db9bc",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "Resolves #18311\r\n\r\nFollow-up to #24473 \r\n\r\n- `eval.lua` is now the source of truth.\r\n   - Now contains `name` and `desc` fields.\r\n- Formatting is much more consistent.\r\n- Fixed Lua type generation for polymorphic functions (`get()`, etc).\r\n- Removed \"Overview\" section from `builtin.txt`\r\n   - Can generate this if we *really* want it.\r\n- Moved functions from `sign.txt` and `testing.txt` into `builtin.txt`.\r\n- Removed the ~~`*timer*`~~ `*timers*` tags since libuv timers via `vim.uv` should be preferred.\r\n- Removed the `temp-file-name` tag from `tempname()`\r\n- ~~Moved `lueval()` from lua.txt to builtin.txt.~~\r\n\r\n### Follow up tasks\r\n\r\n- Add language annotations to code blocks. (#24506)\r\n- Rename `builtin.txt` to `eval_funcs.txt`\r\n- Improve formatting in `eval.lua` and remove tabs.\r\n- Fill out any missing type information.",
    "closed_at": "2023-07-28T13:48:42Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275541030"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275541030"
                }
            },
            "author_association": "MEMBER",
            "body": "The other tag is gone",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:24:46Z",
            "diff_hunk": "@@ -1042,7 +633,7 @@ byteidxcomp({expr}, {nr} [, {utf16}])\t\t\t*byteidxcomp()*\n \t\tCan also be used as a |method|: >\n \t\t\tGetName()->byteidxcomp(idx)\n \n-call({func}, {arglist} [, {dict}])\t\t\t*call()* *E699*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275541030",
            "id": 1275541030,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MBzYm",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 1045,
            "original_position": 1032,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275541030/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275541030",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275542122"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542122"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:26:44Z",
            "diff_hunk": "@@ -1275,7 +865,7 @@ col({expr} [, {winid}])\t\t\t\t\t*col()*\n \t\t\tGetPos()->col()\n <\n \n-complete({startcol}, {matches})\t\t\t*complete()* *E785*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275542122",
            "id": 1275542122,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MBzpq",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 1278,
            "original_position": 1123,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542122/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542122",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275542974"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542974"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:28:24Z",
            "diff_hunk": "@@ -4484,7 +4080,7 @@ isinf({expr})\t\t\t\t\t\t*isinf()*\n \t\tCan also be used as a |method|: >\n \t\t\tCompute()->isinf()\n \n-islocked({expr})\t\t\t\t\t*islocked()* *E786*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275542974",
            "id": 1275542974,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MBz2-",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 4487,
            "original_position": 2298,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542974/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275542974",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543307"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543307"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:29:06Z",
            "diff_hunk": "@@ -5289,7 +4869,7 @@ matcharg({nr})\t\t\t\t\t\t\t*matcharg()*\n \t\tCan also be used as a |method|: >\n \t\t\tGetMatch()->matcharg()\n \n-matchdelete({id} [, {win}])\t\t       *matchdelete()* *E802* *E803*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543307",
            "id": 1275543307,
            "line": 5292,
            "node_id": "PRRC_kwDOAPphoM5MBz8L",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 5292,
            "original_position": 2603,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 2150,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543307/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543307",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543641"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543641"
                }
            },
            "author_association": "MEMBER",
            "body": "These tags seem to belong to the wrong function",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:29:47Z",
            "diff_hunk": "@@ -4730,7 +4309,8 @@ keytrans({string})\t\t\t\t\t*keytrans()*\n \t\t\t\"\\<C-Home>\"->keytrans()\n \n <\t\t\t\t\t\t\t*len()* *E701*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543641",
            "id": 1275543641,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB0BZ",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 4302,
            "original_position": 2427,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543641/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543641",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543727"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543727"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:29:58Z",
            "diff_hunk": "@@ -4744,7 +4324,8 @@ len({expr})\tThe result is a Number, which is the length of the argument.\n \t\t\tmylist->len()\n \n <\t\t\t\t\t\t*libcall()* *E364* *E368*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275543727",
            "id": 1275543727,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB0Cv",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 4317,
            "original_position": 2437,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543727/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275543727",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275544111"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275544111"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:30:43Z",
            "diff_hunk": "@@ -5172,7 +4752,8 @@ match({expr}, {pat} [, {start} [, {count}]])\t\t\t*match()*\n \t\t\tGetList()->match('word')\n <\n \t\t\t*matchadd()* *E798* *E799* *E801* *E957*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275544111",
            "id": 1275544111,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB0Iv",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 4745,
            "original_position": 2582,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275544111/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275544111",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275545059"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545059"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:32:23Z",
            "diff_hunk": "@@ -6259,6 +5839,7 @@ rand([{expr}])\t\t\t\t\t\t*rand()*\n <\n \n \t\t\t\t\t\t\t*E726* *E727*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275545059",
            "id": 1275545059,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB0Xj",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 5885,
            "original_position": 2866,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545059/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545059",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275545991"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545991"
                }
            },
            "author_association": "MEMBER",
            "body": "This become a part of the previous code block",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:34:16Z",
            "diff_hunk": "@@ -5830,7 +5409,7 @@ nr2char({expr} [, {utf8}])\t\t\t\t*nr2char()*\n \t\tCan also be used as a |method|: >\n \t\t\tGetNumber()->nr2char()\n \n-nvim_...({...})\t\t\t\t\t*E5555* *nvim_...()* *eval-api*\n+\t\tnvim_...({...})\t\t\t\t\t*E5555* *nvim_...()* *eval-api*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275545991",
            "id": 1275545991,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB0mH",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 5403,
            "original_position": 2741,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1548702266,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545991/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275545991",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275550565"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275550565"
                }
            },
            "author_association": "MEMBER",
            "body": "This looks really ugly... Doesn't it?",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-26T22:41:26Z",
            "diff_hunk": "@@ -10142,6 +10254,7 @@ function vim.fn.timer_info(id) end\n --- Can also be used as a |method|: >\n ---   GetTimer()->timer_pause(1)\n --- <\n+---         *timer_start()* *timer* *timers*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275550565",
            "id": 1275550565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MB1tl",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 10382,
            "original_position": 397,
            "original_start_line": null,
            "path": "runtime/lua/vim/_meta/vimfn.lua",
            "position": null,
            "pull_request_review_id": 1548722657,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275550565/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-26T22:41:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275550565",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1275973532"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275973532"
                }
            },
            "author_association": "MEMBER",
            "body": "This problem will go away when we eventually we move additional tags into a separate field in `eval.lua`.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-27T09:05:58Z",
            "diff_hunk": "@@ -10142,6 +10254,7 @@ function vim.fn.timer_info(id) end\n --- Can also be used as a |method|: >\n ---   GetTimer()->timer_pause(1)\n --- <\n+---         *timer_start()* *timer* *timers*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1275973532",
            "id": 1275973532,
            "in_reply_to_id": 1275550565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MDc-c",
            "original_commit_id": "bc379bbbadade089d7f80c2b756b1e0a068e6052",
            "original_line": 10382,
            "original_position": 397,
            "original_start_line": null,
            "path": "runtime/lua/vim/_meta/vimfn.lua",
            "position": null,
            "pull_request_review_id": 1549366085,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275973532/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-27T09:05:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1275973532",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277344950"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277344950"
                }
            },
            "author_association": "MEMBER",
            "body": "To be honest, I'd probably leave this section here as-is (with only the `*lua-eval*` tag), as it's much more detailed than the \"reference\" style in `builtin.txt`. Instead, I'd add a brief function(!) documentation (arguments, return value etc.) with the `*luaeval()*` tag and add cross-links.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T09:47:40Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277344950",
            "id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MIry2",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551747679,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277344950/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T09:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277344950",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277354269"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277354269"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't mind either way.\r\n\r\nThe reason I moved it out is because `lua.txt` is mostly useful for Lua usage, not vimscript. `luaeval()` is only useful from vimscript so made sense to bundle it with all the vimscript functions.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T09:56:38Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277354269",
            "id": 1277354269,
            "in_reply_to_id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MIuEd",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551762770,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277354269/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T09:56:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277354269",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277356185"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277356185"
                }
            },
            "author_association": "MEMBER",
            "body": "That's a good point; it just seemed a bit \"chatty\" compared to the rest of the function documentation (and I don't think spending time on rewriting it to be more in line is worth it).",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T09:58:45Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277356185",
            "id": 1277356185,
            "in_reply_to_id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MIuiZ",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551765820,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277356185/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T09:58:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277356185",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277361838"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277361838"
                }
            },
            "author_association": "MEMBER",
            "body": "I did think about that, but there are quite a few chatty descriptions anyway, e.g. `searchpair()`, `searchcount()`, `setqflist()`,\r\n\r\nAdditionally, it would be great if we could eventually generate `lua.txt` by removing most/all the static sections. It's 80% generated atm.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:04:53Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277361838",
            "id": 1277361838,
            "in_reply_to_id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MIv6u",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551774630,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277361838/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:05:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277361838",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277365286"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365286"
                }
            },
            "author_association": "MEMBER",
            "body": "Wrong indent",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:08:51Z",
            "diff_hunk": "@@ -3366,27 +2974,28 @@ getmatches([{win}])\t\t\t\t\t*getmatches()*\n \t\tan empty list is returned.\n \t\tExample: >vim\n \t\t\t:echo getmatches()\n->\n- \t\t\t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+\t\t>\n+\t\t \t\t\t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277365286",
            "id": 1277365286,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MIwwm",
            "original_commit_id": "bfbbf5208787c2b3beb0e6bbea333e30f2bcd2b2",
            "original_line": 2978,
            "original_position": 2000,
            "original_start_line": 2977,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551780028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365286/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-07-28T10:08:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365286",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277365714"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365714"
                }
            },
            "author_association": "MEMBER",
            "body": "More wrong indent",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:09:22Z",
            "diff_hunk": "@@ -1294,22 +891,22 @@ complete({startcol}, {matches})\t\t\t*complete()* *E785*\n \t\tInsert mode completion.  The popup menu will appear if\n \t\tspecified, see |ins-completion-menu|.\n \t\tExample: >\n-\tinoremap <F5> <C-R>=ListMonths()<CR>\n+\t\t\tinoremap <F5> <C-R>=ListMonths()<CR>\n \n-\tfunc ListMonths()\n-\t  call complete(col('.'), ['January', 'February', 'March',\n+\t\t\tfunc ListMonths()\n+\t\t\t  call complete(col('.'), ['January', 'February', 'March',\n \t\t\\ 'April', 'May', 'June', 'July', 'August', 'September',\n \t\t\\ 'October', 'November', 'December'])\n-\t  return ''\n-\tendfunc\n+\t\t\t  return ''\n+\t\t\tendfunc",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277365714",
            "id": 1277365714,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MIw3S",
            "original_commit_id": "bfbbf5208787c2b3beb0e6bbea333e30f2bcd2b2",
            "original_line": 899,
            "original_position": 1189,
            "original_start_line": 1297,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551780714,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365714/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "LEFT",
            "subject_type": "line",
            "updated_at": "2023-07-28T10:09:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277365714",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277368004"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277368004"
                }
            },
            "author_association": "MEMBER",
            "body": "Wrong indent again",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:11:47Z",
            "diff_hunk": "@@ -6328,21 +5954,20 @@ readdir({directory} [, {expr}])\n \t\t  readdir(dirname, {n -> n !~ '^\\.\\|\\~$'})\n \n <\t\tIf you want to get a directory tree: >\n-                  function! s:tree(dir)\n-                      return {a:dir : map(readdir(a:dir),\n+\t\t                  function! s:tree(dir)\n+\t\t                      return {a:dir : map(readdir(a:dir),\n \t\t      \\ {_, x -> isdirectory(x) ?\n \t\t      \\          {x : s:tree(a:dir .. '/' .. x)} : x})}",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277368004",
            "id": 1277368004,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MIxbE",
            "original_commit_id": "bfbbf5208787c2b3beb0e6bbea333e30f2bcd2b2",
            "original_line": 5956,
            "original_position": 3092,
            "original_start_line": 5957,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551784111,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277368004/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-07-28T10:11:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277368004",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277378258"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277378258"
                }
            },
            "author_association": "MEMBER",
            "body": "Well, the static sections are valuable -- where would they go, and would they be able to stand alone?",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:24:09Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277378258",
            "id": 1277378258,
            "in_reply_to_id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MIz7S",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551800277,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277378258/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:24:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277378258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277384962"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277384962"
                }
            },
            "author_association": "MEMBER",
            "body": "In either case, probably best treated as a follow-up (split `lua.txt` in generated and static files).",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:32:06Z",
            "diff_hunk": "@@ -294,78 +294,6 @@ arguments separated by \" \" (space) instead of \"\\t\" (tab).\n         :luafile script.lua\n         :luafile %\n <\n-\n-==============================================================================\n-luaeval()                                                 *lua-eval* *luaeval()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277384962",
            "id": 1277384962,
            "in_reply_to_id": 1277344950,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5MI1kC",
            "original_commit_id": "33e545ba238c11b1c097e0e13c1f538a1c7d6009",
            "original_line": 299,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 4,
            "pull_request_review_id": 1551810591,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277384962/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:32:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277384962",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277400411"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400411"
                }
            },
            "author_association": "MEMBER",
            "body": "Missing tag",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:50:54Z",
            "diff_hunk": "@@ -1575,7 +1175,7 @@ debugbreak({pid})\t\t\t\t\t*debugbreak()*\n \t\tCan also be used as a |method|: >\n \t\t\tGetPid()->debugbreak()\n \n-deepcopy({expr} [, {noref}])\t\t\t\t*deepcopy()* *E698*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277400411",
            "id": 1277400411,
            "line": 1578,
            "node_id": "PRRC_kwDOAPphoM5MI5Vb",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 1578,
            "original_position": 1324,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 1165,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400411/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400411",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277400508"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400508"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:51:03Z",
            "diff_hunk": "@@ -1721,7 +1322,7 @@ diff_hlID({lnum}, {col})\t\t\t\t*diff_hlID()*\n \t\t\tGetLnum()->diff_hlID(col)\n <\n \n-digraph_get({chars})\t\t\t\t\t*digraph_get()* *E1214*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277400508",
            "id": 1277400508,
            "line": 1724,
            "node_id": "PRRC_kwDOAPphoM5MI5W8",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 1724,
            "original_position": 1396,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 1201,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400508/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277400508",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277401967"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277401967"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:52:44Z",
            "diff_hunk": "@@ -6378,7 +6003,7 @@ readfile({fname} [, {type} [, {max}]])\n \t\tCan also be used as a |method|: >\n \t\t\tGetFileName()->readfile()\n \n-reduce({object}, {func} [, {initial}])\t\t\t*reduce()* *E998*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277401967",
            "id": 1277401967,
            "line": 6381,
            "node_id": "PRRC_kwDOAPphoM5MI5tv",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 6381,
            "original_position": 3119,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 2462,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277401967/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277401967",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277402539"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402539"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:53:18Z",
            "diff_hunk": "@@ -6530,7 +6156,7 @@ repeat({expr}, {count})\t\t\t\t\t*repeat()*\n \t\tCan also be used as a |method|: >\n \t\t\tmylist->repeat(count)\n \n-resolve({filename})\t\t\t\t\t*resolve()* *E655*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277402539",
            "id": 1277402539,
            "line": 6533,
            "node_id": "PRRC_kwDOAPphoM5MI52r",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 6533,
            "original_position": 3175,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 2520,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402539/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402539",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277402749"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402749"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:53:36Z",
            "diff_hunk": "@@ -7282,7 +6908,7 @@ setenv({name}, {val})\t\t\t\t\t\t*setenv()*\n \t\tsecond argument: >\n \t\t\tGetPath()->setenv('PATH')\n \n-setfperm({fname}, {mode})\t\t\t\t*setfperm()* *chmod*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277402749",
            "id": 1277402749,
            "line": 7285,
            "node_id": "PRRC_kwDOAPphoM5MI559",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 7285,
            "original_position": 3392,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 2803,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402749/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277402749",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403029"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403029"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:53:56Z",
            "diff_hunk": "@@ -7824,7 +7837,7 @@ sockconnect({mode}, {address} [, {opts}])\t\t *sockconnect()*\n \t\t  - The channel ID on success (greater than zero)\n \t\t  - 0 on invalid arguments or connection failure.\n \n-sort({list} [, {func} [, {dict}]])\t\t\t*sort()* *E702*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403029",
            "id": 1277403029,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI5-V",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 7827,
            "original_position": 3924,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403029/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403029",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403185"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403185"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:54:03Z",
            "diff_hunk": "@@ -8044,8 +8057,7 @@ stdioopen({opts})\t\t\t *stdioopen()*\n \t\t  - |channel-id| on success (value is always 1)\n \t\t  - 0 on invalid arguments\n \n-\n-stdpath({what})\t\t\t\t\t*stdpath()* *E6100*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403185",
            "id": 1277403185,
            "line": 8048,
            "node_id": "PRRC_kwDOAPphoM5MI6Ax",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 8048,
            "original_position": 3994,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 3366,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403185/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403185",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403313"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403313"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:54:12Z",
            "diff_hunk": "@@ -8424,7 +8439,7 @@ strwidth({string})\t\t\t\t\t*strwidth()*\n \t\tCan also be used as a |method|: >\n \t\t\tGetString()->strwidth()\n \n-submatch({nr} [, {list}])\t\t\t*submatch()* *E935*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403313",
            "id": 1277403313,
            "line": 8427,
            "node_id": "PRRC_kwDOAPphoM5MI6Cx",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 8427,
            "original_position": 4147,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": 3482,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403313/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403313",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403406"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403406"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:54:21Z",
            "diff_hunk": "@@ -8670,7 +8685,7 @@ synstack({lnum}, {col})\t\t\t\t\t*synstack()*\n \t\tcharacter in a line and the first column in an empty line are\n \t\tvalid positions.\n \n-system({cmd} [, {input}])\t\t\t\t*system()* *E677*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403406",
            "id": 1277403406,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI6EO",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 8673,
            "original_position": 4238,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403406/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403406",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403560"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403560"
                }
            },
            "author_association": "MEMBER",
            "body": "ditto",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:54:33Z",
            "diff_hunk": "@@ -9136,7 +9153,7 @@ undotree()\t\t\t\t\t\t*undotree()*\n \t\t\t\tblocks.  Each item may again have an \"alt\"\n \t\t\t\titem.\n \n-uniq({list} [, {func} [, {dict}]])\t\t\t*uniq()* *E882*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277403560",
            "id": 1277403560,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI6Go",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 9139,
            "original_position": 4437,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403560/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277403560",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277404065"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277404065"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmm, the tag shouldn't include parentheses.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T10:55:12Z",
            "diff_hunk": "@@ -5829,8 +5454,10 @@ nr2char({expr} [, {utf8}])\t\t\t\t*nr2char()*\n \n \t\tCan also be used as a |method|: >\n \t\t\tGetNumber()->nr2char()\n+<\n \n-nvim_...({...})\t\t\t\t\t*E5555* *nvim_...()* *eval-api*\n+nvim_...({...})\t\t\t\t\t\t*eval-api()*",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277404065",
            "id": 1277404065,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI6Oh",
            "original_commit_id": "66b3f7dbfbc6f83636b5b813ccdf70ed9b191185",
            "original_line": 5459,
            "original_position": 2938,
            "original_start_line": null,
            "path": "runtime/doc/builtin.txt",
            "position": null,
            "pull_request_review_id": 1551846916,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277404065/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T10:59:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277404065",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277413279"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413279"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n            return {a:dir : map(readdir(a:dir),\r\n            \\ {_, x -> isdirectory(x) ?\r\n            \\          {x : s:tree(a:dir .. '/' .. x)} : x})}\r\n```",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T11:06:09Z",
            "diff_hunk": "@@ -11,502 +12,13421 @@\n ---       Defaults to BASE_NONE (function cannot be used as a method).\n --- @field func? string Name of the C function which implements the Vimscript function. Defaults to\n ---       `f_{funcname}`.\n+--- @field float_func? string\n --- @field fast? boolean Function can run in |api-fast| events. Defaults to false.\n---- @field deprecated? string[]\n+--- @field deprecated? true\n --- @field returns? string|false\n+--- @field signature string\n+--- @field desc? string\n+--- @field params {[1]:string, [2]:string}[]\n+--- @field lua? false Do not render type information\n+--- @field tags? string[] Extra tags\n+--- @field data? string Used by gen_eval.lua\n \n -- Usable with the base key: use the last function argument as the method base.\n -- Value is from funcs.h file. \"BASE_\" prefix is omitted.\n -- local LAST = \"BASE_LAST\" (currently unused after port of v8.2.1168)\n \n-local VIMBOOL = '0|1'\n-\n-return {\n-  --- @type table<string,vim.EvalFn>\n-  funcs={\n-    abs={args=1, base=1},\n-    acos={args=1, base=1, float_func=\"acos\", returns='number'},  -- WJMc\n-    add={args=2, base=1},\n-    ['and']={args=2, base=1},\n-    api_info={fast=true},\n-    append={args=2, base=2},\n-    appendbufline={args=3, base=3},\n-    argc={args={0, 1}, returns='integer'},\n-    argidx={returns='integer'},\n-    arglistid={args={0, 2}, returns='integer'},\n-    argv={args={0, 2}},\n-    asin={args=1, base=1, float_func=\"asin\"},  -- WJMc\n-    assert_beeps={args=1, base=1, returns=VIMBOOL},\n-    assert_equal={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_equalfile={args={2, 3}, base=1},\n-    assert_exception={args={1, 2}, returns=VIMBOOL},\n-    assert_fails={args={1, 5}, base=1, returns=VIMBOOL},\n-    assert_false={args={1, 2}, base=1, returns=VIMBOOL},\n-    assert_inrange={args={3, 4}, base=3, returns=VIMBOOL},\n-    assert_match={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_nobeep={args=1, base=1, returns=VIMBOOL},\n-    assert_notequal={args={2, 3}, base=2},\n-    assert_notmatch={args={2, 3}, base=2},\n-    assert_report={args=1, base=1},\n-    assert_true={args={1, 2}, base=1},\n-    atan={args=1, base=1, float_func=\"atan\", returns='number'},\n-    atan2={args=2, base=1, returns='number'},\n-    blob2list={args=1, base=1},\n-    browse={args=4},\n-    browsedir={args=2},\n-    bufadd={args=1, base=1, returns='integer'},\n-    bufexists={args=1, base=1, returns=VIMBOOL},\n-    buffer_exists={\n-      args=1, base=1, func='f_bufexists',\n-      deprecated = { 'Obsolete name for |bufexists()|.' }\n+local M = {}\n+\n+local VARARGS = { { '...', 'any' } }\n+\n+--- @type table<string,vim.EvalFn>\n+M.funcs = {\n+  abs = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the absolute value of {expr}.  When {expr} evaluates to\n+      a |Float| abs() returns a |Float|.  When {expr} can be\n+      converted to a |Number| abs() returns a |Number|.  Otherwise\n+      abs() gives an error message and returns -1.\n+      Examples: >\n+      \techo abs(1.456)\n+      <\t1.456  >\n+      \techo abs(-5.456)\n+      <\t5.456  >\n+      \techo abs(-4)\n+      <\t4\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->abs()\n+\n+    ]=],\n+    name = 'abs',\n+    params = { { 'expr', 'any' } },\n+    signature = 'abs({expr})',\n+    returns = 'number'\n+  },\n+  acos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc cosine of {expr} measured in radians, as a\n+      |Float| in the range of [0, pi].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo acos(0)\n+      <\t1.570796 >\n+      \t:echo acos(-0.5)\n+      <\t2.094395\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->acos()\n+\n+    ]=],\n+    float_func = 'acos',\n+    name = 'acos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'acos({expr})',\n+  },\n+  add = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Append the item {expr} to |List| or |Blob| {object}.  Returns\n+      the resulting |List| or |Blob|.  Examples: >\n+      \t:let alist = add([1, 2, 3], item)\n+      \t:call add(mylist, \"woodstock\")\n+      <Note that when {expr} is a |List| it is appended as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+      When {object} is a |Blob| then {expr} must be a number.\n+      Use |insert()| to add an item at another position.\n+      Returns 1 if {object} is not a |List| or a |Blob|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->add(val1)->add(val2)\n+\n+    ]=],\n+    name = 'add',\n+    params = { { 'object', 'any' }, { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'add({object}, {expr})',\n+  },\n+  ['and'] = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Bitwise AND on the two arguments.  The arguments are converted\n+      to a number.  A List, Dict or Float argument causes an error.\n+      Also see `or()` and `xor()`.\n+      Example: >\n+      \t:let flag = and(bits, 0x80)\n+      <Can also be used as a |method|: >\n+      \t:let flag = bits->and(0x80)\n+\n+    ]=],\n+    name = 'and',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    returns = 'integer',\n+    signature = 'and({expr}, {expr})',\n+  },\n+  api_info = {\n+    desc = [=[\n+      Returns Dictionary of |api-metadata|.\n+\n+      View it in a nice human-readable format: >\n+             :lua vim.print(vim.fn.api_info())\n+\n+    ]=],\n+    fast = true,\n+    name = 'api_info',\n+    params = {},\n+    returns = 'table',\n+    signature = 'api_info()',\n+  },\n+  append = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      When {text} is a |List|: Append each item of the |List| as a\n+      text line below line {lnum} in the current buffer.\n+      Otherwise append {text} as one text line below line {lnum} in\n+      the current buffer.\n+      Any type of item is accepted and converted to a String.\n+      {lnum} can be zero to insert a line before the first one.\n+      {lnum} is used like with |getline()|.\n+      Returns 1 for failure ({lnum} out of range or out of memory),\n+      0 for success.  Example: >\n+      \t:let failed = append(line('$'), \"# THE END\")\n+      \t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])\n+\n+      <Can also be used as a |method| after a List: >\n+      \tmylist->append(lnum)\n+\n+    ]=],\n+    name = 'append',\n+    params = { { 'lnum', 'integer' }, { 'text', 'any' } },\n+    returns = '0|1',\n+    signature = 'append({lnum}, {text})',\n+  },\n+  appendbufline = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Like |append()| but append the text in buffer {expr}.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()|.\n+\n+      {lnum} is the line number to append below.  Note that using\n+      |line()| would use the current buffer, not the one appending\n+      to.  Use \"$\" to append at the end of the buffer.  Other string\n+      values are not supported.\n+\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      If {buf} is not a valid buffer or {lnum} is not valid, an\n+      error message is given. Example: >\n+      \t:let failed = appendbufline(13, 0, \"# THE START\")\n+      <\n+      Can also be used as a |method| after a List: >\n+      \tmylist->appendbufline(buf, lnum)\n+\n+    ]=],\n+    name = 'appendbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'text', 'string' } },\n+    returns = '0|1',\n+    signature = 'appendbufline({buf}, {lnum}, {text})',\n+  },\n+  argc = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      The result is the number of files in the argument list.  See\n+      |arglist|.\n+      If {winid} is not supplied, the argument list of the current\n+      window is used.\n+      If {winid} is -1, the global argument list is used.\n+      Otherwise {winid} specifies the window of which the argument\n+      list is used: either the window number or the window ID.\n+      Returns -1 if the {winid} argument is invalid.\n+    ]=],\n+    name = 'argc',\n+    params = { { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'argc([{winid}])',\n+  },\n+  argidx = {\n+    desc = [=[\n+      The result is the current index in the argument list.  0 is\n+      the first file.  argc() - 1 is the last one.  See |arglist|.\n+    ]=],\n+    name = 'argidx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'argidx()',\n+  },\n+  arglistid = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      Return the argument list ID.  This is a number which\n+      identifies the argument list being used.  Zero is used for the\n+      global argument list.  See |arglist|.\n+      Returns -1 if the arguments are invalid.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.\n+      {winnr} can be the window number or the |window-ID|.\n+    ]=],\n+    name = 'arglistid',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'integer',\n+    signature = 'arglistid([{winnr} [, {tabnr}]])',\n+  },\n+  argv = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      The result is the {nr}th file in the argument list.  See\n+      |arglist|.  \"argv(0)\" is the first one.  Example: >\n+      \t:let i = 0\n+      \t:while i < argc()\n+      \t:  let f = escape(fnameescape(argv(i)), '.')\n+      \t:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'\n+      \t:  let i = i + 1\n+      \t:endwhile\n+      <Without the {nr} argument, or when {nr} is -1, a |List| with\n+      the whole |arglist| is returned.\n+\n+      The {winid} argument specifies the window ID, see |argc()|.\n+      For the Vim command line arguments see |v:argv|.\n+\n+      Returns an empty string if {nr}th argument is not present in\n+      the argument list.  Returns an empty List if the {winid}\n+      argument is invalid.\n+\n+    ]=],\n+    name = 'argv',\n+    params = { { 'nr', 'integer' }, { 'winid', 'integer' } },\n+    returns = 'string|string[]',\n+    signature = 'argv([{nr} [, {winid}]])',\n+  },\n+  asin = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc sine of {expr} measured in radians, as a |Float|\n+      in the range of [-pi/2, pi/2].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo asin(0.8)\n+      <\t0.927295 >\n+      \t:echo asin(-0.5)\n+      <\t-0.523599\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->asin()\n+      <\n+    ]=],\n+    float_func = 'asin',\n+    name = 'asin',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'asin({expr})',\n+  },\n+  assert_beeps = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce a beep or visual bell.\n+      Also see |assert_fails()|, |assert_nobeep()| and\n+      |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_beeps()\n+      <\n+    ]=],\n+    name = 'assert_beeps',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_beeps({cmd})',\n+  },\n+  assert_equal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {expected} and {actual} are not equal an error message is\n+      added to |v:errors| and 1 is returned.  Otherwise zero is\n+      returned. |assert-return|\n+      The error is in the form \"Expected {expected} but got\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      There is no automatic conversion, the String \"4\" is different\n+      from the Number 4.  And the number 4 is different from the\n+      Float 4.0.  The value of 'ignorecase' is not used here, case\n+      always matters.\n+      Example: >\n+      \tassert_equal('foo', 'bar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Expected 'foo' but got 'bar' ~\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_equal([1, 2, 3])\n+    ]=],\n+    name = 'assert_equal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_equal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_equalfile = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When the files {fname-one} and {fname-two} do not contain\n+      exactly the same text an error message is added to |v:errors|.\n+      Also see |assert-return|.\n+      When {fname-one} or {fname-two} does not exist the error will\n+      mention that.\n+\n+      Can also be used as a |method|: >\n+      \tGetLog()->assert_equalfile('expected.log')\n+    ]=],\n+    name = 'assert_equalfile',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'assert_equalfile({fname-one}, {fname-two})',\n+  },\n+  assert_exception = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      When v:exception does not contain the string {error} an error\n+      message is added to |v:errors|.  Also see |assert-return|.\n+      This can be used to assert that a command throws an exception.\n+      Using the error number, followed by a colon, avoids problems\n+      with translations: >\n+      \ttry\n+      \t  commandthatfails\n+      \t  call assert_false(1, 'command should have failed')\n+      \tcatch\n+      \t  call assert_exception('E492:')\n+      \tendtry\n+      <\n+    ]=],\n+    name = 'assert_exception',\n+    params = { { 'error', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_exception({error} [, {msg}])',\n+  },\n+  assert_fails = {\n+    args = { 1, 5 },\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce an error or when {error} is not found in the\n+      error message.  Also see |assert-return|.\n+\n+      When {error} is a string it must be found literally in the\n+      first reported error. Most often this will be the error code,\n+      including the colon, e.g. \"E123:\". >\n+      \tassert_fails('bad cmd', 'E987:')\n+      <\n+      When {error} is a |List| with one or two strings, these are\n+      used as patterns.  The first pattern is matched against the\n+      first reported error: >\n+      \tassert_fails('cmd', ['E987:.*expected bool'])\n+      <The second pattern, if present, is matched against the last\n+      reported error.  To only match the last error use an empty\n+      string for the first error: >\n+      \tassert_fails('cmd', ['', 'E987:'])\n+      <\n+      If {msg} is empty then it is not used.  Do this to get the\n+      default message when passing the {lnum} argument.\n+\n+      When {lnum} is present and not negative, and the {error}\n+      argument is present and matches, then this is compared with\n+      the line number at which the error was reported. That can be\n+      the line number in a function or in a script.\n+\n+      When {context} is present it is used as a pattern and matched\n+      against the context (script name or function name) where\n+      {lnum} is located in.\n+\n+      Note that beeping is not considered an error, and some failing\n+      commands only beep.  Use |assert_beeps()| for those.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_fails('E99:')\n+\n+    ]=],\n+    name = 'assert_fails',\n+    params = {\n+      { 'cmd', 'any' },\n+      { 'error', 'any' },\n+      { 'msg', 'any' },\n+      { 'lnum', 'integer' },\n+      { 'context', 'any' },\n     },\n-    buffer_name={\n-      args={0, 1}, base=1, func='f_bufname',\n-      deprecated = { 'Obsolete name for |bufname()|.' }\n+    returns = '0|1',\n+    signature = 'assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])',\n+  },\n+  assert_false = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not false an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      The error is in the form \"Expected False but got {actual}\".\n+      When {msg} is present it is prepended to that.\n+      Also see |assert-return|.\n+\n+      A value is false when it is zero. When {actual} is not a\n+      number the assert fails.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_false()\n+\n+    ]=],\n+    name = 'assert_false',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_false({actual} [, {msg}])',\n+  },\n+  assert_inrange = {\n+    args = { 3, 4 },\n+    base = 3,\n+    desc = [=[\n+      This asserts number and |Float| values.  When {actual}  is lower\n+      than {lower} or higher than {upper} an error message is added\n+      to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Expected range {lower} - {upper},\n+      but got {actual}\".  When {msg} is present it is prefixed to\n+      that.\n+    ]=],\n+    name = 'assert_inrange',\n+    params = { { 'lower', 'any' }, { 'upper', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_inrange({lower}, {upper}, {actual} [, {msg}])',\n+  },\n+  assert_match = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {pattern} does not match {actual} an error message is\n+      added to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Pattern {pattern} does not match\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      {pattern} is used as with |expr-=~|: The matching is always done\n+      like 'magic' was set and 'cpoptions' is empty, no matter what\n+      the actual value of 'magic' or 'cpoptions' is.\n+\n+      {actual} is used as a string, automatic conversion applies.\n+      Use \"^\" and \"$\" to match with the start and end of the text.\n+      Use both to match the whole text.\n+\n+      Example: >\n+      \tassert_match('^f.*o$', 'foobar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_match('foo.*')\n+      <\n+    ]=],\n+    name = 'assert_match',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_match({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_nobeep = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it\n+      produces a beep or visual bell.\n+      Also see |assert_beeps()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_nobeep()\n+      <\n+    ]=],\n+    name = 'assert_nobeep',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_nobeep({cmd})',\n+  },\n+  assert_notequal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_equal()`: add an error message to\n+      |v:errors| when {expected} and {actual} are equal.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_notequal([1, 2, 3])\n+\n+      <\n+    ]=],\n+    name = 'assert_notequal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notequal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_notmatch = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_match()`: add an error message to\n+      |v:errors| when {pattern} matches {actual}.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_notmatch('bar.*')\n+      <\n+    ]=],\n+    name = 'assert_notmatch',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notmatch({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_report = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Report a test failure directly, using String {msg}.\n+      Always returns one.\n+\n+      Can also be used as a |method|: >\n+      \tGetMessage()->assert_report()\n+      <\n+    ]=],\n+    name = 'assert_report',\n+    params = { { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_report({msg})',\n+  },\n+  assert_true = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not true an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      Also see |assert-return|.\n+      A value is |TRUE| when it is a non-zero number or |v:true|.\n+      When {actual} is not a number or |v:true| the assert fails.\n+      When {msg} is given it precedes the default message.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_true()\n+      <\n+    ]=],\n+    name = 'assert_true',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_true({actual} [, {msg}])',\n+  },\n+  atan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the principal value of the arc tangent of {expr}, in\n+      the range [-pi/2, +pi/2] radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo atan(100)\n+      <\t1.560797 >\n+      \t:echo atan(-4.01)\n+      <\t-1.326405\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan()\n+\n+    ]=],\n+    float_func = 'atan',\n+    name = 'atan',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'atan({expr})',\n+  },\n+  atan2 = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the arc tangent of {expr1} / {expr2}, measured in\n+      radians, as a |Float| in the range [-pi, pi].\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo atan2(-1, 1)\n+      <\t-0.785398 >\n+      \t:echo atan2(1, -1)\n+      <\t2.356194\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan2(1)\n+\n+    ]=],\n+    name = 'atan2',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    returns = 'number',\n+    signature = 'atan2({expr1}, {expr2})',\n+  },\n+  blob2list = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a List containing the number value of each byte in Blob\n+      {blob}.  Examples: >\n+      \tblob2list(0z0102.0304)\treturns [1, 2, 3, 4]\n+      \tblob2list(0z)\t\treturns []\n+      <Returns an empty List on error.  |list2blob()| does the\n+      opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetBlob()->blob2list()\n+      <\n+    ]=],\n+    name = 'blob2list',\n+    params = { { 'blob', 'any' } },\n+    returns = 'any[]',\n+    signature = 'blob2list({blob})',\n+  },\n+  browse = {\n+    args = 4,\n+    desc = [=[\n+      Put up a file requester.  This only works when \"has(\"browse\")\"\n+      returns |TRUE| (only in some GUI versions).\n+      The input fields are:\n+          {save}\twhen |TRUE|, select file to write\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+          {default}\tdefault file name\n+      An empty string is returned when the \"Cancel\" button is hit,\n+      something went wrong, or browsing is not possible.\n+    ]=],\n+    name = 'browse',\n+    params = { { 'save', 'any' }, { 'title', 'any' }, { 'initdir', 'any' }, { 'default', 'any' } },\n+    returns = '0|1',\n+    signature = 'browse({save}, {title}, {initdir}, {default})',\n+  },\n+  browsedir = {\n+    args = 2,\n+    desc = [=[\n+      Put up a directory requester.  This only works when\n+      \"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n+      On systems where a directory browser is not supported a file\n+      browser is used.  In that case: select a file in the directory\n+      to be used.\n+      The input fields are:\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+      When the \"Cancel\" button is hit, something went wrong, or\n+      browsing is not possible, an empty string is returned.\n+\n+    ]=],\n+    name = 'browsedir',\n+    params = { { 'title', 'any' }, { 'initdir', 'any' } },\n+    returns = '0|1',\n+    signature = 'browsedir({title}, {initdir})',\n+  },\n+  bufadd = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add a buffer to the buffer list with name {name} (must be a\n+      String).\n+      If a buffer for file {name} already exists, return that buffer\n+      number.  Otherwise return the buffer number of the newly\n+      created buffer.  When {name} is an empty string then a new\n+      buffer is always created.\n+      The buffer will not have 'buflisted' set and not be loaded\n+      yet.  To add some text to the buffer use this: >\n+      \tlet bufnr = bufadd('someName')\n+      \tcall bufload(bufnr)\n+      \tcall setbufline(bufnr, 1, ['some', 'text'])\n+      <Returns 0 on error.\n+      Can also be used as a |method|: >\n+      \tlet bufnr = 'somename'->bufadd()\n+\n+    ]=],\n+    name = 'bufadd',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'bufadd({name})',\n+  },\n+  bufexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists.\n+      If the {buf} argument is a number, buffer numbers are used.\n+      Number zero is the alternate buffer for the current window.\n+\n+      If the {buf} argument is a string it must match a buffer name\n+      exactly.  The name can be:\n+      - Relative to the current directory.\n+      - A full path.\n+      - The name of a buffer with 'buftype' set to \"nofile\".\n+      - A URL name.\n+      Unlisted buffers will be found.\n+      Note that help files are listed by their short name in the\n+      output of |:buffers|, but bufexists() requires using their\n+      long name to be able to find them.\n+      bufexists() may report a buffer exists, but to use the name\n+      with a |:buffer| command you may need to use |expand()|.  Esp\n+      for MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\n+      Use \"bufexists(0)\" to test for the existence of an alternate\n+      file name.\n+\n+      Can also be used as a |method|: >\n+      \tlet exists = 'somename'->bufexists()\n+\n+    ]=],\n+    name = 'bufexists',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufexists({buf})',\n+  },\n+  buffer_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufexists()|.\n+    ]=],\n+    func = 'f_bufexists',\n+    name = 'buffer_exists',\n+    params = VARARGS,\n+    returns = '0|1',\n+    signature = 'buffer_exists({buf})',\n+  },\n+  buffer_name = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufname()|.\n+    ]=],\n+    func = 'f_bufname',\n+    name = 'buffer_name',\n+    params = VARARGS,\n+    returns = 'string',\n+    signature = 'buffer_name([{buf}])',\n+  },\n+  buffer_number = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufnr()|.\n+    ]=],\n+    func = 'f_bufnr',\n+    name = 'buffer_number',\n+    params = VARARGS,\n+    returns = 'integer',\n+    signature = 'buffer_number([{buf} [, {create}]])',\n+  },\n+  buflisted = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is listed (has the 'buflisted' option set).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet listed = 'somename'->buflisted()\n+\n+    ]=],\n+    name = 'buflisted',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'buflisted({buf})',\n+  },\n+  bufload = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Ensure the buffer {buf} is loaded.  When the buffer name\n+      refers to an existing file then the file is read.  Otherwise\n+      the buffer will be empty.  If the buffer was already loaded\n+      then there is no change.  If the buffer is not related to a\n+      file the no file is read (e.g., when 'buftype' is \"nofile\").\n+      If there is an existing swap file for the file of the buffer,\n+      there will be no dialog, the buffer will be loaded anyway.\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \teval 'somename'->bufload()\n+\n+    ]=],\n+    name = 'bufload',\n+    params = { { 'buf', 'any' } },\n+    returns = false,\n+    signature = 'bufload({buf})',\n+  },\n+  bufloaded = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is loaded (shown in a window or hidden).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet loaded = 'somename'->bufloaded()\n+\n+    ]=],\n+    name = 'bufloaded',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufloaded({buf})',\n+  },\n+  bufname = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is the name of a buffer.  Mostly as it is displayed\n+      by the `:ls` command, but not using special names such as\n+      \"[No Name]\".\n+      If {buf} is omitted the current buffer is used.\n+      If {buf} is a Number, that buffer number's name is given.\n+      Number zero is the alternate buffer for the current window.\n+      If {buf} is a String, it is used as a |file-pattern| to match\n+      with the buffer names.  This is always done like 'magic' is\n+      set and 'cpoptions' is empty.  When there is more than one\n+      match an empty string is returned.\n+      \"\" or \"%\" can be used for the current buffer, \"#\" for the\n+      alternate buffer.\n+      A full match is preferred, otherwise a match at the start, end\n+      or middle of the buffer name is accepted.  If you only want a\n+      full match then put \"^\" at the start and \"$\" at the end of the\n+      pattern.\n+      Listed buffers are found first.  If there is a single match\n+      with a listed buffer, that one is returned.  Next unlisted\n+      buffers are searched for.\n+      If the {buf} is a String, but you want to use it as a buffer\n+      number, force it to be a Number by adding zero to it: >\n+      \t:echo bufname(\"3\" + 0)\n+      <Can also be used as a |method|: >\n+      \techo bufnr->bufname()\n+\n+      <If the buffer doesn't exist, or doesn't have a name, an empty\n+      string is returned. >\n+      \tbufname(\"#\")\t\talternate buffer name\n+      \tbufname(3)\t\tname of buffer 3\n+      \tbufname(\"%\")\t\tname of current buffer\n+      \tbufname(\"file2\")\tname of buffer where \"file2\" matches.\n+      <\n+    ]=],\n+    name = 'bufname',\n+    params = { { 'buf', 'any' } },\n+    returns = 'string',\n+    signature = 'bufname([{buf}])',\n+  },\n+  bufnr = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is the number of a buffer, as it is displayed by\n+      the `:ls` command.  For the use of {buf}, see |bufname()|\n+      above.\n+      If the buffer doesn't exist, -1 is returned.  Or, if the\n+      {create} argument is present and TRUE, a new, unlisted,\n+      buffer is created and its number is returned.\n+      bufnr(\"$\") is the last buffer: >\n+      \t:let last_buffer = bufnr(\"$\")\n+      <The result is a Number, which is the highest buffer number\n+      of existing buffers.  Note that not all buffers with a smaller\n+      number necessarily exist, because \":bwipeout\" may have removed\n+      them.  Use bufexists() to test for the existence of a buffer.\n+\n+      Can also be used as a |method|: >\n+      \techo bufref->bufnr()\n+\n+    ]=],\n+    name = 'bufnr',\n+    params = { { 'buf', 'any' }, { 'create', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufnr([{buf} [, {create}]])',\n+  },\n+  bufwinid = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the |window-ID| of the first\n+      window associated with buffer {buf}.  For the use of {buf},\n+      see |bufname()| above.  If buffer {buf} doesn't exist or\n+      there is no such window, -1 is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinid(1))\n+      <\n+      Only deals with the current tab page.  See |win_findbuf()| for\n+      finding more.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinid()\n+\n+    ]=],\n+    name = 'bufwinid',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinid({buf})',\n+  },\n+  bufwinnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Like |bufwinid()| but return the window number instead of the\n+      |window-ID|.\n+      If buffer {buf} doesn't exist or there is no such window, -1\n+      is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinnr(1))\n+\n+      <The number can be used with |CTRL-W_w| and \":wincmd w\"\n+      |:wincmd|.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinnr()\n+\n+    ]=],\n+    name = 'bufwinnr',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinnr({buf})',\n+  },\n+  byte2line = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the line number that contains the character at byte\n+      count {byte} in the current buffer.  This includes the\n+      end-of-line character, depending on the 'fileformat' option\n+      for the current buffer.  The first character has byte count\n+      one.\n+      Also see |line2byte()|, |go| and |:goto|.\n+\n+      Returns -1 if the {byte} value is invalid.\n+\n+      Can also be used as a |method|: >\n+      \tGetOffset()->byte2line()\n+\n+    ]=],\n+    name = 'byte2line',\n+    params = { { 'byte', 'any' } },\n+    returns = 'integer',\n+    signature = 'byte2line({byte})',\n+  },\n+  byteidx = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return byte index of the {nr}th character in the String\n+      {expr}.  Use zero for the first character, it then returns\n+      zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {nr}.\n+      Composing characters are not counted separately, their byte\n+      length is added to the preceding base character.  See\n+      |byteidxcomp()| below for counting composing characters\n+      separately.\n+      When {utf16} is present and TRUE, {nr} is used as the UTF-16\n+      index in the String {expr} instead of as the character index.\n+      The UTF-16 index is the index in the string when it is encoded\n+      with 16-bit words.  If the specified UTF-16 index is in the\n+      middle of a character (e.g. in a 4-byte character), then the\n+      byte index of the first byte in the character is returned.\n+      Refer to |string-offset-encoding| for more information.\n+      Example : >\n+      \techo matchstr(str, \".\", byteidx(str, 3))\n+      <will display the fourth character.  Another way to do the\n+      same: >\n+      \tlet s = strpart(str, byteidx(str, 3))\n+      \techo strpart(s, 0, byteidx(s, 1))\n+      <Also see |strgetchar()| and |strcharpart()|.\n+\n+      If there are less than {nr} characters -1 is returned.\n+      If there are exactly {nr} characters the length of the string\n+      in bytes is returned.\n+      See |charidx()| and |utf16idx()| for getting the character and\n+      UTF-16 index respectively from the byte index.\n+      Examples: >\n+      \techo byteidx('a', 2)\treturns 5\n+      \techo byteidx('a', 2, 1)\treturns 1\n+      \techo byteidx('a', 3, 1)\treturns 5\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidx(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidx',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidx({expr}, {nr} [, {utf16}])',\n+  },\n+  byteidxcomp = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like byteidx(), except that a composing character is counted\n+      as a separate character.  Example: >\n+      \tlet s = 'e' .. nr2char(0x301)\n+      \techo byteidx(s, 1)\n+      \techo byteidxcomp(s, 1)\n+      \techo byteidxcomp(s, 2)\n+      <The first and third echo result in 3 ('e' plus composing\n+      character is 3 bytes), the second echo results in 1 ('e' is\n+      one byte).\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidxcomp(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidxcomp',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidxcomp({expr}, {nr} [, {utf16}])',\n+  },\n+  call = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Call function {func} with the items in |List| {arglist} as\n+      arguments.\n+      {func} can either be a |Funcref| or the name of a function.\n+      a:firstline and a:lastline are set to the cursor line.\n+      Returns the return value of the called function.\n+      {dict} is for functions with the \"dict\" attribute.  It will be\n+      used to set the local variable \"self\". |Dictionary-function|\n+\n+      Can also be used as a |method|: >\n+      \tGetFunc()->call([arg, arg], dict)\n+      <\n+    ]=],\n+    name = 'call',\n+    params = { { 'func', 'any' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    returns = 'any',\n+    signature = 'call({func}, {arglist} [, {dict}])',\n+    tags = { 'E699' },\n+  },\n+  ceil = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the smallest integral value greater than or equal to\n+      {expr} as a |Float| (round up).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Examples: >\n+      \techo ceil(1.456)\n+      <\t2.0  >\n+      \techo ceil(-5.456)\n+      <\t-5.0  >\n+      \techo ceil(4.0)\n+      <\t4.0\n+\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->ceil()\n+      <\n+    ]=],\n+    float_func = 'ceil',\n+    name = 'ceil',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'ceil({expr})',\n+  },\n+  chanclose = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Close a channel or a specific stream associated with it.\n+      For a job, {stream} can be one of \"stdin\", \"stdout\",\n+      \"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n+      with `\"rpc\":v:true`) If {stream} is omitted, all streams\n+      are closed. If the channel is a pty, this will then close the\n+      pty master, sending SIGHUP to the job process.\n+      For a socket, there is only one stream, and {stream} should be\n+      omitted.\n+    ]=],\n+    name = 'chanclose',\n+    params = { { 'id', 'any' }, { 'stream', 'any' } },\n+    returns = '0|1',\n+    signature = 'chanclose({id} [, {stream}])',\n+  },\n+  changenr = {\n+    desc = [=[\n+      Return the number of the most recent change.  This is the same\n+      number as what is displayed with |:undolist| and can be used\n+      with the |:undo| command.\n+      When a change was made it is the number of that change.  After\n+      redo it is the number of the redone change.  After undo it is\n+      one less than the number of the undone change.\n+      Returns 0 if the undo list is empty.\n+    ]=],\n+    name = 'changenr',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'changenr()',\n+  },\n+  chansend = {\n+    args = 2,\n+    desc = [=[\n+      Send data to channel {id}. For a job, it writes it to the\n+      stdin of the process. For the stdio channel |channel-stdio|,\n+      it writes to Nvim's stdout.  Returns the number of bytes\n+      written if the write succeeded, 0 otherwise.\n+      See |channel-bytes| for more information.\n+\n+      {data} may be a string, string convertible, |Blob|, or a list.\n+      If {data} is a list, the items will be joined by newlines; any\n+      newlines in an item will be sent as NUL. To send a final\n+      newline, include a final empty string. Example: >\n+      \t:call chansend(id, [\"abc\", \"123\\n456\", \"\"])\n+      <will send \"abc<NL>123<NUL>456<NL>\".\n+\n+      chansend() writes raw data, not RPC messages.  If the channel\n+      was created with `\"rpc\":v:true` then the channel expects RPC\n+      messages, use |rpcnotify()| and |rpcrequest()| instead.\n+\n+    ]=],\n+    name = 'chansend',\n+    params = { { 'id', 'any' }, { 'data', 'any' } },\n+    returns = '0|1',\n+    signature = 'chansend({id}, {data})',\n+  },\n+  char2nr = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Return Number value of the first char in {string}.\n+      Examples: >\n+      \tchar2nr(\" \")\t\treturns 32\n+      \tchar2nr(\"ABC\")\t\treturns 65\n+      \tchar2nr(\"\")\t\treturns 225\n+      \tchar2nr(\"\"[0])\t\treturns 195\n+      \tchar2nr(\"\\<M-x>\")\treturns 128\n+      <Non-ASCII characters are always treated as UTF-8 characters.\n+      {utf8} is ignored, it exists only for backwards-compatibility.\n+      A combining character is a separate character.\n+      |nr2char()| does the opposite.\n+\n+      Returns 0 if {string} is not a |String|.\n+\n+      Can also be used as a |method|: >\n+      \tGetChar()->char2nr()\n+\n+    ]=],\n+    fast = true,\n+    name = 'char2nr',\n+    params = { { 'string', 'string' }, { 'utf8', 'any' } },\n+    returns = '0|1',\n+    signature = 'char2nr({string} [, {utf8}])',\n+  },\n+  charclass = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the character class of the first character in {string}.\n+      The character class is one of:\n+      \t0\tblank\n+      \t1\tpunctuation\n+      \t2\tword character\n+      \t3\temoji\n+      \tother\tspecific Unicode class\n+      The class is used in patterns and word motions.\n+      Returns 0 if {string} is not a |String|.\n+    ]=],\n+    name = 'charclass',\n+    params = { { 'string', 'string' } },\n+    returns = \"0|1|2|3|'other'\",\n+    signature = 'charclass({string})',\n+  },\n+  charcol = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Same as |col()| but returns the character index of the column\n+      position given with {expr} instead of the byte position.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tcharcol('.')\t\treturns 3\n+      \tcol('.')\t\treturns 7\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+    ]=],\n+    name = 'charcol',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'charcol({expr} [, {winid}])',\n+  },\n+  charidx = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the character index of the byte at {idx} in {string}.\n+      The index of the first character is zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {idx}.\n+\n+      When {countcc} is omitted or |FALSE|, then composing characters\n+      are not counted separately, their byte length is added to the\n+      preceding base character.\n+      When {countcc} is |TRUE|, then composing characters are\n+      counted as separate characters.\n+\n+      When {utf16} is present and TRUE, {idx} is used as the UTF-16\n+      index in the String {expr} instead of as the byte index.\n+\n+      Returns -1 if the arguments are invalid or if there are less\n+      than {idx} bytes. If there are exactly {idx} bytes the length\n+      of the string in characters is returned.\n+\n+      An error is given and -1 is returned if the first argument is\n+      not a string, the second argument is not a number or when the\n+      third argument is present and is not zero or one.\n+\n+      See |byteidx()| and |byteidxcomp()| for getting the byte index\n+      from the character index and |utf16idx()| for getting the\n+      UTF-16 index from the character index.\n+      Refer to |string-offset-encoding| for more information.\n+      Examples: >\n+      \techo charidx('abc', 3)\t\treturns 1\n+      \techo charidx('abc', 6, 1)\treturns 4\n+      \techo charidx('abc', 16)\t\treturns -1\n+      \techo charidx('a', 4, 0, 1)\treturns 2\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->charidx(idx)\n+\n+    ]=],\n+    name = 'charidx',\n+    params = {\n+      { 'string', 'string' },\n+      { 'idx', 'integer' },\n+      { 'countcc', 'any' },\n+      { 'utf16', 'any' },\n     },\n-    buffer_number={\n-      args={0, 1}, base=1, func='f_bufnr',\n-      deprecated = { 'Obsolete name for |bufnr()|.' }\n+    returns = 'integer',\n+    signature = 'charidx({string}, {idx} [, {countcc} [, {utf16}]])',\n+  },\n+  chdir = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Change the current working directory to {dir}.  The scope of\n+      the directory change depends on the directory of the current\n+      window:\n+      \t- If the current window has a window-local directory\n+      \t  (|:lcd|), then changes the window local directory.\n+      \t- Otherwise, if the current tabpage has a local\n+      \t  directory (|:tcd|) then changes the tabpage local\n+      \t  directory.\n+      \t- Otherwise, changes the global directory.\n+      {dir} must be a String.\n+      If successful, returns the previous working directory.  Pass\n+      this to another chdir() to restore the directory.\n+      On failure, returns an empty string.\n+\n+      Example: >\n+      \tlet save_dir = chdir(newdir)\n+      \tif save_dir != \"\"\n+      \t   \" ... do some work\n+      \t   call chdir(save_dir)\n+      \tendif\n+\n+      <Can also be used as a |method|: >\n+      \tGetDir()->chdir()\n+      <\n+    ]=],\n+    name = 'chdir',\n+    params = { { 'dir', 'string' } },\n+    returns = 'string',\n+    signature = 'chdir({dir})',\n+  },\n+  cindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the C\n+      indenting rules, as with 'cindent'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+      See |C-indenting|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->cindent()\n+    ]=],\n+    name = 'cindent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'cindent({lnum})',\n+  },\n+  clearmatches = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Clears all matches previously defined for the current window\n+      by |matchadd()| and the |:match| commands.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetWin()->clearmatches()\n+      <\n+    ]=],\n+    name = 'clearmatches',\n+    params = { { 'win', 'any' } },\n+    returns = false,\n+    signature = 'clearmatches([{win}])',\n+  },\n+  col = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the byte index of the column\n+      position given with {expr}.  The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the end of the cursor line (the result is the\n+      \t    number of bytes in the cursor line plus one)\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          v       In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Additionally {expr} can be [lnum, col]: a |List| with the line\n+      and column number. Most useful when the column is \"$\", to get\n+      the last column of a specific line.  When \"lnum\" or \"col\" is\n+      out of range then col() returns zero.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      To get the line number use |line()|.  To get both use\n+      |getpos()|.\n+      For the screen column position use |virtcol()|.  For the\n+      character position use |charcol()|.\n+      Note that only marks in the current file can be used.\n+      Examples: >\n+      \tcol(\".\")\t\tcolumn of cursor\n+      \tcol(\"$\")\t\tlength of cursor line plus one\n+      \tcol(\"'t\")\t\tcolumn of mark t\n+      \tcol(\"'\" .. markname)\tcolumn of mark markname\n+      <The first column is 1.  Returns 0 if {expr} is invalid or when\n+      the window with ID {winid} is not found.\n+      For an uppercase mark the column may actually be in another\n+      buffer.\n+      For the cursor position, when 'virtualedit' is active, the\n+      column is one higher if the cursor is after the end of the\n+      line.  Also, when using a <Cmd> mapping the cursor isn't\n+      moved, this can be used to obtain the column in Insert mode: >\n+      \t:imap <F2> <Cmd>echo col(\".\")..\"\\n\"<CR>\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+\n+    ]=],\n+    name = 'col',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'col({expr} [, {winid}])',\n+  },\n+  complete = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Set the matches for Insert mode completion.\n+      Can only be used in Insert mode.  You need to use a mapping\n+      with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n+      or with an expression mapping.\n+      {startcol} is the byte offset in the line where the completed\n+      text start.  The text up to the cursor is the original text\n+      that will be replaced by the matches.  Use col('.') for an\n+      empty string.  \"col('.') - 1\" will replace one character by a\n+      match.\n+      {matches} must be a |List|.  Each |List| item is one match.\n+      See |complete-items| for the kind of items that are possible.\n+      \"longest\" in 'completeopt' is ignored.\n+      Note that the after calling this function you need to avoid\n+      inserting anything that would cause completion to stop.\n+      The match can be selected with CTRL-N and CTRL-P as usual with\n+      Insert mode completion.  The popup menu will appear if\n+      specified, see |ins-completion-menu|.\n+      Example: >\n+      \tinoremap <F5> <C-R>=ListMonths()<CR>\n+\n+      \tfunc ListMonths()\n+      \t  call complete(col('.'), ['January', 'February', 'March',\n+      \t    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n+      \t    \\ 'October', 'November', 'December'])\n+      \t  return ''\n+      \tendfunc\n+      <This isn't very useful, but it shows how it works.  Note that\n+      an empty string is returned to avoid a zero being inserted.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetMatches()->complete(col('.'))\n+\n+    ]=],\n+    name = 'complete',\n+    params = { { 'startcol', 'any' }, { 'matches', 'any' } },\n+    returns = false,\n+    signature = 'complete({startcol}, {matches})',\n+    tags = { 'E785' },\n+  },\n+  complete_add = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add {expr} to the list of matches.  Only to be used by the\n+      function specified with the 'completefunc' option.\n+      Returns 0 for failure (empty string or out of memory),\n+      1 when the match was added, 2 when the match was already in\n+      the list.\n+      See |complete-functions| for an explanation of {expr}.  It is\n+      the same as one item in the list that 'omnifunc' would return.\n+\n+      Can also be used as a |method|: >\n+      \tGetMoreMatches()->complete_add()\n+\n+    ]=],\n+    name = 'complete_add',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1|2',\n+    signature = 'complete_add({expr})',\n+  },\n+  complete_check = {\n+    desc = [=[\n+      Check for a key typed while looking for completion matches.\n+      This is to be used when looking for matches takes some time.\n+      Returns |TRUE| when searching for matches is to be aborted,\n+      zero otherwise.\n+      Only to be used by the function specified with the\n+      'completefunc' option.\n+    ]=],\n+    name = 'complete_check',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'complete_check()',\n+  },\n+  complete_info = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns a |Dictionary| with information about Insert mode\n+      completion.  See |ins-completion|.\n+      The items are:\n+         mode\t\tCurrent completion mode name string.\n+      \t\tSee |complete_info_mode| for the values.\n+         pum_visible\t|TRUE| if popup menu is visible.\n+      \t\tSee |pumvisible()|.\n+         items\tList of completion matches.  Each item is a\n+      \t\tdictionary containing the entries \"word\",\n+      \t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n+      \t\tSee |complete-items|.\n+         selected\tSelected item index.  First index is zero.\n+      \t\tIndex is -1 if no item is selected (showing\n+      \t\ttyped text only, or the last completion after\n+      \t\tno item is selected when using the <Up> or\n+      \t\t<Down> keys)\n+         inserted\tInserted string. [NOT IMPLEMENTED YET]\n+\n+      \t\t\t\t\t*complete_info_mode*\n+      mode values are:\n+         \"\"\t\t     Not in completion mode\n+         \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n+         \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n+         \"scroll\"\t     Scrolling with |i_CTRL-X_CTRL-E| or\n+      \t\t     |i_CTRL-X_CTRL-Y|\n+         \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n+         \"files\"\t     File names |i_CTRL-X_CTRL-F|\n+         \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n+         \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n+         \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n+         \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n+         \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n+         \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n+         \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n+         \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n+         \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n+         \"eval\"\t     |complete()| completion\n+         \"unknown\"\t     Other internal modes\n+\n+      If the optional {what} list argument is supplied, then only\n+      the items listed in {what} are returned.  Unsupported items in\n+      {what} are silently ignored.\n+\n+      To get the position and size of the popup menu, see\n+      |pum_getpos()|. It's also available in |v:event| during the\n+      |CompleteChanged| event.\n+\n+      Returns an empty |Dictionary| on error.\n+\n+      Examples: >\n+      \t\" Get all items\n+      \tcall complete_info()\n+      \t\" Get only 'mode'\n+      \tcall complete_info(['mode'])\n+      \t\" Get only 'mode' and 'pum_visible'\n+      \tcall complete_info(['mode', 'pum_visible'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetItems()->complete_info()\n+      <\n+    ]=],\n+    name = 'complete_info',\n+    params = { { 'what', 'any' } },\n+    returns = 'table',\n+    signature = 'complete_info([{what}])',\n+  },\n+  confirm = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      confirm() offers the user a dialog, from which a choice can be\n+      made.  It returns the number of the choice.  For the first\n+      choice this is 1.\n+\n+      {msg} is displayed in a dialog with {choices} as the\n+      alternatives.  When {choices} is missing or empty, \"&OK\" is\n+      used (and translated).\n+      {msg} is a String, use '\\n' to include a newline.  Only on\n+      some systems the string is wrapped when it doesn't fit.\n+\n+      {choices} is a String, with the individual choices separated\n+      by '\\n', e.g. >\n+      \tconfirm(\"Save changes?\", \"&Yes\\n&No\\n&Cancel\")\n+      <The letter after the '&' is the shortcut key for that choice.\n+      Thus you can type 'c' to select \"Cancel\".  The shortcut does\n+      not need to be the first letter: >\n+      \tconfirm(\"file has been modified\", \"&Save\\nSave &All\")\n+      <For the console, the first letter of each choice is used as\n+      the default shortcut key.  Case is ignored.\n+\n+      The optional {type} String argument gives the type of dialog.\n+      It can be one of these values: \"Error\", \"Question\", \"Info\",\n+      \"Warning\" or \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      The optional {type} argument gives the type of dialog.  This\n+      is only used for the icon of the Win32 GUI.  It can be one of\n+      these values: \"Error\", \"Question\", \"Info\", \"Warning\" or\n+      \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      If the user aborts the dialog by pressing <Esc>, CTRL-C,\n+      or another valid interrupt key, confirm() returns 0.\n+\n+      An example: >\n+         let choice = confirm(\"What do you want?\",\n+      \t\t\t\\ \"&Apples\\n&Oranges\\n&Bananas\", 2)\n+         if choice == 0\n+      \techo \"make up your mind!\"\n+         elseif choice == 3\n+      \techo \"tasteful\"\n+         else\n+      \techo \"I prefer bananas myself.\"\n+         endif\n+      <In a GUI dialog, buttons are used.  The layout of the buttons\n+      depends on the 'v' flag in 'guioptions'.  If it is included,\n+      the buttons are always put vertically.  Otherwise,  confirm()\n+      tries to put the buttons in one horizontal line.  If they\n+      don't fit, a vertical layout is used anyway.  For some systems\n+      the horizontal layout is always used.\n+\n+      Can also be used as a |method|in: >\n+      \tBuildMessage()->confirm(\"&Yes\\n&No\")\n+      <\n+    ]=],\n+    name = 'confirm',\n+    params = { { 'msg', 'any' }, { 'choices', 'any' }, { 'default', 'any' }, { 'type', 'any' } },\n+    returns = 'integer',\n+    signature = 'confirm({msg} [, {choices} [, {default} [, {type}]]])',\n+  },\n+  copy = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a shallow copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  But the items are identical, thus\n+      changing an item changes the contents of both |Lists|.\n+      A |Dictionary| is copied in a similar way as a |List|.\n+      Also see |deepcopy()|.\n+      Can also be used as a |method|: >\n+      \tmylist->copy()\n+    ]=],\n+    name = 'copy',\n+    params = { { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'copy({expr})',\n+  },\n+  cos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the cosine of {expr}, measured in radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cos(100)\n+      <\t0.862319 >\n+      \t:echo cos(-4.01)\n+      <\t-0.646043\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cos()\n+    ]=],\n+    float_func = 'cos',\n+    name = 'cos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cos({expr})',\n+  },\n+  cosh = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the hyperbolic cosine of {expr} as a |Float| in the range\n+      [1, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cosh(0.5)\n+      <\t1.127626 >\n+      \t:echo cosh(-0.5)\n+      <\t-1.127626\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cosh()\n+\n+    ]=],\n+    float_func = 'cosh',\n+    name = 'cosh',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cosh({expr})',\n+  },\n+  count = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the number of times an item with value {expr} appears\n+      in |String|, |List| or |Dictionary| {comp}.\n+\n+      If {start} is given then start with the item with this index.\n+      {start} can only be used with a |List|.\n+\n+      When {ic} is given and it's |TRUE| then case is ignored.\n+\n+      When {comp} is a string then the number of not overlapping\n+      occurrences of {expr} is returned. Zero is returned when\n+      {expr} is an empty string.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->count(val)\n+      <\n+    ]=],\n+    name = 'count',\n+    params = { { 'comp', 'any' }, { 'expr', 'any' }, { 'ic', 'any' }, { 'start', 'any' } },\n+    returns = 'integer',\n+    signature = 'count({comp}, {expr} [, {ic} [, {start}]])',\n+  },\n+  ctxget = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |Dictionary| representing the |context| at {index}\n+      from the top of the |context-stack| (see |context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+    ]=],\n+    name = 'ctxget',\n+    params = { { 'index', 'any' } },\n+    returns = 'table',\n+    signature = 'ctxget([{index}])',\n+  },\n+  ctxpop = {\n+    desc = [=[\n+      Pops and restores the |context| at the top of the\n+      |context-stack|.\n+    ]=],\n+    name = 'ctxpop',\n+    params = {},\n+    signature = 'ctxpop()',\n+  },\n+  ctxpush = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Pushes the current editor state (|context|) on the\n+      |context-stack|.\n+      If {types} is given and is a |List| of |String|s, it specifies\n+      which |context-types| to include in the pushed context.\n+      Otherwise, all context types are included.\n+\n+    ]=],\n+    name = 'ctxpush',\n+    params = { { 'types', 'any' } },\n+    signature = 'ctxpush([{types}])',\n+  },\n+  ctxset = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Sets the |context| at {index} from the top of the\n+      |context-stack| to that represented by {context}.\n+      {context} is a Dictionary with context data (|context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+\n+    ]=],\n+    name = 'ctxset',\n+    params = { { 'context', 'any' }, { 'index', 'any' } },\n+    signature = 'ctxset({context} [, {index}])',\n+  },\n+  ctxsize = {\n+    desc = [=[\n+      Returns the size of the |context-stack|.\n+\n+    ]=],\n+    name = 'ctxsize',\n+    params = {},\n+    signature = 'ctxsize()',\n+  },\n+  cursor = {\n+    args = { 1, 3 },\n+    base = 1,\n+    name = 'cursor',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' }, { 'off', 'any' } },\n+    signature = 'cursor({lnum}, {col} [, {off}])',\n+  },\n+  cursor__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Positions the cursor at the column (byte count) {col} in the\n+      line {lnum}.  The first column is one.\n+\n+      When there is one argument {list} this is used as a |List|\n+      with two, three or four item:\n+      \t[{lnum}, {col}]\n+      \t[{lnum}, {col}, {off}]\n+      \t[{lnum}, {col}, {off}, {curswant}]\n+      This is like the return value of |getpos()| or |getcurpos()|,\n+      but without the first item.\n+\n+      To position the cursor using {col} as the character count, use\n+      |setcursorcharpos()|.\n+\n+      Does not change the jumplist.\n+      {lnum} is used like with |getline()|, except that if {lnum} is\n+      zero, the cursor will stay in the current line.\n+      If {lnum} is greater than the number of lines in the buffer,\n+      the cursor will be positioned at the last line in the buffer.\n+      If {col} is greater than the number of bytes in the line,\n+      the cursor will be positioned at the last character in the\n+      line.\n+      If {col} is zero, the cursor will stay in the current column.\n+      If {curswant} is given it is used to set the preferred column\n+      for vertical movement.  Otherwise {col} is used.\n+\n+      When 'virtualedit' is used {off} specifies the offset in\n+      screen columns from the start of the character.  E.g., a\n+      position within a <Tab> or after the last character.\n+      Returns 0 when the position could be set, -1 otherwise.\n+\n+      Can also be used as a |method|: >\n+      \tGetCursorPos()->cursor()\n+\n+    ]=],\n+    name = 'cursor',\n+    params = { { 'list', 'any' } },\n+    signature = 'cursor({list})',\n+  },\n+  debugbreak = {\n+    args = { 1, 1 },\n+    base = 1,\n+    desc = [=[\n+      Specifically used to interrupt a program being debugged.  It\n+      will cause process {pid} to get a SIGTRAP.  Behavior for other\n+      processes is undefined. See |terminal-debug|.\n+      (Sends a SIGINT to a process {pid} other than MS-Windows)\n+\n+      Returns |TRUE| if successfully interrupted the program.\n+      Otherwise returns |FALSE|.\n+\n+      Can also be used as a |method|: >\n+      \tGetPid()->debugbreak()\n+\n+    ]=],\n+    name = 'debugbreak',\n+    params = { { 'pid', 'any' } },\n+    signature = 'debugbreak({pid})',\n+  },\n+  deepcopy = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a full copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  When an item is a |List|, a copy for it\n+      is made, recursively.  Thus changing an item in the copy does\n+      not change the contents of the original |List|.\n+\n+      When {noref} is omitted or zero a contained |List| or\n+      |Dictionary| is only copied once.  All references point to\n+      this single copy.  With {noref} set to 1 every occurrence of a\n+      |List| or |Dictionary| results in a new copy.  This also means\n+      that a cyclic reference causes deepcopy() to fail.\n+      \t\t\t\t\t\t*E724*\n+      Nesting is possible up to 100 levels.  When there is an item\n+      that refers back to a higher level making a deep copy with\n+      {noref} set to 1 will fail.\n+      Also see |copy()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->deepcopy()\n+\n+    ]=],\n+    name = 'deepcopy',\n+    params = { { 'expr', 'any' }, { 'noref', 'any' } },\n+    signature = 'deepcopy({expr} [, {noref}])',\n+  },\n+  delete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {flags} or with {flags} empty: Deletes the file by the\n+      name {fname}.\n+\n+      This also works when {fname} is a symbolic link.  The symbolic\n+      link itself is deleted, not what it points to.\n+\n+      When {flags} is \"d\": Deletes the directory by the name\n+      {fname}.  This fails when directory {fname} is not empty.\n+\n+      When {flags} is \"rf\": Deletes the directory by the name\n+      {fname} and everything in it, recursively.  BE CAREFUL!\n+      Note: on MS-Windows it is not possible to delete a directory\n+      that is being used.\n+\n+      The result is a Number, which is 0/false if the delete\n+      operation was successful and -1/true when the deletion failed\n+      or partly failed.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->delete()\n+\n+    ]=],\n+    name = 'delete',\n+    params = { { 'fname', 'integer' }, { 'flags', 'string' } },\n+    returns = 'integer',\n+    signature = 'delete({fname} [, {flags}])',\n+  },\n+  deletebufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Delete lines {first} to {last} (inclusive) from buffer {buf}.\n+      If {last} is omitted then delete line {first} only.\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      {first} and {last} are used like with |getline()|. Note that\n+      when using |line()| this refers to the current buffer. Use \"$\"\n+      to refer to the last line in buffer {buf}.\n+\n+      Can also be used as a |method|: >\n+      \tGetBuffer()->deletebufline(1)\n+      <\n+    ]=],\n+    name = 'deletebufline',\n+    params = { { 'buf', 'any' }, { 'first', 'any' }, { 'last', 'any' } },\n+    signature = 'deletebufline({buf}, {first} [, {last}])',\n+  },\n+  dictwatcheradd = {\n+    args = 3,\n+    desc = [=[\n+      Adds a watcher to a dictionary. A dictionary watcher is\n+      identified by three components:\n+\n+      - A dictionary({dict});\n+      - A key pattern({pattern}).\n+      - A function({callback}).\n+\n+      After this is called, every change on {dict} and on keys\n+      matching {pattern} will result in {callback} being invoked.\n+\n+      For example, to watch all global variables: >\n+      \tsilent! call dictwatcherdel(g:, '*', 'OnDictChanged')\n+      \tfunction! OnDictChanged(d,k,z)\n+      \t  echomsg string(a:k) string(a:z)\n+      \tendfunction\n+      \tcall dictwatcheradd(g:, '*', 'OnDictChanged')\n+      <\n+      For now {pattern} only accepts very simple patterns that can\n+      contain a \"*\" at the end of the string, in which case it will\n+      match every key that begins with the substring before the \"*\".\n+      That means if \"*\" is not the last character of {pattern}, only\n+      keys that are exactly equal as {pattern} will be matched.\n+\n+      The {callback} receives three arguments:\n+\n+      - The dictionary being watched.\n+      - The key which changed.\n+      - A dictionary containing the new and old values for the key.\n+\n+      The type of change can be determined by examining the keys\n+      present on the third argument:\n+\n+      - If contains both `old` and `new`, the key was updated.\n+      - If it contains only `new`, the key was added.\n+      - If it contains only `old`, the key was deleted.\n+\n+      This function can be used by plugins to implement options with\n+      validation and parsing logic.\n+\n+    ]=],\n+    name = 'dictwatcheradd',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcheradd({dict}, {pattern}, {callback})',\n+  },\n+  dictwatcherdel = {\n+    args = 3,\n+    desc = [=[\n+      Removes a watcher added  with |dictwatcheradd()|. All three\n+      arguments must match the ones passed to |dictwatcheradd()| in\n+      order for the watcher to be successfully deleted.\n+    ]=],\n+    name = 'dictwatcherdel',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcherdel({dict}, {pattern}, {callback})',\n+  },\n+  did_filetype = {\n+    desc = [=[\n+      Returns |TRUE| when autocommands are being executed and the\n+      FileType event has been triggered at least once.  Can be used\n+      to avoid triggering the FileType event again in the scripts\n+      that detect the file type. |FileType|\n+      Returns |FALSE| when `:setf FALLBACK` was used.\n+      When editing another file, the counter is reset, thus this\n+      really checks if the FileType event has been triggered for the\n+      current buffer.  This allows an autocommand that starts\n+      editing another buffer to set 'filetype' and load a syntax\n+      file.\n+\n+    ]=],\n+    fast = true,\n+    name = 'did_filetype',\n+    params = {},\n+    signature = 'did_filetype()',\n+  },\n+  diff_filler = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the number of filler lines above line {lnum}.\n+      These are the lines that were inserted at this point in\n+      another diff'ed window.  These filler lines are shown in the\n+      display but don't exist in the buffer.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Returns 0 if the current window is not in diff mode.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_filler()\n+\n+    ]=],\n+    name = 'diff_filler',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'diff_filler({lnum})',\n+  },\n+  diff_hlID = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Returns the highlight ID for diff mode at line {lnum} column\n+      {col} (byte index).  When the current line does not have a\n+      diff change zero is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      {col} is 1 for the leftmost column, {lnum} is 1 for the first\n+      line.\n+      The highlight ID can be used with |synIDattr()| to obtain\n+      syntax information about the highlighting.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_hlID(col)\n+      <\n+\n+    ]=],\n+    name = 'diff_hlID',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' } },\n+    signature = 'diff_hlID({lnum}, {col})',\n+  },\n+  digraph_get = {\n+    args = 1,\n+    base = 1,\n+    tags = { 'E1214' },\n+    desc = [=[\n+      Return the digraph of {chars}.  This should be a string with\n+      exactly two characters.  If {chars} are not just two\n+      characters, or the digraph of {chars} does not exist, an error\n+      is given and an empty string is returned.\n+\n+      Also see |digraph_getlist()|.\n+\n+      Examples: >\n+      \" Get a built-in digraph\n+      :echo digraph_get('00')\t\t\" Returns ''\n+\n+      \" Get a user-defined digraph\n+      :call digraph_set('aa', '')\n+      :echo digraph_get('aa')\t\t\" Returns ''\n+      <\n+      Can also be used as a |method|: >\n+      \tGetChars()->digraph_get()\n+      <\n+\n+    ]=],\n+    name = 'digraph_get',\n+    params = { { 'chars', 'any' } },\n+    signature = 'digraph_get({chars})',\n+  },\n+  digraph_getlist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of digraphs.  If the {listall} argument is given\n+      and it is TRUE, return all digraphs, including the default\n+      digraphs.  Otherwise, return only user-defined digraphs.\n+\n+      Also see |digraph_get()|.\n+\n+      Examples: >\n+      \" Get user-defined digraphs\n+      :echo digraph_getlist()\n+\n+      \" Get all the digraphs, including default digraphs\n+      :echo digraph_getlist(1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetNumber()->digraph_getlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_getlist',\n+    params = { { 'listall', 'any' } },\n+    signature = 'digraph_getlist([{listall}])',\n+  },\n+  digraph_set = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Add digraph {chars} to the list.  {chars} must be a string\n+      with two characters.  {digraph} is a string with one UTF-8\n+      encoded character.  *E1215*\n+      Be careful, composing characters are NOT ignored.  This\n+      function is similar to |:digraphs| command, but useful to add\n+      digraphs start with a white space.\n+\n+      The function result is v:true if |digraph| is registered.  If\n+      this fails an error message is given and v:false is returned.\n+\n+      If you want to define multiple digraphs at once, you can use\n+      |digraph_setlist()|.\n+\n+      Example: >\n+      \tcall digraph_set('  ', '')\n+      <\n+      Can be used as a |method|: >\n+      \tGetString()->digraph_set('')\n+      <\n+\n+    ]=],\n+    name = 'digraph_set',\n+    params = { { 'chars', 'any' }, { 'digraph', 'any' } },\n+    signature = 'digraph_set({chars}, {digraph})',\n+  },\n+  digraph_setlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Similar to |digraph_set()| but this function can add multiple\n+      digraphs at once.  {digraphlist} is a list composed of lists,\n+      where each list contains two strings with {chars} and\n+      {digraph} as in |digraph_set()|. *E1216*\n+      Example: >\n+          call digraph_setlist([['aa', ''], ['ii', '']])\n+      <\n+      It is similar to the following: >\n+          for [chars, digraph] in [['aa', ''], ['ii', '']]\n+      \t  call digraph_set(chars, digraph)\n+          endfor\n+      <Except that the function returns after the first error,\n+      following digraphs will not be added.\n+\n+      Can be used as a |method|: >\n+          GetList()->digraph_setlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_setlist',\n+    params = { { 'digraphlist', 'any' } },\n+    signature = 'digraph_setlist({digraphlist})',\n+  },\n+  empty = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the Number 1 if {expr} is empty, zero otherwise.\n+      - A |List| or |Dictionary| is empty when it does not have any\n+        items.\n+      - A |String| is empty when its length is zero.\n+      - A |Number| and |Float| are empty when their value is zero.\n+      - |v:false| and |v:null| are empty, |v:true| is not.\n+      - A |Blob| is empty when its length is zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->empty()\n+\n+    ]=],\n+    name = 'empty',\n+    params = { { 'expr', 'any' } },\n+    signature = 'empty({expr})',\n+  },\n+  environ = {\n+    desc = [=[\n+      Return all of environment variables as dictionary. You can\n+      check if an environment variable exists like this: >\n+      \t:echo has_key(environ(), 'HOME')\n+      <Note that the variable name may be CamelCase; to ignore case\n+      use this: >\n+      \t:echo index(keys(environ()), 'HOME', 0, 1) != -1\n+\n+    ]=],\n+    fast = true,\n+    name = 'environ',\n+    params = {},\n+    signature = 'environ()',\n+  },\n+  escape = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Escape the characters in {chars} that occur in {string} with a\n+      backslash.  Example: >\n+      \t:echo escape('c:\\program files\\vim', ' \\')\n+      <results in: >\n+      \tc:\\\\program\\ files\\\\vim\n+      <Also see |shellescape()| and |fnameescape()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->escape(' \\')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'escape',\n+    params = { { 'string', 'string' }, { 'chars', 'any' } },\n+    signature = 'escape({string}, {chars})',\n+  },\n+  eval = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Evaluate {string} and return the result.  Especially useful to\n+      turn the result of |string()| back into the original value.\n+      This works for Numbers, Floats, Strings, Blobs and composites\n+      of them.  Also works for |Funcref|s that refer to existing\n+      functions.\n+\n+      Can also be used as a |method|: >\n+      \targv->join()->eval()\n+\n+    ]=],\n+    name = 'eval',\n+    params = { { 'string', 'string' } },\n+    signature = 'eval({string})',\n+  },\n+  eventhandler = {\n+    desc = [=[\n+      Returns 1 when inside an event handler.  That is that Vim got\n+      interrupted while waiting for the user to type a character,\n+      e.g., when dropping a file on Vim.  This means interactive\n+      commands cannot be used.  Otherwise zero is returned.\n+\n+    ]=],\n+    name = 'eventhandler',\n+    params = {},\n+    signature = 'eventhandler()',\n+  },\n+  executable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      This function checks if an executable with the name {expr}\n+      exists.  {expr} must be the name of the program without any\n+      arguments.\n+      executable() uses the value of $PATH and/or the normal\n+      searchpath for programs.\t\t*PATHEXT*\n+      On MS-Windows the \".exe\", \".bat\", etc. can optionally be\n+      included.  Then the extensions in $PATHEXT are tried.  Thus if\n+      \"foo.exe\" does not exist, \"foo.exe.bat\" can be found.  If\n+      $PATHEXT is not set then \".exe;.com;.bat;.cmd\" is used.  A dot\n+      by itself can be used in $PATHEXT to try using the name\n+      without an extension.  When 'shell' looks like a Unix shell,\n+      then the name is also tried without adding an extension.\n+      On MS-Windows it only checks if the file exists and is not a\n+      directory, not if it's really executable.\n+      On Windows an executable in the same directory as Vim is\n+      always found (it is added to $PATH at |startup|).\n+      The result is a Number:\n+      \t1\texists\n+      \t0\tdoes not exist\n+      \t-1\tnot implemented on this system\n+      |exepath()| can be used to get the full path of an executable.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->executable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'executable',\n+    params = { { 'expr', 'any' } },\n+    signature = 'executable({expr})',\n+  },\n+  execute = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Execute {command} and capture its output.\n+      If {command} is a |String|, returns {command} output.\n+      If {command} is a |List|, returns concatenated outputs.\n+      Line continuations in {command} are not recognized.\n+      Examples: >\n+      \techo execute('echon \"foo\"')\n+      <\tfoo >\n+      \techo execute(['echon \"foo\"', 'echon \"bar\"'])\n+      <\tfoobar\n+\n+      The optional {silent} argument can have these values:\n+      \t\"\"\t\tno `:silent` used\n+      \t\"silent\"\t`:silent` used\n+      \t\"silent!\"\t`:silent!` used\n+      The default is \"silent\".  Note that with \"silent!\", unlike\n+      `:redir`, error messages are dropped.\n+\n+      To get a list of lines use `split()` on the result: >\n+      \texecute('args')->split(\"\\n\")\n+\n+      <This function is not available in the |sandbox|.\n+      Note: If nested, an outer execute() will not observe output of\n+      the inner calls.\n+      Note: Text attributes (highlights) are not captured.\n+      To execute a command in another window than the current one\n+      use `win_execute()`.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->execute()\n+\n+    ]=],\n+    name = 'execute',\n+    params = { { 'command', 'any' }, { 'silent', 'boolean' } },\n+    signature = 'execute({command} [, {silent}])',\n+  },\n+  exepath = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the full path of {expr} if it is an executable and\n+      given as a (partial or full) path or is found in $PATH.\n+      Returns empty string otherwise.\n+      If {expr} starts with \"./\" the |current-directory| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->exepath()\n+      <\n+    ]=],\n+    name = 'exepath',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exepath({expr})',\n+  },\n+  exists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if {expr} is\n+      defined, zero otherwise.\n+\n+      For checking for a supported feature use |has()|.\n+      For checking if a file exists use |filereadable()|.\n+\n+      The {expr} argument is a string, which contains one of these:\n+      \tvarname\t\tinternal variable (see\n+      \tdict.key\t|internal-variables|).  Also works\n+      \tlist[i]\t\tfor |curly-braces-names|, |Dictionary|\n+      \t\t\tentries, |List| items, etc.\n+      \t\t\tBeware that evaluating an index may\n+      \t\t\tcause an error message for an invalid\n+      \t\t\texpression.  E.g.: >\n+      \t\t\t   :let l = [1, 2, 3]\n+      \t\t\t   :echo exists(\"l[5]\")\n+      <\t\t\t   0 >\n+      \t\t\t   :echo exists(\"l[xx]\")\n+      <\t\t\t   E121: Undefined variable: xx\n+      \t\t\t   0\n+      \t&option-name\tVim option (only checks if it exists,\n+      \t\t\tnot if it really works)\n+      \t+option-name\tVim option that works.\n+      \t$ENVNAME\tenvironment variable (could also be\n+      \t\t\tdone by comparing with an empty\n+      \t\t\tstring)\n+      \t`*funcname`\tbuilt-in function (see |functions|)\n+      \t\t\tor user defined function (see\n+      \t\t\t|user-function|). Also works for a\n+      \t\t\tvariable that is a Funcref.\n+      \t:cmdname\tEx command: built-in command, user\n+      \t\t\tcommand or command modifier |:command|.\n+      \t\t\tReturns:\n+      \t\t\t1  for match with start of a command\n+      \t\t\t2  full match with a command\n+      \t\t\t3  matches several user commands\n+      \t\t\tTo check for a supported command\n+      \t\t\talways check the return value to be 2.\n+      \t:2match\t\tThe |:2match| command.\n+      \t:3match\t\tThe |:3match| command (but you\n+      \t\t\tprobably should not use it, it is\n+      \t\t\treserved for internal usage)\n+      \t#event\t\tautocommand defined for this event\n+      \t#event#pattern\tautocommand defined for this event and\n+      \t\t\tpattern (the pattern is taken\n+      \t\t\tliterally and compared to the\n+      \t\t\tautocommand patterns character by\n+      \t\t\tcharacter)\n+      \t#group\t\tautocommand group exists\n+      \t#group#event\tautocommand defined for this group and\n+      \t\t\tevent.\n+      \t#group#event#pattern\n+      \t\t\tautocommand defined for this group,\n+      \t\t\tevent and pattern.\n+      \t##event\t\tautocommand for this event is\n+      \t\t\tsupported.\n+\n+      Examples: >\n+      \texists(\"&mouse\")\n+      \texists(\"$HOSTNAME\")\n+      \texists(\"*strftime\")\n+      \texists(\"*s:MyFunc\")\n+      \texists(\"*MyFunc\")\n+      \texists(\"bufcount\")\n+      \texists(\":Make\")\n+      \texists(\"#CursorHold\")\n+      \texists(\"#BufReadPre#*.gz\")\n+      \texists(\"#filetypeindent\")\n+      \texists(\"#filetypeindent#FileType\")\n+      \texists(\"#filetypeindent#FileType#*\")\n+      \texists(\"##ColorScheme\")\n+      <There must be no space between the symbol (&/$/*/#) and the\n+      name.\n+      There must be no extra characters after the name, although in\n+      a few cases this is ignored.  That may become stricter in the\n+      future, thus don't count on it!\n+      Working example: >\n+      \texists(\":make\")\n+      <NOT working example: >\n+      \texists(\":make install\")\n+\n+      <Note that the argument must be a string, not the name of the\n+      variable itself.  For example: >\n+      \texists(bufcount)\n+      <This doesn't check for existence of the \"bufcount\" variable,\n+      but gets the value of \"bufcount\", and checks if that exists.\n+\n+      Can also be used as a |method|: >\n+      \tVarname()->exists()\n+\n+    ]=],\n+    name = 'exists',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'exists({expr})',\n+  },\n+  exp = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the exponential of {expr} as a |Float| in the range\n+      [0, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo exp(2)\n+      <\t7.389056 >\n+      \t:echo exp(-1)\n+      <\t0.367879\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->exp()\n+\n+    ]=],\n+    float_func = 'exp',\n+    name = 'exp',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exp({expr})',\n+  },\n+  expand = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Expand wildcards and the following special keywords in\n+      {string}.  'wildignorecase' applies.\n+\n+      If {list} is given and it is |TRUE|, a List will be returned.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty string.  A name\n+      for a non-existing file is not included, unless {string} does\n+      not start with '%', '#' or '<', see below.\n+\n+      When {string} starts with '%', '#' or '<', the expansion is\n+      done like for the |cmdline-special| variables with their\n+      associated modifiers.  Here is a short overview:\n+\n+      \t%\t\tcurrent file name\n+      \t#\t\talternate file name\n+      \t#n\t\talternate file name n\n+      \t<cfile>\t\tfile name under the cursor\n+      \t<afile>\t\tautocmd file name\n+      \t<abuf>\t\tautocmd buffer number (as a String!)\n+      \t<amatch>\tautocmd matched name\n+      \t<cexpr>\t\tC expression under the cursor\n+      \t<sfile>\t\tsourced script file or function name\n+      \t<slnum>\t\tsourced script line number or function\n+      \t\t\tline number\n+      \t<sflnum>\tscript file line number, also when in\n+      \t\t\ta function\n+      \t<SID>\t\t\"<SNR>123_\"  where \"123\" is the\n+      \t\t\tcurrent script ID  |<SID>|\n+      \t<script>\tsourced script file, or script file\n+      \t\t\twhere the current function was defined\n+      \t<stack>\t\tcall stack\n+      \t<cword>\t\tword under the cursor\n+      \t<cWORD>\t\tWORD under the cursor\n+      \t<client>\tthe {clientid} of the last received\n+      \t\t\tmessage\n+      Modifiers:\n+      \t:p\t\texpand to full path\n+      \t:h\t\thead (last path component removed)\n+      \t:t\t\ttail (last path component only)\n+      \t:r\t\troot (one extension removed)\n+      \t:e\t\textension only\n+\n+      Example: >\n+      \t:let &tags = expand(\"%:p:h\") .. \"/tags\"\n+      <Note that when expanding a string that starts with '%', '#' or\n+      '<', any following text is ignored.  This does NOT work: >\n+      \t:let doesntwork = expand(\"%:h.bak\")\n+      <Use this: >\n+      \t:let doeswork = expand(\"%:h\") .. \".bak\"\n+      <Also note that expanding \"<cfile>\" and others only returns the\n+      referenced file name without further expansion.  If \"<cfile>\"\n+      is \"~/.cshrc\", you need to do another expand() to have the\n+      \"~/\" expanded into the path of the home directory: >\n+      \t:echo expand(expand(\"<cfile>\"))\n+      <\n+      There cannot be white space between the variables and the\n+      following modifier.  The |fnamemodify()| function can be used\n+      to modify normal file names.\n+\n+      When using '%' or '#', and the current or alternate file name\n+      is not defined, an empty string is used.  Using \"%:p\" in a\n+      buffer with no name, results in the current directory, with a\n+      '/' added.\n+      When 'verbose' is set then expanding '%', '#' and <> items\n+      will result in an error message if the argument cannot be\n+      expanded.\n+\n+      When {string} does not start with '%', '#' or '<', it is\n+      expanded like a file name is expanded on the command line.\n+      'suffixes' and 'wildignore' are used, unless the optional\n+      {nosuf} argument is given and it is |TRUE|.\n+      Names for non-existing files are included.  The \"**\" item can\n+      be used to search in a directory tree.  For example, to find\n+      all \"README\" files in the current directory and below: >\n+      \t:echo expand(\"**/README\")\n+      <\n+      expand() can also be used to expand variables and environment\n+      variables that are only known in a shell.  But this can be\n+      slow, because a shell may be used to do the expansion.  See\n+      |expr-env-expand|.\n+      The expanded variable is still handled like a list of file\n+      names.  When an environment variable cannot be expanded, it is\n+      left unchanged.  Thus \":echo expand('$FOOBAR')\" results in\n+      \"$FOOBAR\".\n+\n+      See |glob()| for finding existing files.  See |system()| for\n+      getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetpattern()->expand()\n+\n+    ]=],\n+    name = 'expand',\n+    params = { { 'string', 'string' }, { 'nosuf', 'boolean' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'expand({string} [, {nosuf} [, {list}]])',\n+  },\n+  expandcmd = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Expand special items in String {string} like what is done for\n+      an Ex command such as `:edit`.  This expands special keywords,\n+      like with |expand()|, and environment variables, anywhere in\n+      {string}.  \"~user\" and \"~/path\" are only expanded at the\n+      start.\n+\n+      The following items are supported in the {options} Dict\n+      argument:\n+          errmsg\tIf set to TRUE, error messages are displayed\n+      \t\tif an error is encountered during expansion.\n+      \t\tBy default, error messages are not displayed.\n+\n+      Returns the expanded string.  If an error is encountered\n+      during expansion, the unmodified {string} is returned.\n+\n+      Example: >\n+      \t:echo expandcmd('make %<.o')\n+      \tmake /path/runtime/doc/builtin.o\n+      \t:echo expandcmd('make %<.o', {'errmsg': v:true})\n+      <\n+      Can also be used as a |method|: >\n+      \tGetCommand()->expandcmd()\n+      <\n+    ]=],\n+    name = 'expandcmd',\n+    params = { { 'string', 'string' }, { 'options', 'table' } },\n+    signature = 'expandcmd({string} [, {options}])',\n+  },\n+  extend = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      {expr1} and {expr2} must be both |Lists| or both\n+      |Dictionaries|.\n+\n+      If they are |Lists|: Append {expr2} to {expr1}.\n+      If {expr3} is given insert the items of {expr2} before the\n+      item with index {expr3} in {expr1}.  When {expr3} is zero\n+      insert before the first item.  When {expr3} is equal to\n+      len({expr1}) then {expr2} is appended.\n+      Examples: >\n+      \t:echo sort(extend(mylist, [7, 5]))\n+      \t:call extend(mylist, [2, 3], 1)\n+      <When {expr1} is the same List as {expr2} then the number of\n+      items copied is equal to the original length of the List.\n+      E.g., when {expr3} is 1 you get N new copies of the first item\n+      (where N is the original length of the List).\n+      Use |add()| to concatenate one item to a list.  To concatenate\n+      two lists into a new list use the + operator: >\n+      \t:let newlist = [1, 2, 3] + [4, 5]\n+      <\n+      If they are |Dictionaries|:\n+      Add all entries from {expr2} to {expr1}.\n+      If a key exists in both {expr1} and {expr2} then {expr3} is\n+      used to decide what to do:\n+      {expr3} = \"keep\": keep the value of {expr1}\n+      {expr3} = \"force\": use the value of {expr2}\n+      {expr3} = \"error\": give an error message\t\t*E737*\n+      When {expr3} is omitted then \"force\" is assumed.\n+\n+      {expr1} is changed when {expr2} is not empty.  If necessary\n+      make a copy of {expr1} first.\n+      {expr2} remains unchanged.\n+      When {expr1} is locked and {expr2} is not empty the operation\n+      fails.\n+      Returns {expr1}.  Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->extend(otherlist)\n+      <\n+    ]=],\n+    name = 'extend',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extend({expr1}, {expr2} [, {expr3}])',\n+  },\n+  extendnew = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |extend()| but instead of adding items to {expr1} a new\n+      List or Dictionary is created and returned.  {expr1} remains\n+      unchanged.\n+    ]=],\n+    name = 'extendnew',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extendnew({expr1}, {expr2} [, {expr3}])',\n+  },\n+  feedkeys = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Characters in {string} are queued for processing as if they\n+      come from a mapping or were typed by the user.\n+\n+      By default the string is added to the end of the typeahead\n+      buffer, thus if a mapping is still being executed the\n+      characters come after them.  Use the 'i' flag to insert before\n+      other characters, they will be executed next, before any\n+      characters from a mapping.\n+\n+      The function does not wait for processing of keys contained in\n+      {string}.\n+\n+      To include special keys into {string}, use double-quotes\n+      and \"\\...\" notation |expr-quote|. For example,\n+      feedkeys(\"\\<CR>\") simulates pressing of the <Enter> key. But\n+      feedkeys('\\<CR>') pushes 5 characters.\n+      The |<Ignore>| keycode may be used to exit the\n+      wait-for-character without doing anything.\n+\n+      {mode} is a String, which can contain these character flags:\n+      'm'\tRemap keys. This is default.  If {mode} is absent,\n+      \tkeys are remapped.\n+      'n'\tDo not remap keys.\n+      't'\tHandle keys as if typed; otherwise they are handled as\n+      \tif coming from a mapping.  This matters for undo,\n+      \topening folds, etc.\n+      'i'\tInsert the string instead of appending (see above).\n+      'x'\tExecute commands until typeahead is empty.  This is\n+      \tsimilar to using \":normal!\".  You can call feedkeys()\n+      \tseveral times without 'x' and then one time with 'x'\n+      \t(possibly with an empty {string}) to execute all the\n+      \ttypeahead.  Note that when Vim ends in Insert mode it\n+      \twill behave as if <Esc> is typed, to avoid getting\n+      \tstuck, waiting for a character to be typed before the\n+      \tscript continues.\n+      \tNote that if you manage to call feedkeys() while\n+      \texecuting commands, thus calling it recursively, then\n+      \tall typeahead will be consumed by the last call.\n+      '!'\tWhen used with 'x' will not end Insert mode. Can be\n+      \tused in a test when a timer is set to exit Insert mode\n+      \ta little later.  Useful for testing CursorHoldI.\n+\n+      Return value is always 0.\n+\n+      Can also be used as a |method|: >\n+      \tGetInput()->feedkeys()\n+\n+    ]=],\n+    name = 'feedkeys',\n+    params = { { 'string', 'string' }, { 'mode', 'string' } },\n+    signature = 'feedkeys({string} [, {mode}])',\n+  },\n+  file_readable = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |filereadable()|.\n+    ]=],\n+    func = 'f_filereadable',\n+    name = 'file_readable',\n+    params = { { 'file', 'string' } },\n+    signature = 'file_readable({file})',\n+  },\n+  filereadable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a file with the\n+      name {file} exists, and can be read.  If {file} doesn't exist,\n+      or is a directory, the result is |FALSE|.  {file} is any\n+      expression, which is used as a String.\n+      If you don't care about the file being readable you can use\n+      |glob()|.\n+      {file} is used as-is, you may want to expand wildcards first: >\n+      \techo filereadable('~/.vimrc')\n+      \t0\n+      \techo filereadable(expand('~/.vimrc'))\n+      \t1\n+\n+      <Can also be used as a |method|: >\n+      \tGetName()->filereadable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filereadable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filereadable({file})',\n+  },\n+  filewritable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when a file with the\n+      name {file} exists, and can be written.  If {file} doesn't\n+      exist, or is not writable, the result is 0.  If {file} is a\n+      directory, and we can write to it, the result is 2.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->filewritable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filewritable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filewritable({file})',\n+  },\n+  filter = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob|, or a |Dictionary|.\n+      For each item in {expr1} evaluate {expr2} and when the result\n+      is zero remove the item from the |List| or |Dictionary|. For a\n+      |Blob| each byte is removed.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+\n+      Examples: >\n+      \tcall filter(mylist, 'v:val !~ \"OLD\"')\n+      <Removes the items where \"OLD\" appears. >\n+      \tcall filter(mydict, 'v:key >= 8')\n+      <Removes the items with a key below 8. >\n+      \tcall filter(var, 0)\n+      <Removes all the items, thus clears the |List| or |Dictionary|.\n+\n+      Note that {expr2} is the result of expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.\n+\n+      If {expr2} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item should be kept.\n+      Example that keeps the odd items of a list: >\n+      \tfunc Odd(idx, val)\n+      \t  return a:idx % 2 == 1\n+      \tendfunc\n+      \tcall filter(mylist, function('Odd'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall filter(myList, {idx, val -> idx * val <= 42})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall filter(myList, {idx -> idx % 2 == 1})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let l = filter(copy(mylist), 'v:val =~ \"KEEP\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->filter(expr2)\n+\n+    ]=],\n+    name = 'filter',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'filter({expr1}, {expr2})',\n+  },\n+  finddir = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Find directory {name} in {path}.  Supports both downwards and\n+      upwards recursive directory searches.  See |file-searching|\n+      for the syntax of {path}.\n+\n+      Returns the path of the first found match.  When the found\n+      directory is below the current directory a relative path is\n+      returned.  Otherwise a full path is returned.\n+      If {path} is omitted or empty then 'path' is used.\n+\n+      If the optional {count} is given, find {count}'s occurrence of\n+      {name} in {path} instead of the first one.\n+      When {count} is negative return all the matches in a |List|.\n+\n+      Returns an empty string if the directory is not found.\n+\n+      This is quite similar to the ex-command `:find`.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->finddir()\n+\n+    ]=],\n+    name = 'finddir',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'finddir({name} [, {path} [, {count}]])',\n+  },\n+  findfile = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |finddir()|, but find a file instead of a directory.\n+      Uses 'suffixesadd'.\n+      Example: >\n+      \t:echo findfile(\"tags.vim\", \".;\")\n+      <Searches from the directory of the current file upwards until\n+      it finds the file \"tags.vim\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->findfile()\n+\n+    ]=],\n+    name = 'findfile',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'findfile({name} [, {path} [, {count}]])',\n+  },\n+  flatten = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Flatten {list} up to {maxdepth} levels.  Without {maxdepth}\n+      the result is a |List| without nesting, as if {maxdepth} is\n+      a very large number.\n+      The {list} is changed in place, use |flattennew()| if you do\n+      not want that.\n+      \t\t\t\t\t\t*E900*\n+      {maxdepth} means how deep in nested lists changes are made.\n+      {list} is not modified when {maxdepth} is 0.\n+      {maxdepth} must be positive number.\n+\n+      If there is an error the number zero is returned.\n+\n+      Example: >\n+      \t:echo flatten([1, [2, [3, 4]], 5])\n+      <\t[1, 2, 3, 4, 5] >\n+      \t:echo flatten([1, [2, [3, 4]], 5], 1)\n+      <\t[1, 2, [3, 4], 5]\n+\n+      Can also be used as a |method|: >\n+      \tmylist->flatten()\n+      <\n+    ]=],\n+    name = 'flatten',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flatten({list} [, {maxdepth}])',\n+  },\n+  flattennew = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Like |flatten()| but first make a copy of {list}.\n+    ]=],\n+    name = 'flattennew',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flattennew({list} [, {maxdepth}])',\n+  },\n+  float2nr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} to a Number by omitting the part after the\n+      decimal point.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0 if {expr} is not a |Float| or a |Number|.\n+      When the value of {expr} is out of range for a |Number| the\n+      result is truncated to 0x7fffffff or -0x7fffffff (or when\n+      64-bit Number support is enabled, 0x7fffffffffffffff or\n+      -0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n+      64-bit Number support is enabled, -0x8000000000000000).\n+      Examples: >\n+      \techo float2nr(3.95)\n+      <\t3  >\n+      \techo float2nr(-23.45)\n+      <\t-23  >\n+      \techo float2nr(1.0e100)\n+      <\t2147483647  (or 9223372036854775807) >\n+      \techo float2nr(-1.0e150)\n+      <\t-2147483647 (or -9223372036854775807) >\n+      \techo float2nr(1.0e-100)\n+      <\t0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->float2nr()\n+\n+    ]=],\n+    name = 'float2nr',\n+    params = { { 'expr', 'any' } },\n+    signature = 'float2nr({expr})',\n+  },\n+  floor = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the largest integral value less than or equal to\n+      {expr} as a |Float| (round down).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \techo floor(1.856)\n+      <\t1.0  >\n+      \techo floor(-5.456)\n+      <\t-6.0  >\n+      \techo floor(4.0)\n+      <\t4.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->floor()\n+\n+    ]=],\n+    float_func = 'floor',\n+    name = 'floor',\n+    params = { { 'expr', 'any' } },\n+    signature = 'floor({expr})',\n+  },\n+  fmod = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the remainder of {expr1} / {expr2}, even if the\n+      division is not representable.  Returns {expr1} - i * {expr2}\n+      for some integer i such that if {expr2} is non-zero, the\n+      result has the same sign as {expr1} and magnitude less than\n+      the magnitude of {expr2}.  If {expr2} is zero, the value\n+      returned is zero.  The value returned is a |Float|.\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo fmod(12.33, 1.22)\n+      <\t0.13 >\n+      \t:echo fmod(-12.33, 1.22)\n+      <\t-0.13\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->fmod(1.22)\n+\n+    ]=],\n+    name = 'fmod',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'fmod({expr1}, {expr2})',\n+  },\n+  fnameescape = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Escape {string} for use as file name command argument.  All\n+      characters that have a special meaning, such as '%' and '|'\n+      are escaped with a backslash.\n+      For most systems the characters escaped are\n+      \" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\n+      appears in a filename, it depends on the value of 'isfname'.\n+      A leading '+' and '>' is also escaped (special after |:edit|\n+      and |:write|).  And a \"-\" by itself (special after |:cd|).\n+      Returns an empty string on error.\n+      Example: >\n+      \t:let fname = '+some str%nge|name'\n+      \t:exe \"edit \" .. fnameescape(fname)\n+      <results in executing: >\n+      \tedit \\+some\\ str\\%nge\\|name\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->fnameescape()\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnameescape',\n+    params = { { 'string', 'string' } },\n+    returns = 'string',\n+    signature = 'fnameescape({string})',\n+  },\n+  fnamemodify = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Modify file name {fname} according to {mods}.  {mods} is a\n+      string of characters like it is used for file names on the\n+      command line.  See |filename-modifiers|.\n+      Example: >\n+      \t:echo fnamemodify(\"main.c\", \":p:h\")\n+      <results in: >\n+      \t/home/user/vim/vim/src\n+      <If {mods} is empty or an unsupported modifier is used then\n+      {fname} is returned.\n+      When {fname} is empty then with {mods} \":h\" returns \".\", so\n+      that `:cd` can be used with it.  This is different from\n+      expand('%:h') without a buffer name, which returns an empty\n+      string.\n+      Note: Environment variables don't work in {fname}, use\n+      |expand()| first then.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fnamemodify(':p:h')\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnamemodify',\n+    params = { { 'fname', 'integer' }, { 'mods', 'string' } },\n+    returns = 'string',\n+    signature = 'fnamemodify({fname}, {mods})',\n+  },\n+  foldclosed = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the first line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosed()\n+\n+    ]=],\n+    name = 'foldclosed',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosed({lnum})',\n+  },\n+  foldclosedend = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the last line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosedend()\n+\n+    ]=],\n+    name = 'foldclosedend',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosedend({lnum})',\n+  },\n+  foldlevel = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the foldlevel of line {lnum}\n+      in the current buffer.  For nested folds the deepest level is\n+      returned.  If there is no fold at line {lnum}, zero is\n+      returned.  It doesn't matter if the folds are open or closed.\n+      When used while updating folds (from 'foldexpr') -1 is\n+      returned for lines where folds are still to be updated and the\n+      foldlevel is unknown.  As a special case the level of the\n+      previous line is usually available.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldlevel()\n+      <\n+    ]=],\n+    name = 'foldlevel',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldlevel({lnum})',\n+  },\n+  foldtext = {\n+    desc = [=[\n+      Returns a String, to be displayed for a closed fold.  This is\n+      the default function used for the 'foldtext' option and should\n+      only be called from evaluating 'foldtext'.  It uses the\n+      |v:foldstart|, |v:foldend| and |v:folddashes| variables.\n+      The returned string looks like this: >\n+      \t+-- 45 lines: abcdef\n+      <The number of leading dashes depends on the foldlevel.  The\n+      \"45\" is the number of lines in the fold.  \"abcdef\" is the text\n+      in the first non-blank line of the fold.  Leading white space,\n+      \"//\" or \"/*\" and the text from the 'foldmarker' and\n+      'commentstring' options is removed.\n+      When used to draw the actual foldtext, the rest of the line\n+      will be filled with the fold char from the 'fillchars'\n+      setting.\n+      Returns an empty string when there is no fold.\n+\n+    ]=],\n+    name = 'foldtext',\n+    params = {},\n+    returns = 'string',\n+    signature = 'foldtext()',\n+  },\n+  foldtextresult = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the text that is displayed for the closed fold at line\n+      {lnum}.  Evaluates 'foldtext' in the appropriate context.\n+      When there is no closed fold at {lnum} an empty string is\n+      returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Useful when exporting folded text, e.g., to HTML.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldtextresult()\n+      <\n+    ]=],\n+    name = 'foldtextresult',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'string',\n+    signature = 'foldtextresult({lnum})',\n+  },\n+  foreground = {\n+    lua = false,\n+  },\n+  fullcommand = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the full command name from a short abbreviated command\n+      name; see |20.2| for details on command abbreviations.\n+\n+      The string argument {name} may start with a `:` and can\n+      include a [range], these are skipped and not returned.\n+      Returns an empty string if a command doesn't exist or if it's\n+      ambiguous (for user-defined commands).\n+\n+      For example `fullcommand('s')`, `fullcommand('sub')`,\n+      `fullcommand(':%substitute')` all return \"substitute\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fullcommand()\n+      <\n+    ]=],\n+    name = 'fullcommand',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'fullcommand({name})',\n+  },\n+  funcref = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |function()|, but the returned Funcref will lookup\n+      the function by reference, not by name.  This matters when the\n+      function {name} is redefined later.\n+\n+      Unlike |function()|, {name} must be an existing user function.\n+      It only works for an autoloaded function if it has already\n+      been loaded (to avoid mistakenly loading the autoload script\n+      when only intending to use the function name, use |function()|\n+      instead). {name} cannot be a builtin function.\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->funcref([arg])\n+      <\n+    ]=],\n+    name = 'funcref',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'funcref({name} [, {arglist}] [, {dict}])',\n+  },\n+  ['function'] = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |Funcref| variable that refers to function {name}.\n+      {name} can be the name of a user defined function or an\n+      internal function.\n+\n+      {name} can also be a Funcref or a partial. When it is a\n+      partial the dict stored in it will be used and the {dict}\n+      argument is not allowed. E.g.: >\n+      \tlet FuncWithArg = function(dict.Func, [arg])\n+      \tlet Broken = function(dict.Func, [arg], dict)\n+      <\n+      When using the Funcref the function will be found by {name},\n+      also when it was redefined later. Use |funcref()| to keep the\n+      same function.\n+\n+      When {arglist} or {dict} is present this creates a partial.\n+      That means the argument list and/or the dictionary is stored in\n+      the Funcref and will be used when the Funcref is called.\n+\n+      The arguments are passed to the function in front of other\n+      arguments, but after any argument from |method|.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['one', 'two'])\n+      \t\"...\n+      \tcall Partial('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <With a |method|: >\n+      \tfunc Callback(one, two, three)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['two'])\n+      \t\"...\n+      \teval 'one'->Partial('three')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'three')\n+\n+      <The function() call can be nested to add more arguments to the\n+      Funcref.  The extra arguments are appended to the list of\n+      arguments.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Func = function('Callback', ['one'])\n+      \tlet Func2 = function(Func, ['two'])\n+      \t\"...\n+      \tcall Func2('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <The Dictionary is only useful when calling a \"dict\" function.\n+      In that case the {dict} is passed in as \"self\". Example: >\n+      \tfunction Callback() dict\n+      \t   echo \"called for \" .. self.name\n+      \tendfunction\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', context)\n+      \t\"...\n+      \tcall Func()\t\" will echo: called for example\n+      <The use of function() is not needed when there are no extra\n+      arguments, these two are equivalent, if Callback() is defined\n+      as context.Callback(): >\n+      \tlet Func = function('Callback', context)\n+      \tlet Func = context.Callback\n+\n+      <The argument list and the Dictionary can be combined: >\n+      \tfunction Callback(arg1, count) dict\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', ['one'], context)\n+      \t\"...\n+      \tcall Func(500)\n+      <Invokes the function as with: >\n+      \tcall context.Callback('one', 500)\n+      <\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->function([arg])\n+\n+    ]=],\n+    name = 'function',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'function({name} [, {arglist}] [, {dict}])',\n+    tags = { 'partial', 'E700', 'E923' },\n+  },\n+  garbagecollect = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Cleanup unused |Lists| and |Dictionaries| that have circular\n+      references.\n+\n+      There is hardly ever a need to invoke this function, as it is\n+      automatically done when Vim runs out of memory or is waiting\n+      for the user to press a key after 'updatetime'.  Items without\n+      circular references are always freed when they become unused.\n+      This is useful if you have deleted a very big |List| and/or\n+      |Dictionary| with circular references in a script that runs\n+      for a long time.\n+\n+      When the optional {atexit} argument is one, garbage\n+      collection will also be done when exiting Vim, if it wasn't\n+      done before.  This is useful when checking for memory leaks.\n+\n+      The garbage collection is not done immediately but only when\n+      it's safe to perform.  This is when waiting for the user to\n+      type a character.\n+\n+    ]=],\n+    name = 'garbagecollect',\n+    params = { { 'atexit', 'any' } },\n+    signature = 'garbagecollect([{atexit}])',\n+  },\n+  get = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {idx} from |List| {list}.  When this item is not\n+      available return {default}.  Return zero when {default} is\n+      omitted.\n+      Can also be used as a |method|: >\n+      \tmylist->get(idx)\n+    ]=],\n+    name = 'get',\n+    params = { { 'list', 'any[]' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({list}, {idx} [, {default}])',\n+  },\n+  get__1 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get byte {idx} from |Blob| {blob}.  When this byte is not\n+      available return {default}.  Return -1 when {default} is\n+      omitted.\n+    ]=],\n+    name = 'get',\n+    params = { { 'blob', 'string' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({blob}, {idx} [, {default}])',\n+  },\n+  get__2 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item with key {key} from |Dictionary| {dict}.  When this\n+      item is not available return {default}.  Return zero when\n+      {default} is omitted.  Useful example: >\n+      \tlet val = get(g:, 'var_name', 'default')\n+      <This gets the value of g:var_name if it exists, and uses\n+      \"default\" when it does not exist.\n+    ]=],\n+    name = 'get',\n+    params = { { 'dict', 'table<string,any>' }, { 'key', 'string' }, { 'default', 'any' } },\n+    signature = 'get({dict}, {key} [, {default}])',\n+  },\n+  get__3 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {what} from Funcref {func}.  Possible values for\n+      {what} are:\n+      \t\"name\"\tThe function name\n+      \t\"func\"\tThe function\n+      \t\"dict\"\tThe dictionary\n+      \t\"args\"\tThe list with arguments\n+      Returns zero on error.\n+    ]=],\n+    name = 'get',\n+    params = { { 'func', 'function' }, { 'what', 'string' } },\n+    returns = 'any',\n+    signature = 'get({func}, {what})',\n+  },\n+  getbufinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    name = 'getbufinfo',\n+    params = { { 'buf', 'integer|string' } },\n+    signature = 'getbufinfo([{buf}])',\n+  },\n+  getbufinfo__1 = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get information about buffers as a List of Dictionaries.\n+\n+      Without an argument information about all the buffers is\n+      returned.\n+\n+      When the argument is a |Dictionary| only the buffers matching\n+      the specified criteria are returned.  The following keys can\n+      be specified in {dict}:\n+      \tbuflisted\tinclude only listed buffers.\n+      \tbufloaded\tinclude only loaded buffers.\n+      \tbufmodified\tinclude only modified buffers.\n+\n+      Otherwise, {buf} specifies a particular buffer to return\n+      information for.  For the use of {buf}, see |bufname()|\n+      above.  If the buffer is found the returned List has one item.\n+      Otherwise the result is an empty list.\n+\n+      Each returned List item is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tBuffer number.\n+      \tchanged\t\tTRUE if the buffer is modified.\n+      \tchangedtick\tNumber of changes made to the buffer.\n+      \thidden\t\tTRUE if the buffer is hidden.\n+      \tlastused\tTimestamp in seconds, like\n+      \t\t\t|localtime()|, when the buffer was\n+      \t\t\tlast used.\n+      \tlisted\t\tTRUE if the buffer is listed.\n+      \tlnum\t\tLine number used for the buffer when\n+      \t\t\topened in the current window.\n+      \t\t\tOnly valid if the buffer has been\n+      \t\t\tdisplayed in the window in the past.\n+      \t\t\tIf you want the line number of the\n+      \t\t\tlast known cursor position in a given\n+      \t\t\twindow, use |line()|: >\n+      \t\t\t\t:echo line('.', {winid})\n+      <\n+      \tlinecount\tNumber of lines in the buffer (only\n+      \t\t\tvalid when loaded)\n+      \tloaded\t\tTRUE if the buffer is loaded.\n+      \tname\t\tFull path to the file in the buffer.\n+      \tsigns\t\tList of signs placed in the buffer.\n+      \t\t\tEach list item is a dictionary with\n+      \t\t\tthe following fields:\n+      \t\t\t    id\t  sign identifier\n+      \t\t\t    lnum  line number\n+      \t\t\t    name  sign name\n+      \tvariables\tA reference to the dictionary with\n+      \t\t\tbuffer-local variables.\n+      \twindows\t\tList of |window-ID|s that display this\n+      \t\t\tbuffer\n+\n+      Examples: >\n+      \tfor buf in getbufinfo()\n+      \t    echo buf.name\n+      \tendfor\n+      \tfor buf in getbufinfo({'buflisted':1})\n+      \t    if buf.changed\n+      \t\t....\n+      \t    endif\n+      \tendfor\n+      <\n+      To get buffer-local options use: >\n+      \tgetbufvar({bufnr}, '&option_name')\n+      <\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getbufinfo()\n+      <\n+    ]=],\n+    name = 'getbufinfo',\n+    params = { { 'dict', 'table<string,any>' } },\n+    signature = 'getbufinfo([{dict}])',\n+  },\n+  getbufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with the lines starting from {lnum} to {end}\n+      (inclusive) in the buffer {buf}.  If {end} is omitted, a\n+      |List| with only the line {lnum} is returned.  See\n+      `getbufoneline()` for only getting the line.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      For {lnum} and {end} \"$\" can be used for the last line of the\n+      buffer.  Otherwise a number must be used.\n+\n+      When {lnum} is smaller than 1 or bigger than the number of\n+      lines in the buffer, an empty |List| is returned.\n+\n+      When {end} is greater than the number of lines in the buffer,\n+      it is treated as {end} is set to the number of lines in the\n+      buffer.  When {end} is before {lnum} an empty |List| is\n+      returned.\n+\n+      This function works only for loaded buffers.  For unloaded and\n+      non-existing buffers, an empty |List| is returned.\n+\n+      Example: >\n+      \t:let lines = getbufline(bufnr(\"myfile\"), 1, \"$\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufline(lnum)\n+      <\n+    ]=],\n+    name = 'getbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'end', 'integer' } },\n+    signature = 'getbufline({buf}, {lnum} [, {end}])',\n+  },\n+  getbufoneline = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Just like `getbufline()` but only get one line and return it\n+      as a string.\n+    ]=],\n+    name = 'getbufoneline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' } },\n+    signature = 'getbufoneline({buf}, {lnum})',\n+  },\n+  getbufvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is the value of option or local buffer variable\n+      {varname} in buffer {buf}.  Note that the name without \"b:\"\n+      must be used.\n+      The {varname} argument is a string.\n+      When {varname} is empty returns a |Dictionary| with all the\n+      buffer-local variables.\n+      When {varname} is equal to \"&\" returns a |Dictionary| with all\n+      the buffer-local options.\n+      Otherwise, when {varname} starts with \"&\" returns the value of\n+      a buffer-local option.\n+      This also works for a global or buffer-local option, but it\n+      doesn't work for a global variable, window-local variable or\n+      window-local option.\n+      For the use of {buf}, see |bufname()| above.\n+      When the buffer or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+      Examples: >\n+      \t:let bufmodified = getbufvar(1, \"&mod\")\n+      \t:echo \"todo myvar = \" .. getbufvar(\"todo\", \"myvar\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufvar(varname)\n+      <\n+    ]=],\n+    name = 'getbufvar',\n+    params = { { 'buf', 'any' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getbufvar({buf}, {varname} [, {def}])',\n+  },\n+  getcellwidths = {\n+    desc = [=[\n+      Returns a |List| of cell widths of character ranges overridden\n+      by |setcellwidths()|.  The format is equal to the argument of\n+      |setcellwidths()|.  If no character ranges have their cell\n+      widths overridden, an empty List is returned.\n+    ]=],\n+    name = 'getcellwidths',\n+    params = {},\n+    signature = 'getcellwidths()',\n+  },\n+  getchangelist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |changelist| for the buffer {buf}. For the use\n+      of {buf}, see |bufname()| above. If buffer {buf} doesn't\n+      exist, an empty list is returned.\n+\n+      The returned list contains two entries: a list with the change\n+      locations and the current position in the list.  Each\n+      entry in the change list is a dictionary with the following\n+      entries:\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tlnum\t\tline number\n+      If buffer {buf} is the current buffer, then the current\n+      position refers to the position in the list. For other\n+      buffers, it is set to the length of the list.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getchangelist()\n+\n+    ]=],\n+    name = 'getchangelist',\n+    params = { { 'buf', 'integer|string' } },\n+    returns = 'table[]',\n+    signature = 'getchangelist([{buf}])',\n+  },\n+  getchar = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0, only get a character when one is available.\n+      \tReturn zero otherwise.\n+      If [expr] is 1, only check if a character is available, it is\n+      \tnot consumed.  Return zero if no character available.\n+      If you prefer always getting a string use |getcharstr()|.\n+\n+      Without [expr] and when [expr] is 0 a whole character or\n+      special key is returned.  If it is a single character, the\n+      result is a Number.  Use |nr2char()| to convert it to a String.\n+      Otherwise a String is returned with the encoded character.\n+      For a special key it's a String with a sequence of bytes\n+      starting with 0x80 (decimal: 128).  This is the same value as\n+      the String \"\\<Key>\", e.g., \"\\<Left>\".  The returned value is\n+      also a String when a modifier (shift, control, alt) was used\n+      that is not included in the character.\n+\n+      When [expr] is 0 and Esc is typed, there will be a short delay\n+      while Vim waits to see if this is the start of an escape\n+      sequence.\n+\n+      When [expr] is 1 only the first byte is returned.  For a\n+      one-byte character it is the character itself as a number.\n+      Use nr2char() to convert it to a String.\n+\n+      Use getcharmod() to obtain any additional modifiers.\n+\n+      When the user clicks a mouse button, the mouse event will be\n+      returned.  The position can then be found in |v:mouse_col|,\n+      |v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.\n+      |getmousepos()| can also be used.  Mouse move events will be\n+      ignored.\n+      This example positions the mouse as it would normally happen: >\n+      \tlet c = getchar()\n+      \tif c == \"\\<LeftMouse>\" && v:mouse_win > 0\n+      \t  exe v:mouse_win .. \"wincmd w\"\n+      \t  exe v:mouse_lnum\n+      \t  exe \"normal \" .. v:mouse_col .. \"|\"\n+      \tendif\n+      <\n+      There is no prompt, you will somehow have to make clear to the\n+      user that a character has to be typed.  The screen is not\n+      redrawn, e.g. when resizing the window.\n+\n+      There is no mapping for the character.\n+      Key codes are replaced, thus when the user presses the <Del>\n+      key you get the code for the <Del> key, not the raw character\n+      sequence.  Examples: >\n+      \tgetchar() == \"\\<Del>\"\n+      \tgetchar() == \"\\<S-Left>\"\n+      <This example redefines \"f\" to ignore case: >\n+      \t:nmap f :call FindChar()<CR>\n+      \t:function FindChar()\n+      \t:  let c = nr2char(getchar())\n+      \t:  while col('.') < col('$') - 1\n+      \t:    normal l\n+      \t:    if getline('.')[col('.') - 1] ==? c\n+      \t:      break\n+      \t:    endif\n+      \t:  endwhile\n+      \t:endfunction\n+      <\n+    ]=],\n+    name = 'getchar',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getchar([expr])',\n+  },\n+  getcharmod = {\n+    desc = [=[\n+      The result is a Number which is the state of the modifiers for\n+      the last obtained character with getchar() or in another way.\n+      These values are added together:\n+      \t2\tshift\n+      \t4\tcontrol\n+      \t8\talt (meta)\n+      \t16\tmeta (when it's different from ALT)\n+      \t32\tmouse double click\n+      \t64\tmouse triple click\n+      \t96\tmouse quadruple click (== 32 + 64)\n+      \t128\tcommand (Macintosh only)\n+      Only the modifiers that have not been included in the\n+      character itself are obtained.  Thus Shift-a results in \"A\"\n+      without a modifier.  Returns 0 if no modifiers are used.\n+    ]=],\n+    name = 'getcharmod',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcharmod()',\n+  },\n+  getcharpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}. Same as |getpos()| but the\n+      column number in the returned List is a character index\n+      instead of a byte index.\n+      If |getpos()| returns a very large column number, equal to\n+      |v:maxcol|, then getcharpos() will return the character index\n+      of the last character.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tgetcharpos('.')\t\treturns [0, 5, 3, 0]\n+      \tgetpos('.')\t\treturns [0, 5, 7, 0]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetMark()->getcharpos()\n+      <\n+    ]=],\n+    name = 'getcharpos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'integer[]',\n+    signature = 'getcharpos({expr})',\n+  },\n+  getcharsearch = {\n+    desc = [=[\n+      Return the current character search information as a {dict}\n+      with the following entries:\n+\n+          char\tcharacter previously used for a character\n+      \t\tsearch (|t|, |f|, |T|, or |F|); empty string\n+      \t\tif no character search has been performed\n+          forward\tdirection of character search; 1 for forward,\n+      \t\t0 for backward\n+          until\ttype of character search; 1 for a |t| or |T|\n+      \t\tcharacter search, 0 for an |f| or |F|\n+      \t\tcharacter search\n+\n+      This can be useful to always have |;| and |,| search\n+      forward/backward regardless of the direction of the previous\n+      character search: >\n+      \t:nnoremap <expr> ; getcharsearch().forward ? ';' : ','\n+      \t:nnoremap <expr> , getcharsearch().forward ? ',' : ';'\n+      <Also see |setcharsearch()|.\n+    ]=],\n+    name = 'getcharsearch',\n+    params = {},\n+    returns = 'table[]',\n+    signature = 'getcharsearch()',\n+  },\n+  getcharstr = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream as a\n+      string.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0 or false, only get a character when one is\n+      \tavailable.  Return an empty string otherwise.\n+      If [expr] is 1 or true, only check if a character is\n+      \tavailable, it is not consumed.  Return an empty string\n+      \tif no character is available.\n+      Otherwise this works like |getchar()|, except that a number\n+      result is converted to a string.\n+\n+    ]=],\n+    name = 'getcharstr',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcharstr([expr])',\n+  },\n+  getcmdcompltype = {\n+    desc = [=[\n+      Return the type of the current command-line completion.\n+      Only works when the command line is being edited, thus\n+      requires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\n+      See |:command-completion| for the return string.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+      Returns an empty string when completion is not defined.\n+\n+    ]=],\n+    name = 'getcmdcompltype',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdcompltype()',\n+  },\n+  getcmdline = {\n+    desc = [=[\n+      Return the current command-line.  Only works when the command\n+      line is being edited, thus requires use of |c_CTRL-\\_e| or\n+      |c_CTRL-R_=|.\n+      Example: >\n+      \t:cmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n+      <Also see |getcmdtype()|, |getcmdpos()|, |setcmdpos()| and\n+      |setcmdline()|.\n+      Returns an empty string when entering a password or using\n+      |inputsecret()|.\n+    ]=],\n+    name = 'getcmdline',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdline()',\n+  },\n+  getcmdpos = {\n+    desc = [=[\n+      Return the position of the cursor in the command line as a\n+      byte count.  The first column is 1.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+    ]=],\n+    name = 'getcmdpos',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcmdpos()',\n+  },\n+  getcmdscreenpos = {\n+    desc = [=[\n+      Return the screen position of the cursor in the command line\n+      as a byte count.  The first column is 1.\n+      Instead of |getcmdpos()|, it adds the prompt position.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+\n+    ]=],\n+    name = 'getcmdscreenpos',\n+    params = {},\n+    signature = 'getcmdscreenpos()',\n+  },\n+  getcmdtype = {\n+    desc = [=[\n+      Return the current command-line type. Possible return values\n+      are:\n+          :\tnormal Ex command\n+          >\tdebug mode command |debug-mode|\n+          /\tforward search command\n+          ?\tbackward search command\n+          @\t|input()| command\n+          `-`\t|:insert| or |:append| command\n+          =\t|i_CTRL-R_=|\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns an empty string otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.\n+    ]=],\n+    name = 'getcmdtype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdtype()',\n+  },\n+  getcmdwintype = {\n+    desc = [=[\n+      Return the current |command-line-window| type. Possible return\n+      values are the same as |getcmdtype()|. Returns an empty string\n+      when not in the command-line window.\n+    ]=],\n+    name = 'getcmdwintype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdwintype()',\n+  },\n+  getcompletion = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of command-line completion matches. The String\n+      {type} argument specifies what for.  The following completion\n+      types are supported:\n+\n+      arglist\t\tfile names in argument list\n+      augroup\t\tautocmd groups\n+      buffer\t\tbuffer names\n+      breakpoint\t|:breakadd| and |:breakdel| suboptions\n+      cmdline\t\t|cmdline-completion| result\n+      color\t\tcolor schemes\n+      command\t\tEx command\n+      compiler\tcompilers\n+      diff_buffer     |:diffget| and |:diffput| completion\n+      dir\t\tdirectory names\n+      environment\tenvironment variable names\n+      event\t\tautocommand events\n+      expression\tVim expression\n+      file\t\tfile and directory names\n+      file_in_path\tfile and directory names in |'path'|\n+      filetype\tfiletype names |'filetype'|\n+      function\tfunction name\n+      help\t\thelp subjects\n+      highlight\thighlight groups\n+      history\t\t|:history| suboptions\n+      locale\t\tlocale names (as output of locale -a)\n+      mapclear\tbuffer argument\n+      mapping\t\tmapping name\n+      menu\t\tmenus\n+      messages\t|:messages| suboptions\n+      option\t\toptions\n+      packadd\t\toptional package |pack-add| names\n+      runtime\t\t|:runtime| completion\n+      scriptnames\tsourced script names |:scriptnames|\n+      shellcmd\tShell command\n+      sign\t\t|:sign| suboptions\n+      syntax\t\tsyntax file names |'syntax'|\n+      syntime\t\t|:syntime| suboptions\n+      tag\t\ttags\n+      tag_listfiles\ttags, file names\n+      user\t\tuser names\n+      var\t\tuser variables\n+\n+      If {pat} is an empty string, then all the matches are\n+      returned.  Otherwise only items matching {pat} are returned.\n+      See |wildcards| for the use of special characters in {pat}.\n+\n+      If the optional {filtered} flag is set to 1, then 'wildignore'\n+      is applied to filter the results.  Otherwise all the matches\n+      are returned. The 'wildignorecase' option always applies.\n+\n+      If the 'wildoptions' option contains \"fuzzy\", then fuzzy\n+      matching is used to get the completion matches. Otherwise\n+      regular expression matching is used.  Thus this function\n+      follows the user preference, what happens on the command line.\n+      If you do not want this you can make 'wildoptions' empty\n+      before calling getcompletion() and restore it afterwards.\n+\n+      If {type} is \"cmdline\", then the |cmdline-completion| result is\n+      returned.  For example, to complete the possible values after\n+      a \":call\" command: >\n+      \techo getcompletion('call ', 'cmdline')\n+      <\n+      If there are no matches, an empty list is returned.  An\n+      invalid value for {type} produces an error.\n+\n+      Can also be used as a |method|: >\n+      \tGetPattern()->getcompletion('color')\n+      <\n+    ]=],\n+    name = 'getcompletion',\n+    params = { { 'pat', 'any' }, { 'type', 'any' }, { 'filtered', 'any' } },\n+    returns = 'string[]',\n+    signature = 'getcompletion({pat}, {type} [, {filtered}])',\n+  },\n+  getcurpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get the position of the cursor.  This is like getpos('.'), but\n+      includes an extra \"curswant\" item in the list:\n+          [0, lnum, col, off, curswant] ~\n+      The \"curswant\" number is the preferred column when moving the\n+      cursor vertically.  After |$| command it will be a very large\n+      number equal to |v:maxcol|.  Also see |getcursorcharpos()| and\n+      |getpos()|.\n+      The first \"bufnum\" item is always zero. The byte position of\n+      the cursor is returned in \"col\". To get the character\n+      position, use |getcursorcharpos()|.\n+\n+      The optional {winid} argument can specify the window.  It can\n+      be the window number or the |window-ID|.  The last known\n+      cursor position is returned, this may be invalid for the\n+      current value of the buffer if it is not the current window.\n+      If {winid} is invalid a list with zeroes is returned.\n+\n+      This can be used to save and restore the cursor position: >\n+      \tlet save_cursor = getcurpos()\n+      \tMoveTheCursorAround\n+      \tcall setpos('.', save_cursor)\n+      <Note that this only works within the window.  See\n+      |winrestview()| for restoring more state.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcurpos()\n+      <\n+    ]=],\n+    name = 'getcurpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcurpos([{winid}])',\n+  },\n+  getcursorcharpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Same as |getcurpos()| but the column number in the returned\n+      List is a character index instead of a byte index.\n+\n+      Example:\n+      With the cursor on '' in line 3 with text \"\": >\n+      \tgetcursorcharpos()\treturns [0, 3, 2, 0, 3]\n+      \tgetcurpos()\t\treturns [0, 3, 4, 0, 3]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcursorcharpos()\n+\n+    ]=],\n+    name = 'getcursorcharpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcursorcharpos([{winid}])',\n+  },\n+  getcwd = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      With no arguments, returns the name of the effective\n+      |current-directory|. With {winnr} or {tabnr} the working\n+      directory of that scope is returned, and 'autochdir' is\n+      ignored.\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing tab number implies 0.\n+      Thus the following are equivalent: >\n+      \tgetcwd(0)\n+      \tgetcwd(0, 0)\n+      <If {winnr} is -1 it is ignored, only the tab is resolved.\n+      {winnr} can be the window number or the |window-ID|.\n+      If both {winnr} and {tabnr} are -1 the global working\n+      directory is returned.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getcwd()\n+\n+    ]=],\n+    name = 'getcwd',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'string',\n+    signature = 'getcwd([{winnr} [, {tabnr}]])',\n+  },\n+  getenv = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the value of environment variable {name}.  The {name}\n+      argument is a string, without a leading '$'.  Example: >\n+      \tmyHome = getenv('HOME')\n+\n+      <When the variable does not exist |v:null| is returned.  That\n+      is different from a variable set to an empty string.\n+      See also |expr-env|.\n+\n+      Can also be used as a |method|: >\n+      \tGetVarname()->getenv()\n+\n+    ]=],\n+    name = 'getenv',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getenv({name})',\n+  },\n+  getfontname = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Without an argument returns the name of the normal font being\n+      used.  Like what is used for the Normal highlight group\n+      |hl-Normal|.\n+      With an argument a check is done whether String {name} is a\n+      valid font name.  If not then an empty string is returned.\n+      Otherwise the actual font name is returned, or {name} if the\n+      GUI does not support obtaining the real name.\n+      Only works when the GUI is running, thus not in your vimrc or\n+      gvimrc file.  Use the |GUIEnter| autocommand to use this\n+      function just after the GUI has started.\n+\n+    ]=],\n+    name = 'getfontname',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getfontname([{name}])',\n+  },\n+  getfperm = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the read, write, and execute\n+      permissions of the given file {fname}.\n+      If {fname} does not exist or its directory cannot be read, an\n+      empty string is returned.\n+      The result is of the form \"rwxrwxrwx\", where each group of\n+      \"rwx\" flags represent, in turn, the permissions of the owner\n+      of the file, the group the file belongs to, and other users.\n+      If a user does not have a given permission the flag for this\n+      is replaced with the string \"-\".  Examples: >\n+      \t:echo getfperm(\"/etc/passwd\")\n+      \t:echo getfperm(expand(\"~/.config/nvim/init.vim\"))\n+      <This will hopefully (from a security point of view) display\n+      the string \"rw-r--r--\" or even \"rw-------\".\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfperm()\n+      <\n+      For setting permissions use |setfperm()|.\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfperm',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'string',\n+    signature = 'getfperm({fname})',\n+  },\n+  getfsize = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the size in bytes of the\n+      given file {fname}.\n+      If {fname} is a directory, 0 is returned.\n+      If the file {fname} can't be found, -1 is returned.\n+      If the size of {fname} is too big to fit in a Number then -2\n+      is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfsize()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfsize',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getfsize({fname})',\n+  },\n+  getftime = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the last modification time of\n+      the given file {fname}.  The value is measured as seconds\n+      since 1st Jan 1970, and may be passed to strftime().  See also\n+      |localtime()| and |strftime()|.\n+      If the file {fname} can't be found -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftime()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getftime',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getftime({fname})',\n+  },\n+  getftype = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is a description of the kind of\n+      file of the given file {fname}.\n+      If {fname} does not exist an empty string is returned.\n+      Here is a table over different kinds of files and their\n+      results:\n+      \tNormal file\t\t\"file\"\n+      \tDirectory\t\t\"dir\"\n+      \tSymbolic link\t\t\"link\"\n+      \tBlock device\t\t\"bdev\"\n+      \tCharacter device\t\"cdev\"\n+      \tSocket\t\t\t\"socket\"\n+      \tFIFO\t\t\t\"fifo\"\n+      \tAll other\t\t\"other\"\n+      Example: >\n+      \tgetftype(\"/home\")\n+      <Note that a type such as \"link\" will only be returned on\n+      systems that support it.  On some systems only \"dir\" and\n+      \"file\" are returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftype()\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'getftype',\n+    params = { { 'fname', 'integer' } },\n+    returns = \"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\",\n+    signature = 'getftype({fname})',\n+  },\n+  getjumplist = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |jumplist| for the specified window.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      {winnr} can also be a |window-ID|.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.  If {winnr} or {tabnr} is invalid, an empty list is\n+      returned.\n+\n+      The returned list contains two entries: a list with the jump\n+      locations and the last used jump position number in the list.\n+      Each entry in the jump location list is a dictionary with\n+      the following entries:\n+      \tbufnr\t\tbuffer number\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tfilename\tfilename if available\n+      \tlnum\t\tline number\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getjumplist()\n+      <\n+    ]=],\n+    name = 'getjumplist',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    signature = 'getjumplist([{winnr} [, {tabnr}]])',\n+  },\n+  getline = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {end} the result is a String, which is line {lnum}\n+      from the current buffer.  Example: >\n+      \tgetline(1)\n+      <When {lnum} is a String that doesn't start with a\n+      digit, |line()| is called to translate the String into a Number.\n+      To get the line under the cursor: >\n+      \tgetline(\".\")\n+      <When {lnum} is a number smaller than 1 or bigger than the\n+      number of lines in the buffer, an empty string is returned.\n+\n+      When {end} is given the result is a |List| where each item is\n+      a line from the current buffer in the range {lnum} to {end},\n+      including line {end}.\n+      {end} is used in the same way as {lnum}.\n+      Non-existing lines are silently omitted.\n+      When {end} is before {lnum} an empty |List| is returned.\n+      Example: >\n+      \t:let start = line('.')\n+      \t:let end = search(\"^$\") - 1\n+      \t:let lines = getline(start, end)\n+\n+      <Can also be used as a |method|: >\n+      \tComputeLnum()->getline()\n+\n+      <To get lines from another buffer see |getbufline()| and\n+      |getbufoneline()|\n+    ]=],\n+    name = 'getline',\n+    params = { { 'lnum', 'integer' }, { 'end', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getline({lnum} [, {end}])',\n+  },\n+  getloclist = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Returns a |List| with all the entries in the location list for\n+      window {nr}.  {nr} can be the window number or the |window-ID|.\n+      When {nr} is zero the current window is used.\n+\n+      For a location list window, the displayed location list is\n+      returned.  For an invalid window number {nr}, an empty list is\n+      returned. Otherwise, same as |getqflist()|.\n+\n+      If the optional {what} dictionary argument is supplied, then\n+      returns the items listed in {what} as a dictionary. Refer to\n+      |getqflist()| for the supported items in {what}.\n+\n+      In addition to the items supported by |getqflist()| in {what},\n+      the following item is supported by |getloclist()|:\n+\n+      \tfilewinid\tid of the window used to display files\n+      \t\t\tfrom the location list. This field is\n+      \t\t\tapplicable only when called from a\n+      \t\t\tlocation list window. See\n+      \t\t\t|location-list-file-window| for more\n+      \t\t\tdetails.\n+\n+      Returns a |Dictionary| with default values if there is no\n+      location list for the window {nr}.\n+      Returns an empty Dictionary if window {nr} does not exist.\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getloclist(3, {'all': 0})\n+      \t:echo getloclist(5, {'filewinid': 0})\n+      <\n+    ]=],\n+    name = 'getloclist',\n+    params = { { 'nr', 'integer' }, { 'what', 'any' } },\n+    signature = 'getloclist({nr} [, {what}])',\n+  },\n+  getmarklist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Without the {buf} argument returns a |List| with information\n+      about all the global marks. |mark|\n+\n+      If the optional {buf} argument is specified, returns the\n+      local marks defined in buffer {buf}.  For the use of {buf},\n+      see |bufname()|.  If {buf} is invalid, an empty list is\n+      returned.\n+\n+      Each item in the returned List is a |Dict| with the following:\n+          mark   name of the mark prefixed by \"'\"\n+          pos\t   a |List| with the position of the mark:\n+      \t\t[bufnum, lnum, col, off]\n+      \t   Refer to |getpos()| for more information.\n+          file   file name\n+\n+      Refer to |getpos()| for getting information about a specific\n+      mark.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getmarklist()\n+\n+    ]=],\n+    name = 'getmarklist',\n+    params = { { 'buf', 'any' } },\n+    signature = 'getmarklist([{buf}])',\n+  },\n+  getmatches = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all matches previously defined for the\n+      current window by |matchadd()| and the |:match| commands.\n+      |getmatches()| is useful in combination with |setmatches()|,\n+      as |setmatches()| can restore a list of matches saved by\n+      |getmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.  If {win} is invalid,\n+      an empty list is returned.\n+      Example: >vim\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:let m = getmatches()\n+      \t:call clearmatches()\n+      \t:echo getmatches()\n+      < >\n+      \t[]\n+      < >vim\n+      \t:call setmatches(m)\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:unlet m\n+      <\n+    ]=],\n+    name = 'getmatches',\n+    params = { { 'win', 'any' } },\n+    signature = 'getmatches([{win}])',\n+  },\n+  getmousepos = {\n+    desc = [=[\n+      Returns a Dictionary with the last known position of the\n+      mouse.  This can be used in a mapping for a mouse click.  The\n+      items are:\n+      \tscreenrow\tscreen row\n+      \tscreencol\tscreen column\n+      \twinid\t\tWindow ID of the click\n+      \twinrow\t\trow inside \"winid\"\n+      \twincol\t\tcolumn inside \"winid\"\n+      \tline\t\ttext line inside \"winid\"\n+      \tcolumn\t\ttext column inside \"winid\"\n+      All numbers are 1-based.\n+\n+      If not over a window, e.g. when in the command line, then only\n+      \"screenrow\" and \"screencol\" are valid, the others are zero.\n+\n+      When on the status line below a window or the vertical\n+      separator right of a window, the \"line\" and \"column\" values\n+      are zero.\n+\n+      When the position is after the text then \"column\" is the\n+      length of the text in bytes plus one.\n+\n+      If the mouse is over a focusable floating window then that\n+      window is used.\n+\n+      When using |getchar()| the Vim variables |v:mouse_lnum|,\n+      |v:mouse_col| and |v:mouse_winid| also provide these values.\n+    ]=],\n+    name = 'getmousepos',\n+    params = {},\n+    signature = 'getmousepos()',\n+  },\n+  getpid = {\n+    desc = [=[\n+      Return a Number which is the process ID of the Vim process.\n+      This is a unique number, until Vim exits.\n+    ]=],\n+    fast = true,\n+    name = 'getpid',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getpid()',\n+  },\n+  getpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}.  For possible values of\n+      {expr} see |line()|.  For getting the cursor position see\n+      |getcurpos()|.\n+      The result is a |List| with four numbers:\n+          [bufnum, lnum, col, off]\n+      \"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\n+      is the buffer number of the mark.\n+      \"lnum\" and \"col\" are the position in the buffer.  The first\n+      column is 1.\n+      The \"off\" number is zero, unless 'virtualedit' is used.  Then\n+      it is the offset in screen columns from the start of the\n+      character.  E.g., a position within a <Tab> or after the last\n+      character.\n+      Note that for '< and '> Visual mode matters: when it is \"V\"\n+      (visual line mode) the column of '< is zero and the column of\n+      '> is a large number equal to |v:maxcol|.\n+      The column number in the returned List is the byte position\n+      within the line. To get the character position in the line,\n+      use |getcharpos()|.\n+      A very large column number equal to |v:maxcol| can be returned,\n+      in which case it means \"after the end of the line\".\n+      If {expr} is invalid, returns a list with all zeros.\n+      This can be used to save and restore the position of a mark: >\n+      \tlet save_a_mark = getpos(\"'a\")\n+      \t...\n+      \tcall setpos(\"'a\", save_a_mark)\n+      <Also see |getcharpos()|, |getcurpos()| and |setpos()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetMark()->getpos()\n+      <\n+    ]=],\n+    name = 'getpos',\n+    params = { { 'expr', 'any' } },\n+    signature = 'getpos({expr})',\n+  },\n+  getqflist = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all the current quickfix errors.  Each\n+      list item is a dictionary with these entries:\n+      \tbufnr\tnumber of buffer that has the file name, use\n+      \t\tbufname() to get the name\n+      \tmodule\tmodule name\n+      \tlnum\tline number in the buffer (first line is 1)\n+      \tend_lnum\n+      \t\tend of line number if the item is multiline\n+      \tcol\tcolumn number (first column is 1)\n+      \tend_col\tend of column number if the item has range\n+      \tvcol\t|TRUE|: \"col\" is visual column\n+      \t\t|FALSE|: \"col\" is byte index\n+      \tnr\terror number\n+      \tpattern\tsearch pattern used to locate the error\n+      \ttext\tdescription of the error\n+      \ttype\ttype of the error, 'E', '1', etc.\n+      \tvalid\t|TRUE|: recognized error message\n+\n+      When there is no error list or it's empty, an empty list is\n+      returned. Quickfix list entries with a non-existing buffer\n+      number are returned with \"bufnr\" set to zero (Note: some\n+      functions accept buffer number zero for the alternate buffer,\n+      you may need to explicitly check for zero).\n+\n+      Useful application: Find pattern matches in multiple files and\n+      do something with them: >\n+      \t:vimgrep /theword/jg *.c\n+      \t:for d in getqflist()\n+      \t:   echo bufname(d.bufnr) ':' d.lnum '=' d.text\n+      \t:endfor\n+      <\n+      If the optional {what} dictionary argument is supplied, then\n+      returns only the items listed in {what} as a dictionary. The\n+      following string items are supported in {what}:\n+      \tchangedtick\tget the total number of changes made\n+      \t\t\tto the list |quickfix-changedtick|\n+      \tcontext\tget the |quickfix-context|\n+      \tefm\terrorformat to use when parsing \"lines\". If\n+      \t\tnot present, then the 'errorformat' option\n+      \t\tvalue is used.\n+      \tid\tget information for the quickfix list with\n+      \t\t|quickfix-ID|; zero means the id for the\n+      \t\tcurrent list or the list specified by \"nr\"\n+      \tidx\tget information for the quickfix entry at this\n+      \t\tindex in the list specified by \"id\" or \"nr\".\n+      \t\tIf set to zero, then uses the current entry.\n+      \t\tSee |quickfix-index|\n+      \titems\tquickfix list entries\n+      \tlines\tparse a list of lines using 'efm' and return\n+      \t\tthe resulting entries.  Only a |List| type is\n+      \t\taccepted.  The current quickfix list is not\n+      \t\tmodified. See |quickfix-parse|.\n+      \tnr\tget information for this quickfix list; zero\n+      \t\tmeans the current quickfix list and \"$\" means\n+      \t\tthe last quickfix list\n+      \tqfbufnr number of the buffer displayed in the quickfix\n+      \t\twindow. Returns 0 if the quickfix buffer is\n+      \t\tnot present. See |quickfix-buffer|.\n+      \tsize\tnumber of entries in the quickfix list\n+      \ttitle\tget the list title |quickfix-title|\n+      \twinid\tget the quickfix |window-ID|\n+      \tall\tall of the above quickfix properties\n+      Non-string items in {what} are ignored. To get the value of a\n+      particular item, set it to zero.\n+      If \"nr\" is not present then the current quickfix list is used.\n+      If both \"nr\" and a non-zero \"id\" are specified, then the list\n+      specified by \"id\" is used.\n+      To get the number of lists in the quickfix stack, set \"nr\" to\n+      \"$\" in {what}. The \"nr\" value in the returned dictionary\n+      contains the quickfix stack size.\n+      When \"lines\" is specified, all the other items except \"efm\"\n+      are ignored.  The returned dictionary contains the entry\n+      \"items\" with the list of entries.\n+\n+      The returned dictionary contains the following entries:\n+      \tchangedtick\ttotal number of changes made to the\n+      \t\t\tlist |quickfix-changedtick|\n+      \tcontext\tquickfix list context. See |quickfix-context|\n+      \t\tIf not present, set to \"\".\n+      \tid\tquickfix list ID |quickfix-ID|. If not\n+      \t\tpresent, set to 0.\n+      \tidx\tindex of the quickfix entry in the list. If not\n+      \t\tpresent, set to 0.\n+      \titems\tquickfix list entries. If not present, set to\n+      \t\tan empty list.\n+      \tnr\tquickfix list number. If not present, set to 0\n+      \tqfbufnr\tnumber of the buffer displayed in the quickfix\n+      \t\twindow. If not present, set to 0.\n+      \tsize\tnumber of entries in the quickfix list. If not\n+      \t\tpresent, set to 0.\n+      \ttitle\tquickfix list title text. If not present, set\n+      \t\tto \"\".\n+      \twinid\tquickfix |window-ID|. If not present, set to 0\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getqflist({'all': 1})\n+      \t:echo getqflist({'nr': 2, 'title': 1})\n+      \t:echo getqflist({'lines' : [\"F1:10:L10\"]})\n+      <\n+    ]=],\n+    name = 'getqflist',\n+    params = { { 'what', 'any' } },\n+    signature = 'getqflist([{what}])',\n+  },\n+  getreg = {\n+    args = { 0, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the contents of register\n+      {regname}.  Example: >\n+      \t:let cliptext = getreg('*')\n+      <When register {regname} was not set the result is an empty\n+      string.\n+      The {regname} argument must be a string.\n+\n+      getreg('=') returns the last evaluated value of the expression\n+      register.  (For use in maps.)\n+      getreg('=', 1) returns the expression itself, so that it can\n+      be restored with |setreg()|.  For other registers the extra\n+      argument is ignored, thus you can always give it.\n+\n+      If {list} is present and |TRUE|, the result type is changed\n+      to |List|. Each list item is one text line. Use it if you care\n+      about zero bytes possibly present inside register: without\n+      third argument both NLs and zero bytes are represented as NLs\n+      (see |NL-used-for-Nul|).\n+      When the register was not set an empty list is returned.\n+\n+      If {regname} is not specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreg()\n+\n+    ]=],\n+    name = 'getreg',\n+    params = { { 'regname', 'string' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getreg([{regname} [, 1 [, {list}]]])',\n+  },\n+  getreginfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns detailed information about register {regname} as a\n+      Dictionary with the following entries:\n+      \tregcontents\tList of lines contained in register\n+      \t\t\t{regname}, like\n+      \t\t\tgetreg({regname}, 1, 1).\n+      \tregtype\t\tthe type of register {regname}, as in\n+      \t\t\t|getregtype()|.\n+      \tisunnamed\tBoolean flag, v:true if this register\n+      \t\t\tis currently pointed to by the unnamed\n+      \t\t\tregister.\n+      \tpoints_to\tfor the unnamed register, gives the\n+      \t\t\tsingle letter name of the register\n+      \t\t\tcurrently pointed to (see |quotequote|).\n+      \t\t\tFor example, after deleting a line\n+      \t\t\twith `dd`, this field will be \"1\",\n+      \t\t\twhich is the register that got the\n+      \t\t\tdeleted text.\n+\n+      The {regname} argument is a string.  If {regname} is invalid\n+      or not set, an empty Dictionary will be returned.\n+      If {regname} is not specified, |v:register| is used.\n+      The returned Dictionary can be passed to |setreg()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreginfo()\n+\n+    ]=],\n+    name = 'getreginfo',\n+    params = { { 'regname', 'string' } },\n+    returns = 'table',\n+    signature = 'getreginfo([{regname}])',\n+  },\n+  getregtype = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is type of register {regname}.\n+      The value will be one of:\n+          \"v\"\t\t\tfor |charwise| text\n+          \"V\"\t\t\tfor |linewise| text\n+          \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n+          \"\"\t\t\tfor an empty or unknown register\n+      <CTRL-V> is one character with value 0x16.\n+      The {regname} argument is a string.  If {regname} is not\n+      specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getregtype()\n+\n+    ]=],\n+    name = 'getregtype',\n+    params = { { 'regname', 'string' } },\n+    returns = 'string',\n+    signature = 'getregtype([{regname}])',\n+  },\n+  getscriptinfo = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with information about all the sourced Vim\n+      scripts in the order they were sourced, like what\n+      `:scriptnames` shows.\n+\n+      The optional Dict argument {opts} supports the following\n+      optional items:\n+          name\tScript name match pattern. If specified,\n+      \t\tand \"sid\" is not specified, information about\n+      \t\tscripts with a name that match the pattern\n+      \t\t\"name\" are returned.\n+          sid\t\tScript ID |<SID>|.  If specified, only\n+      \t\tinformation about the script with ID \"sid\" is\n+      \t\treturned and \"name\" is ignored.\n+\n+      Each item in the returned List is a |Dict| with the following\n+      items:\n+          autoload\tAlways set to FALSE.\n+          functions   List of script-local function names defined in\n+      \t\tthe script.  Present only when a particular\n+      \t\tscript is specified using the \"sid\" item in\n+      \t\t{opts}.\n+          name\tVim script file name.\n+          sid\t\tScript ID |<SID>|.\n+          variables   A dictionary with the script-local variables.\n+      \t\tPresent only when a particular script is\n+      \t\tspecified using the \"sid\" item in {opts}.\n+      \t\tNote that this is a copy, the value of\n+      \t\tscript-local variables cannot be changed using\n+      \t\tthis dictionary.\n+          version\tVimscript version, always 1\n+\n+      Examples: >\n+      \t:echo getscriptinfo({'name': 'myscript'})\n+      \t:echo getscriptinfo({'sid': 15}).variables\n+      <\n+    ]=],\n+    name = 'getscriptinfo',\n+    params = { { 'opts', 'table' } },\n+    signature = 'getscriptinfo([{opts}])',\n+  },\n+  gettabinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      If {tabnr} is not specified, then information about all the\n+      tab pages is returned as a |List|. Each List item is a\n+      |Dictionary|.  Otherwise, {tabnr} specifies the tab page\n+      number and information about that one is returned.  If the tab\n+      page does not exist an empty List is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \ttabnr\t\ttab page number.\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\ttabpage-local variables\n+      \twindows\t\tList of |window-ID|s in the tab page.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabinfo()\n+\n+    ]=],\n+    name = 'gettabinfo',\n+    params = { { 'tabnr', 'integer' } },\n+    signature = 'gettabinfo([{tabnr}])',\n+  },\n+  gettabvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of a tab-local variable {varname} in tab page\n+      {tabnr}. |t:var|\n+      Tabs are numbered starting with one.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all tab-local variables is returned.\n+      Note that the name without \"t:\" must be used.\n+      When the tab or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabvar(varname)\n+\n+    ]=],\n+    name = 'gettabvar',\n+    params = { { 'tabnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'gettabvar({tabnr}, {varname} [, {def}])',\n+  },\n+  gettabwinvar = {\n+    args = { 3, 4 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of window-local variable {varname} in window\n+      {winnr} in tab page {tabnr}.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all window-local variables is returned.\n+      When {varname} is equal to \"&\" get the values of all\n+      window-local options in a |Dictionary|.\n+      Otherwise, when {varname} starts with \"&\" get the value of a\n+      window-local option.\n+      Note that {varname} must be the name without \"w:\".\n+      Tabs are numbered starting with one.  For the current tabpage\n+      use |getwinvar()|.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is zero the current window is used.\n+      This also works for a global option, buffer-local option and\n+      window-local option, but it doesn't work for a global variable\n+      or buffer-local variable.\n+      When the tab, window or variable doesn't exist {def} or an\n+      empty string is returned, there is no error message.\n+      Examples: >\n+      \t:let list_is_on = gettabwinvar(1, 2, '&list')\n+      \t:echo \"myvar = \" .. gettabwinvar(3, 1, 'myvar')\n+      <\n+      To obtain all window-local variables use: >\n+      \tgettabwinvar({tabnr}, {winnr}, '&')\n+\n+      <Can also be used as a |method|: >\n+      \tGetTabnr()->gettabwinvar(winnr, varname)\n+\n+    ]=],\n+    name = 'gettabwinvar',\n+    params = {\n+      { 'tabnr', 'integer' },\n+      { 'winnr', 'integer' },\n+      { 'varname', 'string' },\n+      { 'def', 'any' },\n     },\n-    buflisted={args=1, base=1, returns=VIMBOOL},\n-    bufload={args=1, base=1, returns=false},\n-    bufloaded={args=1, base=1, returns=VIMBOOL},\n-    bufname={args={0, 1}, base=1, returns='string'},\n-    bufnr={args={0, 2}, base=1, returns='integer'},\n-    bufwinid={args=1, base=1, returns='integer'},\n-    bufwinnr={args=1, base=1, returns='integer'},\n-    byte2line={args=1, base=1, returns='integer'},\n-    byteidx={args={2, 3}, base=1, fast=true, returns='integer'},\n-    byteidxcomp={args={2, 3}, base=1, fast=true, returns='integer'},\n-    call={args={2, 3}, base=1},\n-    ceil={args=1, base=1, float_func=\"ceil\"},\n-    changenr={returns='integer'},\n-    chanclose={args={1, 2}},\n-    chansend={args=2},\n-    char2nr={args={1, 2}, base=1, fast=true},\n-    charclass={args=1, base=1},\n-    charcol={args={1, 2}, base=1},\n-    charidx={args={2, 4}, base=1},\n-    chdir={args=1, base=1},\n-    cindent={args=1, base=1},\n-    clearmatches={args={0, 1}, base=1},\n-    col={args={1, 2}, base=1, returns='integer'},\n-    complete={args=2, base=2, returns=false},\n-    complete_add={args=1, base=1, returns='0|1|2'},\n-    complete_check={returns=VIMBOOL},\n-    complete_info={args={0, 1}, base=1, returns='table'},\n-    confirm={args={1, 4}, base=1},\n-    copy={args=1, base=1},\n-    cos={args=1, base=1, float_func=\"cos\"},\n-    cosh={args=1, base=1, float_func=\"cosh\"},\n-    count={args={2, 4}, base=1},\n-    ctxget={args={0, 1}},\n-    ctxpop={},\n-    ctxpush={args={0, 1}},\n-    ctxset={args={1, 2}},\n-    ctxsize={},\n-    cursor={args={1, 3}, base=1},\n-    debugbreak={args={1, 1}, base=1},\n-    deepcopy={args={1, 2}, base=1},\n-    delete={args={1,2}, base=1, returns='integer'},\n-    deletebufline={args={2,3}, base=1},\n-    dictwatcheradd={args=3},\n-    dictwatcherdel={args=3},\n-    did_filetype={fast=true},\n-    diff_filler={args=1, base=1},\n-    diff_hlID={args=2, base=1},\n-    digraph_get={args=1, base=1},\n-    digraph_getlist={args={0, 1}, base=1},\n-    digraph_set={args=2, base=1},\n-    digraph_setlist={args=1, base=1},\n-    empty={args=1, base=1},\n-    environ={fast=true},\n-    escape={args=2, base=1, fast=true},\n-    eval={args=1, base=1},\n-    eventhandler={},\n-    executable={args=1, base=1, fast=true},\n-    execute={args={1, 2}, base=1},\n-    exepath={args=1, base=1},\n-    exists={args=1, base=1, returns=VIMBOOL},\n-    exp={args=1, base=1, float_func=\"exp\"},\n-    expand={args={1, 3}, base=1, returns='string|string[]'},\n-    expandcmd={args={1, 2}, base=1},\n-    extend={args={2, 3}, base=1},\n-    extendnew={args={2, 3}, base=1},\n-    feedkeys={args={1, 2}, base=1},\n-    file_readable={\n-      args=1, base=1, func='f_filereadable',\n-      deprecated = { 'Obsolete name for |filereadable()|.' }\n+    signature = 'gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])',\n+  },\n+  gettagstack = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Dict, which is the tag stack of window {winnr}.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is not specified, the current window is used.\n+      When window {winnr} doesn't exist, an empty Dict is returned.\n+\n+      The returned dictionary contains the following entries:\n+      \tcuridx\t\tCurrent index in the stack. When at\n+      \t\t\ttop of the stack, set to (length + 1).\n+      \t\t\tIndex of bottom of the stack is 1.\n+      \titems\t\tList of items in the stack. Each item\n+      \t\t\tis a dictionary containing the\n+      \t\t\tentries described below.\n+      \tlength\t\tNumber of entries in the stack.\n+\n+      Each item in the stack is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tbuffer number of the current jump\n+      \tfrom\t\tcursor position before the tag jump.\n+      \t\t\tSee |getpos()| for the format of the\n+      \t\t\treturned list.\n+      \tmatchnr\t\tcurrent matching tag number. Used when\n+      \t\t\tmultiple matching tags are found for a\n+      \t\t\tname.\n+      \ttagname\t\tname of the tag\n+\n+      See |tagstack| for more information about the tag stack.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->gettagstack()\n+      <\n+    ]=],\n+    name = 'gettagstack',\n+    params = { { 'winnr', 'integer' } },\n+    signature = 'gettagstack([{winnr}])',\n+  },\n+  gettext = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Translate String {text} if possible.\n+      This is mainly for use in the distributed Vim scripts.  When\n+      generating message translations the {text} is extracted by\n+      xgettext, the translator can add the translated message in the\n+      .po file and Vim will lookup the translation when gettext() is\n+      called.\n+      For {text} double quoted strings are preferred, because\n+      xgettext does not understand escaping in single quoted\n+      strings.\n+    ]=],\n+    name = 'gettext',\n+    params = { { 'text', 'any' } },\n+    signature = 'gettext({text})',\n+  },\n+  getwininfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns information about windows as a |List| with Dictionaries.\n+\n+      If {winid} is given Information about the window with that ID\n+      is returned, as a |List| with one item.  If the window does not\n+      exist the result is an empty list.\n+\n+      Without {winid} information about all the windows in all the\n+      tab pages is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \tbotline\t\tlast complete displayed buffer line\n+      \tbufnr\t\tnumber of buffer in the window\n+      \theight\t\twindow height (excluding winbar)\n+      \tloclist\t\t1 if showing a location list\n+      \tquickfix\t1 if quickfix or location list window\n+      \tterminal\t1 if a terminal window\n+      \ttabnr\t\ttab page number\n+      \ttopline\t\tfirst displayed buffer line\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\twindow-local variables\n+      \twidth\t\twindow width\n+      \twinbar\t\t1 if the window has a toolbar, 0\n+      \t\t\totherwise\n+      \twincol\t\tleftmost screen column of the window;\n+      \t\t\t\"col\" from |win_screenpos()|\n+      \ttextoff\t\tnumber of columns occupied by any\n+      \t\t\t'foldcolumn', 'signcolumn' and line\n+      \t\t\tnumber in front of the text\n+      \twinid\t\t|window-ID|\n+      \twinnr\t\twindow number\n+      \twinrow\t\ttopmost screen line of the window;\n+      \t\t\t\"row\" from |win_screenpos()|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getwininfo()\n+\n+    ]=],\n+    name = 'getwininfo',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getwininfo([{winid}])',\n+  },\n+  getwinpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a |List| with two numbers, the result of\n+      |getwinposx()| and |getwinposy()| combined:\n+      \t[x-pos, y-pos]\n+      {timeout} can be used to specify how long to wait in msec for\n+      a response from the terminal.  When omitted 100 msec is used.\n+\n+      Use a longer time for a remote terminal.\n+      When using a value less than 10 and no response is received\n+      within that time, a previously reported position is returned,\n+      if available.  This can be used to poll for the position and\n+      do some work in the meantime: >\n+      \twhile 1\n+      \t  let res = getwinpos(1)\n+      \t  if res[0] >= 0\n+      \t    break\n+      \t  endif\n+      \t  \" Do some work here\n+      \tendwhile\n+      <\n+      Can also be used as a |method|: >\n+      \tGetTimeout()->getwinpos()\n+      <\n+    ]=],\n+    name = 'getwinpos',\n+    params = { { 'timeout', 'integer' } },\n+    signature = 'getwinpos([{timeout}])',\n+  },\n+  getwinposx = {\n+    desc = [=[\n+      The result is a Number, which is the X coordinate in pixels of\n+      the left hand side of the GUI Vim window.  The result will be\n+      -1 if the information is not available.\n+      The value can be used with `:winpos`.\n+    ]=],\n+    name = 'getwinposx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposx()',\n+  },\n+  getwinposy = {\n+    desc = [=[\n+      The result is a Number, which is the Y coordinate in pixels of\n+      the top of the GUI Vim window.  The result will be -1 if the\n+      information is not available.\n+      The value can be used with `:winpos`.\n+\n+    ]=],\n+    name = 'getwinposy',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposy()',\n+  },\n+  getwinvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |gettabwinvar()| for the current tabpage.\n+      Examples: >\n+      \t:let list_is_on = getwinvar(2, '&list')\n+      \t:echo \"myvar = \" .. getwinvar(1, 'myvar')\n+\n+      <Can also be used as a |method|: >\n+      \tGetWinnr()->getwinvar(varname)\n+      <\n+    ]=],\n+    name = 'getwinvar',\n+    params = { { 'winnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getwinvar({winnr}, {varname} [, {def}])',\n+  },\n+  glob = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      Expand the file wildcards in {expr}.  See |wildcards| for the\n+      use of special characters.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+      'wildignorecase' always applies.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is,\n+      you also get filenames containing newlines correctly.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty String or List.\n+\n+      You can also use |readdir()| if you need to do complicated\n+      things, such as limiting the number of matches.\n+\n+      A name for a non-existing file is not included.  A symbolic\n+      link is only included if it points to an existing file.\n+      However, when the {alllinks} argument is present and it is\n+      |TRUE| then all symbolic links are included.\n+\n+      For most systems backticks can be used to get files names from\n+      any external command.  Example: >\n+      \t:let tagfiles = glob(\"`find . -name tags -print`\")\n+      \t:let &tags = substitute(tagfiles, \"\\n\", \",\", \"g\")\n+      <The result of the program inside the backticks should be one\n+      item per line.  Spaces inside an item are allowed.\n+\n+      See |expand()| for expanding special Vim variables.  See\n+      |system()| for getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob()\n+\n+    ]=],\n+    name = 'glob',\n+    params = { { 'expr', 'any' }, { 'nosuf', 'boolean' }, { 'list', 'any' }, { 'alllinks', 'any' } },\n+    signature = 'glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])',\n+  },\n+  glob2regpat = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert a file pattern, as used by glob(), into a search\n+      pattern.  The result can be used to match with a string that\n+      is a file name.  E.g. >\n+      \tif filename =~ glob2regpat('Make*.mak')\n+      <This is equivalent to: >\n+      \tif filename =~ '^Make.*\\.mak$'\n+      <When {string} is an empty string the result is \"^$\", match an\n+      empty string.\n+      Note that the result depends on the system.  On MS-Windows\n+      a backslash usually means a path separator.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob2regpat()\n+      <\n+    ]=],\n+    name = 'glob2regpat',\n+    params = { { 'string', 'string' } },\n+    signature = 'glob2regpat({string})',\n+  },\n+  globpath = {\n+    args = { 2, 5 },\n+    base = 2,\n+    desc = [=[\n+      Perform glob() for String {expr} on all directories in {path}\n+      and concatenate the results.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\")\n+      <\n+      {path} is a comma-separated list of directory names.  Each\n+      directory name is prepended to {expr} and expanded like with\n+      |glob()|.  A path separator is inserted when needed.\n+      To add a comma inside a directory name escape it with a\n+      backslash.  Note that on MS-Windows a directory may have a\n+      trailing backslash, remove it if you put a comma after it.\n+      If the expansion fails for one of the directories, there is no\n+      error message.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is, you\n+      also get filenames containing newlines correctly. Otherwise\n+      the result is a String and when there are several matches,\n+      they are separated by <NL> characters.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\", 0, 1)\n+      <\n+      {allinks} is used as with |glob()|.\n+\n+      The \"**\" item can be used to search in a directory tree.\n+      For example, to find all \"README.txt\" files in the directories\n+      in 'runtimepath' and below: >\n+      \t:echo globpath(&rtp, \"**/README.txt\")\n+      <Upwards search and limiting the depth of \"**\" is not\n+      supported, thus using 'path' will not always work properly.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetExpr()->globpath(&rtp)\n+      <\n+    ]=],\n+    name = 'globpath',\n+    params = {\n+      { 'path', 'string' },\n+      { 'expr', 'any' },\n+      { 'nosuf', 'boolean' },\n+      { 'list', 'any' },\n+      { 'allinks', 'any' },\n     },\n-    filereadable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filewritable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filter={args=2, base=1},\n-    finddir={args={1, 3}, base=1},\n-    findfile={args={1, 3}, base=1},\n-    flatten={args={1, 2}, base=1, returns='any[]|0'},\n-    flattennew={args={1, 2}, base=1, returns='any[]|0'},\n-    float2nr={args=1, base=1},\n-    floor={args=1, base=1, float_func=\"floor\"},\n-    fmod={args=2, base=1},\n-    fnameescape={args=1, base=1, fast=true, returns='string'},\n-    fnamemodify={args=2, base=1, fast=true, returns='string'},\n-    foldclosed={args=1, base=1, returns='integer'},\n-    foldclosedend={args=1, base=1, returns='integer'},\n-    foldlevel={args=1, base=1, returns='integer'},\n-    foldtext={returns='string'},\n-    foldtextresult={args=1, base=1, returns='string'},\n-    foreground={},\n-    fullcommand={args=1, base=1, returns='string'},\n-    funcref={args={1, 3}, base=1},\n-    ['function']={args={1, 3}, base=1},\n-    garbagecollect={args={0, 1}},\n-    get={args={2, 3}, base=1},\n-    getbufinfo={args={0, 1}, base=1},\n-    getbufline={args={2, 3}, base=1},\n-    getbufoneline={args=2, base=1},\n-    getbufvar={args={2, 3}, base=1},\n-    getcellwidths={},\n-    getchangelist={args={0, 1}, base=1},\n-    getchar={args={0, 1}, returns='integer'},\n-    getcharmod={returns='integer'},\n-    getcharpos={args=1, base=1},\n-    getcharsearch={},\n-    getcharstr={args={0, 1}, returns='string'},\n-    getcmdcompltype={returns='string'},\n-    getcmdline={returns='string'},\n-    getcmdpos={},\n-    getcmdscreenpos={},\n-    getcmdtype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcmdwintype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcompletion={args={2, 3}, base=1, returns='string[]'},\n-    getcurpos={args={0, 1}, base=1},\n-    getcursorcharpos={args={0, 1}, base=1},\n-    getcwd={args={0, 2}, base=1, returns='string'},\n-    getenv={args=1, base=1, returns='string'},\n-    getfontname={args={0, 1}, returns='string'},\n-    getfperm={args=1, base=1, fast=true, returns='string'},\n-    getfsize={args=1, base=1, fast=true, returns='integer'},\n-    getftime={args=1, base=1, fast=true, returns='integer'},\n-    getftype={args=1, base=1, fast=true, returns=\"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\"},\n-    getjumplist={args={0, 2}, base=1},\n-    getline={args={1, 2}, base=1},\n-    getloclist={args={1, 2}},\n-    getmarklist={args={0, 1}, base=1},\n-    getmatches={args={0, 1}},\n-    getmousepos={},\n-    getpid={fast=true, returns='integer'},\n-    getpos={args=1, base=1},\n-    getqflist={args={0, 1}},\n-    getreg={args={0, 3}, base=1, returns='string|string[]'},\n-    getreginfo={args={0, 1}, base=1, returns='table'},\n-    getregtype={args={0, 1}, base=1, returns='string'},\n-    gettabinfo={args={0, 1}, base=1},\n-    gettabvar={args={2, 3}, base=1},\n-    gettabwinvar={args={3, 4}, base=1},\n-    getscriptinfo={args={0, 1}},\n-    gettagstack={args={0, 1}, base=1},\n-    gettext={args=1, base=1},\n-    getwininfo={args={0, 1}, base=1},\n-    getwinpos={args={0, 1}, base=1},\n-    getwinposx={returns='integer'},\n-    getwinposy={returns='integer'},\n-    getwinvar={args={2, 3}, base=1},\n-    glob={args={1, 4}, base=1},\n-    glob2regpat={args=1, base=1},\n-    globpath={args={2, 5}, base=2},\n-    has={args=1, returns=VIMBOOL},\n-    has_key={args=2, base=1, returns=VIMBOOL},\n-    haslocaldir={args={0, 2}, base=1, returns=VIMBOOL},\n-    hasmapto={args={1, 3}, base=1, returns=VIMBOOL},\n-    highlightID={\n-      args=1, base=1, func='f_hlID',\n-      deprecated = { 'Obsolete name for |hlID()|.' }\n+    signature = 'globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])',\n+  },\n+  has = {\n+    args = 1,\n+    desc = [=[\n+      Returns 1 if {feature} is supported, 0 otherwise.  The\n+      {feature} argument is a feature name like \"nvim-0.2.1\" or\n+      \"win32\", see below.  See also |exists()|.\n+\n+      To get the system name use |vim.uv|.os_uname() in Lua: >lua\n+      \tprint(vim.uv.os_uname().sysname)\n+\n+      <If the code has a syntax error then Vimscript may skip the\n+      rest of the line.  Put |:if| and |:endif| on separate lines to\n+      avoid the syntax error: >\n+      \tif has('feature')\n+      \t  let x = this->breaks->without->the->feature\n+      \tendif\n+      <\n+      Vim's compile-time feature-names (prefixed with \"+\") are not\n+      recognized because Nvim is always compiled with all possible\n+      features. |feature-compile|\n+\n+      Feature names can be:\n+      1.  Nvim version. For example the \"nvim-0.2.1\" feature means\n+          that Nvim is version 0.2.1 or later: >\n+      \t:if has(\"nvim-0.2.1\")\n+\n+      <2.  Runtime condition or other pseudo-feature. For example the\n+          \"win32\" feature checks if the current system is Windows: >\n+      \t:if has(\"win32\")\n+      <\t\t\t\t\t*feature-list*\n+          List of supported pseudo-feature names:\n+      \tacl\t\t|ACL| support.\n+      \tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n+      \tclipboard\t|clipboard| provider is available.\n+      \tfname_case\tCase in file names matters (for Darwin and MS-Windows\n+      \t\t\tthis is not present).\n+                              gui_running\tNvim has a GUI.\n+      \ticonv\t\tCan use |iconv()| for conversion.\n+      \tlinux\t\tLinux system.\n+      \tmac\t\tMacOS system.\n+      \tnvim\t\tThis is Nvim.\n+      \tpython3\t\tLegacy Vim |python3| interface. |has-python|\n+      \tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n+      \tsun\t\tSunOS system.\n+      \tttyin\t\tinput is a terminal (tty).\n+      \tttyout\t\toutput is a terminal (tty).\n+      \tunix\t\tUnix system.\n+      \t*vim_starting*\tTrue during |startup|.\n+      \twin32\t\tWindows system (32 or 64 bit).\n+      \twin64\t\tWindows system (64 bit).\n+      \twsl\t\tWSL (Windows Subsystem for Linux) system.\n+\n+      \t\t\t\t\t*has-patch*\n+      3.  Vim patch. For example the \"patch123\" feature means that\n+          Vim patch 123 at the current |v:version| was included: >\n+      \t:if v:version > 602 || v:version == 602 && has(\"patch148\")\n+\n+      <4.  Vim version. For example the \"patch-7.4.237\" feature means\n+          that Nvim is Vim-compatible to version 7.4.237 or later. >\n+      \t:if has(\"patch-7.4.237\")\n+      <\n+    ]=],\n+    name = 'has',\n+    params = { { 'feature', 'any' } },\n+    returns = '0|1',\n+    signature = 'has({feature})',\n+  },\n+  has_key = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if |Dictionary| {dict}\n+      has an entry with key {key}.  FALSE otherwise. The {key}\n+      argument is a string.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->has_key(key)\n+\n+    ]=],\n+    name = 'has_key',\n+    params = { { 'dict', 'any' }, { 'key', 'any' } },\n+    returns = '0|1',\n+    signature = 'has_key({dict}, {key})',\n+  },\n+  haslocaldir = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when the window has set a\n+      local path via |:lcd| or when {winnr} is -1 and the tabpage\n+      has set a local path via |:tcd|, otherwise 0.\n+\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing argument implies 0.\n+      Thus the following are equivalent: >\n+      \thaslocaldir()\n+      \thaslocaldir(0)\n+      \thaslocaldir(0, 0)\n+      <With {winnr} use that window in the current tabpage.\n+      With {winnr} and {tabnr} use the window in that tabpage.\n+      {winnr} can be the window number or the |window-ID|.\n+      If {winnr} is -1 it is ignored, only the tab is resolved.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->haslocaldir()\n+\n+    ]=],\n+    name = 'haslocaldir',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = '0|1',\n+    signature = 'haslocaldir([{winnr} [, {tabnr}]])',\n+  },\n+  hasmapto = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if there is a mapping\n+      that contains {what} in somewhere in the rhs (what it is\n+      mapped to) and this mapping exists in one of the modes\n+      indicated by {mode}.\n+      The arguments {what} and {mode} are strings.\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.  Don't forget to specify Insert and/or\n+      Command-line mode.\n+      Both the global mappings and the mappings local to the current\n+      buffer are checked for a match.\n+      If no matching mapping is found FALSE is returned.\n+      The following characters are recognized in {mode}:\n+      \tn\tNormal mode\n+      \tv\tVisual and Select mode\n+      \tx\tVisual mode\n+      \ts\tSelect mode\n+      \to\tOperator-pending mode\n+      \ti\tInsert mode\n+      \tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n+      \tc\tCommand-line mode\n+      When {mode} is omitted, \"nvo\" is used.\n+\n+      This function is useful to check if a mapping already exists\n+      to a function in a Vim script.  Example: >\n+      \t:if !hasmapto('\\ABCdoit')\n+      \t:   map <Leader>d \\ABCdoit\n+      \t:endif\n+      <This installs the mapping to \"\\ABCdoit\" only if there isn't\n+      already a mapping to \"\\ABCdoit\".\n+\n+      Can also be used as a |method|: >\n+      \tGetRHS()->hasmapto()\n+\n+    ]=],\n+    name = 'hasmapto',\n+    params = { { 'what', 'any' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    returns = '0|1',\n+    signature = 'hasmapto({what} [, {mode} [, {abbr}]])',\n+  },\n+  highlightID = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlID()|.\n+    ]=],\n+    func = 'f_hlID',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlightID({name})',\n+  },\n+  highlight_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlexists()|.\n+    ]=],\n+    func = 'f_hlexists',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlight_exists({name})',\n+  },\n+  histadd = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Add the String {item} to the history {history} which can be\n+      one of:\t\t\t\t\t*hist-names*\n+      \t\"cmd\"\t or \":\"\t  command line history\n+      \t\"search\" or \"/\"   search pattern history\n+      \t\"expr\"\t or \"=\"   typed expression history\n+      \t\"input\"  or \"@\"\t  input line history\n+      \t\"debug\"  or \">\"   debug command history\n+      \tempty\t\t  the current or last used history\n+      The {history} string does not need to be the whole name, one\n+      character is sufficient.\n+      If {item} does already exist in the history, it will be\n+      shifted to become the newest entry.\n+      The result is a Number: TRUE if the operation was successful,\n+      otherwise FALSE is returned.\n+\n+      Example: >\n+      \t:call histadd(\"input\", strftime(\"%Y %b %d\"))\n+      \t:let date=input(\"Enter date: \")\n+      <This function is not available in the |sandbox|.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetHistory()->histadd('search')\n+\n+    ]=],\n+    name = 'histadd',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histadd({history}, {item})',\n+  },\n+  histdel = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Clear {history}, i.e. delete all its entries.  See |hist-names|\n+      for the possible values of {history}.\n+\n+      If the parameter {item} evaluates to a String, it is used as a\n+      regular expression.  All entries matching that expression will\n+      be removed from the history (if there are any).\n+      Upper/lowercase must match, unless \"\\c\" is used |/\\c|.\n+      If {item} evaluates to a Number, it will be interpreted as\n+      an index, see |:history-indexing|.  The respective entry will\n+      be removed if it exists.\n+\n+      The result is TRUE for a successful operation, otherwise FALSE\n+      is returned.\n+\n+      Examples:\n+      Clear expression register history: >\n+      \t:call histdel(\"expr\")\n+      <\n+      Remove all entries starting with \"*\" from the search history: >\n+      \t:call histdel(\"/\", '^\\*')\n+      <\n+      The following three are equivalent: >\n+      \t:call histdel(\"search\", histnr(\"search\"))\n+      \t:call histdel(\"search\", -1)\n+      \t:call histdel(\"search\", '^' .. histget(\"search\", -1) .. '$')\n+      <\n+      To delete the last search pattern and use the last-but-one for\n+      the \"n\" command and 'hlsearch': >\n+      \t:call histdel(\"search\", -1)\n+      \t:let @/ = histget(\"search\", -1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histdel()\n+\n+    ]=],\n+    name = 'histdel',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histdel({history} [, {item}])',\n+  },\n+  histget = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, the entry with Number {index} from\n+      {history}.  See |hist-names| for the possible values of\n+      {history}, and |:history-indexing| for {index}.  If there is\n+      no such entry, an empty String is returned.  When {index} is\n+      omitted, the most recent item from the history is used.\n+\n+      Examples:\n+      Redo the second last search from history. >\n+      \t:execute '/' .. histget(\"search\", -2)\n+\n+      <Define an Ex command \":H {num}\" that supports re-execution of\n+      the {num}th entry from the output of |:history|. >\n+      \t:command -nargs=1 H execute histget(\"cmd\", 0+<args>)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histget()\n+\n+    ]=],\n+    name = 'histget',\n+    params = { { 'history', 'any' }, { 'index', 'any' } },\n+    returns = 'string',\n+    signature = 'histget({history} [, {index}])',\n+  },\n+  histnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is the Number of the current entry in {history}.\n+      See |hist-names| for the possible values of {history}.\n+      If an error occurred, -1 is returned.\n+\n+      Example: >\n+      \t:let inp_index = histnr(\"expr\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetHistory()->histnr()\n+      <\n+    ]=],\n+    name = 'histnr',\n+    params = { { 'history', 'any' } },\n+    returns = 'integer',\n+    signature = 'histnr({history})',\n+  },\n+  hlID = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the ID of the highlight group\n+      with name {name}.  When the highlight group doesn't exist,\n+      zero is returned.\n+      This can be used to retrieve information about the highlight\n+      group.  For example, to get the background color of the\n+      \"Comment\" group: >\n+      \t:echo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->hlID()\n+\n+    ]=],\n+    name = 'hlID',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'hlID({name})',\n+  },\n+  hlexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if a highlight group\n+      called {name} exists.  This is when the group has been\n+      defined in some way.  Not necessarily when highlighting has\n+      been defined for it, it may also have been used for a syntax\n+      item.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->hlexists()\n+      <\n+    ]=],\n+    name = 'hlexists',\n+    params = { { 'name', 'string' } },\n+    returns = '0|1',\n+    signature = 'hlexists({name})',\n+  },\n+  hostname = {\n+    desc = [=[\n+      The result is a String, which is the name of the machine on\n+      which Vim is currently running.  Machine names greater than\n+      256 characters long are truncated.\n+\n+    ]=],\n+    fast = true,\n+    name = 'hostname',\n+    params = {},\n+    returns = 'string',\n+    signature = 'hostname()',\n+  },\n+  iconv = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the text {string} converted\n+      from encoding {from} to encoding {to}.\n+      When the conversion completely fails an empty string is\n+      returned.  When some characters could not be converted they\n+      are replaced with \"?\".\n+      The encoding names are whatever the iconv() library function\n+      can accept, see \":!man 3 iconv\".\n+      Note that Vim uses UTF-8 for all Unicode encodings, conversion\n+      from/to UCS-2 is automatically changed to use UTF-8.  You\n+      cannot use UCS-2 in a string anyway, because of the NUL bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->iconv('latin1', 'utf-8')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'iconv',\n+    params = { { 'string', 'string' }, { 'from', 'any' }, { 'to', 'any' } },\n+    signature = 'iconv({string}, {from}, {to})',\n+  },\n+  id = {\n+    args = 1,\n+    desc = [=[\n+      Returns a |String| which is a unique identifier of the\n+      container type (|List|, |Dict|, |Blob| and |Partial|). It is\n+      guaranteed that for the mentioned types `id(v1) ==# id(v2)`\n+      returns true iff `type(v1) == type(v2) && v1 is v2`.\n+      Note that |v:_null_string|, |v:_null_list|, |v:_null_dict| and\n+      |v:_null_blob| have the same `id()` with different types\n+      because they are internally represented as NULL pointers.\n+      `id()` returns a hexadecimal representanion of the pointers to\n+      the containers (i.e. like `0x994a40`), same as `printf(\"%p\",\n+      {expr})`, but it is advised against counting on the exact\n+      format of the return value.\n+\n+      It is not guaranteed that `id(no_longer_existing_container)`\n+      will not be equal to some other `id()`: new containers may\n+      reuse identifiers of the garbage-collected ones.\n+\n+    ]=],\n+    name = 'id',\n+    params = { { 'expr', 'any' } },\n+    signature = 'id({expr})',\n+  },\n+  indent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      current buffer.  The indent is counted in spaces, the value\n+      of 'tabstop' is relevant.  {lnum} is used just like in\n+      |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->indent()\n+\n+    ]=],\n+    name = 'indent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'indent({lnum})',\n+  },\n+  index = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Find {expr} in {object} and return its index.  See\n+      |indexof()| for using a lambda to select the item.\n+\n+      If {object} is a |List| return the lowest index where the item\n+      has a value equal to {expr}.  There is no automatic\n+      conversion, so the String \"4\" is different from the Number 4.\n+      And the Number 4 is different from the Float 4.0.  The value\n+      of 'ignorecase' is not used here, case matters as indicated by\n+      the {ic} argument.\n+\n+      If {object} is a |Blob| return the lowest index where the byte\n+      value is equal to {expr}.\n+\n+      If {start} is given then start looking at the item with index\n+      {start} (may be negative for an item relative to the end).\n+\n+      When {ic} is given and it is |TRUE|, ignore case.  Otherwise\n+      case must match.\n+\n+      -1 is returned when {expr} is not found in {object}.\n+      Example: >\n+      \t:let idx = index(words, \"the\")\n+      \t:if index(numbers, 123) >= 0\n+\n+      <Can also be used as a |method|: >\n+      \tGetObject()->index(what)\n+\n+    ]=],\n+    name = 'index',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'start', 'any' }, { 'ic', 'any' } },\n+    signature = 'index({object}, {expr} [, {start} [, {ic}]])',\n+  },\n+  indexof = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Returns the index of an item in {object} where {expr} is\n+      v:true.  {object} must be a |List| or a |Blob|.\n+\n+      If {object} is a |List|, evaluate {expr} for each item in the\n+      List until the expression is v:true and return the index of\n+      this item.\n+\n+      If {object} is a |Blob| evaluate {expr} for each byte in the\n+      Blob until the expression is v:true and return the index of\n+      this byte.\n+\n+      {expr} must be a |string| or |Funcref|.\n+\n+      If {expr} is a |string|: If {object} is a |List|, inside\n+      {expr} |v:key| has the index of the current List item and\n+      |v:val| has the value of the item.  If {object} is a |Blob|,\n+      inside {expr} |v:key| has the index of the current byte and\n+      |v:val| has the byte value.\n+\n+      If {expr} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item is found and the\n+      search should stop.\n+\n+      The optional argument {opts} is a Dict and supports the\n+      following items:\n+          startidx\tstart evaluating {expr} at the item with this\n+      \t\tindex; may be negative for an item relative to\n+      \t\tthe end\n+      Returns -1 when {expr} evaluates to v:false for all the items.\n+      Example: >\n+      \t:let l = [#{n: 10}, #{n: 20}, #{n: 30}]\n+      \t:echo indexof(l, \"v:val.n == 20\")\n+      \t:echo indexof(l, {i, v -> v.n == 30})\n+      \t:echo indexof(l, \"v:val.n == 20\", #{startidx: 1})\n+\n+      <Can also be used as a |method|: >\n+      \tmylist->indexof(expr)\n+\n+    ]=],\n+    name = 'indexof',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'opts', 'table' } },\n+    signature = 'indexof({object}, {expr} [, {opts}])',\n+  },\n+  input = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = '',\n+    name = 'input',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' }, { 'completion', 'any' } },\n+    signature = 'input({prompt} [, {text} [, {completion}]])',\n+  },\n+  input__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is whatever the user typed on\n+      the command-line.  The {prompt} argument is either a prompt\n+      string, or a blank string (for no prompt).  A '\\n' can be used\n+      in the prompt to start a new line.\n+\n+      In the second form it accepts a single dictionary with the\n+      following keys, any of which may be omitted:\n+\n+      Key           Default  Description ~\n+      prompt        \"\"       Same as {prompt} in the first form.\n+      default       \"\"       Same as {text} in the first form.\n+      completion    nothing  Same as {completion} in the first form.\n+      cancelreturn  \"\"       The value returned when the dialog is\n+                             cancelled.\n+      highlight     nothing  Highlight handler: |Funcref|.\n+\n+      The highlighting set with |:echohl| is used for the prompt.\n+      The input is entered just like a command-line, with the same\n+      editing commands and mappings.  There is a separate history\n+      for lines typed for input().\n+      Example: >\n+      \t:if input(\"Coffee or beer? \") == \"beer\"\n+      \t:  echo \"Cheers!\"\n+      \t:endif\n+      <\n+      If the optional {text} argument is present and not empty, this\n+      is used for the default reply, as if the user typed this.\n+      Example: >\n+      \t:let color = input(\"Color? \", \"white\")\n+\n+      <The optional {completion} argument specifies the type of\n+      completion supported for the input.  Without it completion is\n+      not performed.  The supported completion types are the same as\n+      that can be supplied to a user-defined command using the\n+      \"-complete=\" argument.  Refer to |:command-completion| for\n+      more information.  Example: >\n+      \tlet fname = input(\"File: \", \"\", \"file\")\n+\n+      <\t\t\t*input()-highlight* *E5400* *E5402*\n+      The optional `highlight` key allows specifying function which\n+      will be used for highlighting user input.  This function\n+      receives user input as its only argument and must return\n+      a list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n+      where\n+      \thl_start_col is the first highlighted column,\n+      \thl_end_col is the last highlighted column (+ 1!),\n+      \thl_group is |:hi| group used for highlighting.\n+      \t\t\t      *E5403* *E5404* *E5405* *E5406*\n+      Both hl_start_col and hl_end_col + 1 must point to the start\n+      of the multibyte character (highlighting must not break\n+      multibyte characters), hl_end_col + 1 may be equal to the\n+      input length.  Start column must be in range [0, len(input)),\n+      end column must be in range (hl_start_col, len(input)],\n+      sections must be ordered so that next hl_start_col is greater\n+      then or equal to previous hl_end_col.\n+\n+      Example (try some input with parentheses): >\n+      \thighlight RBP1 guibg=Red ctermbg=red\n+      \thighlight RBP2 guibg=Yellow ctermbg=yellow\n+      \thighlight RBP3 guibg=Green ctermbg=green\n+      \thighlight RBP4 guibg=Blue ctermbg=blue\n+      \tlet g:rainbow_levels = 4\n+      \tfunction! RainbowParens(cmdline)\n+      \t  let ret = []\n+      \t  let i = 0\n+      \t  let lvl = 0\n+      \t  while i < len(a:cmdline)\n+      \t    if a:cmdline[i] is# '('\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t      let lvl += 1\n+      \t    elseif a:cmdline[i] is# ')'\n+      \t      let lvl -= 1\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t    endif\n+      \t    let i += 1\n+      \t  endwhile\n+      \t  return ret\n+      \tendfunction\n+      \tcall input({'prompt':'>','highlight':'RainbowParens'})\n+      <\n+      Highlight function is called at least once for each new\n+      displayed input string, before command-line is redrawn.  It is\n+      expected that function is pure for the duration of one input()\n+      call, i.e. it produces the same output for the same input, so\n+      output may be memoized.  Function is run like under |:silent|\n+      modifier. If the function causes any errors, it will be\n+      skipped for the duration of the current input() call.\n+\n+      Highlighting is disabled if command-line contains arabic\n+      characters.\n+\n+      NOTE: This function must not be used in a startup file, for\n+      the versions that only run in GUI mode (e.g., the Win32 GUI).\n+      Note: When input() is called from within a mapping it will\n+      consume remaining characters from that mapping, because a\n+      mapping is handled like the characters were typed.\n+      Use |inputsave()| before input() and |inputrestore()|\n+      after input() to avoid that.  Another solution is to avoid\n+      that further characters follow in the mapping, e.g., by using\n+      |:execute| or |:normal|.\n+\n+      Example with a mapping: >\n+      \t:nmap \\x :call GetFoo()<CR>:exe \"/\" .. Foo<CR>\n+      \t:function GetFoo()\n+      \t:  call inputsave()\n+      \t:  let g:Foo = input(\"enter search pattern: \")\n+      \t:  call inputrestore()\n+      \t:endfunction\n+\n+      <Can also be used as a |method|: >\n+      \tGetPrompt()->input()\n+\n+    ]=],\n+    name = 'input',\n+    params = { { 'opts', 'table' } },\n+    signature = 'input({opts})',\n+  },\n+  inputdialog = {\n+    args = { 1, 3 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Use |input()| instead.\n+    ]=],\n+    params = VARARGS,\n+    signature = 'input(...)',\n+  },\n+  inputlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      {textlist} must be a |List| of strings.  This |List| is\n+      displayed, one string per line.  The user will be prompted to\n+      enter a number, which is returned.\n+      The user can also select an item by clicking on it with the\n+      mouse, if the mouse is enabled in the command line ('mouse' is\n+      \"a\" or includes \"c\").  For the first string 0 is returned.\n+      When clicking above the first item a negative number is\n+      returned.  When clicking on the prompt one more than the\n+      length of {textlist} is returned.\n+      Make sure {textlist} has less than 'lines' entries, otherwise\n+      it won't work.  It's a good idea to put the entry number at\n+      the start of the string.  And put a prompt in the first item.\n+      Example: >\n+      \tlet color = inputlist(['Select color:', '1. red',\n+      \t\t\\ '2. green', '3. blue'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetChoices()->inputlist()\n+\n+    ]=],\n+    name = 'inputlist',\n+    params = { { 'textlist', 'any' } },\n+    signature = 'inputlist({textlist})',\n+  },\n+  inputrestore = {\n+    desc = [=[\n+      Restore typeahead that was saved with a previous |inputsave()|.\n+      Should be called the same number of times inputsave() is\n+      called.  Calling it more often is harmless though.\n+      Returns TRUE when there is nothing to restore, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputrestore',\n+    params = {},\n+    signature = 'inputrestore()',\n+  },\n+  inputsave = {\n+    desc = [=[\n+      Preserve typeahead (also from mappings) and clear it, so that\n+      a following prompt gets input from the user.  Should be\n+      followed by a matching inputrestore() after the prompt.  Can\n+      be used several times, in which case there must be just as\n+      many inputrestore() calls.\n+      Returns TRUE when out of memory, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputsave',\n+    params = {},\n+    signature = 'inputsave()',\n+  },\n+  inputsecret = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      This function acts much like the |input()| function with but\n+      two exceptions:\n+      a) the user's response will be displayed as a sequence of\n+      asterisks (\"*\") thereby keeping the entry secret, and\n+      b) the user's response will not be recorded on the input\n+      |history| stack.\n+      The result is a String, which is whatever the user actually\n+      typed on the command-line in response to the issued prompt.\n+      NOTE: Command-line completion is not supported.\n+\n+      Can also be used as a |method|: >\n+      \tGetPrompt()->inputsecret()\n+\n+    ]=],\n+    name = 'inputsecret',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' } },\n+    signature = 'inputsecret({prompt} [, {text}])',\n+  },\n+  insert = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When {object} is a |List| or a |Blob| insert {item} at the start\n+      of it.\n+\n+      If {idx} is specified insert {item} before the item with index\n+      {idx}.  If {idx} is zero it goes before the first item, just\n+      like omitting {idx}.  A negative {idx} is also possible, see\n+      |list-index|.  -1 inserts just before the last item.\n+\n+      Returns the resulting |List| or |Blob|.  Examples: >\n+      \t:let mylist = insert([2, 3, 5], 1)\n+      \t:call insert(mylist, 4, -1)\n+      \t:call insert(mylist, 6, len(mylist))\n+      <The last example can be done simpler with |add()|.\n+      Note that when {item} is a |List| it is inserted as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->insert(item)\n+\n+    ]=],\n+    name = 'insert',\n+    params = { { 'object', 'any' }, { 'item', 'any' }, { 'idx', 'integer' } },\n+    signature = 'insert({object}, {item} [, {idx}])',\n+  },\n+  interrupt = {\n+    args = 0,\n+    desc = [=[\n+      Interrupt script execution.  It works more or less like the\n+      user typing CTRL-C, most commands won't execute and control\n+      returns to the user.  This is useful to abort execution\n+      from lower down, e.g. in an autocommand.  Example: >\n+      :function s:check_typoname(file)\n+      :   if fnamemodify(a:file, ':t') == '['\n+      :       echomsg 'Maybe typo'\n+      :       call interrupt()\n+      :   endif\n+      :endfunction\n+      :au BufWritePre * call s:check_typoname(expand('<amatch>'))\n+\n+    ]=],\n+    name = 'interrupt',\n+    params = {},\n+    signature = 'interrupt()',\n+  },\n+  invert = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Bitwise invert.  The argument is converted to a number.  A\n+      List, Dict or Float argument causes an error.  Example: >\n+      \t:let bits = invert(bits)\n+      <Can also be used as a |method|: >\n+      \t:let bits = bits->invert()\n+\n+    ]=],\n+    name = 'invert',\n+    params = { { 'expr', 'any' } },\n+    signature = 'invert({expr})',\n+  },\n+  isdirectory = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a directory\n+      with the name {directory} exists.  If {directory} doesn't\n+      exist, or isn't a directory, the result is |FALSE|.  {directory}\n+      is any expression, which is used as a String.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->isdirectory()\n+\n+    ]=],\n+    fast = true,\n+    name = 'isdirectory',\n+    params = { { 'directory', 'any' } },\n+    returns = '0|1',\n+    signature = 'isdirectory({directory})',\n+  },\n+  isinf = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return 1 if {expr} is a positive infinity, or -1 a negative\n+      infinity, otherwise 0. >\n+      \t:echo isinf(1.0 / 0.0)\n+      <\t1 >\n+      \t:echo isinf(-1.0 / 0.0)\n+      <\t-1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isinf()\n+\n+    ]=],\n+    name = 'isinf',\n+    params = { { 'expr', 'any' } },\n+    returns = '1|0|-1',\n+    signature = 'isinf({expr})',\n+  },\n+  islocked = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when {expr} is the\n+      name of a locked variable.\n+      The string argument {expr} must be the name of a variable,\n+      |List| item or |Dictionary| entry, not the variable itself!\n+      Example: >\n+      \t:let alist = [0, ['a', 'b'], 2, 3]\n+      \t:lockvar 1 alist\n+      \t:echo islocked('alist')\t\t\" 1\n+      \t:echo islocked('alist[1]')\t\" 0\n+\n+      <When {expr} is a variable that does not exist you get an error\n+      message.  Use |exists()| to check for existence.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->islocked()\n+\n+    ]=],\n+    name = 'islocked',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'islocked({expr})',\n+    tags = { 'E786' },\n+  },\n+  isnan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return |TRUE| if {expr} is a float with value NaN. >\n+      \techo isnan(0.0 / 0.0)\n+      <\t1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isnan()\n+\n+    ]=],\n+    name = 'isnan',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'isnan({expr})',\n+  },\n+  items = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the key-value pairs of {dict}.  Each\n+      |List| item is a list with two items: the key of a {dict}\n+      entry and the value of this entry.  The |List| is in arbitrary\n+      order.  Also see |keys()| and |values()|.\n+      Example: >\n+      \tfor [key, value] in items(mydict)\n+      \t   echo key .. ': ' .. value\n+      \tendfor\n+\n+      <Can also be used as a |method|: >\n+      \tmydict->items()\n+\n+    ]=],\n+    name = 'items',\n+    params = { { 'dict', 'any' } },\n+    signature = 'items({dict})',\n+  },\n+  jobclose = {\n+    args = { 1, 2 },\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chanclose()|\n+    ]=],\n+    func = 'f_chanclose',\n+    params = VARARGS,\n+    signature = 'jobclose({id} [, {stream}])',\n+  },\n+  jobpid = {\n+    args = 1,\n+    desc = [=[\n+      Return the PID (process id) of |job-id| {job}.\n+\n+    ]=],\n+    name = 'jobpid',\n+    params = { { 'job', 'any' } },\n+    returns = 'integer',\n+    signature = 'jobpid({job})',\n+  },\n+  jobresize = {\n+    args = 3,\n+    desc = [=[\n+      Resize the pseudo terminal window of |job-id| {job} to {width}\n+      columns and {height} rows.\n+      Fails if the job was not started with `\"pty\":v:true`.\n+\n+    ]=],\n+    name = 'jobresize',\n+    params = { { 'job', 'any' }, { 'width', 'integer' }, { 'height', 'integer' } },\n+    signature = 'jobresize({job}, {width}, {height})',\n+  },\n+  jobsend = {\n+    args = 2,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chansend()|\n+    ]=],\n+    func = 'f_chansend',\n+    params = VARARGS,\n+    signature = 'jobsend({id}, {data})',\n+  },\n+  jobstart = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Note: Prefer |vim.system()| in Lua.\n+\n+      Spawns {cmd} as a job.\n+      If {cmd} is a List it runs directly (no 'shell').\n+      If {cmd} is a String it runs in the 'shell', like this: >\n+        :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n+      <(See |shell-unquoting| for details.)\n+\n+      Example: >\n+        :call jobstart('nvim -h', {'on_stdout':{j,d,e->append(line('.'),d)}})\n+      <\n+      Returns |job-id| on success, 0 on invalid arguments (or job\n+      table is full), -1 if {cmd}[0] or 'shell' is not executable.\n+      The returned job-id is a valid |channel-id| representing the\n+      job's stdio streams. Use |chansend()| (or |rpcnotify()| and\n+      |rpcrequest()| if \"rpc\" was enabled) to send data to stdin and\n+      |chanclose()| to close the streams without stopping the job.\n+\n+      See |job-control| and |RPC|.\n+\n+      NOTE: on Windows if {cmd} is a List:\n+        - cmd[0] must be an executable (not a \"built-in\"). If it is\n+          in $PATH it can be called by name, without an extension: >\n+            :call jobstart(['ping', 'neovim.io'])\n+      <    If it is a full or partial path, extension is required: >\n+            :call jobstart(['System32\\ping.exe', 'neovim.io'])\n+      <  - {cmd} is collapsed to a string of quoted args as expected\n+          by CommandLineToArgvW https://msdn.microsoft.com/bb776391\n+          unless cmd[0] is some form of \"cmd.exe\".\n+\n+      \t\t\t\t\t*jobstart-env*\n+      The job environment is initialized as follows:\n+        $NVIM                is set to |v:servername| of the parent Nvim\n+        $NVIM_LISTEN_ADDRESS is unset\n+        $NVIM_LOG_FILE       is unset\n+        $VIM                 is unset\n+        $VIMRUNTIME          is unset\n+      You can set these with the `env` option.\n+\n+      \t\t\t\t\t*jobstart-options*\n+      {opts} is a dictionary with these keys:\n+        clear_env:  (boolean) `env` defines the job environment\n+      \t      exactly, instead of merging current environment.\n+        cwd:\t      (string, default=|current-directory|) Working\n+      \t      directory of the job.\n+        detach:     (boolean) Detach the job process: it will not be\n+      \t      killed when Nvim exits. If the process exits\n+      \t      before Nvim, `on_exit` will be invoked.\n+        env:\t      (dict) Map of environment variable name:value\n+      \t      pairs extending (or replace with \"clear_env\")\n+      \t      the current environment. |jobstart-env|\n+        height:     (number) Height of the `pty` terminal.\n+        |on_exit|:    (function) Callback invoked when the job exits.\n+        |on_stdout|:  (function) Callback invoked when the job emits\n+      \t      stdout data.\n+        |on_stderr|:  (function) Callback invoked when the job emits\n+      \t      stderr data.\n+        overlapped: (boolean) Sets FILE_FLAG_OVERLAPPED for the\n+      \t      stdio passed to the child process. Only on\n+      \t      MS-Windows; ignored on other platforms.\n+        pty:\t      (boolean) Connect the job to a new pseudo\n+      \t      terminal, and its streams to the master file\n+      \t      descriptor. `on_stdout` receives all output,\n+      \t      `on_stderr` is ignored. |terminal-start|\n+        rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n+      \t      the job over stdio. Then `on_stdout` is ignored,\n+      \t      but `on_stderr` can still be used.\n+        stderr_buffered: (boolean) Collect data until EOF (stream closed)\n+      \t      before invoking `on_stderr`. |channel-buffered|\n+        stdout_buffered: (boolean) Collect data until EOF (stream\n+      \t      closed) before invoking `on_stdout`. |channel-buffered|\n+        stdin:      (string) Either \"pipe\" (default) to connect the\n+      \t      job's stdin to a channel or \"null\" to disconnect\n+      \t      stdin.\n+        width:      (number) Width of the `pty` terminal.\n+\n+      {opts} is passed as |self| dictionary to the callback; the\n+      caller may set other keys to pass application-specific data.\n+\n+      Returns:\n+        - |channel-id| on success\n+        - 0 on invalid arguments\n+        - -1 if {cmd}[0] is not executable.\n+      See also |job-control|, |channel|, |msgpack-rpc|.\n+\n+    ]=],\n+    name = 'jobstart',\n+    params = { { 'cmd', 'any' }, { 'opts', 'table' } },\n+    signature = 'jobstart({cmd} [, {opts}])',\n+  },\n+  jobstop = {\n+    args = 1,\n+    desc = [=[\n+      Stop |job-id| {id} by sending SIGTERM to the job process. If\n+      the process does not terminate after a timeout then SIGKILL\n+      will be sent. When the job terminates its |on_exit| handler\n+      (if any) will be invoked.\n+      See |job-control|.\n+\n+      Returns 1 for valid job id, 0 for invalid id, including jobs have\n+      exited or stopped.\n+\n+    ]=],\n+    name = 'jobstop',\n+    params = { { 'id', 'any' } },\n+    signature = 'jobstop({id})',\n+  },\n+  jobwait = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Waits for jobs and their |on_exit| handlers to complete.\n+\n+      {jobs} is a List of |job-id|s to wait for.\n+      {timeout} is the maximum waiting time in milliseconds. If\n+      omitted or -1, wait forever.\n+\n+      Timeout of 0 can be used to check the status of a job: >\n+      \tlet running = jobwait([{job-id}], 0)[0] == -1\n+      <\n+      During jobwait() callbacks for jobs not in the {jobs} list may\n+      be invoked. The screen will not redraw unless |:redraw| is\n+      invoked by a callback.\n+\n+      Returns a list of len({jobs}) integers, where each integer is\n+      the status of the corresponding job:\n+      \tExit-code, if the job exited\n+      \t-1 if the timeout was exceeded\n+      \t-2 if the job was interrupted (by |CTRL-C|)\n+      \t-3 if the job-id is invalid\n+\n+    ]=],\n+    name = 'jobwait',\n+    params = { { 'jobs', 'any' }, { 'timeout', 'integer' } },\n+    signature = 'jobwait({jobs} [, {timeout}])',\n+  },\n+  join = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Join the items in {list} together into one String.\n+      When {sep} is specified it is put in between the items.  If\n+      {sep} is omitted a single space is used.\n+      Note that {sep} is not added at the end.  You might want to\n+      add it there too: >\n+      \tlet lines = join(mylist, \"\\n\") .. \"\\n\"\n+      <String items are used as-is.  |Lists| and |Dictionaries| are\n+      converted into a string like with |string()|.\n+      The opposite function is |split()|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->join()\n+\n+    ]=],\n+    name = 'join',\n+    params = { { 'list', 'any' }, { 'sep', 'any' } },\n+    signature = 'join({list} [, {sep}])',\n+  },\n+  json_decode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} from JSON object.  Accepts |readfile()|-style\n+      list as the input, as well as regular string.  May output any\n+      Vim value. In the following cases it will output\n+      |msgpack-special-dict|:\n+      1. Dictionary contains duplicate key.\n+      2. Dictionary contains empty key.\n+      3. String contains NUL byte.  Two special dictionaries: for\n+         dictionary and for string will be emitted in case string\n+         with NUL byte was a dictionary key.\n+\n+      Note: function treats its input as UTF-8 always.  The JSON\n+      standard allows only a few encodings, of which UTF-8 is\n+      recommended and the only one required to be supported.\n+      Non-UTF-8 characters are an error.\n+\n+      Can also be used as a |method|: >\n+      \tReadObject()->json_decode()\n+\n+    ]=],\n+    name = 'json_decode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_decode({expr})',\n+  },\n+  json_encode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} into a JSON string.  Accepts\n+      |msgpack-special-dict| as the input.  Will not convert\n+      |Funcref|s, mappings with non-string keys (can be created as\n+      |msgpack-special-dict|), values with self-referencing\n+      containers, strings which contain non-UTF-8 characters,\n+      pseudo-UTF-8 strings which contain codepoints reserved for\n+      surrogate pairs (such strings are not valid UTF-8 strings).\n+      Non-printable characters are converted into \"\\u1234\" escapes\n+      or special escapes like \"\\t\", other are dumped as-is.\n+      |Blob|s are converted to arrays of the individual bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->json_encode()\n+\n+    ]=],\n+    name = 'json_encode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_encode({expr})',\n+  },\n+  keys = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the keys of {dict}.  The |List| is in\n+      arbitrary order.  Also see |items()| and |values()|.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->keys()\n+\n+    ]=],\n+    name = 'keys',\n+    params = { { 'dict', 'any' } },\n+    signature = 'keys({dict})',\n+  },\n+  keytrans = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Turn the internal byte representation of keys into a form that\n+      can be used for |:map|.  E.g. >\n+      \t:let xx = \"\\<C-Home>\"\n+      \t:echo keytrans(xx)\n+      <\t<C-Home>\n+\n+      Can also be used as a |method|: >\n+      \t\"\\<C-Home>\"->keytrans()\n+      <\n+    ]=],\n+    name = 'keytrans',\n+    params = { { 'string', 'string' } },\n+    signature = 'keytrans({string})',\n+  },\n+  last_buffer_nr = {\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for bufnr(\"$\").\n+    ]=],\n+    params = {},\n+    signature = 'last_buffer_nr()',\n+  },\n+  len = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a String or a Number the length in bytes is\n+      used, as with |strlen()|.\n+      When {expr} is a |List| the number of items in the |List| is\n+      returned.\n+      When {expr} is a |Blob| the number of bytes is returned.\n+      When {expr} is a |Dictionary| the number of entries in the\n+      |Dictionary| is returned.\n+      Otherwise an error is given and returns zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->len()\n+      <\n+    ]=],\n+    name = 'len',\n+    params = { { 'expr', 'any' } },\n+    signature = 'len({expr})',\n+    tags = { 'E701' },\n+  },\n+  libcall = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Call function {funcname} in the run-time library {libname}\n+      with single argument {argument}.\n+      This is useful to call functions in a library that you\n+      especially made to be used with Vim.  Since only one argument\n+      is possible, calling standard library functions is rather\n+      limited.\n+      The result is the String returned by the function.  If the\n+      function returns NULL, this will appear as an empty string \"\"\n+      to Vim.\n+      If the function returns a number, use libcallnr()!\n+      If {argument} is a number, it is passed to the function as an\n+      int; if {argument} is a string, it is passed as a\n+      null-terminated string.\n+\n+      libcall() allows you to write your own 'plug-in' extensions to\n+      Vim without having to recompile the program.  It is NOT a\n+      means to call system functions!  If you try to do so Vim will\n+      very probably crash.\n+\n+      For Win32, the functions you write must be placed in a DLL\n+      and use the normal C calling convention (NOT Pascal which is\n+      used in Windows System DLLs).  The function must take exactly\n+      one parameter, either a character pointer or a long integer,\n+      and must return a character pointer or NULL.  The character\n+      pointer returned must point to memory that will remain valid\n+      after the function has returned (e.g. in static data in the\n+      DLL).  If it points to allocated memory, that memory will\n+      leak away.  Using a static buffer in the function should work,\n+      it's then freed when the DLL is unloaded.\n+\n+      WARNING: If the function returns a non-valid pointer, Vim may\n+      crash!\tThis also happens if the function returns a number,\n+      because Vim thinks it's a pointer.\n+      For Win32 systems, {libname} should be the filename of the DLL\n+      without the \".DLL\" suffix.  A full path is only required if\n+      the DLL is not in the usual places.\n+      For Unix: When compiling your own plugins, remember that the\n+      object code must be compiled as position-independent ('PIC').\n+      Examples: >\n+      \t:echo libcall(\"libc.so\", \"getenv\", \"HOME\")\n+\n+      <Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcall(\"libc.so\", \"getenv\")\n+      <\n+    ]=],\n+    name = 'libcall',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcall({libname}, {funcname}, {argument})',\n+    tags = { 'E364', 'E368' },\n+  },\n+  libcallnr = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Just like |libcall()|, but used for a function that returns an\n+      int instead of a string.\n+      Examples: >\n+      \t:echo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n+      \t:call libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n+      \t:call libcallnr(\"libc.so\", \"sleep\", 10)\n+      <\n+      Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcallnr(\"libc.so\", \"printf\")\n+      <\n+    ]=],\n+    name = 'libcallnr',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcallnr({libname}, {funcname}, {argument})',\n+  },\n+  line = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the line number of the file\n+      position given with {expr}.  The {expr} argument is a string.\n+      The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the last line in the current buffer\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          w0\t    first line visible in current window (one if the\n+      \t    display isn't updated, e.g. in silent Ex mode)\n+          w$\t    last line visible in current window (this is one\n+      \t    less than \"w0\" if no lines are visible)\n+          v\t    In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Note that a mark in another file can be used.  The line number\n+      then applies to another buffer.\n+      To get the column number use |col()|.  To get both use\n+      |getpos()|.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      Returns 0 for invalid values of {expr} and {winid}.\n+      Examples: >\n+      \tline(\".\")\t\tline number of the cursor\n+      \tline(\".\", winid)\tidem, in window \"winid\"\n+      \tline(\"'t\")\t\tline number of mark t\n+      \tline(\"'\" .. marker)\tline number of mark marker\n+      <\n+      To jump to the last known position when opening a file see\n+      |last-position-jump|.\n+\n+      Can also be used as a |method|: >\n+      \tGetValue()->line()\n+\n+    ]=],\n+    name = 'line',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line({expr} [, {winid}])',\n+  },\n+  line2byte = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the byte count from the start of the buffer for line\n+      {lnum}.  This includes the end-of-line character, depending on\n+      the 'fileformat' option for the current buffer.  The first\n+      line returns 1. UTF-8 encoding is used, 'fileencoding' is\n+      ignored.  This can also be used to get the byte count for the\n+      line just below the last line: >\n+      \tline2byte(line(\"$\") + 1)\n+      <This is the buffer size plus one.  If 'fileencoding' is empty\n+      it is the file size plus one.  {lnum} is used like with\n+      |getline()|.  When {lnum} is invalid -1 is returned.\n+      Also see |byte2line()|, |go| and |:goto|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->line2byte()\n+\n+    ]=],\n+    name = 'line2byte',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line2byte({lnum})',\n+  },\n+  lispindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the lisp\n+      indenting rules, as with 'lisp'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid, -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->lispindent()\n+\n+    ]=],\n+    name = 'lispindent',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'lispindent({lnum})',\n+  },\n+  list2blob = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a Blob concatenating all the number values in {list}.\n+      Examples: >\n+      \tlist2blob([1, 2, 3, 4])\treturns 0z01020304\n+      \tlist2blob([])\t\treturns 0z\n+      <Returns an empty Blob on error.  If one of the numbers is\n+      negative or more than 255 error *E1239* is given.\n+\n+      |blob2list()| does the opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2blob()\n+\n+    ]=],\n+    name = 'list2blob',\n+    params = { { 'list', 'any' } },\n+    signature = 'list2blob({list})',\n+  },\n+  list2str = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Convert each number in {list} to a character string can\n+      concatenate them all.  Examples: >\n+      \tlist2str([32])\t\treturns \" \"\n+      \tlist2str([65, 66, 67])\treturns \"ABC\"\n+      <The same can be done (slowly) with: >\n+      \tjoin(map(list, {nr, val -> nr2char(val)}), '')\n+      <|str2list()| does the opposite.\n+\n+      UTF-8 encoding is always used, {utf8} option has no effect,\n+      and exists only for backwards-compatibility.\n+      With UTF-8 composing characters work as expected: >\n+      \tlist2str([97, 769])\treturns \"a\"\n+      <\n+      Returns an empty string on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2str()\n+\n+    ]=],\n+    name = 'list2str',\n+    params = { { 'list', 'any' }, { 'utf8', 'any' } },\n+    signature = 'list2str({list} [, {utf8}])',\n+  },\n+  localtime = {\n+    desc = [=[\n+      Return the current time, measured as seconds since 1st Jan\n+      1970.  See also |strftime()|, |strptime()| and |getftime()|.\n+    ]=],\n+    name = 'localtime',\n+    params = {},\n+    signature = 'localtime()',\n+  },\n+  log = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the natural logarithm (base e) of {expr} as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      (0, inf].\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log(10)\n+      <\t2.302585 >\n+      \t:echo log(exp(5))\n+      <\t5.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log()\n+\n+    ]=],\n+    float_func = 'log',\n+    name = 'log',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log({expr})',\n+  },\n+  log10 = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the logarithm of Float {expr} to base 10 as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log10(1000)\n+      <\t3.0 >\n+      \t:echo log10(0.01)\n+      <\t-2.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log10()\n+\n+    ]=],\n+    float_func = 'log10',\n+    name = 'log10',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log10({expr})',\n+  },\n+  luaeval = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Evaluate Lua expression {expr} and return its result converted\n+      to Vim data structures. See |lua-eval| for more details.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->luaeval()\n+      <\n+    ]=],\n+    lua = false,\n+    name = 'luaeval',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    signature = 'luaeval({expr} [, {expr}])',\n+  },\n+  map = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob| or |Dictionary|.\n+      Replace each item in {expr1} with the result of evaluating\n+      {expr2}.  For a |Blob| each byte is replaced.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+      Example: >\n+      \t:call map(mylist, '\"> \" .. v:val .. \" <\"')\n+      <This puts \"> \" before and \" <\" after each item in \"mylist\".\n+\n+      Note that {expr2} is the result of an expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.  You\n+      still have to double ' quotes\n+\n+      If {expr2} is a |Funcref| it is called with two arguments:\n+      \t1. The key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return the new value of the item. Example\n+      that changes each value by \"key-value\": >\n+      \tfunc KeyValue(key, val)\n+      \t  return a:key .. '-' .. a:val\n+      \tendfunc\n+      \tcall map(myDict, function('KeyValue'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall map(myDict, {key, val -> key .. '-' .. val})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall map(myDict, {key -> 'item: ' .. key})\n+      <If you do not use \"key\" you can use a short name: >\n+      \tcall map(myDict, {_, val -> 'item: ' .. val})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let tlist = map(copy(mylist), ' v:val .. \"\\t\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->map(expr2)\n+      <\n+    ]=],\n+    name = 'map',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'map({expr1}, {expr2})',\n+  },\n+  maparg = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {dict} is omitted or zero: Return the rhs of mapping\n+      {name} in mode {mode}.  The returned String has special\n+      characters translated like in the output of the \":map\" command\n+      listing.\n+\n+      When there is no mapping for {name}, an empty String is\n+      returned if {dict} is FALSE, otherwise returns an empty Dict.\n+      When the mapping for {name} is empty, then \"<Nop>\" is\n+      returned.\n+\n+      The {name} can have special key names, like in the \":map\"\n+      command.\n+\n+      {mode} can be one of these strings:\n+      \t\"n\"\tNormal\n+      \t\"v\"\tVisual (including Select)\n+      \t\"o\"\tOperator-pending\n+      \t\"i\"\tInsert\n+      \t\"c\"\tCmd-line\n+      \t\"s\"\tSelect\n+      \t\"x\"\tVisual\n+      \t\"l\"\tlangmap |language-mapping|\n+      \t\"t\"\tTerminal\n+      \t\"\"\tNormal, Visual and Operator-pending\n+      When {mode} is omitted, the modes for \"\" are used.\n+\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.\n+\n+      When {dict} is there and it is |TRUE| return a dictionary\n+      containing all the information of the mapping with the\n+      following items:\n+        \"lhs\"\t     The {lhs} of the mapping as it would be typed\n+        \"lhsraw\"   The {lhs} of the mapping as raw bytes\n+        \"lhsrawalt\" The {lhs} of the mapping as raw bytes, alternate\n+      \t      form, only present when it differs from \"lhsraw\"\n+        \"rhs\"\t     The {rhs} of the mapping as typed.\n+        \"silent\"   1 for a |:map-silent| mapping, else 0.\n+        \"noremap\"  1 if the {rhs} of the mapping is not remappable.\n+        \"script\"   1 if mapping was defined with <script>.\n+        \"expr\"     1 for an expression mapping (|:map-<expr>|).\n+        \"buffer\"   1 for a buffer local mapping (|:map-local|).\n+        \"mode\"     Modes for which the mapping is defined. In\n+      \t     addition to the modes mentioned above, these\n+      \t     characters will be used:\n+      \t     \" \"     Normal, Visual and Operator-pending\n+      \t     \"!\"     Insert and Commandline mode\n+      \t\t     (|mapmode-ic|)\n+        \"sid\"\t     The script local ID, used for <sid> mappings\n+      \t     (|<SID>|).  Negative for special contexts.\n+        \"lnum\"     The line number in \"sid\", zero if unknown.\n+        \"nowait\"   Do not wait for other, longer mappings.\n+      \t     (|:map-<nowait>|).\n+\n+      The dictionary can be used to restore a mapping with\n+      |mapset()|.\n+\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to map a key even when it's already\n+      mapped, and have it do the original mapping too.  Sketch: >\n+      \texe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')\n+\n+      <Can also be used as a |method|: >\n+      \tGetKey()->maparg('n')\n+\n+    ]=],\n+    name = 'maparg',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'boolean' }, { 'dict', 'boolean' } },\n+    returns = 'string|table<string,any>',\n+    signature = 'maparg({name} [, {mode} [, {abbr} [, {dict}]]])',\n+  },\n+  mapcheck = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Check if there is a mapping that matches with {name} in mode\n+      {mode}.  See |maparg()| for {mode} and special names in\n+      {name}.\n+      When {abbr} is there and it is non-zero use abbreviations\n+      instead of mappings.\n+      A match happens with a mapping that starts with {name} and\n+      with a mapping which is equal to the start of {name}.\n+\n+      \tmatches mapping \"a\"\t\"ab\"\t\"abc\" ~\n+         mapcheck(\"a\")\tyes\tyes\t yes\n+         mapcheck(\"abc\")\tyes\tyes\t yes\n+         mapcheck(\"ax\")\tyes\tno\t no\n+         mapcheck(\"b\")\tno\tno\t no\n+\n+      The difference with maparg() is that mapcheck() finds a\n+      mapping that matches with {name}, while maparg() only finds a\n+      mapping for {name} exactly.\n+      When there is no mapping that starts with {name}, an empty\n+      String is returned.  If there is one, the RHS of that mapping\n+      is returned.  If there are several mappings that start with\n+      {name}, the RHS of one of them is returned.  This will be\n+      \"<Nop>\" if the RHS is empty.\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to check if a mapping can be added\n+      without being ambiguous.  Example: >\n+      \t:if mapcheck(\"_vv\") == \"\"\n+      \t:   map _vv :set guifont=7x13<CR>\n+      \t:endif\n+      <This avoids adding the \"_vv\" mapping when there already is a\n+      mapping for \"_v\" or for \"_vvv\".\n+\n+      Can also be used as a |method|: >\n+      \tGetKey()->mapcheck('n')\n+\n+    ]=],\n+    name = 'mapcheck',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    signature = 'mapcheck({name} [, {mode} [, {abbr}]])',\n+  },\n+  mapset = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      Restore a mapping from a dictionary returned by |maparg()|.\n+      {mode} and {abbr} should be the same as for the call to\n+      |maparg()|. *E460*\n+      {mode} is used to define the mode in which the mapping is set,\n+      not the \"mode\" entry in {dict}.\n+      Example for saving and restoring a mapping: >\n+      \tlet save_map = maparg('K', 'n', 0, 1)\n+      \tnnoremap K somethingelse\n+      \t...\n+      \tcall mapset('n', 0, save_map)\n+      <Note that if you are going to replace a map in several modes,\n+      e.g. with `:map!`, you need to save the mapping for all of\n+      them, since they can differ.\n+    ]=],\n+    name = 'mapset',\n+    params = { { 'mode', 'string' }, { 'abbr', 'any' }, { 'dict', 'any' } },\n+    signature = 'mapset({mode}, {abbr}, {dict})',\n+  },\n+  match = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a |List| then this returns the index of the\n+      first item where {pat} matches.  Each item is used as a\n+      String, |Lists| and |Dictionaries| are used as echoed.\n+\n+      Otherwise, {expr} is used as a String.  The result is a\n+      Number, which gives the index (byte offset) in {expr} where\n+      {pat} matches.\n+\n+      A match at the first character or |List| item returns zero.\n+      If there is no match -1 is returned.\n+\n+      For getting submatches see |matchlist()|.\n+      Example: >\n+      \t:echo match(\"testing\", \"ing\")\t\" results in 4\n+      \t:echo match([1, 'x'], '\\a')\t\" results in 1\n+      <See |string-match| for how {pat} is used.\n+      \t\t\t\t\t\t*strpbrk()*\n+      Vim doesn't have a strpbrk() function.  But you can do: >\n+      \t:let sepidx = match(line, '[.,;: \\t]')\n+      <\t\t\t\t\t\t*strcasestr()*\n+      Vim doesn't have a strcasestr() function.  But you can add\n+      \"\\c\" to the pattern to ignore case: >\n+      \t:let idx = match(haystack, '\\cneedle')\n+      <\n+      If {start} is given, the search starts from byte index\n+      {start} in a String or item {start} in a |List|.\n+      The result, however, is still the index counted from the\n+      first character/item.  Example: >\n+      \t:echo match(\"testing\", \"ing\", 2)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"ing\", 4)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"t\", 2)\n+      <result is \"3\".\n+      For a String, if {start} > 0 then it is like the string starts\n+      {start} bytes later, thus \"^\" will match at {start}.  Except\n+      when {count} is given, then it's like matches before the\n+      {start} byte are ignored (this is a bit complicated to keep it\n+      backwards compatible).\n+      For a String, if {start} < 0, it will be set to 0.  For a list\n+      the index is counted from the end.\n+      If {start} is out of range ({start} > strlen({expr}) for a\n+      String or {start} > len({expr}) for a |List|) -1 is returned.\n+\n+      When {count} is given use the {count}th match.  When a match\n+      is found in a String the search for the next one starts one\n+      character further.  Thus this example results in 1: >\n+      \techo match(\"testing\", \"..\", 0, 2)\n+      <In a |List| the search continues in the next item.\n+      Note that when {count} is added the way {start} works changes,\n+      see above.\n+\n+      See |pattern| for the patterns that are accepted.\n+      The 'ignorecase' option is used to set the ignore-caseness of\n+      the pattern.  'smartcase' is NOT used.  The matching is always\n+      done like 'magic' is set and 'cpoptions' is empty.\n+      Note that a match at the start is preferred, thus when the\n+      pattern is using \"*\" (any number of matches) it tends to find\n+      zero matches at the start instead of a number of matches\n+      further down in the text.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->match('word')\n+      \tGetList()->match('word')\n+      <\n+    ]=],\n+    name = 'match',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'match({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchadd = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Defines a pattern to be highlighted in the current window (a\n+      \"match\").  It will be highlighted with {group}.  Returns an\n+      identification number (ID), which can be used to delete the\n+      match using |matchdelete()|.  The ID is bound to the window.\n+      Matching is case sensitive and magic, unless case sensitivity\n+      or magicness are explicitly overridden in {pattern}.  The\n+      'magic', 'smartcase' and 'ignorecase' options are not used.\n+      The \"Conceal\" value is special, it causes the match to be\n+      concealed.\n+\n+      The optional {priority} argument assigns a priority to the\n+      match.  A match with a high priority will have its\n+      highlighting overrule that of a match with a lower priority.\n+      A priority is specified as an integer (negative numbers are no\n+      exception).  If the {priority} argument is not specified, the\n+      default priority is 10.  The priority of 'hlsearch' is zero,\n+      hence all matches with a priority greater than zero will\n+      overrule it.  Syntax highlighting (see 'syntax') is a separate\n+      mechanism, and regardless of the chosen priority a match will\n+      always overrule syntax highlighting.\n+\n+      The optional {id} argument allows the request for a specific\n+      match ID.  If a specified ID is already taken, an error\n+      message will appear and the match will not be added.  An ID\n+      is specified as a positive integer (zero excluded).  IDs 1, 2\n+      and 3 are reserved for |:match|, |:2match| and |:3match|,\n+      respectively.  3 is reserved for use by the |matchparen|\n+      plugin.\n+      If the {id} argument is not specified or -1, |matchadd()|\n+      automatically chooses a free ID, which is at least 1000.\n+\n+      The optional {dict} argument allows for further custom\n+      values. Currently this is used to specify a match specific\n+      conceal character that will be shown for |hl-Conceal|\n+      highlighted matches. The dict can have the following members:\n+\n+      \tconceal\t    Special character to show instead of the\n+      \t\t    match (only for |hl-Conceal| highlighted\n+      \t\t    matches, see |:syn-cchar|)\n+      \twindow\t    Instead of the current window use the\n+      \t\t    window with this number or window ID.\n+\n+      The number of matches is not limited, as it is the case with\n+      the |:match| commands.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchadd(\"MyGroup\", \"TODO\")\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <A list of matches defined by |matchadd()| and |:match| are\n+      available from |getmatches()|.  All matches can be deleted in\n+      one operation by |clearmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchadd('TODO')\n+      <\n+    ]=],\n+    name = 'matchadd',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pattern', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    highlight_exists={\n-      args=1, base=1, func='f_hlexists',\n-      deprecated = { 'Obsolete name for |hlexists()|.' }\n+    signature = 'matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])',\n+    tags = { 'E798', 'E799', 'E801', 'E957' },\n+  },\n+  matchaddpos = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchadd()|, but requires a list of positions {pos}\n+      instead of a pattern. This command is faster than |matchadd()|\n+      because it does not require to handle regular expressions and\n+      sets buffer line boundaries to redraw screen. It is supposed\n+      to be used when fast match additions and deletions are\n+      required, for example to highlight matching parentheses.\n+      \t\t\t\t\t*E5030* *E5031*\n+      {pos} is a list of positions.  Each position can be one of\n+      these:\n+      - A number.  This whole line will be highlighted.  The first\n+        line has number 1.\n+      - A list with one number, e.g., [23]. The whole line with this\n+        number will be highlighted.\n+      - A list with two numbers, e.g., [23, 11]. The first number is\n+        the line number, the second one is the column number (first\n+        column is 1, the value must correspond to the byte index as\n+        |col()| would return).  The character at this position will\n+        be highlighted.\n+      - A list with three numbers, e.g., [23, 11, 3]. As above, but\n+        the third number gives the length of the highlight in bytes.\n+\n+      Entries with zero and negative line numbers are silently\n+      ignored, as well as entries with negative column numbers and\n+      lengths.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchaddpos(\"MyGroup\", [[23, 24], 34])\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <Matches added by |matchaddpos()| are returned by\n+      |getmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchaddpos([23, 11])\n+\n+    ]=],\n+    name = 'matchaddpos',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pos', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    histadd={args=2, base=2, returns=VIMBOOL},\n-    histdel={args={1, 2}, base=1, returns=VIMBOOL},\n-    histget={args={1, 2}, base=1, returns='string'},\n-    histnr={args=1, base=1, returns='integer'},\n-    hlID={args=1, base=1, returns='integer'},\n-    hlexists={args=1, base=1, returns=VIMBOOL},\n-    hostname={fast=true, returns='string'},\n-    iconv={args=3, base=1, fast=true},\n-    indent={args=1, base=1, returns='integer'},\n-    index={args={2, 4}, base=1},\n-    indexof={args={2, 3}, base=1},\n-    input={args={1, 3}, base=1},\n-    inputdialog={\n-      args={1, 3}, base=1,\n-      deprecated = { 'Use |input()| instead.' }\n+    signature = 'matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])',\n+  },\n+  matcharg = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Selects the {nr} match item, as set with a |:match|,\n+      |:2match| or |:3match| command.\n+      Return a |List| with two elements:\n+      \tThe name of the highlight group used\n+      \tThe pattern used.\n+      When {nr} is not 1, 2 or 3 returns an empty |List|.\n+      When there is no match item set returns ['', ''].\n+      This is useful to save and restore a |:match|.\n+      Highlighting matches using the |:match| commands are limited\n+      to three matches. |matchadd()| does not have this limitation.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matcharg()\n+\n+    ]=],\n+    name = 'matcharg',\n+    params = { { 'nr', 'integer' } },\n+    signature = 'matcharg({nr})',\n+  },\n+  matchdelete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Deletes a match with ID {id} previously defined by |matchadd()|\n+      or one of the |:match| commands.  Returns 0 if successful,\n+      otherwise -1.  See example for |matchadd()|.  All matches can\n+      be deleted in one operation by |clearmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matchdelete()\n+\n+    ]=],\n+    name = 'matchdelete',\n+    params = { { 'id', 'any' }, { 'win', 'any' } },\n+    signature = 'matchdelete({id} [, {win}])',\n+    tags = { 'E802', 'E803' },\n+  },\n+  matchend = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Same as |match()|, but return the index of first character\n+      after the match.  Example: >\n+      \t:echo matchend(\"testing\", \"ing\")\n+      <results in \"7\".\n+      \t\t\t\t\t*strspn()* *strcspn()*\n+      Vim doesn't have a strspn() or strcspn() function, but you can\n+      do it with matchend(): >\n+      \t:let span = matchend(line, '[a-zA-Z]')\n+      \t:let span = matchend(line, '[^a-zA-Z]')\n+      <Except that -1 is returned when there are no matches.\n+\n+      The {start}, if given, has the same meaning as for |match()|. >\n+      \t:echo matchend(\"testing\", \"ing\", 2)\n+      <results in \"7\". >\n+      \t:echo matchend(\"testing\", \"ing\", 5)\n+      <result is \"-1\".\n+      When {expr} is a |List| the result is equal to |match()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->matchend('word')\n+\n+    ]=],\n+    name = 'matchend',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'matchend({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchfuzzy = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      If {list} is a list of strings, then returns a |List| with all\n+      the strings in {list} that fuzzy match {str}. The strings in\n+      the returned list are sorted based on the matching score.\n+\n+      The optional {dict} argument always supports the following\n+      items:\n+          matchseq\tWhen this item is present return only matches\n+      \t\tthat contain the characters in {str} in the\n+      \t\tgiven sequence.\n+          limit\tMaximum number of matches in {list} to be\n+      \t\treturned.  Zero means no limit.\n+\n+      If {list} is a list of dictionaries, then the optional {dict}\n+      argument supports the following additional items:\n+          key\t\tKey of the item which is fuzzy matched against\n+      \t\t{str}. The value of this item should be a\n+      \t\tstring.\n+          text_cb\t|Funcref| that will be called for every item\n+      \t\tin {list} to get the text for fuzzy matching.\n+      \t\tThis should accept a dictionary item as the\n+      \t\targument and return the text for that item to\n+      \t\tuse for fuzzy matching.\n+\n+      {str} is treated as a literal string and regular expression\n+      matching is NOT supported.  The maximum supported {str} length\n+      is 256.\n+\n+      When {str} has multiple words each separated by white space,\n+      then the list of strings that have all the words is returned.\n+\n+      If there are no matching strings or there is an error, then an\n+      empty list is returned. If length of {str} is greater than\n+      256, then returns an empty list.\n+\n+      When {limit} is given, matchfuzzy() will find up to this\n+      number of matches in {list} and return them in sorted order.\n+\n+      Refer to |fuzzy-matching| for more information about fuzzy\n+      matching strings.\n+\n+      Example: >\n+         :echo matchfuzzy([\"clay\", \"crow\"], \"cay\")\n+      <results in [\"clay\"]. >\n+         :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy(\"ndl\")\n+      <results in a list of buffer names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"ndl\", {'key' : 'name'})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"spl\",\n+      \t\t\t\t\\ {'text_cb' : {v -> v.name}})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"spl\". >\n+         :echo v:oldfiles->matchfuzzy(\"test\")\n+      <results in a list of file names fuzzy matching \"test\". >\n+         :let l = readfile(\"buffer.c\")->matchfuzzy(\"str\")\n+      <results in a list of lines in \"buffer.c\" fuzzy matching \"str\". >\n+         :echo ['one two', 'two one']->matchfuzzy('two one')\n+      <results in `['two one', 'one two']` . >\n+         :echo ['one two', 'two one']->matchfuzzy('two one',\n+      \t\t\t\t\\ {'matchseq': 1})\n+      <results in `['two one']`.\n+\n+    ]=],\n+    name = 'matchfuzzy',\n+    params = { { 'list', 'any' }, { 'str', 'any' }, { 'dict', 'any' } },\n+    signature = 'matchfuzzy({list}, {str} [, {dict}])',\n+  },\n+  matchfuzzypos = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchfuzzy()|, but returns the list of matched\n+      strings, the list of character positions where characters\n+      in {str} matches and a list of matching scores.  You can\n+      use |byteidx()| to convert a character position to a byte\n+      position.\n+\n+      If {str} matches multiple times in a string, then only the\n+      positions for the best match is returned.\n+\n+      If there are no matching strings or there is an error, then a\n+      list with three empty list items is returned.\n+\n+      Example: >\n+      \t:echo matchfuzzypos(['testing'], 'tsg')\n+      <results in [[\"testing\"], [[0, 2, 6]], [99]] >\n+      \t:echo matchfuzzypos(['clay', 'lacy'], 'la')\n+      <results in [[\"lacy\", \"clay\"], [[0, 1], [1, 2]], [153, 133]] >\n+      \t:echo ",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277413279",
            "id": 1277413279,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI8ef",
            "original_commit_id": "9ae17e2a633d34f79ff0ac030b5abf3d979bc75c",
            "original_line": 8275,
            "original_position": 8490,
            "original_start_line": 7095,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1551880789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413279/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-07-28T11:06:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413279",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277413909"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413909"
                }
            },
            "author_association": "MEMBER",
            "body": "The suggestion seems broken.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T11:07:05Z",
            "diff_hunk": "@@ -11,502 +12,13421 @@\n ---       Defaults to BASE_NONE (function cannot be used as a method).\n --- @field func? string Name of the C function which implements the Vimscript function. Defaults to\n ---       `f_{funcname}`.\n+--- @field float_func? string\n --- @field fast? boolean Function can run in |api-fast| events. Defaults to false.\n---- @field deprecated? string[]\n+--- @field deprecated? true\n --- @field returns? string|false\n+--- @field signature string\n+--- @field desc? string\n+--- @field params {[1]:string, [2]:string}[]\n+--- @field lua? false Do not render type information\n+--- @field tags? string[] Extra tags\n+--- @field data? string Used by gen_eval.lua\n \n -- Usable with the base key: use the last function argument as the method base.\n -- Value is from funcs.h file. \"BASE_\" prefix is omitted.\n -- local LAST = \"BASE_LAST\" (currently unused after port of v8.2.1168)\n \n-local VIMBOOL = '0|1'\n-\n-return {\n-  --- @type table<string,vim.EvalFn>\n-  funcs={\n-    abs={args=1, base=1},\n-    acos={args=1, base=1, float_func=\"acos\", returns='number'},  -- WJMc\n-    add={args=2, base=1},\n-    ['and']={args=2, base=1},\n-    api_info={fast=true},\n-    append={args=2, base=2},\n-    appendbufline={args=3, base=3},\n-    argc={args={0, 1}, returns='integer'},\n-    argidx={returns='integer'},\n-    arglistid={args={0, 2}, returns='integer'},\n-    argv={args={0, 2}},\n-    asin={args=1, base=1, float_func=\"asin\"},  -- WJMc\n-    assert_beeps={args=1, base=1, returns=VIMBOOL},\n-    assert_equal={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_equalfile={args={2, 3}, base=1},\n-    assert_exception={args={1, 2}, returns=VIMBOOL},\n-    assert_fails={args={1, 5}, base=1, returns=VIMBOOL},\n-    assert_false={args={1, 2}, base=1, returns=VIMBOOL},\n-    assert_inrange={args={3, 4}, base=3, returns=VIMBOOL},\n-    assert_match={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_nobeep={args=1, base=1, returns=VIMBOOL},\n-    assert_notequal={args={2, 3}, base=2},\n-    assert_notmatch={args={2, 3}, base=2},\n-    assert_report={args=1, base=1},\n-    assert_true={args={1, 2}, base=1},\n-    atan={args=1, base=1, float_func=\"atan\", returns='number'},\n-    atan2={args=2, base=1, returns='number'},\n-    blob2list={args=1, base=1},\n-    browse={args=4},\n-    browsedir={args=2},\n-    bufadd={args=1, base=1, returns='integer'},\n-    bufexists={args=1, base=1, returns=VIMBOOL},\n-    buffer_exists={\n-      args=1, base=1, func='f_bufexists',\n-      deprecated = { 'Obsolete name for |bufexists()|.' }\n+local M = {}\n+\n+local VARARGS = { { '...', 'any' } }\n+\n+--- @type table<string,vim.EvalFn>\n+M.funcs = {\n+  abs = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the absolute value of {expr}.  When {expr} evaluates to\n+      a |Float| abs() returns a |Float|.  When {expr} can be\n+      converted to a |Number| abs() returns a |Number|.  Otherwise\n+      abs() gives an error message and returns -1.\n+      Examples: >\n+      \techo abs(1.456)\n+      <\t1.456  >\n+      \techo abs(-5.456)\n+      <\t5.456  >\n+      \techo abs(-4)\n+      <\t4\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->abs()\n+\n+    ]=],\n+    name = 'abs',\n+    params = { { 'expr', 'any' } },\n+    signature = 'abs({expr})',\n+    returns = 'number'\n+  },\n+  acos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc cosine of {expr} measured in radians, as a\n+      |Float| in the range of [0, pi].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo acos(0)\n+      <\t1.570796 >\n+      \t:echo acos(-0.5)\n+      <\t2.094395\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->acos()\n+\n+    ]=],\n+    float_func = 'acos',\n+    name = 'acos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'acos({expr})',\n+  },\n+  add = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Append the item {expr} to |List| or |Blob| {object}.  Returns\n+      the resulting |List| or |Blob|.  Examples: >\n+      \t:let alist = add([1, 2, 3], item)\n+      \t:call add(mylist, \"woodstock\")\n+      <Note that when {expr} is a |List| it is appended as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+      When {object} is a |Blob| then {expr} must be a number.\n+      Use |insert()| to add an item at another position.\n+      Returns 1 if {object} is not a |List| or a |Blob|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->add(val1)->add(val2)\n+\n+    ]=],\n+    name = 'add',\n+    params = { { 'object', 'any' }, { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'add({object}, {expr})',\n+  },\n+  ['and'] = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Bitwise AND on the two arguments.  The arguments are converted\n+      to a number.  A List, Dict or Float argument causes an error.\n+      Also see `or()` and `xor()`.\n+      Example: >\n+      \t:let flag = and(bits, 0x80)\n+      <Can also be used as a |method|: >\n+      \t:let flag = bits->and(0x80)\n+\n+    ]=],\n+    name = 'and',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    returns = 'integer',\n+    signature = 'and({expr}, {expr})',\n+  },\n+  api_info = {\n+    desc = [=[\n+      Returns Dictionary of |api-metadata|.\n+\n+      View it in a nice human-readable format: >\n+             :lua vim.print(vim.fn.api_info())\n+\n+    ]=],\n+    fast = true,\n+    name = 'api_info',\n+    params = {},\n+    returns = 'table',\n+    signature = 'api_info()',\n+  },\n+  append = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      When {text} is a |List|: Append each item of the |List| as a\n+      text line below line {lnum} in the current buffer.\n+      Otherwise append {text} as one text line below line {lnum} in\n+      the current buffer.\n+      Any type of item is accepted and converted to a String.\n+      {lnum} can be zero to insert a line before the first one.\n+      {lnum} is used like with |getline()|.\n+      Returns 1 for failure ({lnum} out of range or out of memory),\n+      0 for success.  Example: >\n+      \t:let failed = append(line('$'), \"# THE END\")\n+      \t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])\n+\n+      <Can also be used as a |method| after a List: >\n+      \tmylist->append(lnum)\n+\n+    ]=],\n+    name = 'append',\n+    params = { { 'lnum', 'integer' }, { 'text', 'any' } },\n+    returns = '0|1',\n+    signature = 'append({lnum}, {text})',\n+  },\n+  appendbufline = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Like |append()| but append the text in buffer {expr}.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()|.\n+\n+      {lnum} is the line number to append below.  Note that using\n+      |line()| would use the current buffer, not the one appending\n+      to.  Use \"$\" to append at the end of the buffer.  Other string\n+      values are not supported.\n+\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      If {buf} is not a valid buffer or {lnum} is not valid, an\n+      error message is given. Example: >\n+      \t:let failed = appendbufline(13, 0, \"# THE START\")\n+      <\n+      Can also be used as a |method| after a List: >\n+      \tmylist->appendbufline(buf, lnum)\n+\n+    ]=],\n+    name = 'appendbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'text', 'string' } },\n+    returns = '0|1',\n+    signature = 'appendbufline({buf}, {lnum}, {text})',\n+  },\n+  argc = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      The result is the number of files in the argument list.  See\n+      |arglist|.\n+      If {winid} is not supplied, the argument list of the current\n+      window is used.\n+      If {winid} is -1, the global argument list is used.\n+      Otherwise {winid} specifies the window of which the argument\n+      list is used: either the window number or the window ID.\n+      Returns -1 if the {winid} argument is invalid.\n+    ]=],\n+    name = 'argc',\n+    params = { { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'argc([{winid}])',\n+  },\n+  argidx = {\n+    desc = [=[\n+      The result is the current index in the argument list.  0 is\n+      the first file.  argc() - 1 is the last one.  See |arglist|.\n+    ]=],\n+    name = 'argidx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'argidx()',\n+  },\n+  arglistid = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      Return the argument list ID.  This is a number which\n+      identifies the argument list being used.  Zero is used for the\n+      global argument list.  See |arglist|.\n+      Returns -1 if the arguments are invalid.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.\n+      {winnr} can be the window number or the |window-ID|.\n+    ]=],\n+    name = 'arglistid',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'integer',\n+    signature = 'arglistid([{winnr} [, {tabnr}]])',\n+  },\n+  argv = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      The result is the {nr}th file in the argument list.  See\n+      |arglist|.  \"argv(0)\" is the first one.  Example: >\n+      \t:let i = 0\n+      \t:while i < argc()\n+      \t:  let f = escape(fnameescape(argv(i)), '.')\n+      \t:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'\n+      \t:  let i = i + 1\n+      \t:endwhile\n+      <Without the {nr} argument, or when {nr} is -1, a |List| with\n+      the whole |arglist| is returned.\n+\n+      The {winid} argument specifies the window ID, see |argc()|.\n+      For the Vim command line arguments see |v:argv|.\n+\n+      Returns an empty string if {nr}th argument is not present in\n+      the argument list.  Returns an empty List if the {winid}\n+      argument is invalid.\n+\n+    ]=],\n+    name = 'argv',\n+    params = { { 'nr', 'integer' }, { 'winid', 'integer' } },\n+    returns = 'string|string[]',\n+    signature = 'argv([{nr} [, {winid}]])',\n+  },\n+  asin = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc sine of {expr} measured in radians, as a |Float|\n+      in the range of [-pi/2, pi/2].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo asin(0.8)\n+      <\t0.927295 >\n+      \t:echo asin(-0.5)\n+      <\t-0.523599\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->asin()\n+      <\n+    ]=],\n+    float_func = 'asin',\n+    name = 'asin',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'asin({expr})',\n+  },\n+  assert_beeps = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce a beep or visual bell.\n+      Also see |assert_fails()|, |assert_nobeep()| and\n+      |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_beeps()\n+      <\n+    ]=],\n+    name = 'assert_beeps',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_beeps({cmd})',\n+  },\n+  assert_equal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {expected} and {actual} are not equal an error message is\n+      added to |v:errors| and 1 is returned.  Otherwise zero is\n+      returned. |assert-return|\n+      The error is in the form \"Expected {expected} but got\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      There is no automatic conversion, the String \"4\" is different\n+      from the Number 4.  And the number 4 is different from the\n+      Float 4.0.  The value of 'ignorecase' is not used here, case\n+      always matters.\n+      Example: >\n+      \tassert_equal('foo', 'bar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Expected 'foo' but got 'bar' ~\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_equal([1, 2, 3])\n+    ]=],\n+    name = 'assert_equal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_equal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_equalfile = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When the files {fname-one} and {fname-two} do not contain\n+      exactly the same text an error message is added to |v:errors|.\n+      Also see |assert-return|.\n+      When {fname-one} or {fname-two} does not exist the error will\n+      mention that.\n+\n+      Can also be used as a |method|: >\n+      \tGetLog()->assert_equalfile('expected.log')\n+    ]=],\n+    name = 'assert_equalfile',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'assert_equalfile({fname-one}, {fname-two})',\n+  },\n+  assert_exception = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      When v:exception does not contain the string {error} an error\n+      message is added to |v:errors|.  Also see |assert-return|.\n+      This can be used to assert that a command throws an exception.\n+      Using the error number, followed by a colon, avoids problems\n+      with translations: >\n+      \ttry\n+      \t  commandthatfails\n+      \t  call assert_false(1, 'command should have failed')\n+      \tcatch\n+      \t  call assert_exception('E492:')\n+      \tendtry\n+      <\n+    ]=],\n+    name = 'assert_exception',\n+    params = { { 'error', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_exception({error} [, {msg}])',\n+  },\n+  assert_fails = {\n+    args = { 1, 5 },\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce an error or when {error} is not found in the\n+      error message.  Also see |assert-return|.\n+\n+      When {error} is a string it must be found literally in the\n+      first reported error. Most often this will be the error code,\n+      including the colon, e.g. \"E123:\". >\n+      \tassert_fails('bad cmd', 'E987:')\n+      <\n+      When {error} is a |List| with one or two strings, these are\n+      used as patterns.  The first pattern is matched against the\n+      first reported error: >\n+      \tassert_fails('cmd', ['E987:.*expected bool'])\n+      <The second pattern, if present, is matched against the last\n+      reported error.  To only match the last error use an empty\n+      string for the first error: >\n+      \tassert_fails('cmd', ['', 'E987:'])\n+      <\n+      If {msg} is empty then it is not used.  Do this to get the\n+      default message when passing the {lnum} argument.\n+\n+      When {lnum} is present and not negative, and the {error}\n+      argument is present and matches, then this is compared with\n+      the line number at which the error was reported. That can be\n+      the line number in a function or in a script.\n+\n+      When {context} is present it is used as a pattern and matched\n+      against the context (script name or function name) where\n+      {lnum} is located in.\n+\n+      Note that beeping is not considered an error, and some failing\n+      commands only beep.  Use |assert_beeps()| for those.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_fails('E99:')\n+\n+    ]=],\n+    name = 'assert_fails',\n+    params = {\n+      { 'cmd', 'any' },\n+      { 'error', 'any' },\n+      { 'msg', 'any' },\n+      { 'lnum', 'integer' },\n+      { 'context', 'any' },\n     },\n-    buffer_name={\n-      args={0, 1}, base=1, func='f_bufname',\n-      deprecated = { 'Obsolete name for |bufname()|.' }\n+    returns = '0|1',\n+    signature = 'assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])',\n+  },\n+  assert_false = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not false an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      The error is in the form \"Expected False but got {actual}\".\n+      When {msg} is present it is prepended to that.\n+      Also see |assert-return|.\n+\n+      A value is false when it is zero. When {actual} is not a\n+      number the assert fails.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_false()\n+\n+    ]=],\n+    name = 'assert_false',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_false({actual} [, {msg}])',\n+  },\n+  assert_inrange = {\n+    args = { 3, 4 },\n+    base = 3,\n+    desc = [=[\n+      This asserts number and |Float| values.  When {actual}  is lower\n+      than {lower} or higher than {upper} an error message is added\n+      to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Expected range {lower} - {upper},\n+      but got {actual}\".  When {msg} is present it is prefixed to\n+      that.\n+    ]=],\n+    name = 'assert_inrange',\n+    params = { { 'lower', 'any' }, { 'upper', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_inrange({lower}, {upper}, {actual} [, {msg}])',\n+  },\n+  assert_match = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {pattern} does not match {actual} an error message is\n+      added to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Pattern {pattern} does not match\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      {pattern} is used as with |expr-=~|: The matching is always done\n+      like 'magic' was set and 'cpoptions' is empty, no matter what\n+      the actual value of 'magic' or 'cpoptions' is.\n+\n+      {actual} is used as a string, automatic conversion applies.\n+      Use \"^\" and \"$\" to match with the start and end of the text.\n+      Use both to match the whole text.\n+\n+      Example: >\n+      \tassert_match('^f.*o$', 'foobar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_match('foo.*')\n+      <\n+    ]=],\n+    name = 'assert_match',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_match({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_nobeep = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it\n+      produces a beep or visual bell.\n+      Also see |assert_beeps()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_nobeep()\n+      <\n+    ]=],\n+    name = 'assert_nobeep',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_nobeep({cmd})',\n+  },\n+  assert_notequal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_equal()`: add an error message to\n+      |v:errors| when {expected} and {actual} are equal.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_notequal([1, 2, 3])\n+\n+      <\n+    ]=],\n+    name = 'assert_notequal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notequal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_notmatch = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_match()`: add an error message to\n+      |v:errors| when {pattern} matches {actual}.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_notmatch('bar.*')\n+      <\n+    ]=],\n+    name = 'assert_notmatch',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notmatch({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_report = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Report a test failure directly, using String {msg}.\n+      Always returns one.\n+\n+      Can also be used as a |method|: >\n+      \tGetMessage()->assert_report()\n+      <\n+    ]=],\n+    name = 'assert_report',\n+    params = { { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_report({msg})',\n+  },\n+  assert_true = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not true an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      Also see |assert-return|.\n+      A value is |TRUE| when it is a non-zero number or |v:true|.\n+      When {actual} is not a number or |v:true| the assert fails.\n+      When {msg} is given it precedes the default message.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_true()\n+      <\n+    ]=],\n+    name = 'assert_true',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_true({actual} [, {msg}])',\n+  },\n+  atan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the principal value of the arc tangent of {expr}, in\n+      the range [-pi/2, +pi/2] radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo atan(100)\n+      <\t1.560797 >\n+      \t:echo atan(-4.01)\n+      <\t-1.326405\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan()\n+\n+    ]=],\n+    float_func = 'atan',\n+    name = 'atan',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'atan({expr})',\n+  },\n+  atan2 = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the arc tangent of {expr1} / {expr2}, measured in\n+      radians, as a |Float| in the range [-pi, pi].\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo atan2(-1, 1)\n+      <\t-0.785398 >\n+      \t:echo atan2(1, -1)\n+      <\t2.356194\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan2(1)\n+\n+    ]=],\n+    name = 'atan2',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    returns = 'number',\n+    signature = 'atan2({expr1}, {expr2})',\n+  },\n+  blob2list = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a List containing the number value of each byte in Blob\n+      {blob}.  Examples: >\n+      \tblob2list(0z0102.0304)\treturns [1, 2, 3, 4]\n+      \tblob2list(0z)\t\treturns []\n+      <Returns an empty List on error.  |list2blob()| does the\n+      opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetBlob()->blob2list()\n+      <\n+    ]=],\n+    name = 'blob2list',\n+    params = { { 'blob', 'any' } },\n+    returns = 'any[]',\n+    signature = 'blob2list({blob})',\n+  },\n+  browse = {\n+    args = 4,\n+    desc = [=[\n+      Put up a file requester.  This only works when \"has(\"browse\")\"\n+      returns |TRUE| (only in some GUI versions).\n+      The input fields are:\n+          {save}\twhen |TRUE|, select file to write\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+          {default}\tdefault file name\n+      An empty string is returned when the \"Cancel\" button is hit,\n+      something went wrong, or browsing is not possible.\n+    ]=],\n+    name = 'browse',\n+    params = { { 'save', 'any' }, { 'title', 'any' }, { 'initdir', 'any' }, { 'default', 'any' } },\n+    returns = '0|1',\n+    signature = 'browse({save}, {title}, {initdir}, {default})',\n+  },\n+  browsedir = {\n+    args = 2,\n+    desc = [=[\n+      Put up a directory requester.  This only works when\n+      \"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n+      On systems where a directory browser is not supported a file\n+      browser is used.  In that case: select a file in the directory\n+      to be used.\n+      The input fields are:\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+      When the \"Cancel\" button is hit, something went wrong, or\n+      browsing is not possible, an empty string is returned.\n+\n+    ]=],\n+    name = 'browsedir',\n+    params = { { 'title', 'any' }, { 'initdir', 'any' } },\n+    returns = '0|1',\n+    signature = 'browsedir({title}, {initdir})',\n+  },\n+  bufadd = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add a buffer to the buffer list with name {name} (must be a\n+      String).\n+      If a buffer for file {name} already exists, return that buffer\n+      number.  Otherwise return the buffer number of the newly\n+      created buffer.  When {name} is an empty string then a new\n+      buffer is always created.\n+      The buffer will not have 'buflisted' set and not be loaded\n+      yet.  To add some text to the buffer use this: >\n+      \tlet bufnr = bufadd('someName')\n+      \tcall bufload(bufnr)\n+      \tcall setbufline(bufnr, 1, ['some', 'text'])\n+      <Returns 0 on error.\n+      Can also be used as a |method|: >\n+      \tlet bufnr = 'somename'->bufadd()\n+\n+    ]=],\n+    name = 'bufadd',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'bufadd({name})',\n+  },\n+  bufexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists.\n+      If the {buf} argument is a number, buffer numbers are used.\n+      Number zero is the alternate buffer for the current window.\n+\n+      If the {buf} argument is a string it must match a buffer name\n+      exactly.  The name can be:\n+      - Relative to the current directory.\n+      - A full path.\n+      - The name of a buffer with 'buftype' set to \"nofile\".\n+      - A URL name.\n+      Unlisted buffers will be found.\n+      Note that help files are listed by their short name in the\n+      output of |:buffers|, but bufexists() requires using their\n+      long name to be able to find them.\n+      bufexists() may report a buffer exists, but to use the name\n+      with a |:buffer| command you may need to use |expand()|.  Esp\n+      for MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\n+      Use \"bufexists(0)\" to test for the existence of an alternate\n+      file name.\n+\n+      Can also be used as a |method|: >\n+      \tlet exists = 'somename'->bufexists()\n+\n+    ]=],\n+    name = 'bufexists',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufexists({buf})',\n+  },\n+  buffer_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufexists()|.\n+    ]=],\n+    func = 'f_bufexists',\n+    name = 'buffer_exists',\n+    params = VARARGS,\n+    returns = '0|1',\n+    signature = 'buffer_exists({buf})',\n+  },\n+  buffer_name = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufname()|.\n+    ]=],\n+    func = 'f_bufname',\n+    name = 'buffer_name',\n+    params = VARARGS,\n+    returns = 'string',\n+    signature = 'buffer_name([{buf}])',\n+  },\n+  buffer_number = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufnr()|.\n+    ]=],\n+    func = 'f_bufnr',\n+    name = 'buffer_number',\n+    params = VARARGS,\n+    returns = 'integer',\n+    signature = 'buffer_number([{buf} [, {create}]])',\n+  },\n+  buflisted = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is listed (has the 'buflisted' option set).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet listed = 'somename'->buflisted()\n+\n+    ]=],\n+    name = 'buflisted',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'buflisted({buf})',\n+  },\n+  bufload = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Ensure the buffer {buf} is loaded.  When the buffer name\n+      refers to an existing file then the file is read.  Otherwise\n+      the buffer will be empty.  If the buffer was already loaded\n+      then there is no change.  If the buffer is not related to a\n+      file the no file is read (e.g., when 'buftype' is \"nofile\").\n+      If there is an existing swap file for the file of the buffer,\n+      there will be no dialog, the buffer will be loaded anyway.\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \teval 'somename'->bufload()\n+\n+    ]=],\n+    name = 'bufload',\n+    params = { { 'buf', 'any' } },\n+    returns = false,\n+    signature = 'bufload({buf})',\n+  },\n+  bufloaded = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is loaded (shown in a window or hidden).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet loaded = 'somename'->bufloaded()\n+\n+    ]=],\n+    name = 'bufloaded',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufloaded({buf})',\n+  },\n+  bufname = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is the name of a buffer.  Mostly as it is displayed\n+      by the `:ls` command, but not using special names such as\n+      \"[No Name]\".\n+      If {buf} is omitted the current buffer is used.\n+      If {buf} is a Number, that buffer number's name is given.\n+      Number zero is the alternate buffer for the current window.\n+      If {buf} is a String, it is used as a |file-pattern| to match\n+      with the buffer names.  This is always done like 'magic' is\n+      set and 'cpoptions' is empty.  When there is more than one\n+      match an empty string is returned.\n+      \"\" or \"%\" can be used for the current buffer, \"#\" for the\n+      alternate buffer.\n+      A full match is preferred, otherwise a match at the start, end\n+      or middle of the buffer name is accepted.  If you only want a\n+      full match then put \"^\" at the start and \"$\" at the end of the\n+      pattern.\n+      Listed buffers are found first.  If there is a single match\n+      with a listed buffer, that one is returned.  Next unlisted\n+      buffers are searched for.\n+      If the {buf} is a String, but you want to use it as a buffer\n+      number, force it to be a Number by adding zero to it: >\n+      \t:echo bufname(\"3\" + 0)\n+      <Can also be used as a |method|: >\n+      \techo bufnr->bufname()\n+\n+      <If the buffer doesn't exist, or doesn't have a name, an empty\n+      string is returned. >\n+      \tbufname(\"#\")\t\talternate buffer name\n+      \tbufname(3)\t\tname of buffer 3\n+      \tbufname(\"%\")\t\tname of current buffer\n+      \tbufname(\"file2\")\tname of buffer where \"file2\" matches.\n+      <\n+    ]=],\n+    name = 'bufname',\n+    params = { { 'buf', 'any' } },\n+    returns = 'string',\n+    signature = 'bufname([{buf}])',\n+  },\n+  bufnr = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is the number of a buffer, as it is displayed by\n+      the `:ls` command.  For the use of {buf}, see |bufname()|\n+      above.\n+      If the buffer doesn't exist, -1 is returned.  Or, if the\n+      {create} argument is present and TRUE, a new, unlisted,\n+      buffer is created and its number is returned.\n+      bufnr(\"$\") is the last buffer: >\n+      \t:let last_buffer = bufnr(\"$\")\n+      <The result is a Number, which is the highest buffer number\n+      of existing buffers.  Note that not all buffers with a smaller\n+      number necessarily exist, because \":bwipeout\" may have removed\n+      them.  Use bufexists() to test for the existence of a buffer.\n+\n+      Can also be used as a |method|: >\n+      \techo bufref->bufnr()\n+\n+    ]=],\n+    name = 'bufnr',\n+    params = { { 'buf', 'any' }, { 'create', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufnr([{buf} [, {create}]])',\n+  },\n+  bufwinid = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the |window-ID| of the first\n+      window associated with buffer {buf}.  For the use of {buf},\n+      see |bufname()| above.  If buffer {buf} doesn't exist or\n+      there is no such window, -1 is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinid(1))\n+      <\n+      Only deals with the current tab page.  See |win_findbuf()| for\n+      finding more.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinid()\n+\n+    ]=],\n+    name = 'bufwinid',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinid({buf})',\n+  },\n+  bufwinnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Like |bufwinid()| but return the window number instead of the\n+      |window-ID|.\n+      If buffer {buf} doesn't exist or there is no such window, -1\n+      is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinnr(1))\n+\n+      <The number can be used with |CTRL-W_w| and \":wincmd w\"\n+      |:wincmd|.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinnr()\n+\n+    ]=],\n+    name = 'bufwinnr',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinnr({buf})',\n+  },\n+  byte2line = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the line number that contains the character at byte\n+      count {byte} in the current buffer.  This includes the\n+      end-of-line character, depending on the 'fileformat' option\n+      for the current buffer.  The first character has byte count\n+      one.\n+      Also see |line2byte()|, |go| and |:goto|.\n+\n+      Returns -1 if the {byte} value is invalid.\n+\n+      Can also be used as a |method|: >\n+      \tGetOffset()->byte2line()\n+\n+    ]=],\n+    name = 'byte2line',\n+    params = { { 'byte', 'any' } },\n+    returns = 'integer',\n+    signature = 'byte2line({byte})',\n+  },\n+  byteidx = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return byte index of the {nr}th character in the String\n+      {expr}.  Use zero for the first character, it then returns\n+      zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {nr}.\n+      Composing characters are not counted separately, their byte\n+      length is added to the preceding base character.  See\n+      |byteidxcomp()| below for counting composing characters\n+      separately.\n+      When {utf16} is present and TRUE, {nr} is used as the UTF-16\n+      index in the String {expr} instead of as the character index.\n+      The UTF-16 index is the index in the string when it is encoded\n+      with 16-bit words.  If the specified UTF-16 index is in the\n+      middle of a character (e.g. in a 4-byte character), then the\n+      byte index of the first byte in the character is returned.\n+      Refer to |string-offset-encoding| for more information.\n+      Example : >\n+      \techo matchstr(str, \".\", byteidx(str, 3))\n+      <will display the fourth character.  Another way to do the\n+      same: >\n+      \tlet s = strpart(str, byteidx(str, 3))\n+      \techo strpart(s, 0, byteidx(s, 1))\n+      <Also see |strgetchar()| and |strcharpart()|.\n+\n+      If there are less than {nr} characters -1 is returned.\n+      If there are exactly {nr} characters the length of the string\n+      in bytes is returned.\n+      See |charidx()| and |utf16idx()| for getting the character and\n+      UTF-16 index respectively from the byte index.\n+      Examples: >\n+      \techo byteidx('a', 2)\treturns 5\n+      \techo byteidx('a', 2, 1)\treturns 1\n+      \techo byteidx('a', 3, 1)\treturns 5\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidx(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidx',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidx({expr}, {nr} [, {utf16}])',\n+  },\n+  byteidxcomp = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like byteidx(), except that a composing character is counted\n+      as a separate character.  Example: >\n+      \tlet s = 'e' .. nr2char(0x301)\n+      \techo byteidx(s, 1)\n+      \techo byteidxcomp(s, 1)\n+      \techo byteidxcomp(s, 2)\n+      <The first and third echo result in 3 ('e' plus composing\n+      character is 3 bytes), the second echo results in 1 ('e' is\n+      one byte).\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidxcomp(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidxcomp',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidxcomp({expr}, {nr} [, {utf16}])',\n+  },\n+  call = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Call function {func} with the items in |List| {arglist} as\n+      arguments.\n+      {func} can either be a |Funcref| or the name of a function.\n+      a:firstline and a:lastline are set to the cursor line.\n+      Returns the return value of the called function.\n+      {dict} is for functions with the \"dict\" attribute.  It will be\n+      used to set the local variable \"self\". |Dictionary-function|\n+\n+      Can also be used as a |method|: >\n+      \tGetFunc()->call([arg, arg], dict)\n+      <\n+    ]=],\n+    name = 'call',\n+    params = { { 'func', 'any' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    returns = 'any',\n+    signature = 'call({func}, {arglist} [, {dict}])',\n+    tags = { 'E699' },\n+  },\n+  ceil = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the smallest integral value greater than or equal to\n+      {expr} as a |Float| (round up).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Examples: >\n+      \techo ceil(1.456)\n+      <\t2.0  >\n+      \techo ceil(-5.456)\n+      <\t-5.0  >\n+      \techo ceil(4.0)\n+      <\t4.0\n+\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->ceil()\n+      <\n+    ]=],\n+    float_func = 'ceil',\n+    name = 'ceil',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'ceil({expr})',\n+  },\n+  chanclose = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Close a channel or a specific stream associated with it.\n+      For a job, {stream} can be one of \"stdin\", \"stdout\",\n+      \"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n+      with `\"rpc\":v:true`) If {stream} is omitted, all streams\n+      are closed. If the channel is a pty, this will then close the\n+      pty master, sending SIGHUP to the job process.\n+      For a socket, there is only one stream, and {stream} should be\n+      omitted.\n+    ]=],\n+    name = 'chanclose',\n+    params = { { 'id', 'any' }, { 'stream', 'any' } },\n+    returns = '0|1',\n+    signature = 'chanclose({id} [, {stream}])',\n+  },\n+  changenr = {\n+    desc = [=[\n+      Return the number of the most recent change.  This is the same\n+      number as what is displayed with |:undolist| and can be used\n+      with the |:undo| command.\n+      When a change was made it is the number of that change.  After\n+      redo it is the number of the redone change.  After undo it is\n+      one less than the number of the undone change.\n+      Returns 0 if the undo list is empty.\n+    ]=],\n+    name = 'changenr',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'changenr()',\n+  },\n+  chansend = {\n+    args = 2,\n+    desc = [=[\n+      Send data to channel {id}. For a job, it writes it to the\n+      stdin of the process. For the stdio channel |channel-stdio|,\n+      it writes to Nvim's stdout.  Returns the number of bytes\n+      written if the write succeeded, 0 otherwise.\n+      See |channel-bytes| for more information.\n+\n+      {data} may be a string, string convertible, |Blob|, or a list.\n+      If {data} is a list, the items will be joined by newlines; any\n+      newlines in an item will be sent as NUL. To send a final\n+      newline, include a final empty string. Example: >\n+      \t:call chansend(id, [\"abc\", \"123\\n456\", \"\"])\n+      <will send \"abc<NL>123<NUL>456<NL>\".\n+\n+      chansend() writes raw data, not RPC messages.  If the channel\n+      was created with `\"rpc\":v:true` then the channel expects RPC\n+      messages, use |rpcnotify()| and |rpcrequest()| instead.\n+\n+    ]=],\n+    name = 'chansend',\n+    params = { { 'id', 'any' }, { 'data', 'any' } },\n+    returns = '0|1',\n+    signature = 'chansend({id}, {data})',\n+  },\n+  char2nr = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Return Number value of the first char in {string}.\n+      Examples: >\n+      \tchar2nr(\" \")\t\treturns 32\n+      \tchar2nr(\"ABC\")\t\treturns 65\n+      \tchar2nr(\"\")\t\treturns 225\n+      \tchar2nr(\"\"[0])\t\treturns 195\n+      \tchar2nr(\"\\<M-x>\")\treturns 128\n+      <Non-ASCII characters are always treated as UTF-8 characters.\n+      {utf8} is ignored, it exists only for backwards-compatibility.\n+      A combining character is a separate character.\n+      |nr2char()| does the opposite.\n+\n+      Returns 0 if {string} is not a |String|.\n+\n+      Can also be used as a |method|: >\n+      \tGetChar()->char2nr()\n+\n+    ]=],\n+    fast = true,\n+    name = 'char2nr',\n+    params = { { 'string', 'string' }, { 'utf8', 'any' } },\n+    returns = '0|1',\n+    signature = 'char2nr({string} [, {utf8}])',\n+  },\n+  charclass = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the character class of the first character in {string}.\n+      The character class is one of:\n+      \t0\tblank\n+      \t1\tpunctuation\n+      \t2\tword character\n+      \t3\temoji\n+      \tother\tspecific Unicode class\n+      The class is used in patterns and word motions.\n+      Returns 0 if {string} is not a |String|.\n+    ]=],\n+    name = 'charclass',\n+    params = { { 'string', 'string' } },\n+    returns = \"0|1|2|3|'other'\",\n+    signature = 'charclass({string})',\n+  },\n+  charcol = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Same as |col()| but returns the character index of the column\n+      position given with {expr} instead of the byte position.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tcharcol('.')\t\treturns 3\n+      \tcol('.')\t\treturns 7\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+    ]=],\n+    name = 'charcol',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'charcol({expr} [, {winid}])',\n+  },\n+  charidx = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the character index of the byte at {idx} in {string}.\n+      The index of the first character is zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {idx}.\n+\n+      When {countcc} is omitted or |FALSE|, then composing characters\n+      are not counted separately, their byte length is added to the\n+      preceding base character.\n+      When {countcc} is |TRUE|, then composing characters are\n+      counted as separate characters.\n+\n+      When {utf16} is present and TRUE, {idx} is used as the UTF-16\n+      index in the String {expr} instead of as the byte index.\n+\n+      Returns -1 if the arguments are invalid or if there are less\n+      than {idx} bytes. If there are exactly {idx} bytes the length\n+      of the string in characters is returned.\n+\n+      An error is given and -1 is returned if the first argument is\n+      not a string, the second argument is not a number or when the\n+      third argument is present and is not zero or one.\n+\n+      See |byteidx()| and |byteidxcomp()| for getting the byte index\n+      from the character index and |utf16idx()| for getting the\n+      UTF-16 index from the character index.\n+      Refer to |string-offset-encoding| for more information.\n+      Examples: >\n+      \techo charidx('abc', 3)\t\treturns 1\n+      \techo charidx('abc', 6, 1)\treturns 4\n+      \techo charidx('abc', 16)\t\treturns -1\n+      \techo charidx('a', 4, 0, 1)\treturns 2\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->charidx(idx)\n+\n+    ]=],\n+    name = 'charidx',\n+    params = {\n+      { 'string', 'string' },\n+      { 'idx', 'integer' },\n+      { 'countcc', 'any' },\n+      { 'utf16', 'any' },\n     },\n-    buffer_number={\n-      args={0, 1}, base=1, func='f_bufnr',\n-      deprecated = { 'Obsolete name for |bufnr()|.' }\n+    returns = 'integer',\n+    signature = 'charidx({string}, {idx} [, {countcc} [, {utf16}]])',\n+  },\n+  chdir = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Change the current working directory to {dir}.  The scope of\n+      the directory change depends on the directory of the current\n+      window:\n+      \t- If the current window has a window-local directory\n+      \t  (|:lcd|), then changes the window local directory.\n+      \t- Otherwise, if the current tabpage has a local\n+      \t  directory (|:tcd|) then changes the tabpage local\n+      \t  directory.\n+      \t- Otherwise, changes the global directory.\n+      {dir} must be a String.\n+      If successful, returns the previous working directory.  Pass\n+      this to another chdir() to restore the directory.\n+      On failure, returns an empty string.\n+\n+      Example: >\n+      \tlet save_dir = chdir(newdir)\n+      \tif save_dir != \"\"\n+      \t   \" ... do some work\n+      \t   call chdir(save_dir)\n+      \tendif\n+\n+      <Can also be used as a |method|: >\n+      \tGetDir()->chdir()\n+      <\n+    ]=],\n+    name = 'chdir',\n+    params = { { 'dir', 'string' } },\n+    returns = 'string',\n+    signature = 'chdir({dir})',\n+  },\n+  cindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the C\n+      indenting rules, as with 'cindent'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+      See |C-indenting|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->cindent()\n+    ]=],\n+    name = 'cindent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'cindent({lnum})',\n+  },\n+  clearmatches = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Clears all matches previously defined for the current window\n+      by |matchadd()| and the |:match| commands.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetWin()->clearmatches()\n+      <\n+    ]=],\n+    name = 'clearmatches',\n+    params = { { 'win', 'any' } },\n+    returns = false,\n+    signature = 'clearmatches([{win}])',\n+  },\n+  col = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the byte index of the column\n+      position given with {expr}.  The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the end of the cursor line (the result is the\n+      \t    number of bytes in the cursor line plus one)\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          v       In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Additionally {expr} can be [lnum, col]: a |List| with the line\n+      and column number. Most useful when the column is \"$\", to get\n+      the last column of a specific line.  When \"lnum\" or \"col\" is\n+      out of range then col() returns zero.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      To get the line number use |line()|.  To get both use\n+      |getpos()|.\n+      For the screen column position use |virtcol()|.  For the\n+      character position use |charcol()|.\n+      Note that only marks in the current file can be used.\n+      Examples: >\n+      \tcol(\".\")\t\tcolumn of cursor\n+      \tcol(\"$\")\t\tlength of cursor line plus one\n+      \tcol(\"'t\")\t\tcolumn of mark t\n+      \tcol(\"'\" .. markname)\tcolumn of mark markname\n+      <The first column is 1.  Returns 0 if {expr} is invalid or when\n+      the window with ID {winid} is not found.\n+      For an uppercase mark the column may actually be in another\n+      buffer.\n+      For the cursor position, when 'virtualedit' is active, the\n+      column is one higher if the cursor is after the end of the\n+      line.  Also, when using a <Cmd> mapping the cursor isn't\n+      moved, this can be used to obtain the column in Insert mode: >\n+      \t:imap <F2> <Cmd>echo col(\".\")..\"\\n\"<CR>\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+\n+    ]=],\n+    name = 'col',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'col({expr} [, {winid}])',\n+  },\n+  complete = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Set the matches for Insert mode completion.\n+      Can only be used in Insert mode.  You need to use a mapping\n+      with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n+      or with an expression mapping.\n+      {startcol} is the byte offset in the line where the completed\n+      text start.  The text up to the cursor is the original text\n+      that will be replaced by the matches.  Use col('.') for an\n+      empty string.  \"col('.') - 1\" will replace one character by a\n+      match.\n+      {matches} must be a |List|.  Each |List| item is one match.\n+      See |complete-items| for the kind of items that are possible.\n+      \"longest\" in 'completeopt' is ignored.\n+      Note that the after calling this function you need to avoid\n+      inserting anything that would cause completion to stop.\n+      The match can be selected with CTRL-N and CTRL-P as usual with\n+      Insert mode completion.  The popup menu will appear if\n+      specified, see |ins-completion-menu|.\n+      Example: >\n+      \tinoremap <F5> <C-R>=ListMonths()<CR>\n+\n+      \tfunc ListMonths()\n+      \t  call complete(col('.'), ['January', 'February', 'March',\n+      \t    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n+      \t    \\ 'October', 'November', 'December'])\n+      \t  return ''\n+      \tendfunc\n+      <This isn't very useful, but it shows how it works.  Note that\n+      an empty string is returned to avoid a zero being inserted.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetMatches()->complete(col('.'))\n+\n+    ]=],\n+    name = 'complete',\n+    params = { { 'startcol', 'any' }, { 'matches', 'any' } },\n+    returns = false,\n+    signature = 'complete({startcol}, {matches})',\n+    tags = { 'E785' },\n+  },\n+  complete_add = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add {expr} to the list of matches.  Only to be used by the\n+      function specified with the 'completefunc' option.\n+      Returns 0 for failure (empty string or out of memory),\n+      1 when the match was added, 2 when the match was already in\n+      the list.\n+      See |complete-functions| for an explanation of {expr}.  It is\n+      the same as one item in the list that 'omnifunc' would return.\n+\n+      Can also be used as a |method|: >\n+      \tGetMoreMatches()->complete_add()\n+\n+    ]=],\n+    name = 'complete_add',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1|2',\n+    signature = 'complete_add({expr})',\n+  },\n+  complete_check = {\n+    desc = [=[\n+      Check for a key typed while looking for completion matches.\n+      This is to be used when looking for matches takes some time.\n+      Returns |TRUE| when searching for matches is to be aborted,\n+      zero otherwise.\n+      Only to be used by the function specified with the\n+      'completefunc' option.\n+    ]=],\n+    name = 'complete_check',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'complete_check()',\n+  },\n+  complete_info = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns a |Dictionary| with information about Insert mode\n+      completion.  See |ins-completion|.\n+      The items are:\n+         mode\t\tCurrent completion mode name string.\n+      \t\tSee |complete_info_mode| for the values.\n+         pum_visible\t|TRUE| if popup menu is visible.\n+      \t\tSee |pumvisible()|.\n+         items\tList of completion matches.  Each item is a\n+      \t\tdictionary containing the entries \"word\",\n+      \t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n+      \t\tSee |complete-items|.\n+         selected\tSelected item index.  First index is zero.\n+      \t\tIndex is -1 if no item is selected (showing\n+      \t\ttyped text only, or the last completion after\n+      \t\tno item is selected when using the <Up> or\n+      \t\t<Down> keys)\n+         inserted\tInserted string. [NOT IMPLEMENTED YET]\n+\n+      \t\t\t\t\t*complete_info_mode*\n+      mode values are:\n+         \"\"\t\t     Not in completion mode\n+         \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n+         \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n+         \"scroll\"\t     Scrolling with |i_CTRL-X_CTRL-E| or\n+      \t\t     |i_CTRL-X_CTRL-Y|\n+         \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n+         \"files\"\t     File names |i_CTRL-X_CTRL-F|\n+         \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n+         \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n+         \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n+         \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n+         \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n+         \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n+         \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n+         \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n+         \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n+         \"eval\"\t     |complete()| completion\n+         \"unknown\"\t     Other internal modes\n+\n+      If the optional {what} list argument is supplied, then only\n+      the items listed in {what} are returned.  Unsupported items in\n+      {what} are silently ignored.\n+\n+      To get the position and size of the popup menu, see\n+      |pum_getpos()|. It's also available in |v:event| during the\n+      |CompleteChanged| event.\n+\n+      Returns an empty |Dictionary| on error.\n+\n+      Examples: >\n+      \t\" Get all items\n+      \tcall complete_info()\n+      \t\" Get only 'mode'\n+      \tcall complete_info(['mode'])\n+      \t\" Get only 'mode' and 'pum_visible'\n+      \tcall complete_info(['mode', 'pum_visible'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetItems()->complete_info()\n+      <\n+    ]=],\n+    name = 'complete_info',\n+    params = { { 'what', 'any' } },\n+    returns = 'table',\n+    signature = 'complete_info([{what}])',\n+  },\n+  confirm = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      confirm() offers the user a dialog, from which a choice can be\n+      made.  It returns the number of the choice.  For the first\n+      choice this is 1.\n+\n+      {msg} is displayed in a dialog with {choices} as the\n+      alternatives.  When {choices} is missing or empty, \"&OK\" is\n+      used (and translated).\n+      {msg} is a String, use '\\n' to include a newline.  Only on\n+      some systems the string is wrapped when it doesn't fit.\n+\n+      {choices} is a String, with the individual choices separated\n+      by '\\n', e.g. >\n+      \tconfirm(\"Save changes?\", \"&Yes\\n&No\\n&Cancel\")\n+      <The letter after the '&' is the shortcut key for that choice.\n+      Thus you can type 'c' to select \"Cancel\".  The shortcut does\n+      not need to be the first letter: >\n+      \tconfirm(\"file has been modified\", \"&Save\\nSave &All\")\n+      <For the console, the first letter of each choice is used as\n+      the default shortcut key.  Case is ignored.\n+\n+      The optional {type} String argument gives the type of dialog.\n+      It can be one of these values: \"Error\", \"Question\", \"Info\",\n+      \"Warning\" or \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      The optional {type} argument gives the type of dialog.  This\n+      is only used for the icon of the Win32 GUI.  It can be one of\n+      these values: \"Error\", \"Question\", \"Info\", \"Warning\" or\n+      \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      If the user aborts the dialog by pressing <Esc>, CTRL-C,\n+      or another valid interrupt key, confirm() returns 0.\n+\n+      An example: >\n+         let choice = confirm(\"What do you want?\",\n+      \t\t\t\\ \"&Apples\\n&Oranges\\n&Bananas\", 2)\n+         if choice == 0\n+      \techo \"make up your mind!\"\n+         elseif choice == 3\n+      \techo \"tasteful\"\n+         else\n+      \techo \"I prefer bananas myself.\"\n+         endif\n+      <In a GUI dialog, buttons are used.  The layout of the buttons\n+      depends on the 'v' flag in 'guioptions'.  If it is included,\n+      the buttons are always put vertically.  Otherwise,  confirm()\n+      tries to put the buttons in one horizontal line.  If they\n+      don't fit, a vertical layout is used anyway.  For some systems\n+      the horizontal layout is always used.\n+\n+      Can also be used as a |method|in: >\n+      \tBuildMessage()->confirm(\"&Yes\\n&No\")\n+      <\n+    ]=],\n+    name = 'confirm',\n+    params = { { 'msg', 'any' }, { 'choices', 'any' }, { 'default', 'any' }, { 'type', 'any' } },\n+    returns = 'integer',\n+    signature = 'confirm({msg} [, {choices} [, {default} [, {type}]]])',\n+  },\n+  copy = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a shallow copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  But the items are identical, thus\n+      changing an item changes the contents of both |Lists|.\n+      A |Dictionary| is copied in a similar way as a |List|.\n+      Also see |deepcopy()|.\n+      Can also be used as a |method|: >\n+      \tmylist->copy()\n+    ]=],\n+    name = 'copy',\n+    params = { { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'copy({expr})',\n+  },\n+  cos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the cosine of {expr}, measured in radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cos(100)\n+      <\t0.862319 >\n+      \t:echo cos(-4.01)\n+      <\t-0.646043\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cos()\n+    ]=],\n+    float_func = 'cos',\n+    name = 'cos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cos({expr})',\n+  },\n+  cosh = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the hyperbolic cosine of {expr} as a |Float| in the range\n+      [1, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cosh(0.5)\n+      <\t1.127626 >\n+      \t:echo cosh(-0.5)\n+      <\t-1.127626\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cosh()\n+\n+    ]=],\n+    float_func = 'cosh',\n+    name = 'cosh',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cosh({expr})',\n+  },\n+  count = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the number of times an item with value {expr} appears\n+      in |String|, |List| or |Dictionary| {comp}.\n+\n+      If {start} is given then start with the item with this index.\n+      {start} can only be used with a |List|.\n+\n+      When {ic} is given and it's |TRUE| then case is ignored.\n+\n+      When {comp} is a string then the number of not overlapping\n+      occurrences of {expr} is returned. Zero is returned when\n+      {expr} is an empty string.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->count(val)\n+      <\n+    ]=],\n+    name = 'count',\n+    params = { { 'comp', 'any' }, { 'expr', 'any' }, { 'ic', 'any' }, { 'start', 'any' } },\n+    returns = 'integer',\n+    signature = 'count({comp}, {expr} [, {ic} [, {start}]])',\n+  },\n+  ctxget = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |Dictionary| representing the |context| at {index}\n+      from the top of the |context-stack| (see |context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+    ]=],\n+    name = 'ctxget',\n+    params = { { 'index', 'any' } },\n+    returns = 'table',\n+    signature = 'ctxget([{index}])',\n+  },\n+  ctxpop = {\n+    desc = [=[\n+      Pops and restores the |context| at the top of the\n+      |context-stack|.\n+    ]=],\n+    name = 'ctxpop',\n+    params = {},\n+    signature = 'ctxpop()',\n+  },\n+  ctxpush = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Pushes the current editor state (|context|) on the\n+      |context-stack|.\n+      If {types} is given and is a |List| of |String|s, it specifies\n+      which |context-types| to include in the pushed context.\n+      Otherwise, all context types are included.\n+\n+    ]=],\n+    name = 'ctxpush',\n+    params = { { 'types', 'any' } },\n+    signature = 'ctxpush([{types}])',\n+  },\n+  ctxset = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Sets the |context| at {index} from the top of the\n+      |context-stack| to that represented by {context}.\n+      {context} is a Dictionary with context data (|context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+\n+    ]=],\n+    name = 'ctxset',\n+    params = { { 'context', 'any' }, { 'index', 'any' } },\n+    signature = 'ctxset({context} [, {index}])',\n+  },\n+  ctxsize = {\n+    desc = [=[\n+      Returns the size of the |context-stack|.\n+\n+    ]=],\n+    name = 'ctxsize',\n+    params = {},\n+    signature = 'ctxsize()',\n+  },\n+  cursor = {\n+    args = { 1, 3 },\n+    base = 1,\n+    name = 'cursor',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' }, { 'off', 'any' } },\n+    signature = 'cursor({lnum}, {col} [, {off}])',\n+  },\n+  cursor__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Positions the cursor at the column (byte count) {col} in the\n+      line {lnum}.  The first column is one.\n+\n+      When there is one argument {list} this is used as a |List|\n+      with two, three or four item:\n+      \t[{lnum}, {col}]\n+      \t[{lnum}, {col}, {off}]\n+      \t[{lnum}, {col}, {off}, {curswant}]\n+      This is like the return value of |getpos()| or |getcurpos()|,\n+      but without the first item.\n+\n+      To position the cursor using {col} as the character count, use\n+      |setcursorcharpos()|.\n+\n+      Does not change the jumplist.\n+      {lnum} is used like with |getline()|, except that if {lnum} is\n+      zero, the cursor will stay in the current line.\n+      If {lnum} is greater than the number of lines in the buffer,\n+      the cursor will be positioned at the last line in the buffer.\n+      If {col} is greater than the number of bytes in the line,\n+      the cursor will be positioned at the last character in the\n+      line.\n+      If {col} is zero, the cursor will stay in the current column.\n+      If {curswant} is given it is used to set the preferred column\n+      for vertical movement.  Otherwise {col} is used.\n+\n+      When 'virtualedit' is used {off} specifies the offset in\n+      screen columns from the start of the character.  E.g., a\n+      position within a <Tab> or after the last character.\n+      Returns 0 when the position could be set, -1 otherwise.\n+\n+      Can also be used as a |method|: >\n+      \tGetCursorPos()->cursor()\n+\n+    ]=],\n+    name = 'cursor',\n+    params = { { 'list', 'any' } },\n+    signature = 'cursor({list})',\n+  },\n+  debugbreak = {\n+    args = { 1, 1 },\n+    base = 1,\n+    desc = [=[\n+      Specifically used to interrupt a program being debugged.  It\n+      will cause process {pid} to get a SIGTRAP.  Behavior for other\n+      processes is undefined. See |terminal-debug|.\n+      (Sends a SIGINT to a process {pid} other than MS-Windows)\n+\n+      Returns |TRUE| if successfully interrupted the program.\n+      Otherwise returns |FALSE|.\n+\n+      Can also be used as a |method|: >\n+      \tGetPid()->debugbreak()\n+\n+    ]=],\n+    name = 'debugbreak',\n+    params = { { 'pid', 'any' } },\n+    signature = 'debugbreak({pid})',\n+  },\n+  deepcopy = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a full copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  When an item is a |List|, a copy for it\n+      is made, recursively.  Thus changing an item in the copy does\n+      not change the contents of the original |List|.\n+\n+      When {noref} is omitted or zero a contained |List| or\n+      |Dictionary| is only copied once.  All references point to\n+      this single copy.  With {noref} set to 1 every occurrence of a\n+      |List| or |Dictionary| results in a new copy.  This also means\n+      that a cyclic reference causes deepcopy() to fail.\n+      \t\t\t\t\t\t*E724*\n+      Nesting is possible up to 100 levels.  When there is an item\n+      that refers back to a higher level making a deep copy with\n+      {noref} set to 1 will fail.\n+      Also see |copy()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->deepcopy()\n+\n+    ]=],\n+    name = 'deepcopy',\n+    params = { { 'expr', 'any' }, { 'noref', 'any' } },\n+    signature = 'deepcopy({expr} [, {noref}])',\n+  },\n+  delete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {flags} or with {flags} empty: Deletes the file by the\n+      name {fname}.\n+\n+      This also works when {fname} is a symbolic link.  The symbolic\n+      link itself is deleted, not what it points to.\n+\n+      When {flags} is \"d\": Deletes the directory by the name\n+      {fname}.  This fails when directory {fname} is not empty.\n+\n+      When {flags} is \"rf\": Deletes the directory by the name\n+      {fname} and everything in it, recursively.  BE CAREFUL!\n+      Note: on MS-Windows it is not possible to delete a directory\n+      that is being used.\n+\n+      The result is a Number, which is 0/false if the delete\n+      operation was successful and -1/true when the deletion failed\n+      or partly failed.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->delete()\n+\n+    ]=],\n+    name = 'delete',\n+    params = { { 'fname', 'integer' }, { 'flags', 'string' } },\n+    returns = 'integer',\n+    signature = 'delete({fname} [, {flags}])',\n+  },\n+  deletebufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Delete lines {first} to {last} (inclusive) from buffer {buf}.\n+      If {last} is omitted then delete line {first} only.\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      {first} and {last} are used like with |getline()|. Note that\n+      when using |line()| this refers to the current buffer. Use \"$\"\n+      to refer to the last line in buffer {buf}.\n+\n+      Can also be used as a |method|: >\n+      \tGetBuffer()->deletebufline(1)\n+      <\n+    ]=],\n+    name = 'deletebufline',\n+    params = { { 'buf', 'any' }, { 'first', 'any' }, { 'last', 'any' } },\n+    signature = 'deletebufline({buf}, {first} [, {last}])',\n+  },\n+  dictwatcheradd = {\n+    args = 3,\n+    desc = [=[\n+      Adds a watcher to a dictionary. A dictionary watcher is\n+      identified by three components:\n+\n+      - A dictionary({dict});\n+      - A key pattern({pattern}).\n+      - A function({callback}).\n+\n+      After this is called, every change on {dict} and on keys\n+      matching {pattern} will result in {callback} being invoked.\n+\n+      For example, to watch all global variables: >\n+      \tsilent! call dictwatcherdel(g:, '*', 'OnDictChanged')\n+      \tfunction! OnDictChanged(d,k,z)\n+      \t  echomsg string(a:k) string(a:z)\n+      \tendfunction\n+      \tcall dictwatcheradd(g:, '*', 'OnDictChanged')\n+      <\n+      For now {pattern} only accepts very simple patterns that can\n+      contain a \"*\" at the end of the string, in which case it will\n+      match every key that begins with the substring before the \"*\".\n+      That means if \"*\" is not the last character of {pattern}, only\n+      keys that are exactly equal as {pattern} will be matched.\n+\n+      The {callback} receives three arguments:\n+\n+      - The dictionary being watched.\n+      - The key which changed.\n+      - A dictionary containing the new and old values for the key.\n+\n+      The type of change can be determined by examining the keys\n+      present on the third argument:\n+\n+      - If contains both `old` and `new`, the key was updated.\n+      - If it contains only `new`, the key was added.\n+      - If it contains only `old`, the key was deleted.\n+\n+      This function can be used by plugins to implement options with\n+      validation and parsing logic.\n+\n+    ]=],\n+    name = 'dictwatcheradd',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcheradd({dict}, {pattern}, {callback})',\n+  },\n+  dictwatcherdel = {\n+    args = 3,\n+    desc = [=[\n+      Removes a watcher added  with |dictwatcheradd()|. All three\n+      arguments must match the ones passed to |dictwatcheradd()| in\n+      order for the watcher to be successfully deleted.\n+    ]=],\n+    name = 'dictwatcherdel',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcherdel({dict}, {pattern}, {callback})',\n+  },\n+  did_filetype = {\n+    desc = [=[\n+      Returns |TRUE| when autocommands are being executed and the\n+      FileType event has been triggered at least once.  Can be used\n+      to avoid triggering the FileType event again in the scripts\n+      that detect the file type. |FileType|\n+      Returns |FALSE| when `:setf FALLBACK` was used.\n+      When editing another file, the counter is reset, thus this\n+      really checks if the FileType event has been triggered for the\n+      current buffer.  This allows an autocommand that starts\n+      editing another buffer to set 'filetype' and load a syntax\n+      file.\n+\n+    ]=],\n+    fast = true,\n+    name = 'did_filetype',\n+    params = {},\n+    signature = 'did_filetype()',\n+  },\n+  diff_filler = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the number of filler lines above line {lnum}.\n+      These are the lines that were inserted at this point in\n+      another diff'ed window.  These filler lines are shown in the\n+      display but don't exist in the buffer.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Returns 0 if the current window is not in diff mode.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_filler()\n+\n+    ]=],\n+    name = 'diff_filler',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'diff_filler({lnum})',\n+  },\n+  diff_hlID = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Returns the highlight ID for diff mode at line {lnum} column\n+      {col} (byte index).  When the current line does not have a\n+      diff change zero is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      {col} is 1 for the leftmost column, {lnum} is 1 for the first\n+      line.\n+      The highlight ID can be used with |synIDattr()| to obtain\n+      syntax information about the highlighting.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_hlID(col)\n+      <\n+\n+    ]=],\n+    name = 'diff_hlID',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' } },\n+    signature = 'diff_hlID({lnum}, {col})',\n+  },\n+  digraph_get = {\n+    args = 1,\n+    base = 1,\n+    tags = { 'E1214' },\n+    desc = [=[\n+      Return the digraph of {chars}.  This should be a string with\n+      exactly two characters.  If {chars} are not just two\n+      characters, or the digraph of {chars} does not exist, an error\n+      is given and an empty string is returned.\n+\n+      Also see |digraph_getlist()|.\n+\n+      Examples: >\n+      \" Get a built-in digraph\n+      :echo digraph_get('00')\t\t\" Returns ''\n+\n+      \" Get a user-defined digraph\n+      :call digraph_set('aa', '')\n+      :echo digraph_get('aa')\t\t\" Returns ''\n+      <\n+      Can also be used as a |method|: >\n+      \tGetChars()->digraph_get()\n+      <\n+\n+    ]=],\n+    name = 'digraph_get',\n+    params = { { 'chars', 'any' } },\n+    signature = 'digraph_get({chars})',\n+  },\n+  digraph_getlist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of digraphs.  If the {listall} argument is given\n+      and it is TRUE, return all digraphs, including the default\n+      digraphs.  Otherwise, return only user-defined digraphs.\n+\n+      Also see |digraph_get()|.\n+\n+      Examples: >\n+      \" Get user-defined digraphs\n+      :echo digraph_getlist()\n+\n+      \" Get all the digraphs, including default digraphs\n+      :echo digraph_getlist(1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetNumber()->digraph_getlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_getlist',\n+    params = { { 'listall', 'any' } },\n+    signature = 'digraph_getlist([{listall}])',\n+  },\n+  digraph_set = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Add digraph {chars} to the list.  {chars} must be a string\n+      with two characters.  {digraph} is a string with one UTF-8\n+      encoded character.  *E1215*\n+      Be careful, composing characters are NOT ignored.  This\n+      function is similar to |:digraphs| command, but useful to add\n+      digraphs start with a white space.\n+\n+      The function result is v:true if |digraph| is registered.  If\n+      this fails an error message is given and v:false is returned.\n+\n+      If you want to define multiple digraphs at once, you can use\n+      |digraph_setlist()|.\n+\n+      Example: >\n+      \tcall digraph_set('  ', '')\n+      <\n+      Can be used as a |method|: >\n+      \tGetString()->digraph_set('')\n+      <\n+\n+    ]=],\n+    name = 'digraph_set',\n+    params = { { 'chars', 'any' }, { 'digraph', 'any' } },\n+    signature = 'digraph_set({chars}, {digraph})',\n+  },\n+  digraph_setlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Similar to |digraph_set()| but this function can add multiple\n+      digraphs at once.  {digraphlist} is a list composed of lists,\n+      where each list contains two strings with {chars} and\n+      {digraph} as in |digraph_set()|. *E1216*\n+      Example: >\n+          call digraph_setlist([['aa', ''], ['ii', '']])\n+      <\n+      It is similar to the following: >\n+          for [chars, digraph] in [['aa', ''], ['ii', '']]\n+      \t  call digraph_set(chars, digraph)\n+          endfor\n+      <Except that the function returns after the first error,\n+      following digraphs will not be added.\n+\n+      Can be used as a |method|: >\n+          GetList()->digraph_setlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_setlist',\n+    params = { { 'digraphlist', 'any' } },\n+    signature = 'digraph_setlist({digraphlist})',\n+  },\n+  empty = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the Number 1 if {expr} is empty, zero otherwise.\n+      - A |List| or |Dictionary| is empty when it does not have any\n+        items.\n+      - A |String| is empty when its length is zero.\n+      - A |Number| and |Float| are empty when their value is zero.\n+      - |v:false| and |v:null| are empty, |v:true| is not.\n+      - A |Blob| is empty when its length is zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->empty()\n+\n+    ]=],\n+    name = 'empty',\n+    params = { { 'expr', 'any' } },\n+    signature = 'empty({expr})',\n+  },\n+  environ = {\n+    desc = [=[\n+      Return all of environment variables as dictionary. You can\n+      check if an environment variable exists like this: >\n+      \t:echo has_key(environ(), 'HOME')\n+      <Note that the variable name may be CamelCase; to ignore case\n+      use this: >\n+      \t:echo index(keys(environ()), 'HOME', 0, 1) != -1\n+\n+    ]=],\n+    fast = true,\n+    name = 'environ',\n+    params = {},\n+    signature = 'environ()',\n+  },\n+  escape = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Escape the characters in {chars} that occur in {string} with a\n+      backslash.  Example: >\n+      \t:echo escape('c:\\program files\\vim', ' \\')\n+      <results in: >\n+      \tc:\\\\program\\ files\\\\vim\n+      <Also see |shellescape()| and |fnameescape()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->escape(' \\')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'escape',\n+    params = { { 'string', 'string' }, { 'chars', 'any' } },\n+    signature = 'escape({string}, {chars})',\n+  },\n+  eval = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Evaluate {string} and return the result.  Especially useful to\n+      turn the result of |string()| back into the original value.\n+      This works for Numbers, Floats, Strings, Blobs and composites\n+      of them.  Also works for |Funcref|s that refer to existing\n+      functions.\n+\n+      Can also be used as a |method|: >\n+      \targv->join()->eval()\n+\n+    ]=],\n+    name = 'eval',\n+    params = { { 'string', 'string' } },\n+    signature = 'eval({string})',\n+  },\n+  eventhandler = {\n+    desc = [=[\n+      Returns 1 when inside an event handler.  That is that Vim got\n+      interrupted while waiting for the user to type a character,\n+      e.g., when dropping a file on Vim.  This means interactive\n+      commands cannot be used.  Otherwise zero is returned.\n+\n+    ]=],\n+    name = 'eventhandler',\n+    params = {},\n+    signature = 'eventhandler()',\n+  },\n+  executable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      This function checks if an executable with the name {expr}\n+      exists.  {expr} must be the name of the program without any\n+      arguments.\n+      executable() uses the value of $PATH and/or the normal\n+      searchpath for programs.\t\t*PATHEXT*\n+      On MS-Windows the \".exe\", \".bat\", etc. can optionally be\n+      included.  Then the extensions in $PATHEXT are tried.  Thus if\n+      \"foo.exe\" does not exist, \"foo.exe.bat\" can be found.  If\n+      $PATHEXT is not set then \".exe;.com;.bat;.cmd\" is used.  A dot\n+      by itself can be used in $PATHEXT to try using the name\n+      without an extension.  When 'shell' looks like a Unix shell,\n+      then the name is also tried without adding an extension.\n+      On MS-Windows it only checks if the file exists and is not a\n+      directory, not if it's really executable.\n+      On Windows an executable in the same directory as Vim is\n+      always found (it is added to $PATH at |startup|).\n+      The result is a Number:\n+      \t1\texists\n+      \t0\tdoes not exist\n+      \t-1\tnot implemented on this system\n+      |exepath()| can be used to get the full path of an executable.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->executable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'executable',\n+    params = { { 'expr', 'any' } },\n+    signature = 'executable({expr})',\n+  },\n+  execute = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Execute {command} and capture its output.\n+      If {command} is a |String|, returns {command} output.\n+      If {command} is a |List|, returns concatenated outputs.\n+      Line continuations in {command} are not recognized.\n+      Examples: >\n+      \techo execute('echon \"foo\"')\n+      <\tfoo >\n+      \techo execute(['echon \"foo\"', 'echon \"bar\"'])\n+      <\tfoobar\n+\n+      The optional {silent} argument can have these values:\n+      \t\"\"\t\tno `:silent` used\n+      \t\"silent\"\t`:silent` used\n+      \t\"silent!\"\t`:silent!` used\n+      The default is \"silent\".  Note that with \"silent!\", unlike\n+      `:redir`, error messages are dropped.\n+\n+      To get a list of lines use `split()` on the result: >\n+      \texecute('args')->split(\"\\n\")\n+\n+      <This function is not available in the |sandbox|.\n+      Note: If nested, an outer execute() will not observe output of\n+      the inner calls.\n+      Note: Text attributes (highlights) are not captured.\n+      To execute a command in another window than the current one\n+      use `win_execute()`.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->execute()\n+\n+    ]=],\n+    name = 'execute',\n+    params = { { 'command', 'any' }, { 'silent', 'boolean' } },\n+    signature = 'execute({command} [, {silent}])',\n+  },\n+  exepath = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the full path of {expr} if it is an executable and\n+      given as a (partial or full) path or is found in $PATH.\n+      Returns empty string otherwise.\n+      If {expr} starts with \"./\" the |current-directory| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->exepath()\n+      <\n+    ]=],\n+    name = 'exepath',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exepath({expr})',\n+  },\n+  exists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if {expr} is\n+      defined, zero otherwise.\n+\n+      For checking for a supported feature use |has()|.\n+      For checking if a file exists use |filereadable()|.\n+\n+      The {expr} argument is a string, which contains one of these:\n+      \tvarname\t\tinternal variable (see\n+      \tdict.key\t|internal-variables|).  Also works\n+      \tlist[i]\t\tfor |curly-braces-names|, |Dictionary|\n+      \t\t\tentries, |List| items, etc.\n+      \t\t\tBeware that evaluating an index may\n+      \t\t\tcause an error message for an invalid\n+      \t\t\texpression.  E.g.: >\n+      \t\t\t   :let l = [1, 2, 3]\n+      \t\t\t   :echo exists(\"l[5]\")\n+      <\t\t\t   0 >\n+      \t\t\t   :echo exists(\"l[xx]\")\n+      <\t\t\t   E121: Undefined variable: xx\n+      \t\t\t   0\n+      \t&option-name\tVim option (only checks if it exists,\n+      \t\t\tnot if it really works)\n+      \t+option-name\tVim option that works.\n+      \t$ENVNAME\tenvironment variable (could also be\n+      \t\t\tdone by comparing with an empty\n+      \t\t\tstring)\n+      \t`*funcname`\tbuilt-in function (see |functions|)\n+      \t\t\tor user defined function (see\n+      \t\t\t|user-function|). Also works for a\n+      \t\t\tvariable that is a Funcref.\n+      \t:cmdname\tEx command: built-in command, user\n+      \t\t\tcommand or command modifier |:command|.\n+      \t\t\tReturns:\n+      \t\t\t1  for match with start of a command\n+      \t\t\t2  full match with a command\n+      \t\t\t3  matches several user commands\n+      \t\t\tTo check for a supported command\n+      \t\t\talways check the return value to be 2.\n+      \t:2match\t\tThe |:2match| command.\n+      \t:3match\t\tThe |:3match| command (but you\n+      \t\t\tprobably should not use it, it is\n+      \t\t\treserved for internal usage)\n+      \t#event\t\tautocommand defined for this event\n+      \t#event#pattern\tautocommand defined for this event and\n+      \t\t\tpattern (the pattern is taken\n+      \t\t\tliterally and compared to the\n+      \t\t\tautocommand patterns character by\n+      \t\t\tcharacter)\n+      \t#group\t\tautocommand group exists\n+      \t#group#event\tautocommand defined for this group and\n+      \t\t\tevent.\n+      \t#group#event#pattern\n+      \t\t\tautocommand defined for this group,\n+      \t\t\tevent and pattern.\n+      \t##event\t\tautocommand for this event is\n+      \t\t\tsupported.\n+\n+      Examples: >\n+      \texists(\"&mouse\")\n+      \texists(\"$HOSTNAME\")\n+      \texists(\"*strftime\")\n+      \texists(\"*s:MyFunc\")\n+      \texists(\"*MyFunc\")\n+      \texists(\"bufcount\")\n+      \texists(\":Make\")\n+      \texists(\"#CursorHold\")\n+      \texists(\"#BufReadPre#*.gz\")\n+      \texists(\"#filetypeindent\")\n+      \texists(\"#filetypeindent#FileType\")\n+      \texists(\"#filetypeindent#FileType#*\")\n+      \texists(\"##ColorScheme\")\n+      <There must be no space between the symbol (&/$/*/#) and the\n+      name.\n+      There must be no extra characters after the name, although in\n+      a few cases this is ignored.  That may become stricter in the\n+      future, thus don't count on it!\n+      Working example: >\n+      \texists(\":make\")\n+      <NOT working example: >\n+      \texists(\":make install\")\n+\n+      <Note that the argument must be a string, not the name of the\n+      variable itself.  For example: >\n+      \texists(bufcount)\n+      <This doesn't check for existence of the \"bufcount\" variable,\n+      but gets the value of \"bufcount\", and checks if that exists.\n+\n+      Can also be used as a |method|: >\n+      \tVarname()->exists()\n+\n+    ]=],\n+    name = 'exists',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'exists({expr})',\n+  },\n+  exp = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the exponential of {expr} as a |Float| in the range\n+      [0, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo exp(2)\n+      <\t7.389056 >\n+      \t:echo exp(-1)\n+      <\t0.367879\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->exp()\n+\n+    ]=],\n+    float_func = 'exp',\n+    name = 'exp',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exp({expr})',\n+  },\n+  expand = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Expand wildcards and the following special keywords in\n+      {string}.  'wildignorecase' applies.\n+\n+      If {list} is given and it is |TRUE|, a List will be returned.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty string.  A name\n+      for a non-existing file is not included, unless {string} does\n+      not start with '%', '#' or '<', see below.\n+\n+      When {string} starts with '%', '#' or '<', the expansion is\n+      done like for the |cmdline-special| variables with their\n+      associated modifiers.  Here is a short overview:\n+\n+      \t%\t\tcurrent file name\n+      \t#\t\talternate file name\n+      \t#n\t\talternate file name n\n+      \t<cfile>\t\tfile name under the cursor\n+      \t<afile>\t\tautocmd file name\n+      \t<abuf>\t\tautocmd buffer number (as a String!)\n+      \t<amatch>\tautocmd matched name\n+      \t<cexpr>\t\tC expression under the cursor\n+      \t<sfile>\t\tsourced script file or function name\n+      \t<slnum>\t\tsourced script line number or function\n+      \t\t\tline number\n+      \t<sflnum>\tscript file line number, also when in\n+      \t\t\ta function\n+      \t<SID>\t\t\"<SNR>123_\"  where \"123\" is the\n+      \t\t\tcurrent script ID  |<SID>|\n+      \t<script>\tsourced script file, or script file\n+      \t\t\twhere the current function was defined\n+      \t<stack>\t\tcall stack\n+      \t<cword>\t\tword under the cursor\n+      \t<cWORD>\t\tWORD under the cursor\n+      \t<client>\tthe {clientid} of the last received\n+      \t\t\tmessage\n+      Modifiers:\n+      \t:p\t\texpand to full path\n+      \t:h\t\thead (last path component removed)\n+      \t:t\t\ttail (last path component only)\n+      \t:r\t\troot (one extension removed)\n+      \t:e\t\textension only\n+\n+      Example: >\n+      \t:let &tags = expand(\"%:p:h\") .. \"/tags\"\n+      <Note that when expanding a string that starts with '%', '#' or\n+      '<', any following text is ignored.  This does NOT work: >\n+      \t:let doesntwork = expand(\"%:h.bak\")\n+      <Use this: >\n+      \t:let doeswork = expand(\"%:h\") .. \".bak\"\n+      <Also note that expanding \"<cfile>\" and others only returns the\n+      referenced file name without further expansion.  If \"<cfile>\"\n+      is \"~/.cshrc\", you need to do another expand() to have the\n+      \"~/\" expanded into the path of the home directory: >\n+      \t:echo expand(expand(\"<cfile>\"))\n+      <\n+      There cannot be white space between the variables and the\n+      following modifier.  The |fnamemodify()| function can be used\n+      to modify normal file names.\n+\n+      When using '%' or '#', and the current or alternate file name\n+      is not defined, an empty string is used.  Using \"%:p\" in a\n+      buffer with no name, results in the current directory, with a\n+      '/' added.\n+      When 'verbose' is set then expanding '%', '#' and <> items\n+      will result in an error message if the argument cannot be\n+      expanded.\n+\n+      When {string} does not start with '%', '#' or '<', it is\n+      expanded like a file name is expanded on the command line.\n+      'suffixes' and 'wildignore' are used, unless the optional\n+      {nosuf} argument is given and it is |TRUE|.\n+      Names for non-existing files are included.  The \"**\" item can\n+      be used to search in a directory tree.  For example, to find\n+      all \"README\" files in the current directory and below: >\n+      \t:echo expand(\"**/README\")\n+      <\n+      expand() can also be used to expand variables and environment\n+      variables that are only known in a shell.  But this can be\n+      slow, because a shell may be used to do the expansion.  See\n+      |expr-env-expand|.\n+      The expanded variable is still handled like a list of file\n+      names.  When an environment variable cannot be expanded, it is\n+      left unchanged.  Thus \":echo expand('$FOOBAR')\" results in\n+      \"$FOOBAR\".\n+\n+      See |glob()| for finding existing files.  See |system()| for\n+      getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetpattern()->expand()\n+\n+    ]=],\n+    name = 'expand',\n+    params = { { 'string', 'string' }, { 'nosuf', 'boolean' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'expand({string} [, {nosuf} [, {list}]])',\n+  },\n+  expandcmd = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Expand special items in String {string} like what is done for\n+      an Ex command such as `:edit`.  This expands special keywords,\n+      like with |expand()|, and environment variables, anywhere in\n+      {string}.  \"~user\" and \"~/path\" are only expanded at the\n+      start.\n+\n+      The following items are supported in the {options} Dict\n+      argument:\n+          errmsg\tIf set to TRUE, error messages are displayed\n+      \t\tif an error is encountered during expansion.\n+      \t\tBy default, error messages are not displayed.\n+\n+      Returns the expanded string.  If an error is encountered\n+      during expansion, the unmodified {string} is returned.\n+\n+      Example: >\n+      \t:echo expandcmd('make %<.o')\n+      \tmake /path/runtime/doc/builtin.o\n+      \t:echo expandcmd('make %<.o', {'errmsg': v:true})\n+      <\n+      Can also be used as a |method|: >\n+      \tGetCommand()->expandcmd()\n+      <\n+    ]=],\n+    name = 'expandcmd',\n+    params = { { 'string', 'string' }, { 'options', 'table' } },\n+    signature = 'expandcmd({string} [, {options}])',\n+  },\n+  extend = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      {expr1} and {expr2} must be both |Lists| or both\n+      |Dictionaries|.\n+\n+      If they are |Lists|: Append {expr2} to {expr1}.\n+      If {expr3} is given insert the items of {expr2} before the\n+      item with index {expr3} in {expr1}.  When {expr3} is zero\n+      insert before the first item.  When {expr3} is equal to\n+      len({expr1}) then {expr2} is appended.\n+      Examples: >\n+      \t:echo sort(extend(mylist, [7, 5]))\n+      \t:call extend(mylist, [2, 3], 1)\n+      <When {expr1} is the same List as {expr2} then the number of\n+      items copied is equal to the original length of the List.\n+      E.g., when {expr3} is 1 you get N new copies of the first item\n+      (where N is the original length of the List).\n+      Use |add()| to concatenate one item to a list.  To concatenate\n+      two lists into a new list use the + operator: >\n+      \t:let newlist = [1, 2, 3] + [4, 5]\n+      <\n+      If they are |Dictionaries|:\n+      Add all entries from {expr2} to {expr1}.\n+      If a key exists in both {expr1} and {expr2} then {expr3} is\n+      used to decide what to do:\n+      {expr3} = \"keep\": keep the value of {expr1}\n+      {expr3} = \"force\": use the value of {expr2}\n+      {expr3} = \"error\": give an error message\t\t*E737*\n+      When {expr3} is omitted then \"force\" is assumed.\n+\n+      {expr1} is changed when {expr2} is not empty.  If necessary\n+      make a copy of {expr1} first.\n+      {expr2} remains unchanged.\n+      When {expr1} is locked and {expr2} is not empty the operation\n+      fails.\n+      Returns {expr1}.  Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->extend(otherlist)\n+      <\n+    ]=],\n+    name = 'extend',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extend({expr1}, {expr2} [, {expr3}])',\n+  },\n+  extendnew = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |extend()| but instead of adding items to {expr1} a new\n+      List or Dictionary is created and returned.  {expr1} remains\n+      unchanged.\n+    ]=],\n+    name = 'extendnew',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extendnew({expr1}, {expr2} [, {expr3}])',\n+  },\n+  feedkeys = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Characters in {string} are queued for processing as if they\n+      come from a mapping or were typed by the user.\n+\n+      By default the string is added to the end of the typeahead\n+      buffer, thus if a mapping is still being executed the\n+      characters come after them.  Use the 'i' flag to insert before\n+      other characters, they will be executed next, before any\n+      characters from a mapping.\n+\n+      The function does not wait for processing of keys contained in\n+      {string}.\n+\n+      To include special keys into {string}, use double-quotes\n+      and \"\\...\" notation |expr-quote|. For example,\n+      feedkeys(\"\\<CR>\") simulates pressing of the <Enter> key. But\n+      feedkeys('\\<CR>') pushes 5 characters.\n+      The |<Ignore>| keycode may be used to exit the\n+      wait-for-character without doing anything.\n+\n+      {mode} is a String, which can contain these character flags:\n+      'm'\tRemap keys. This is default.  If {mode} is absent,\n+      \tkeys are remapped.\n+      'n'\tDo not remap keys.\n+      't'\tHandle keys as if typed; otherwise they are handled as\n+      \tif coming from a mapping.  This matters for undo,\n+      \topening folds, etc.\n+      'i'\tInsert the string instead of appending (see above).\n+      'x'\tExecute commands until typeahead is empty.  This is\n+      \tsimilar to using \":normal!\".  You can call feedkeys()\n+      \tseveral times without 'x' and then one time with 'x'\n+      \t(possibly with an empty {string}) to execute all the\n+      \ttypeahead.  Note that when Vim ends in Insert mode it\n+      \twill behave as if <Esc> is typed, to avoid getting\n+      \tstuck, waiting for a character to be typed before the\n+      \tscript continues.\n+      \tNote that if you manage to call feedkeys() while\n+      \texecuting commands, thus calling it recursively, then\n+      \tall typeahead will be consumed by the last call.\n+      '!'\tWhen used with 'x' will not end Insert mode. Can be\n+      \tused in a test when a timer is set to exit Insert mode\n+      \ta little later.  Useful for testing CursorHoldI.\n+\n+      Return value is always 0.\n+\n+      Can also be used as a |method|: >\n+      \tGetInput()->feedkeys()\n+\n+    ]=],\n+    name = 'feedkeys',\n+    params = { { 'string', 'string' }, { 'mode', 'string' } },\n+    signature = 'feedkeys({string} [, {mode}])',\n+  },\n+  file_readable = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |filereadable()|.\n+    ]=],\n+    func = 'f_filereadable',\n+    name = 'file_readable',\n+    params = { { 'file', 'string' } },\n+    signature = 'file_readable({file})',\n+  },\n+  filereadable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a file with the\n+      name {file} exists, and can be read.  If {file} doesn't exist,\n+      or is a directory, the result is |FALSE|.  {file} is any\n+      expression, which is used as a String.\n+      If you don't care about the file being readable you can use\n+      |glob()|.\n+      {file} is used as-is, you may want to expand wildcards first: >\n+      \techo filereadable('~/.vimrc')\n+      \t0\n+      \techo filereadable(expand('~/.vimrc'))\n+      \t1\n+\n+      <Can also be used as a |method|: >\n+      \tGetName()->filereadable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filereadable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filereadable({file})',\n+  },\n+  filewritable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when a file with the\n+      name {file} exists, and can be written.  If {file} doesn't\n+      exist, or is not writable, the result is 0.  If {file} is a\n+      directory, and we can write to it, the result is 2.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->filewritable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filewritable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filewritable({file})',\n+  },\n+  filter = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob|, or a |Dictionary|.\n+      For each item in {expr1} evaluate {expr2} and when the result\n+      is zero remove the item from the |List| or |Dictionary|. For a\n+      |Blob| each byte is removed.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+\n+      Examples: >\n+      \tcall filter(mylist, 'v:val !~ \"OLD\"')\n+      <Removes the items where \"OLD\" appears. >\n+      \tcall filter(mydict, 'v:key >= 8')\n+      <Removes the items with a key below 8. >\n+      \tcall filter(var, 0)\n+      <Removes all the items, thus clears the |List| or |Dictionary|.\n+\n+      Note that {expr2} is the result of expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.\n+\n+      If {expr2} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item should be kept.\n+      Example that keeps the odd items of a list: >\n+      \tfunc Odd(idx, val)\n+      \t  return a:idx % 2 == 1\n+      \tendfunc\n+      \tcall filter(mylist, function('Odd'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall filter(myList, {idx, val -> idx * val <= 42})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall filter(myList, {idx -> idx % 2 == 1})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let l = filter(copy(mylist), 'v:val =~ \"KEEP\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->filter(expr2)\n+\n+    ]=],\n+    name = 'filter',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'filter({expr1}, {expr2})',\n+  },\n+  finddir = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Find directory {name} in {path}.  Supports both downwards and\n+      upwards recursive directory searches.  See |file-searching|\n+      for the syntax of {path}.\n+\n+      Returns the path of the first found match.  When the found\n+      directory is below the current directory a relative path is\n+      returned.  Otherwise a full path is returned.\n+      If {path} is omitted or empty then 'path' is used.\n+\n+      If the optional {count} is given, find {count}'s occurrence of\n+      {name} in {path} instead of the first one.\n+      When {count} is negative return all the matches in a |List|.\n+\n+      Returns an empty string if the directory is not found.\n+\n+      This is quite similar to the ex-command `:find`.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->finddir()\n+\n+    ]=],\n+    name = 'finddir',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'finddir({name} [, {path} [, {count}]])',\n+  },\n+  findfile = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |finddir()|, but find a file instead of a directory.\n+      Uses 'suffixesadd'.\n+      Example: >\n+      \t:echo findfile(\"tags.vim\", \".;\")\n+      <Searches from the directory of the current file upwards until\n+      it finds the file \"tags.vim\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->findfile()\n+\n+    ]=],\n+    name = 'findfile',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'findfile({name} [, {path} [, {count}]])',\n+  },\n+  flatten = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Flatten {list} up to {maxdepth} levels.  Without {maxdepth}\n+      the result is a |List| without nesting, as if {maxdepth} is\n+      a very large number.\n+      The {list} is changed in place, use |flattennew()| if you do\n+      not want that.\n+      \t\t\t\t\t\t*E900*\n+      {maxdepth} means how deep in nested lists changes are made.\n+      {list} is not modified when {maxdepth} is 0.\n+      {maxdepth} must be positive number.\n+\n+      If there is an error the number zero is returned.\n+\n+      Example: >\n+      \t:echo flatten([1, [2, [3, 4]], 5])\n+      <\t[1, 2, 3, 4, 5] >\n+      \t:echo flatten([1, [2, [3, 4]], 5], 1)\n+      <\t[1, 2, [3, 4], 5]\n+\n+      Can also be used as a |method|: >\n+      \tmylist->flatten()\n+      <\n+    ]=],\n+    name = 'flatten',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flatten({list} [, {maxdepth}])',\n+  },\n+  flattennew = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Like |flatten()| but first make a copy of {list}.\n+    ]=],\n+    name = 'flattennew',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flattennew({list} [, {maxdepth}])',\n+  },\n+  float2nr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} to a Number by omitting the part after the\n+      decimal point.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0 if {expr} is not a |Float| or a |Number|.\n+      When the value of {expr} is out of range for a |Number| the\n+      result is truncated to 0x7fffffff or -0x7fffffff (or when\n+      64-bit Number support is enabled, 0x7fffffffffffffff or\n+      -0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n+      64-bit Number support is enabled, -0x8000000000000000).\n+      Examples: >\n+      \techo float2nr(3.95)\n+      <\t3  >\n+      \techo float2nr(-23.45)\n+      <\t-23  >\n+      \techo float2nr(1.0e100)\n+      <\t2147483647  (or 9223372036854775807) >\n+      \techo float2nr(-1.0e150)\n+      <\t-2147483647 (or -9223372036854775807) >\n+      \techo float2nr(1.0e-100)\n+      <\t0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->float2nr()\n+\n+    ]=],\n+    name = 'float2nr',\n+    params = { { 'expr', 'any' } },\n+    signature = 'float2nr({expr})',\n+  },\n+  floor = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the largest integral value less than or equal to\n+      {expr} as a |Float| (round down).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \techo floor(1.856)\n+      <\t1.0  >\n+      \techo floor(-5.456)\n+      <\t-6.0  >\n+      \techo floor(4.0)\n+      <\t4.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->floor()\n+\n+    ]=],\n+    float_func = 'floor',\n+    name = 'floor',\n+    params = { { 'expr', 'any' } },\n+    signature = 'floor({expr})',\n+  },\n+  fmod = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the remainder of {expr1} / {expr2}, even if the\n+      division is not representable.  Returns {expr1} - i * {expr2}\n+      for some integer i such that if {expr2} is non-zero, the\n+      result has the same sign as {expr1} and magnitude less than\n+      the magnitude of {expr2}.  If {expr2} is zero, the value\n+      returned is zero.  The value returned is a |Float|.\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo fmod(12.33, 1.22)\n+      <\t0.13 >\n+      \t:echo fmod(-12.33, 1.22)\n+      <\t-0.13\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->fmod(1.22)\n+\n+    ]=],\n+    name = 'fmod',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'fmod({expr1}, {expr2})',\n+  },\n+  fnameescape = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Escape {string} for use as file name command argument.  All\n+      characters that have a special meaning, such as '%' and '|'\n+      are escaped with a backslash.\n+      For most systems the characters escaped are\n+      \" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\n+      appears in a filename, it depends on the value of 'isfname'.\n+      A leading '+' and '>' is also escaped (special after |:edit|\n+      and |:write|).  And a \"-\" by itself (special after |:cd|).\n+      Returns an empty string on error.\n+      Example: >\n+      \t:let fname = '+some str%nge|name'\n+      \t:exe \"edit \" .. fnameescape(fname)\n+      <results in executing: >\n+      \tedit \\+some\\ str\\%nge\\|name\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->fnameescape()\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnameescape',\n+    params = { { 'string', 'string' } },\n+    returns = 'string',\n+    signature = 'fnameescape({string})',\n+  },\n+  fnamemodify = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Modify file name {fname} according to {mods}.  {mods} is a\n+      string of characters like it is used for file names on the\n+      command line.  See |filename-modifiers|.\n+      Example: >\n+      \t:echo fnamemodify(\"main.c\", \":p:h\")\n+      <results in: >\n+      \t/home/user/vim/vim/src\n+      <If {mods} is empty or an unsupported modifier is used then\n+      {fname} is returned.\n+      When {fname} is empty then with {mods} \":h\" returns \".\", so\n+      that `:cd` can be used with it.  This is different from\n+      expand('%:h') without a buffer name, which returns an empty\n+      string.\n+      Note: Environment variables don't work in {fname}, use\n+      |expand()| first then.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fnamemodify(':p:h')\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnamemodify',\n+    params = { { 'fname', 'integer' }, { 'mods', 'string' } },\n+    returns = 'string',\n+    signature = 'fnamemodify({fname}, {mods})',\n+  },\n+  foldclosed = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the first line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosed()\n+\n+    ]=],\n+    name = 'foldclosed',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosed({lnum})',\n+  },\n+  foldclosedend = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the last line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosedend()\n+\n+    ]=],\n+    name = 'foldclosedend',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosedend({lnum})',\n+  },\n+  foldlevel = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the foldlevel of line {lnum}\n+      in the current buffer.  For nested folds the deepest level is\n+      returned.  If there is no fold at line {lnum}, zero is\n+      returned.  It doesn't matter if the folds are open or closed.\n+      When used while updating folds (from 'foldexpr') -1 is\n+      returned for lines where folds are still to be updated and the\n+      foldlevel is unknown.  As a special case the level of the\n+      previous line is usually available.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldlevel()\n+      <\n+    ]=],\n+    name = 'foldlevel',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldlevel({lnum})',\n+  },\n+  foldtext = {\n+    desc = [=[\n+      Returns a String, to be displayed for a closed fold.  This is\n+      the default function used for the 'foldtext' option and should\n+      only be called from evaluating 'foldtext'.  It uses the\n+      |v:foldstart|, |v:foldend| and |v:folddashes| variables.\n+      The returned string looks like this: >\n+      \t+-- 45 lines: abcdef\n+      <The number of leading dashes depends on the foldlevel.  The\n+      \"45\" is the number of lines in the fold.  \"abcdef\" is the text\n+      in the first non-blank line of the fold.  Leading white space,\n+      \"//\" or \"/*\" and the text from the 'foldmarker' and\n+      'commentstring' options is removed.\n+      When used to draw the actual foldtext, the rest of the line\n+      will be filled with the fold char from the 'fillchars'\n+      setting.\n+      Returns an empty string when there is no fold.\n+\n+    ]=],\n+    name = 'foldtext',\n+    params = {},\n+    returns = 'string',\n+    signature = 'foldtext()',\n+  },\n+  foldtextresult = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the text that is displayed for the closed fold at line\n+      {lnum}.  Evaluates 'foldtext' in the appropriate context.\n+      When there is no closed fold at {lnum} an empty string is\n+      returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Useful when exporting folded text, e.g., to HTML.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldtextresult()\n+      <\n+    ]=],\n+    name = 'foldtextresult',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'string',\n+    signature = 'foldtextresult({lnum})',\n+  },\n+  foreground = {\n+    lua = false,\n+  },\n+  fullcommand = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the full command name from a short abbreviated command\n+      name; see |20.2| for details on command abbreviations.\n+\n+      The string argument {name} may start with a `:` and can\n+      include a [range], these are skipped and not returned.\n+      Returns an empty string if a command doesn't exist or if it's\n+      ambiguous (for user-defined commands).\n+\n+      For example `fullcommand('s')`, `fullcommand('sub')`,\n+      `fullcommand(':%substitute')` all return \"substitute\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fullcommand()\n+      <\n+    ]=],\n+    name = 'fullcommand',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'fullcommand({name})',\n+  },\n+  funcref = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |function()|, but the returned Funcref will lookup\n+      the function by reference, not by name.  This matters when the\n+      function {name} is redefined later.\n+\n+      Unlike |function()|, {name} must be an existing user function.\n+      It only works for an autoloaded function if it has already\n+      been loaded (to avoid mistakenly loading the autoload script\n+      when only intending to use the function name, use |function()|\n+      instead). {name} cannot be a builtin function.\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->funcref([arg])\n+      <\n+    ]=],\n+    name = 'funcref',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'funcref({name} [, {arglist}] [, {dict}])',\n+  },\n+  ['function'] = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |Funcref| variable that refers to function {name}.\n+      {name} can be the name of a user defined function or an\n+      internal function.\n+\n+      {name} can also be a Funcref or a partial. When it is a\n+      partial the dict stored in it will be used and the {dict}\n+      argument is not allowed. E.g.: >\n+      \tlet FuncWithArg = function(dict.Func, [arg])\n+      \tlet Broken = function(dict.Func, [arg], dict)\n+      <\n+      When using the Funcref the function will be found by {name},\n+      also when it was redefined later. Use |funcref()| to keep the\n+      same function.\n+\n+      When {arglist} or {dict} is present this creates a partial.\n+      That means the argument list and/or the dictionary is stored in\n+      the Funcref and will be used when the Funcref is called.\n+\n+      The arguments are passed to the function in front of other\n+      arguments, but after any argument from |method|.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['one', 'two'])\n+      \t\"...\n+      \tcall Partial('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <With a |method|: >\n+      \tfunc Callback(one, two, three)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['two'])\n+      \t\"...\n+      \teval 'one'->Partial('three')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'three')\n+\n+      <The function() call can be nested to add more arguments to the\n+      Funcref.  The extra arguments are appended to the list of\n+      arguments.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Func = function('Callback', ['one'])\n+      \tlet Func2 = function(Func, ['two'])\n+      \t\"...\n+      \tcall Func2('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <The Dictionary is only useful when calling a \"dict\" function.\n+      In that case the {dict} is passed in as \"self\". Example: >\n+      \tfunction Callback() dict\n+      \t   echo \"called for \" .. self.name\n+      \tendfunction\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', context)\n+      \t\"...\n+      \tcall Func()\t\" will echo: called for example\n+      <The use of function() is not needed when there are no extra\n+      arguments, these two are equivalent, if Callback() is defined\n+      as context.Callback(): >\n+      \tlet Func = function('Callback', context)\n+      \tlet Func = context.Callback\n+\n+      <The argument list and the Dictionary can be combined: >\n+      \tfunction Callback(arg1, count) dict\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', ['one'], context)\n+      \t\"...\n+      \tcall Func(500)\n+      <Invokes the function as with: >\n+      \tcall context.Callback('one', 500)\n+      <\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->function([arg])\n+\n+    ]=],\n+    name = 'function',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'function({name} [, {arglist}] [, {dict}])',\n+    tags = { 'partial', 'E700', 'E923' },\n+  },\n+  garbagecollect = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Cleanup unused |Lists| and |Dictionaries| that have circular\n+      references.\n+\n+      There is hardly ever a need to invoke this function, as it is\n+      automatically done when Vim runs out of memory or is waiting\n+      for the user to press a key after 'updatetime'.  Items without\n+      circular references are always freed when they become unused.\n+      This is useful if you have deleted a very big |List| and/or\n+      |Dictionary| with circular references in a script that runs\n+      for a long time.\n+\n+      When the optional {atexit} argument is one, garbage\n+      collection will also be done when exiting Vim, if it wasn't\n+      done before.  This is useful when checking for memory leaks.\n+\n+      The garbage collection is not done immediately but only when\n+      it's safe to perform.  This is when waiting for the user to\n+      type a character.\n+\n+    ]=],\n+    name = 'garbagecollect',\n+    params = { { 'atexit', 'any' } },\n+    signature = 'garbagecollect([{atexit}])',\n+  },\n+  get = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {idx} from |List| {list}.  When this item is not\n+      available return {default}.  Return zero when {default} is\n+      omitted.\n+      Can also be used as a |method|: >\n+      \tmylist->get(idx)\n+    ]=],\n+    name = 'get',\n+    params = { { 'list', 'any[]' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({list}, {idx} [, {default}])',\n+  },\n+  get__1 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get byte {idx} from |Blob| {blob}.  When this byte is not\n+      available return {default}.  Return -1 when {default} is\n+      omitted.\n+    ]=],\n+    name = 'get',\n+    params = { { 'blob', 'string' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({blob}, {idx} [, {default}])',\n+  },\n+  get__2 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item with key {key} from |Dictionary| {dict}.  When this\n+      item is not available return {default}.  Return zero when\n+      {default} is omitted.  Useful example: >\n+      \tlet val = get(g:, 'var_name', 'default')\n+      <This gets the value of g:var_name if it exists, and uses\n+      \"default\" when it does not exist.\n+    ]=],\n+    name = 'get',\n+    params = { { 'dict', 'table<string,any>' }, { 'key', 'string' }, { 'default', 'any' } },\n+    signature = 'get({dict}, {key} [, {default}])',\n+  },\n+  get__3 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {what} from Funcref {func}.  Possible values for\n+      {what} are:\n+      \t\"name\"\tThe function name\n+      \t\"func\"\tThe function\n+      \t\"dict\"\tThe dictionary\n+      \t\"args\"\tThe list with arguments\n+      Returns zero on error.\n+    ]=],\n+    name = 'get',\n+    params = { { 'func', 'function' }, { 'what', 'string' } },\n+    returns = 'any',\n+    signature = 'get({func}, {what})',\n+  },\n+  getbufinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    name = 'getbufinfo',\n+    params = { { 'buf', 'integer|string' } },\n+    signature = 'getbufinfo([{buf}])',\n+  },\n+  getbufinfo__1 = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get information about buffers as a List of Dictionaries.\n+\n+      Without an argument information about all the buffers is\n+      returned.\n+\n+      When the argument is a |Dictionary| only the buffers matching\n+      the specified criteria are returned.  The following keys can\n+      be specified in {dict}:\n+      \tbuflisted\tinclude only listed buffers.\n+      \tbufloaded\tinclude only loaded buffers.\n+      \tbufmodified\tinclude only modified buffers.\n+\n+      Otherwise, {buf} specifies a particular buffer to return\n+      information for.  For the use of {buf}, see |bufname()|\n+      above.  If the buffer is found the returned List has one item.\n+      Otherwise the result is an empty list.\n+\n+      Each returned List item is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tBuffer number.\n+      \tchanged\t\tTRUE if the buffer is modified.\n+      \tchangedtick\tNumber of changes made to the buffer.\n+      \thidden\t\tTRUE if the buffer is hidden.\n+      \tlastused\tTimestamp in seconds, like\n+      \t\t\t|localtime()|, when the buffer was\n+      \t\t\tlast used.\n+      \tlisted\t\tTRUE if the buffer is listed.\n+      \tlnum\t\tLine number used for the buffer when\n+      \t\t\topened in the current window.\n+      \t\t\tOnly valid if the buffer has been\n+      \t\t\tdisplayed in the window in the past.\n+      \t\t\tIf you want the line number of the\n+      \t\t\tlast known cursor position in a given\n+      \t\t\twindow, use |line()|: >\n+      \t\t\t\t:echo line('.', {winid})\n+      <\n+      \tlinecount\tNumber of lines in the buffer (only\n+      \t\t\tvalid when loaded)\n+      \tloaded\t\tTRUE if the buffer is loaded.\n+      \tname\t\tFull path to the file in the buffer.\n+      \tsigns\t\tList of signs placed in the buffer.\n+      \t\t\tEach list item is a dictionary with\n+      \t\t\tthe following fields:\n+      \t\t\t    id\t  sign identifier\n+      \t\t\t    lnum  line number\n+      \t\t\t    name  sign name\n+      \tvariables\tA reference to the dictionary with\n+      \t\t\tbuffer-local variables.\n+      \twindows\t\tList of |window-ID|s that display this\n+      \t\t\tbuffer\n+\n+      Examples: >\n+      \tfor buf in getbufinfo()\n+      \t    echo buf.name\n+      \tendfor\n+      \tfor buf in getbufinfo({'buflisted':1})\n+      \t    if buf.changed\n+      \t\t....\n+      \t    endif\n+      \tendfor\n+      <\n+      To get buffer-local options use: >\n+      \tgetbufvar({bufnr}, '&option_name')\n+      <\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getbufinfo()\n+      <\n+    ]=],\n+    name = 'getbufinfo',\n+    params = { { 'dict', 'table<string,any>' } },\n+    signature = 'getbufinfo([{dict}])',\n+  },\n+  getbufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with the lines starting from {lnum} to {end}\n+      (inclusive) in the buffer {buf}.  If {end} is omitted, a\n+      |List| with only the line {lnum} is returned.  See\n+      `getbufoneline()` for only getting the line.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      For {lnum} and {end} \"$\" can be used for the last line of the\n+      buffer.  Otherwise a number must be used.\n+\n+      When {lnum} is smaller than 1 or bigger than the number of\n+      lines in the buffer, an empty |List| is returned.\n+\n+      When {end} is greater than the number of lines in the buffer,\n+      it is treated as {end} is set to the number of lines in the\n+      buffer.  When {end} is before {lnum} an empty |List| is\n+      returned.\n+\n+      This function works only for loaded buffers.  For unloaded and\n+      non-existing buffers, an empty |List| is returned.\n+\n+      Example: >\n+      \t:let lines = getbufline(bufnr(\"myfile\"), 1, \"$\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufline(lnum)\n+      <\n+    ]=],\n+    name = 'getbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'end', 'integer' } },\n+    signature = 'getbufline({buf}, {lnum} [, {end}])',\n+  },\n+  getbufoneline = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Just like `getbufline()` but only get one line and return it\n+      as a string.\n+    ]=],\n+    name = 'getbufoneline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' } },\n+    signature = 'getbufoneline({buf}, {lnum})',\n+  },\n+  getbufvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is the value of option or local buffer variable\n+      {varname} in buffer {buf}.  Note that the name without \"b:\"\n+      must be used.\n+      The {varname} argument is a string.\n+      When {varname} is empty returns a |Dictionary| with all the\n+      buffer-local variables.\n+      When {varname} is equal to \"&\" returns a |Dictionary| with all\n+      the buffer-local options.\n+      Otherwise, when {varname} starts with \"&\" returns the value of\n+      a buffer-local option.\n+      This also works for a global or buffer-local option, but it\n+      doesn't work for a global variable, window-local variable or\n+      window-local option.\n+      For the use of {buf}, see |bufname()| above.\n+      When the buffer or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+      Examples: >\n+      \t:let bufmodified = getbufvar(1, \"&mod\")\n+      \t:echo \"todo myvar = \" .. getbufvar(\"todo\", \"myvar\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufvar(varname)\n+      <\n+    ]=],\n+    name = 'getbufvar',\n+    params = { { 'buf', 'any' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getbufvar({buf}, {varname} [, {def}])',\n+  },\n+  getcellwidths = {\n+    desc = [=[\n+      Returns a |List| of cell widths of character ranges overridden\n+      by |setcellwidths()|.  The format is equal to the argument of\n+      |setcellwidths()|.  If no character ranges have their cell\n+      widths overridden, an empty List is returned.\n+    ]=],\n+    name = 'getcellwidths',\n+    params = {},\n+    signature = 'getcellwidths()',\n+  },\n+  getchangelist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |changelist| for the buffer {buf}. For the use\n+      of {buf}, see |bufname()| above. If buffer {buf} doesn't\n+      exist, an empty list is returned.\n+\n+      The returned list contains two entries: a list with the change\n+      locations and the current position in the list.  Each\n+      entry in the change list is a dictionary with the following\n+      entries:\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tlnum\t\tline number\n+      If buffer {buf} is the current buffer, then the current\n+      position refers to the position in the list. For other\n+      buffers, it is set to the length of the list.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getchangelist()\n+\n+    ]=],\n+    name = 'getchangelist',\n+    params = { { 'buf', 'integer|string' } },\n+    returns = 'table[]',\n+    signature = 'getchangelist([{buf}])',\n+  },\n+  getchar = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0, only get a character when one is available.\n+      \tReturn zero otherwise.\n+      If [expr] is 1, only check if a character is available, it is\n+      \tnot consumed.  Return zero if no character available.\n+      If you prefer always getting a string use |getcharstr()|.\n+\n+      Without [expr] and when [expr] is 0 a whole character or\n+      special key is returned.  If it is a single character, the\n+      result is a Number.  Use |nr2char()| to convert it to a String.\n+      Otherwise a String is returned with the encoded character.\n+      For a special key it's a String with a sequence of bytes\n+      starting with 0x80 (decimal: 128).  This is the same value as\n+      the String \"\\<Key>\", e.g., \"\\<Left>\".  The returned value is\n+      also a String when a modifier (shift, control, alt) was used\n+      that is not included in the character.\n+\n+      When [expr] is 0 and Esc is typed, there will be a short delay\n+      while Vim waits to see if this is the start of an escape\n+      sequence.\n+\n+      When [expr] is 1 only the first byte is returned.  For a\n+      one-byte character it is the character itself as a number.\n+      Use nr2char() to convert it to a String.\n+\n+      Use getcharmod() to obtain any additional modifiers.\n+\n+      When the user clicks a mouse button, the mouse event will be\n+      returned.  The position can then be found in |v:mouse_col|,\n+      |v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.\n+      |getmousepos()| can also be used.  Mouse move events will be\n+      ignored.\n+      This example positions the mouse as it would normally happen: >\n+      \tlet c = getchar()\n+      \tif c == \"\\<LeftMouse>\" && v:mouse_win > 0\n+      \t  exe v:mouse_win .. \"wincmd w\"\n+      \t  exe v:mouse_lnum\n+      \t  exe \"normal \" .. v:mouse_col .. \"|\"\n+      \tendif\n+      <\n+      There is no prompt, you will somehow have to make clear to the\n+      user that a character has to be typed.  The screen is not\n+      redrawn, e.g. when resizing the window.\n+\n+      There is no mapping for the character.\n+      Key codes are replaced, thus when the user presses the <Del>\n+      key you get the code for the <Del> key, not the raw character\n+      sequence.  Examples: >\n+      \tgetchar() == \"\\<Del>\"\n+      \tgetchar() == \"\\<S-Left>\"\n+      <This example redefines \"f\" to ignore case: >\n+      \t:nmap f :call FindChar()<CR>\n+      \t:function FindChar()\n+      \t:  let c = nr2char(getchar())\n+      \t:  while col('.') < col('$') - 1\n+      \t:    normal l\n+      \t:    if getline('.')[col('.') - 1] ==? c\n+      \t:      break\n+      \t:    endif\n+      \t:  endwhile\n+      \t:endfunction\n+      <\n+    ]=],\n+    name = 'getchar',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getchar([expr])',\n+  },\n+  getcharmod = {\n+    desc = [=[\n+      The result is a Number which is the state of the modifiers for\n+      the last obtained character with getchar() or in another way.\n+      These values are added together:\n+      \t2\tshift\n+      \t4\tcontrol\n+      \t8\talt (meta)\n+      \t16\tmeta (when it's different from ALT)\n+      \t32\tmouse double click\n+      \t64\tmouse triple click\n+      \t96\tmouse quadruple click (== 32 + 64)\n+      \t128\tcommand (Macintosh only)\n+      Only the modifiers that have not been included in the\n+      character itself are obtained.  Thus Shift-a results in \"A\"\n+      without a modifier.  Returns 0 if no modifiers are used.\n+    ]=],\n+    name = 'getcharmod',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcharmod()',\n+  },\n+  getcharpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}. Same as |getpos()| but the\n+      column number in the returned List is a character index\n+      instead of a byte index.\n+      If |getpos()| returns a very large column number, equal to\n+      |v:maxcol|, then getcharpos() will return the character index\n+      of the last character.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tgetcharpos('.')\t\treturns [0, 5, 3, 0]\n+      \tgetpos('.')\t\treturns [0, 5, 7, 0]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetMark()->getcharpos()\n+      <\n+    ]=],\n+    name = 'getcharpos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'integer[]',\n+    signature = 'getcharpos({expr})',\n+  },\n+  getcharsearch = {\n+    desc = [=[\n+      Return the current character search information as a {dict}\n+      with the following entries:\n+\n+          char\tcharacter previously used for a character\n+      \t\tsearch (|t|, |f|, |T|, or |F|); empty string\n+      \t\tif no character search has been performed\n+          forward\tdirection of character search; 1 for forward,\n+      \t\t0 for backward\n+          until\ttype of character search; 1 for a |t| or |T|\n+      \t\tcharacter search, 0 for an |f| or |F|\n+      \t\tcharacter search\n+\n+      This can be useful to always have |;| and |,| search\n+      forward/backward regardless of the direction of the previous\n+      character search: >\n+      \t:nnoremap <expr> ; getcharsearch().forward ? ';' : ','\n+      \t:nnoremap <expr> , getcharsearch().forward ? ',' : ';'\n+      <Also see |setcharsearch()|.\n+    ]=],\n+    name = 'getcharsearch',\n+    params = {},\n+    returns = 'table[]',\n+    signature = 'getcharsearch()',\n+  },\n+  getcharstr = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream as a\n+      string.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0 or false, only get a character when one is\n+      \tavailable.  Return an empty string otherwise.\n+      If [expr] is 1 or true, only check if a character is\n+      \tavailable, it is not consumed.  Return an empty string\n+      \tif no character is available.\n+      Otherwise this works like |getchar()|, except that a number\n+      result is converted to a string.\n+\n+    ]=],\n+    name = 'getcharstr',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcharstr([expr])',\n+  },\n+  getcmdcompltype = {\n+    desc = [=[\n+      Return the type of the current command-line completion.\n+      Only works when the command line is being edited, thus\n+      requires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\n+      See |:command-completion| for the return string.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+      Returns an empty string when completion is not defined.\n+\n+    ]=],\n+    name = 'getcmdcompltype',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdcompltype()',\n+  },\n+  getcmdline = {\n+    desc = [=[\n+      Return the current command-line.  Only works when the command\n+      line is being edited, thus requires use of |c_CTRL-\\_e| or\n+      |c_CTRL-R_=|.\n+      Example: >\n+      \t:cmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n+      <Also see |getcmdtype()|, |getcmdpos()|, |setcmdpos()| and\n+      |setcmdline()|.\n+      Returns an empty string when entering a password or using\n+      |inputsecret()|.\n+    ]=],\n+    name = 'getcmdline',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdline()',\n+  },\n+  getcmdpos = {\n+    desc = [=[\n+      Return the position of the cursor in the command line as a\n+      byte count.  The first column is 1.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+    ]=],\n+    name = 'getcmdpos',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcmdpos()',\n+  },\n+  getcmdscreenpos = {\n+    desc = [=[\n+      Return the screen position of the cursor in the command line\n+      as a byte count.  The first column is 1.\n+      Instead of |getcmdpos()|, it adds the prompt position.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+\n+    ]=],\n+    name = 'getcmdscreenpos',\n+    params = {},\n+    signature = 'getcmdscreenpos()',\n+  },\n+  getcmdtype = {\n+    desc = [=[\n+      Return the current command-line type. Possible return values\n+      are:\n+          :\tnormal Ex command\n+          >\tdebug mode command |debug-mode|\n+          /\tforward search command\n+          ?\tbackward search command\n+          @\t|input()| command\n+          `-`\t|:insert| or |:append| command\n+          =\t|i_CTRL-R_=|\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns an empty string otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.\n+    ]=],\n+    name = 'getcmdtype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdtype()',\n+  },\n+  getcmdwintype = {\n+    desc = [=[\n+      Return the current |command-line-window| type. Possible return\n+      values are the same as |getcmdtype()|. Returns an empty string\n+      when not in the command-line window.\n+    ]=],\n+    name = 'getcmdwintype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdwintype()',\n+  },\n+  getcompletion = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of command-line completion matches. The String\n+      {type} argument specifies what for.  The following completion\n+      types are supported:\n+\n+      arglist\t\tfile names in argument list\n+      augroup\t\tautocmd groups\n+      buffer\t\tbuffer names\n+      breakpoint\t|:breakadd| and |:breakdel| suboptions\n+      cmdline\t\t|cmdline-completion| result\n+      color\t\tcolor schemes\n+      command\t\tEx command\n+      compiler\tcompilers\n+      diff_buffer     |:diffget| and |:diffput| completion\n+      dir\t\tdirectory names\n+      environment\tenvironment variable names\n+      event\t\tautocommand events\n+      expression\tVim expression\n+      file\t\tfile and directory names\n+      file_in_path\tfile and directory names in |'path'|\n+      filetype\tfiletype names |'filetype'|\n+      function\tfunction name\n+      help\t\thelp subjects\n+      highlight\thighlight groups\n+      history\t\t|:history| suboptions\n+      locale\t\tlocale names (as output of locale -a)\n+      mapclear\tbuffer argument\n+      mapping\t\tmapping name\n+      menu\t\tmenus\n+      messages\t|:messages| suboptions\n+      option\t\toptions\n+      packadd\t\toptional package |pack-add| names\n+      runtime\t\t|:runtime| completion\n+      scriptnames\tsourced script names |:scriptnames|\n+      shellcmd\tShell command\n+      sign\t\t|:sign| suboptions\n+      syntax\t\tsyntax file names |'syntax'|\n+      syntime\t\t|:syntime| suboptions\n+      tag\t\ttags\n+      tag_listfiles\ttags, file names\n+      user\t\tuser names\n+      var\t\tuser variables\n+\n+      If {pat} is an empty string, then all the matches are\n+      returned.  Otherwise only items matching {pat} are returned.\n+      See |wildcards| for the use of special characters in {pat}.\n+\n+      If the optional {filtered} flag is set to 1, then 'wildignore'\n+      is applied to filter the results.  Otherwise all the matches\n+      are returned. The 'wildignorecase' option always applies.\n+\n+      If the 'wildoptions' option contains \"fuzzy\", then fuzzy\n+      matching is used to get the completion matches. Otherwise\n+      regular expression matching is used.  Thus this function\n+      follows the user preference, what happens on the command line.\n+      If you do not want this you can make 'wildoptions' empty\n+      before calling getcompletion() and restore it afterwards.\n+\n+      If {type} is \"cmdline\", then the |cmdline-completion| result is\n+      returned.  For example, to complete the possible values after\n+      a \":call\" command: >\n+      \techo getcompletion('call ', 'cmdline')\n+      <\n+      If there are no matches, an empty list is returned.  An\n+      invalid value for {type} produces an error.\n+\n+      Can also be used as a |method|: >\n+      \tGetPattern()->getcompletion('color')\n+      <\n+    ]=],\n+    name = 'getcompletion',\n+    params = { { 'pat', 'any' }, { 'type', 'any' }, { 'filtered', 'any' } },\n+    returns = 'string[]',\n+    signature = 'getcompletion({pat}, {type} [, {filtered}])',\n+  },\n+  getcurpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get the position of the cursor.  This is like getpos('.'), but\n+      includes an extra \"curswant\" item in the list:\n+          [0, lnum, col, off, curswant] ~\n+      The \"curswant\" number is the preferred column when moving the\n+      cursor vertically.  After |$| command it will be a very large\n+      number equal to |v:maxcol|.  Also see |getcursorcharpos()| and\n+      |getpos()|.\n+      The first \"bufnum\" item is always zero. The byte position of\n+      the cursor is returned in \"col\". To get the character\n+      position, use |getcursorcharpos()|.\n+\n+      The optional {winid} argument can specify the window.  It can\n+      be the window number or the |window-ID|.  The last known\n+      cursor position is returned, this may be invalid for the\n+      current value of the buffer if it is not the current window.\n+      If {winid} is invalid a list with zeroes is returned.\n+\n+      This can be used to save and restore the cursor position: >\n+      \tlet save_cursor = getcurpos()\n+      \tMoveTheCursorAround\n+      \tcall setpos('.', save_cursor)\n+      <Note that this only works within the window.  See\n+      |winrestview()| for restoring more state.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcurpos()\n+      <\n+    ]=],\n+    name = 'getcurpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcurpos([{winid}])',\n+  },\n+  getcursorcharpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Same as |getcurpos()| but the column number in the returned\n+      List is a character index instead of a byte index.\n+\n+      Example:\n+      With the cursor on '' in line 3 with text \"\": >\n+      \tgetcursorcharpos()\treturns [0, 3, 2, 0, 3]\n+      \tgetcurpos()\t\treturns [0, 3, 4, 0, 3]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcursorcharpos()\n+\n+    ]=],\n+    name = 'getcursorcharpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcursorcharpos([{winid}])',\n+  },\n+  getcwd = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      With no arguments, returns the name of the effective\n+      |current-directory|. With {winnr} or {tabnr} the working\n+      directory of that scope is returned, and 'autochdir' is\n+      ignored.\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing tab number implies 0.\n+      Thus the following are equivalent: >\n+      \tgetcwd(0)\n+      \tgetcwd(0, 0)\n+      <If {winnr} is -1 it is ignored, only the tab is resolved.\n+      {winnr} can be the window number or the |window-ID|.\n+      If both {winnr} and {tabnr} are -1 the global working\n+      directory is returned.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getcwd()\n+\n+    ]=],\n+    name = 'getcwd',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'string',\n+    signature = 'getcwd([{winnr} [, {tabnr}]])',\n+  },\n+  getenv = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the value of environment variable {name}.  The {name}\n+      argument is a string, without a leading '$'.  Example: >\n+      \tmyHome = getenv('HOME')\n+\n+      <When the variable does not exist |v:null| is returned.  That\n+      is different from a variable set to an empty string.\n+      See also |expr-env|.\n+\n+      Can also be used as a |method|: >\n+      \tGetVarname()->getenv()\n+\n+    ]=],\n+    name = 'getenv',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getenv({name})',\n+  },\n+  getfontname = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Without an argument returns the name of the normal font being\n+      used.  Like what is used for the Normal highlight group\n+      |hl-Normal|.\n+      With an argument a check is done whether String {name} is a\n+      valid font name.  If not then an empty string is returned.\n+      Otherwise the actual font name is returned, or {name} if the\n+      GUI does not support obtaining the real name.\n+      Only works when the GUI is running, thus not in your vimrc or\n+      gvimrc file.  Use the |GUIEnter| autocommand to use this\n+      function just after the GUI has started.\n+\n+    ]=],\n+    name = 'getfontname',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getfontname([{name}])',\n+  },\n+  getfperm = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the read, write, and execute\n+      permissions of the given file {fname}.\n+      If {fname} does not exist or its directory cannot be read, an\n+      empty string is returned.\n+      The result is of the form \"rwxrwxrwx\", where each group of\n+      \"rwx\" flags represent, in turn, the permissions of the owner\n+      of the file, the group the file belongs to, and other users.\n+      If a user does not have a given permission the flag for this\n+      is replaced with the string \"-\".  Examples: >\n+      \t:echo getfperm(\"/etc/passwd\")\n+      \t:echo getfperm(expand(\"~/.config/nvim/init.vim\"))\n+      <This will hopefully (from a security point of view) display\n+      the string \"rw-r--r--\" or even \"rw-------\".\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfperm()\n+      <\n+      For setting permissions use |setfperm()|.\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfperm',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'string',\n+    signature = 'getfperm({fname})',\n+  },\n+  getfsize = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the size in bytes of the\n+      given file {fname}.\n+      If {fname} is a directory, 0 is returned.\n+      If the file {fname} can't be found, -1 is returned.\n+      If the size of {fname} is too big to fit in a Number then -2\n+      is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfsize()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfsize',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getfsize({fname})',\n+  },\n+  getftime = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the last modification time of\n+      the given file {fname}.  The value is measured as seconds\n+      since 1st Jan 1970, and may be passed to strftime().  See also\n+      |localtime()| and |strftime()|.\n+      If the file {fname} can't be found -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftime()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getftime',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getftime({fname})',\n+  },\n+  getftype = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is a description of the kind of\n+      file of the given file {fname}.\n+      If {fname} does not exist an empty string is returned.\n+      Here is a table over different kinds of files and their\n+      results:\n+      \tNormal file\t\t\"file\"\n+      \tDirectory\t\t\"dir\"\n+      \tSymbolic link\t\t\"link\"\n+      \tBlock device\t\t\"bdev\"\n+      \tCharacter device\t\"cdev\"\n+      \tSocket\t\t\t\"socket\"\n+      \tFIFO\t\t\t\"fifo\"\n+      \tAll other\t\t\"other\"\n+      Example: >\n+      \tgetftype(\"/home\")\n+      <Note that a type such as \"link\" will only be returned on\n+      systems that support it.  On some systems only \"dir\" and\n+      \"file\" are returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftype()\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'getftype',\n+    params = { { 'fname', 'integer' } },\n+    returns = \"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\",\n+    signature = 'getftype({fname})',\n+  },\n+  getjumplist = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |jumplist| for the specified window.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      {winnr} can also be a |window-ID|.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.  If {winnr} or {tabnr} is invalid, an empty list is\n+      returned.\n+\n+      The returned list contains two entries: a list with the jump\n+      locations and the last used jump position number in the list.\n+      Each entry in the jump location list is a dictionary with\n+      the following entries:\n+      \tbufnr\t\tbuffer number\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tfilename\tfilename if available\n+      \tlnum\t\tline number\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getjumplist()\n+      <\n+    ]=],\n+    name = 'getjumplist',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    signature = 'getjumplist([{winnr} [, {tabnr}]])',\n+  },\n+  getline = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {end} the result is a String, which is line {lnum}\n+      from the current buffer.  Example: >\n+      \tgetline(1)\n+      <When {lnum} is a String that doesn't start with a\n+      digit, |line()| is called to translate the String into a Number.\n+      To get the line under the cursor: >\n+      \tgetline(\".\")\n+      <When {lnum} is a number smaller than 1 or bigger than the\n+      number of lines in the buffer, an empty string is returned.\n+\n+      When {end} is given the result is a |List| where each item is\n+      a line from the current buffer in the range {lnum} to {end},\n+      including line {end}.\n+      {end} is used in the same way as {lnum}.\n+      Non-existing lines are silently omitted.\n+      When {end} is before {lnum} an empty |List| is returned.\n+      Example: >\n+      \t:let start = line('.')\n+      \t:let end = search(\"^$\") - 1\n+      \t:let lines = getline(start, end)\n+\n+      <Can also be used as a |method|: >\n+      \tComputeLnum()->getline()\n+\n+      <To get lines from another buffer see |getbufline()| and\n+      |getbufoneline()|\n+    ]=],\n+    name = 'getline',\n+    params = { { 'lnum', 'integer' }, { 'end', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getline({lnum} [, {end}])',\n+  },\n+  getloclist = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Returns a |List| with all the entries in the location list for\n+      window {nr}.  {nr} can be the window number or the |window-ID|.\n+      When {nr} is zero the current window is used.\n+\n+      For a location list window, the displayed location list is\n+      returned.  For an invalid window number {nr}, an empty list is\n+      returned. Otherwise, same as |getqflist()|.\n+\n+      If the optional {what} dictionary argument is supplied, then\n+      returns the items listed in {what} as a dictionary. Refer to\n+      |getqflist()| for the supported items in {what}.\n+\n+      In addition to the items supported by |getqflist()| in {what},\n+      the following item is supported by |getloclist()|:\n+\n+      \tfilewinid\tid of the window used to display files\n+      \t\t\tfrom the location list. This field is\n+      \t\t\tapplicable only when called from a\n+      \t\t\tlocation list window. See\n+      \t\t\t|location-list-file-window| for more\n+      \t\t\tdetails.\n+\n+      Returns a |Dictionary| with default values if there is no\n+      location list for the window {nr}.\n+      Returns an empty Dictionary if window {nr} does not exist.\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getloclist(3, {'all': 0})\n+      \t:echo getloclist(5, {'filewinid': 0})\n+      <\n+    ]=],\n+    name = 'getloclist',\n+    params = { { 'nr', 'integer' }, { 'what', 'any' } },\n+    signature = 'getloclist({nr} [, {what}])',\n+  },\n+  getmarklist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Without the {buf} argument returns a |List| with information\n+      about all the global marks. |mark|\n+\n+      If the optional {buf} argument is specified, returns the\n+      local marks defined in buffer {buf}.  For the use of {buf},\n+      see |bufname()|.  If {buf} is invalid, an empty list is\n+      returned.\n+\n+      Each item in the returned List is a |Dict| with the following:\n+          mark   name of the mark prefixed by \"'\"\n+          pos\t   a |List| with the position of the mark:\n+      \t\t[bufnum, lnum, col, off]\n+      \t   Refer to |getpos()| for more information.\n+          file   file name\n+\n+      Refer to |getpos()| for getting information about a specific\n+      mark.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getmarklist()\n+\n+    ]=],\n+    name = 'getmarklist',\n+    params = { { 'buf', 'any' } },\n+    signature = 'getmarklist([{buf}])',\n+  },\n+  getmatches = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all matches previously defined for the\n+      current window by |matchadd()| and the |:match| commands.\n+      |getmatches()| is useful in combination with |setmatches()|,\n+      as |setmatches()| can restore a list of matches saved by\n+      |getmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.  If {win} is invalid,\n+      an empty list is returned.\n+      Example: >vim\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:let m = getmatches()\n+      \t:call clearmatches()\n+      \t:echo getmatches()\n+      < >\n+      \t[]\n+      < >vim\n+      \t:call setmatches(m)\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:unlet m\n+      <\n+    ]=],\n+    name = 'getmatches',\n+    params = { { 'win', 'any' } },\n+    signature = 'getmatches([{win}])',\n+  },\n+  getmousepos = {\n+    desc = [=[\n+      Returns a Dictionary with the last known position of the\n+      mouse.  This can be used in a mapping for a mouse click.  The\n+      items are:\n+      \tscreenrow\tscreen row\n+      \tscreencol\tscreen column\n+      \twinid\t\tWindow ID of the click\n+      \twinrow\t\trow inside \"winid\"\n+      \twincol\t\tcolumn inside \"winid\"\n+      \tline\t\ttext line inside \"winid\"\n+      \tcolumn\t\ttext column inside \"winid\"\n+      All numbers are 1-based.\n+\n+      If not over a window, e.g. when in the command line, then only\n+      \"screenrow\" and \"screencol\" are valid, the others are zero.\n+\n+      When on the status line below a window or the vertical\n+      separator right of a window, the \"line\" and \"column\" values\n+      are zero.\n+\n+      When the position is after the text then \"column\" is the\n+      length of the text in bytes plus one.\n+\n+      If the mouse is over a focusable floating window then that\n+      window is used.\n+\n+      When using |getchar()| the Vim variables |v:mouse_lnum|,\n+      |v:mouse_col| and |v:mouse_winid| also provide these values.\n+    ]=],\n+    name = 'getmousepos',\n+    params = {},\n+    signature = 'getmousepos()',\n+  },\n+  getpid = {\n+    desc = [=[\n+      Return a Number which is the process ID of the Vim process.\n+      This is a unique number, until Vim exits.\n+    ]=],\n+    fast = true,\n+    name = 'getpid',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getpid()',\n+  },\n+  getpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}.  For possible values of\n+      {expr} see |line()|.  For getting the cursor position see\n+      |getcurpos()|.\n+      The result is a |List| with four numbers:\n+          [bufnum, lnum, col, off]\n+      \"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\n+      is the buffer number of the mark.\n+      \"lnum\" and \"col\" are the position in the buffer.  The first\n+      column is 1.\n+      The \"off\" number is zero, unless 'virtualedit' is used.  Then\n+      it is the offset in screen columns from the start of the\n+      character.  E.g., a position within a <Tab> or after the last\n+      character.\n+      Note that for '< and '> Visual mode matters: when it is \"V\"\n+      (visual line mode) the column of '< is zero and the column of\n+      '> is a large number equal to |v:maxcol|.\n+      The column number in the returned List is the byte position\n+      within the line. To get the character position in the line,\n+      use |getcharpos()|.\n+      A very large column number equal to |v:maxcol| can be returned,\n+      in which case it means \"after the end of the line\".\n+      If {expr} is invalid, returns a list with all zeros.\n+      This can be used to save and restore the position of a mark: >\n+      \tlet save_a_mark = getpos(\"'a\")\n+      \t...\n+      \tcall setpos(\"'a\", save_a_mark)\n+      <Also see |getcharpos()|, |getcurpos()| and |setpos()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetMark()->getpos()\n+      <\n+    ]=],\n+    name = 'getpos',\n+    params = { { 'expr', 'any' } },\n+    signature = 'getpos({expr})',\n+  },\n+  getqflist = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all the current quickfix errors.  Each\n+      list item is a dictionary with these entries:\n+      \tbufnr\tnumber of buffer that has the file name, use\n+      \t\tbufname() to get the name\n+      \tmodule\tmodule name\n+      \tlnum\tline number in the buffer (first line is 1)\n+      \tend_lnum\n+      \t\tend of line number if the item is multiline\n+      \tcol\tcolumn number (first column is 1)\n+      \tend_col\tend of column number if the item has range\n+      \tvcol\t|TRUE|: \"col\" is visual column\n+      \t\t|FALSE|: \"col\" is byte index\n+      \tnr\terror number\n+      \tpattern\tsearch pattern used to locate the error\n+      \ttext\tdescription of the error\n+      \ttype\ttype of the error, 'E', '1', etc.\n+      \tvalid\t|TRUE|: recognized error message\n+\n+      When there is no error list or it's empty, an empty list is\n+      returned. Quickfix list entries with a non-existing buffer\n+      number are returned with \"bufnr\" set to zero (Note: some\n+      functions accept buffer number zero for the alternate buffer,\n+      you may need to explicitly check for zero).\n+\n+      Useful application: Find pattern matches in multiple files and\n+      do something with them: >\n+      \t:vimgrep /theword/jg *.c\n+      \t:for d in getqflist()\n+      \t:   echo bufname(d.bufnr) ':' d.lnum '=' d.text\n+      \t:endfor\n+      <\n+      If the optional {what} dictionary argument is supplied, then\n+      returns only the items listed in {what} as a dictionary. The\n+      following string items are supported in {what}:\n+      \tchangedtick\tget the total number of changes made\n+      \t\t\tto the list |quickfix-changedtick|\n+      \tcontext\tget the |quickfix-context|\n+      \tefm\terrorformat to use when parsing \"lines\". If\n+      \t\tnot present, then the 'errorformat' option\n+      \t\tvalue is used.\n+      \tid\tget information for the quickfix list with\n+      \t\t|quickfix-ID|; zero means the id for the\n+      \t\tcurrent list or the list specified by \"nr\"\n+      \tidx\tget information for the quickfix entry at this\n+      \t\tindex in the list specified by \"id\" or \"nr\".\n+      \t\tIf set to zero, then uses the current entry.\n+      \t\tSee |quickfix-index|\n+      \titems\tquickfix list entries\n+      \tlines\tparse a list of lines using 'efm' and return\n+      \t\tthe resulting entries.  Only a |List| type is\n+      \t\taccepted.  The current quickfix list is not\n+      \t\tmodified. See |quickfix-parse|.\n+      \tnr\tget information for this quickfix list; zero\n+      \t\tmeans the current quickfix list and \"$\" means\n+      \t\tthe last quickfix list\n+      \tqfbufnr number of the buffer displayed in the quickfix\n+      \t\twindow. Returns 0 if the quickfix buffer is\n+      \t\tnot present. See |quickfix-buffer|.\n+      \tsize\tnumber of entries in the quickfix list\n+      \ttitle\tget the list title |quickfix-title|\n+      \twinid\tget the quickfix |window-ID|\n+      \tall\tall of the above quickfix properties\n+      Non-string items in {what} are ignored. To get the value of a\n+      particular item, set it to zero.\n+      If \"nr\" is not present then the current quickfix list is used.\n+      If both \"nr\" and a non-zero \"id\" are specified, then the list\n+      specified by \"id\" is used.\n+      To get the number of lists in the quickfix stack, set \"nr\" to\n+      \"$\" in {what}. The \"nr\" value in the returned dictionary\n+      contains the quickfix stack size.\n+      When \"lines\" is specified, all the other items except \"efm\"\n+      are ignored.  The returned dictionary contains the entry\n+      \"items\" with the list of entries.\n+\n+      The returned dictionary contains the following entries:\n+      \tchangedtick\ttotal number of changes made to the\n+      \t\t\tlist |quickfix-changedtick|\n+      \tcontext\tquickfix list context. See |quickfix-context|\n+      \t\tIf not present, set to \"\".\n+      \tid\tquickfix list ID |quickfix-ID|. If not\n+      \t\tpresent, set to 0.\n+      \tidx\tindex of the quickfix entry in the list. If not\n+      \t\tpresent, set to 0.\n+      \titems\tquickfix list entries. If not present, set to\n+      \t\tan empty list.\n+      \tnr\tquickfix list number. If not present, set to 0\n+      \tqfbufnr\tnumber of the buffer displayed in the quickfix\n+      \t\twindow. If not present, set to 0.\n+      \tsize\tnumber of entries in the quickfix list. If not\n+      \t\tpresent, set to 0.\n+      \ttitle\tquickfix list title text. If not present, set\n+      \t\tto \"\".\n+      \twinid\tquickfix |window-ID|. If not present, set to 0\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getqflist({'all': 1})\n+      \t:echo getqflist({'nr': 2, 'title': 1})\n+      \t:echo getqflist({'lines' : [\"F1:10:L10\"]})\n+      <\n+    ]=],\n+    name = 'getqflist',\n+    params = { { 'what', 'any' } },\n+    signature = 'getqflist([{what}])',\n+  },\n+  getreg = {\n+    args = { 0, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the contents of register\n+      {regname}.  Example: >\n+      \t:let cliptext = getreg('*')\n+      <When register {regname} was not set the result is an empty\n+      string.\n+      The {regname} argument must be a string.\n+\n+      getreg('=') returns the last evaluated value of the expression\n+      register.  (For use in maps.)\n+      getreg('=', 1) returns the expression itself, so that it can\n+      be restored with |setreg()|.  For other registers the extra\n+      argument is ignored, thus you can always give it.\n+\n+      If {list} is present and |TRUE|, the result type is changed\n+      to |List|. Each list item is one text line. Use it if you care\n+      about zero bytes possibly present inside register: without\n+      third argument both NLs and zero bytes are represented as NLs\n+      (see |NL-used-for-Nul|).\n+      When the register was not set an empty list is returned.\n+\n+      If {regname} is not specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreg()\n+\n+    ]=],\n+    name = 'getreg',\n+    params = { { 'regname', 'string' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getreg([{regname} [, 1 [, {list}]]])',\n+  },\n+  getreginfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns detailed information about register {regname} as a\n+      Dictionary with the following entries:\n+      \tregcontents\tList of lines contained in register\n+      \t\t\t{regname}, like\n+      \t\t\tgetreg({regname}, 1, 1).\n+      \tregtype\t\tthe type of register {regname}, as in\n+      \t\t\t|getregtype()|.\n+      \tisunnamed\tBoolean flag, v:true if this register\n+      \t\t\tis currently pointed to by the unnamed\n+      \t\t\tregister.\n+      \tpoints_to\tfor the unnamed register, gives the\n+      \t\t\tsingle letter name of the register\n+      \t\t\tcurrently pointed to (see |quotequote|).\n+      \t\t\tFor example, after deleting a line\n+      \t\t\twith `dd`, this field will be \"1\",\n+      \t\t\twhich is the register that got the\n+      \t\t\tdeleted text.\n+\n+      The {regname} argument is a string.  If {regname} is invalid\n+      or not set, an empty Dictionary will be returned.\n+      If {regname} is not specified, |v:register| is used.\n+      The returned Dictionary can be passed to |setreg()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreginfo()\n+\n+    ]=],\n+    name = 'getreginfo',\n+    params = { { 'regname', 'string' } },\n+    returns = 'table',\n+    signature = 'getreginfo([{regname}])',\n+  },\n+  getregtype = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is type of register {regname}.\n+      The value will be one of:\n+          \"v\"\t\t\tfor |charwise| text\n+          \"V\"\t\t\tfor |linewise| text\n+          \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n+          \"\"\t\t\tfor an empty or unknown register\n+      <CTRL-V> is one character with value 0x16.\n+      The {regname} argument is a string.  If {regname} is not\n+      specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getregtype()\n+\n+    ]=],\n+    name = 'getregtype',\n+    params = { { 'regname', 'string' } },\n+    returns = 'string',\n+    signature = 'getregtype([{regname}])',\n+  },\n+  getscriptinfo = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with information about all the sourced Vim\n+      scripts in the order they were sourced, like what\n+      `:scriptnames` shows.\n+\n+      The optional Dict argument {opts} supports the following\n+      optional items:\n+          name\tScript name match pattern. If specified,\n+      \t\tand \"sid\" is not specified, information about\n+      \t\tscripts with a name that match the pattern\n+      \t\t\"name\" are returned.\n+          sid\t\tScript ID |<SID>|.  If specified, only\n+      \t\tinformation about the script with ID \"sid\" is\n+      \t\treturned and \"name\" is ignored.\n+\n+      Each item in the returned List is a |Dict| with the following\n+      items:\n+          autoload\tAlways set to FALSE.\n+          functions   List of script-local function names defined in\n+      \t\tthe script.  Present only when a particular\n+      \t\tscript is specified using the \"sid\" item in\n+      \t\t{opts}.\n+          name\tVim script file name.\n+          sid\t\tScript ID |<SID>|.\n+          variables   A dictionary with the script-local variables.\n+      \t\tPresent only when a particular script is\n+      \t\tspecified using the \"sid\" item in {opts}.\n+      \t\tNote that this is a copy, the value of\n+      \t\tscript-local variables cannot be changed using\n+      \t\tthis dictionary.\n+          version\tVimscript version, always 1\n+\n+      Examples: >\n+      \t:echo getscriptinfo({'name': 'myscript'})\n+      \t:echo getscriptinfo({'sid': 15}).variables\n+      <\n+    ]=],\n+    name = 'getscriptinfo',\n+    params = { { 'opts', 'table' } },\n+    signature = 'getscriptinfo([{opts}])',\n+  },\n+  gettabinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      If {tabnr} is not specified, then information about all the\n+      tab pages is returned as a |List|. Each List item is a\n+      |Dictionary|.  Otherwise, {tabnr} specifies the tab page\n+      number and information about that one is returned.  If the tab\n+      page does not exist an empty List is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \ttabnr\t\ttab page number.\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\ttabpage-local variables\n+      \twindows\t\tList of |window-ID|s in the tab page.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabinfo()\n+\n+    ]=],\n+    name = 'gettabinfo',\n+    params = { { 'tabnr', 'integer' } },\n+    signature = 'gettabinfo([{tabnr}])',\n+  },\n+  gettabvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of a tab-local variable {varname} in tab page\n+      {tabnr}. |t:var|\n+      Tabs are numbered starting with one.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all tab-local variables is returned.\n+      Note that the name without \"t:\" must be used.\n+      When the tab or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabvar(varname)\n+\n+    ]=],\n+    name = 'gettabvar',\n+    params = { { 'tabnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'gettabvar({tabnr}, {varname} [, {def}])',\n+  },\n+  gettabwinvar = {\n+    args = { 3, 4 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of window-local variable {varname} in window\n+      {winnr} in tab page {tabnr}.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all window-local variables is returned.\n+      When {varname} is equal to \"&\" get the values of all\n+      window-local options in a |Dictionary|.\n+      Otherwise, when {varname} starts with \"&\" get the value of a\n+      window-local option.\n+      Note that {varname} must be the name without \"w:\".\n+      Tabs are numbered starting with one.  For the current tabpage\n+      use |getwinvar()|.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is zero the current window is used.\n+      This also works for a global option, buffer-local option and\n+      window-local option, but it doesn't work for a global variable\n+      or buffer-local variable.\n+      When the tab, window or variable doesn't exist {def} or an\n+      empty string is returned, there is no error message.\n+      Examples: >\n+      \t:let list_is_on = gettabwinvar(1, 2, '&list')\n+      \t:echo \"myvar = \" .. gettabwinvar(3, 1, 'myvar')\n+      <\n+      To obtain all window-local variables use: >\n+      \tgettabwinvar({tabnr}, {winnr}, '&')\n+\n+      <Can also be used as a |method|: >\n+      \tGetTabnr()->gettabwinvar(winnr, varname)\n+\n+    ]=],\n+    name = 'gettabwinvar',\n+    params = {\n+      { 'tabnr', 'integer' },\n+      { 'winnr', 'integer' },\n+      { 'varname', 'string' },\n+      { 'def', 'any' },\n     },\n-    buflisted={args=1, base=1, returns=VIMBOOL},\n-    bufload={args=1, base=1, returns=false},\n-    bufloaded={args=1, base=1, returns=VIMBOOL},\n-    bufname={args={0, 1}, base=1, returns='string'},\n-    bufnr={args={0, 2}, base=1, returns='integer'},\n-    bufwinid={args=1, base=1, returns='integer'},\n-    bufwinnr={args=1, base=1, returns='integer'},\n-    byte2line={args=1, base=1, returns='integer'},\n-    byteidx={args={2, 3}, base=1, fast=true, returns='integer'},\n-    byteidxcomp={args={2, 3}, base=1, fast=true, returns='integer'},\n-    call={args={2, 3}, base=1},\n-    ceil={args=1, base=1, float_func=\"ceil\"},\n-    changenr={returns='integer'},\n-    chanclose={args={1, 2}},\n-    chansend={args=2},\n-    char2nr={args={1, 2}, base=1, fast=true},\n-    charclass={args=1, base=1},\n-    charcol={args={1, 2}, base=1},\n-    charidx={args={2, 4}, base=1},\n-    chdir={args=1, base=1},\n-    cindent={args=1, base=1},\n-    clearmatches={args={0, 1}, base=1},\n-    col={args={1, 2}, base=1, returns='integer'},\n-    complete={args=2, base=2, returns=false},\n-    complete_add={args=1, base=1, returns='0|1|2'},\n-    complete_check={returns=VIMBOOL},\n-    complete_info={args={0, 1}, base=1, returns='table'},\n-    confirm={args={1, 4}, base=1},\n-    copy={args=1, base=1},\n-    cos={args=1, base=1, float_func=\"cos\"},\n-    cosh={args=1, base=1, float_func=\"cosh\"},\n-    count={args={2, 4}, base=1},\n-    ctxget={args={0, 1}},\n-    ctxpop={},\n-    ctxpush={args={0, 1}},\n-    ctxset={args={1, 2}},\n-    ctxsize={},\n-    cursor={args={1, 3}, base=1},\n-    debugbreak={args={1, 1}, base=1},\n-    deepcopy={args={1, 2}, base=1},\n-    delete={args={1,2}, base=1, returns='integer'},\n-    deletebufline={args={2,3}, base=1},\n-    dictwatcheradd={args=3},\n-    dictwatcherdel={args=3},\n-    did_filetype={fast=true},\n-    diff_filler={args=1, base=1},\n-    diff_hlID={args=2, base=1},\n-    digraph_get={args=1, base=1},\n-    digraph_getlist={args={0, 1}, base=1},\n-    digraph_set={args=2, base=1},\n-    digraph_setlist={args=1, base=1},\n-    empty={args=1, base=1},\n-    environ={fast=true},\n-    escape={args=2, base=1, fast=true},\n-    eval={args=1, base=1},\n-    eventhandler={},\n-    executable={args=1, base=1, fast=true},\n-    execute={args={1, 2}, base=1},\n-    exepath={args=1, base=1},\n-    exists={args=1, base=1, returns=VIMBOOL},\n-    exp={args=1, base=1, float_func=\"exp\"},\n-    expand={args={1, 3}, base=1, returns='string|string[]'},\n-    expandcmd={args={1, 2}, base=1},\n-    extend={args={2, 3}, base=1},\n-    extendnew={args={2, 3}, base=1},\n-    feedkeys={args={1, 2}, base=1},\n-    file_readable={\n-      args=1, base=1, func='f_filereadable',\n-      deprecated = { 'Obsolete name for |filereadable()|.' }\n+    signature = 'gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])',\n+  },\n+  gettagstack = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Dict, which is the tag stack of window {winnr}.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is not specified, the current window is used.\n+      When window {winnr} doesn't exist, an empty Dict is returned.\n+\n+      The returned dictionary contains the following entries:\n+      \tcuridx\t\tCurrent index in the stack. When at\n+      \t\t\ttop of the stack, set to (length + 1).\n+      \t\t\tIndex of bottom of the stack is 1.\n+      \titems\t\tList of items in the stack. Each item\n+      \t\t\tis a dictionary containing the\n+      \t\t\tentries described below.\n+      \tlength\t\tNumber of entries in the stack.\n+\n+      Each item in the stack is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tbuffer number of the current jump\n+      \tfrom\t\tcursor position before the tag jump.\n+      \t\t\tSee |getpos()| for the format of the\n+      \t\t\treturned list.\n+      \tmatchnr\t\tcurrent matching tag number. Used when\n+      \t\t\tmultiple matching tags are found for a\n+      \t\t\tname.\n+      \ttagname\t\tname of the tag\n+\n+      See |tagstack| for more information about the tag stack.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->gettagstack()\n+      <\n+    ]=],\n+    name = 'gettagstack',\n+    params = { { 'winnr', 'integer' } },\n+    signature = 'gettagstack([{winnr}])',\n+  },\n+  gettext = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Translate String {text} if possible.\n+      This is mainly for use in the distributed Vim scripts.  When\n+      generating message translations the {text} is extracted by\n+      xgettext, the translator can add the translated message in the\n+      .po file and Vim will lookup the translation when gettext() is\n+      called.\n+      For {text} double quoted strings are preferred, because\n+      xgettext does not understand escaping in single quoted\n+      strings.\n+    ]=],\n+    name = 'gettext',\n+    params = { { 'text', 'any' } },\n+    signature = 'gettext({text})',\n+  },\n+  getwininfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns information about windows as a |List| with Dictionaries.\n+\n+      If {winid} is given Information about the window with that ID\n+      is returned, as a |List| with one item.  If the window does not\n+      exist the result is an empty list.\n+\n+      Without {winid} information about all the windows in all the\n+      tab pages is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \tbotline\t\tlast complete displayed buffer line\n+      \tbufnr\t\tnumber of buffer in the window\n+      \theight\t\twindow height (excluding winbar)\n+      \tloclist\t\t1 if showing a location list\n+      \tquickfix\t1 if quickfix or location list window\n+      \tterminal\t1 if a terminal window\n+      \ttabnr\t\ttab page number\n+      \ttopline\t\tfirst displayed buffer line\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\twindow-local variables\n+      \twidth\t\twindow width\n+      \twinbar\t\t1 if the window has a toolbar, 0\n+      \t\t\totherwise\n+      \twincol\t\tleftmost screen column of the window;\n+      \t\t\t\"col\" from |win_screenpos()|\n+      \ttextoff\t\tnumber of columns occupied by any\n+      \t\t\t'foldcolumn', 'signcolumn' and line\n+      \t\t\tnumber in front of the text\n+      \twinid\t\t|window-ID|\n+      \twinnr\t\twindow number\n+      \twinrow\t\ttopmost screen line of the window;\n+      \t\t\t\"row\" from |win_screenpos()|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getwininfo()\n+\n+    ]=],\n+    name = 'getwininfo',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getwininfo([{winid}])',\n+  },\n+  getwinpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a |List| with two numbers, the result of\n+      |getwinposx()| and |getwinposy()| combined:\n+      \t[x-pos, y-pos]\n+      {timeout} can be used to specify how long to wait in msec for\n+      a response from the terminal.  When omitted 100 msec is used.\n+\n+      Use a longer time for a remote terminal.\n+      When using a value less than 10 and no response is received\n+      within that time, a previously reported position is returned,\n+      if available.  This can be used to poll for the position and\n+      do some work in the meantime: >\n+      \twhile 1\n+      \t  let res = getwinpos(1)\n+      \t  if res[0] >= 0\n+      \t    break\n+      \t  endif\n+      \t  \" Do some work here\n+      \tendwhile\n+      <\n+      Can also be used as a |method|: >\n+      \tGetTimeout()->getwinpos()\n+      <\n+    ]=],\n+    name = 'getwinpos',\n+    params = { { 'timeout', 'integer' } },\n+    signature = 'getwinpos([{timeout}])',\n+  },\n+  getwinposx = {\n+    desc = [=[\n+      The result is a Number, which is the X coordinate in pixels of\n+      the left hand side of the GUI Vim window.  The result will be\n+      -1 if the information is not available.\n+      The value can be used with `:winpos`.\n+    ]=],\n+    name = 'getwinposx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposx()',\n+  },\n+  getwinposy = {\n+    desc = [=[\n+      The result is a Number, which is the Y coordinate in pixels of\n+      the top of the GUI Vim window.  The result will be -1 if the\n+      information is not available.\n+      The value can be used with `:winpos`.\n+\n+    ]=],\n+    name = 'getwinposy',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposy()',\n+  },\n+  getwinvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |gettabwinvar()| for the current tabpage.\n+      Examples: >\n+      \t:let list_is_on = getwinvar(2, '&list')\n+      \t:echo \"myvar = \" .. getwinvar(1, 'myvar')\n+\n+      <Can also be used as a |method|: >\n+      \tGetWinnr()->getwinvar(varname)\n+      <\n+    ]=],\n+    name = 'getwinvar',\n+    params = { { 'winnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getwinvar({winnr}, {varname} [, {def}])',\n+  },\n+  glob = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      Expand the file wildcards in {expr}.  See |wildcards| for the\n+      use of special characters.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+      'wildignorecase' always applies.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is,\n+      you also get filenames containing newlines correctly.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty String or List.\n+\n+      You can also use |readdir()| if you need to do complicated\n+      things, such as limiting the number of matches.\n+\n+      A name for a non-existing file is not included.  A symbolic\n+      link is only included if it points to an existing file.\n+      However, when the {alllinks} argument is present and it is\n+      |TRUE| then all symbolic links are included.\n+\n+      For most systems backticks can be used to get files names from\n+      any external command.  Example: >\n+      \t:let tagfiles = glob(\"`find . -name tags -print`\")\n+      \t:let &tags = substitute(tagfiles, \"\\n\", \",\", \"g\")\n+      <The result of the program inside the backticks should be one\n+      item per line.  Spaces inside an item are allowed.\n+\n+      See |expand()| for expanding special Vim variables.  See\n+      |system()| for getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob()\n+\n+    ]=],\n+    name = 'glob',\n+    params = { { 'expr', 'any' }, { 'nosuf', 'boolean' }, { 'list', 'any' }, { 'alllinks', 'any' } },\n+    signature = 'glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])',\n+  },\n+  glob2regpat = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert a file pattern, as used by glob(), into a search\n+      pattern.  The result can be used to match with a string that\n+      is a file name.  E.g. >\n+      \tif filename =~ glob2regpat('Make*.mak')\n+      <This is equivalent to: >\n+      \tif filename =~ '^Make.*\\.mak$'\n+      <When {string} is an empty string the result is \"^$\", match an\n+      empty string.\n+      Note that the result depends on the system.  On MS-Windows\n+      a backslash usually means a path separator.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob2regpat()\n+      <\n+    ]=],\n+    name = 'glob2regpat',\n+    params = { { 'string', 'string' } },\n+    signature = 'glob2regpat({string})',\n+  },\n+  globpath = {\n+    args = { 2, 5 },\n+    base = 2,\n+    desc = [=[\n+      Perform glob() for String {expr} on all directories in {path}\n+      and concatenate the results.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\")\n+      <\n+      {path} is a comma-separated list of directory names.  Each\n+      directory name is prepended to {expr} and expanded like with\n+      |glob()|.  A path separator is inserted when needed.\n+      To add a comma inside a directory name escape it with a\n+      backslash.  Note that on MS-Windows a directory may have a\n+      trailing backslash, remove it if you put a comma after it.\n+      If the expansion fails for one of the directories, there is no\n+      error message.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is, you\n+      also get filenames containing newlines correctly. Otherwise\n+      the result is a String and when there are several matches,\n+      they are separated by <NL> characters.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\", 0, 1)\n+      <\n+      {allinks} is used as with |glob()|.\n+\n+      The \"**\" item can be used to search in a directory tree.\n+      For example, to find all \"README.txt\" files in the directories\n+      in 'runtimepath' and below: >\n+      \t:echo globpath(&rtp, \"**/README.txt\")\n+      <Upwards search and limiting the depth of \"**\" is not\n+      supported, thus using 'path' will not always work properly.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetExpr()->globpath(&rtp)\n+      <\n+    ]=],\n+    name = 'globpath',\n+    params = {\n+      { 'path', 'string' },\n+      { 'expr', 'any' },\n+      { 'nosuf', 'boolean' },\n+      { 'list', 'any' },\n+      { 'allinks', 'any' },\n     },\n-    filereadable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filewritable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filter={args=2, base=1},\n-    finddir={args={1, 3}, base=1},\n-    findfile={args={1, 3}, base=1},\n-    flatten={args={1, 2}, base=1, returns='any[]|0'},\n-    flattennew={args={1, 2}, base=1, returns='any[]|0'},\n-    float2nr={args=1, base=1},\n-    floor={args=1, base=1, float_func=\"floor\"},\n-    fmod={args=2, base=1},\n-    fnameescape={args=1, base=1, fast=true, returns='string'},\n-    fnamemodify={args=2, base=1, fast=true, returns='string'},\n-    foldclosed={args=1, base=1, returns='integer'},\n-    foldclosedend={args=1, base=1, returns='integer'},\n-    foldlevel={args=1, base=1, returns='integer'},\n-    foldtext={returns='string'},\n-    foldtextresult={args=1, base=1, returns='string'},\n-    foreground={},\n-    fullcommand={args=1, base=1, returns='string'},\n-    funcref={args={1, 3}, base=1},\n-    ['function']={args={1, 3}, base=1},\n-    garbagecollect={args={0, 1}},\n-    get={args={2, 3}, base=1},\n-    getbufinfo={args={0, 1}, base=1},\n-    getbufline={args={2, 3}, base=1},\n-    getbufoneline={args=2, base=1},\n-    getbufvar={args={2, 3}, base=1},\n-    getcellwidths={},\n-    getchangelist={args={0, 1}, base=1},\n-    getchar={args={0, 1}, returns='integer'},\n-    getcharmod={returns='integer'},\n-    getcharpos={args=1, base=1},\n-    getcharsearch={},\n-    getcharstr={args={0, 1}, returns='string'},\n-    getcmdcompltype={returns='string'},\n-    getcmdline={returns='string'},\n-    getcmdpos={},\n-    getcmdscreenpos={},\n-    getcmdtype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcmdwintype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcompletion={args={2, 3}, base=1, returns='string[]'},\n-    getcurpos={args={0, 1}, base=1},\n-    getcursorcharpos={args={0, 1}, base=1},\n-    getcwd={args={0, 2}, base=1, returns='string'},\n-    getenv={args=1, base=1, returns='string'},\n-    getfontname={args={0, 1}, returns='string'},\n-    getfperm={args=1, base=1, fast=true, returns='string'},\n-    getfsize={args=1, base=1, fast=true, returns='integer'},\n-    getftime={args=1, base=1, fast=true, returns='integer'},\n-    getftype={args=1, base=1, fast=true, returns=\"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\"},\n-    getjumplist={args={0, 2}, base=1},\n-    getline={args={1, 2}, base=1},\n-    getloclist={args={1, 2}},\n-    getmarklist={args={0, 1}, base=1},\n-    getmatches={args={0, 1}},\n-    getmousepos={},\n-    getpid={fast=true, returns='integer'},\n-    getpos={args=1, base=1},\n-    getqflist={args={0, 1}},\n-    getreg={args={0, 3}, base=1, returns='string|string[]'},\n-    getreginfo={args={0, 1}, base=1, returns='table'},\n-    getregtype={args={0, 1}, base=1, returns='string'},\n-    gettabinfo={args={0, 1}, base=1},\n-    gettabvar={args={2, 3}, base=1},\n-    gettabwinvar={args={3, 4}, base=1},\n-    getscriptinfo={args={0, 1}},\n-    gettagstack={args={0, 1}, base=1},\n-    gettext={args=1, base=1},\n-    getwininfo={args={0, 1}, base=1},\n-    getwinpos={args={0, 1}, base=1},\n-    getwinposx={returns='integer'},\n-    getwinposy={returns='integer'},\n-    getwinvar={args={2, 3}, base=1},\n-    glob={args={1, 4}, base=1},\n-    glob2regpat={args=1, base=1},\n-    globpath={args={2, 5}, base=2},\n-    has={args=1, returns=VIMBOOL},\n-    has_key={args=2, base=1, returns=VIMBOOL},\n-    haslocaldir={args={0, 2}, base=1, returns=VIMBOOL},\n-    hasmapto={args={1, 3}, base=1, returns=VIMBOOL},\n-    highlightID={\n-      args=1, base=1, func='f_hlID',\n-      deprecated = { 'Obsolete name for |hlID()|.' }\n+    signature = 'globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])',\n+  },\n+  has = {\n+    args = 1,\n+    desc = [=[\n+      Returns 1 if {feature} is supported, 0 otherwise.  The\n+      {feature} argument is a feature name like \"nvim-0.2.1\" or\n+      \"win32\", see below.  See also |exists()|.\n+\n+      To get the system name use |vim.uv|.os_uname() in Lua: >lua\n+      \tprint(vim.uv.os_uname().sysname)\n+\n+      <If the code has a syntax error then Vimscript may skip the\n+      rest of the line.  Put |:if| and |:endif| on separate lines to\n+      avoid the syntax error: >\n+      \tif has('feature')\n+      \t  let x = this->breaks->without->the->feature\n+      \tendif\n+      <\n+      Vim's compile-time feature-names (prefixed with \"+\") are not\n+      recognized because Nvim is always compiled with all possible\n+      features. |feature-compile|\n+\n+      Feature names can be:\n+      1.  Nvim version. For example the \"nvim-0.2.1\" feature means\n+          that Nvim is version 0.2.1 or later: >\n+      \t:if has(\"nvim-0.2.1\")\n+\n+      <2.  Runtime condition or other pseudo-feature. For example the\n+          \"win32\" feature checks if the current system is Windows: >\n+      \t:if has(\"win32\")\n+      <\t\t\t\t\t*feature-list*\n+          List of supported pseudo-feature names:\n+      \tacl\t\t|ACL| support.\n+      \tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n+      \tclipboard\t|clipboard| provider is available.\n+      \tfname_case\tCase in file names matters (for Darwin and MS-Windows\n+      \t\t\tthis is not present).\n+                              gui_running\tNvim has a GUI.\n+      \ticonv\t\tCan use |iconv()| for conversion.\n+      \tlinux\t\tLinux system.\n+      \tmac\t\tMacOS system.\n+      \tnvim\t\tThis is Nvim.\n+      \tpython3\t\tLegacy Vim |python3| interface. |has-python|\n+      \tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n+      \tsun\t\tSunOS system.\n+      \tttyin\t\tinput is a terminal (tty).\n+      \tttyout\t\toutput is a terminal (tty).\n+      \tunix\t\tUnix system.\n+      \t*vim_starting*\tTrue during |startup|.\n+      \twin32\t\tWindows system (32 or 64 bit).\n+      \twin64\t\tWindows system (64 bit).\n+      \twsl\t\tWSL (Windows Subsystem for Linux) system.\n+\n+      \t\t\t\t\t*has-patch*\n+      3.  Vim patch. For example the \"patch123\" feature means that\n+          Vim patch 123 at the current |v:version| was included: >\n+      \t:if v:version > 602 || v:version == 602 && has(\"patch148\")\n+\n+      <4.  Vim version. For example the \"patch-7.4.237\" feature means\n+          that Nvim is Vim-compatible to version 7.4.237 or later. >\n+      \t:if has(\"patch-7.4.237\")\n+      <\n+    ]=],\n+    name = 'has',\n+    params = { { 'feature', 'any' } },\n+    returns = '0|1',\n+    signature = 'has({feature})',\n+  },\n+  has_key = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if |Dictionary| {dict}\n+      has an entry with key {key}.  FALSE otherwise. The {key}\n+      argument is a string.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->has_key(key)\n+\n+    ]=],\n+    name = 'has_key',\n+    params = { { 'dict', 'any' }, { 'key', 'any' } },\n+    returns = '0|1',\n+    signature = 'has_key({dict}, {key})',\n+  },\n+  haslocaldir = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when the window has set a\n+      local path via |:lcd| or when {winnr} is -1 and the tabpage\n+      has set a local path via |:tcd|, otherwise 0.\n+\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing argument implies 0.\n+      Thus the following are equivalent: >\n+      \thaslocaldir()\n+      \thaslocaldir(0)\n+      \thaslocaldir(0, 0)\n+      <With {winnr} use that window in the current tabpage.\n+      With {winnr} and {tabnr} use the window in that tabpage.\n+      {winnr} can be the window number or the |window-ID|.\n+      If {winnr} is -1 it is ignored, only the tab is resolved.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->haslocaldir()\n+\n+    ]=],\n+    name = 'haslocaldir',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = '0|1',\n+    signature = 'haslocaldir([{winnr} [, {tabnr}]])',\n+  },\n+  hasmapto = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if there is a mapping\n+      that contains {what} in somewhere in the rhs (what it is\n+      mapped to) and this mapping exists in one of the modes\n+      indicated by {mode}.\n+      The arguments {what} and {mode} are strings.\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.  Don't forget to specify Insert and/or\n+      Command-line mode.\n+      Both the global mappings and the mappings local to the current\n+      buffer are checked for a match.\n+      If no matching mapping is found FALSE is returned.\n+      The following characters are recognized in {mode}:\n+      \tn\tNormal mode\n+      \tv\tVisual and Select mode\n+      \tx\tVisual mode\n+      \ts\tSelect mode\n+      \to\tOperator-pending mode\n+      \ti\tInsert mode\n+      \tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n+      \tc\tCommand-line mode\n+      When {mode} is omitted, \"nvo\" is used.\n+\n+      This function is useful to check if a mapping already exists\n+      to a function in a Vim script.  Example: >\n+      \t:if !hasmapto('\\ABCdoit')\n+      \t:   map <Leader>d \\ABCdoit\n+      \t:endif\n+      <This installs the mapping to \"\\ABCdoit\" only if there isn't\n+      already a mapping to \"\\ABCdoit\".\n+\n+      Can also be used as a |method|: >\n+      \tGetRHS()->hasmapto()\n+\n+    ]=],\n+    name = 'hasmapto',\n+    params = { { 'what', 'any' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    returns = '0|1',\n+    signature = 'hasmapto({what} [, {mode} [, {abbr}]])',\n+  },\n+  highlightID = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlID()|.\n+    ]=],\n+    func = 'f_hlID',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlightID({name})',\n+  },\n+  highlight_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlexists()|.\n+    ]=],\n+    func = 'f_hlexists',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlight_exists({name})',\n+  },\n+  histadd = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Add the String {item} to the history {history} which can be\n+      one of:\t\t\t\t\t*hist-names*\n+      \t\"cmd\"\t or \":\"\t  command line history\n+      \t\"search\" or \"/\"   search pattern history\n+      \t\"expr\"\t or \"=\"   typed expression history\n+      \t\"input\"  or \"@\"\t  input line history\n+      \t\"debug\"  or \">\"   debug command history\n+      \tempty\t\t  the current or last used history\n+      The {history} string does not need to be the whole name, one\n+      character is sufficient.\n+      If {item} does already exist in the history, it will be\n+      shifted to become the newest entry.\n+      The result is a Number: TRUE if the operation was successful,\n+      otherwise FALSE is returned.\n+\n+      Example: >\n+      \t:call histadd(\"input\", strftime(\"%Y %b %d\"))\n+      \t:let date=input(\"Enter date: \")\n+      <This function is not available in the |sandbox|.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetHistory()->histadd('search')\n+\n+    ]=],\n+    name = 'histadd',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histadd({history}, {item})',\n+  },\n+  histdel = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Clear {history}, i.e. delete all its entries.  See |hist-names|\n+      for the possible values of {history}.\n+\n+      If the parameter {item} evaluates to a String, it is used as a\n+      regular expression.  All entries matching that expression will\n+      be removed from the history (if there are any).\n+      Upper/lowercase must match, unless \"\\c\" is used |/\\c|.\n+      If {item} evaluates to a Number, it will be interpreted as\n+      an index, see |:history-indexing|.  The respective entry will\n+      be removed if it exists.\n+\n+      The result is TRUE for a successful operation, otherwise FALSE\n+      is returned.\n+\n+      Examples:\n+      Clear expression register history: >\n+      \t:call histdel(\"expr\")\n+      <\n+      Remove all entries starting with \"*\" from the search history: >\n+      \t:call histdel(\"/\", '^\\*')\n+      <\n+      The following three are equivalent: >\n+      \t:call histdel(\"search\", histnr(\"search\"))\n+      \t:call histdel(\"search\", -1)\n+      \t:call histdel(\"search\", '^' .. histget(\"search\", -1) .. '$')\n+      <\n+      To delete the last search pattern and use the last-but-one for\n+      the \"n\" command and 'hlsearch': >\n+      \t:call histdel(\"search\", -1)\n+      \t:let @/ = histget(\"search\", -1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histdel()\n+\n+    ]=],\n+    name = 'histdel',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histdel({history} [, {item}])',\n+  },\n+  histget = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, the entry with Number {index} from\n+      {history}.  See |hist-names| for the possible values of\n+      {history}, and |:history-indexing| for {index}.  If there is\n+      no such entry, an empty String is returned.  When {index} is\n+      omitted, the most recent item from the history is used.\n+\n+      Examples:\n+      Redo the second last search from history. >\n+      \t:execute '/' .. histget(\"search\", -2)\n+\n+      <Define an Ex command \":H {num}\" that supports re-execution of\n+      the {num}th entry from the output of |:history|. >\n+      \t:command -nargs=1 H execute histget(\"cmd\", 0+<args>)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histget()\n+\n+    ]=],\n+    name = 'histget',\n+    params = { { 'history', 'any' }, { 'index', 'any' } },\n+    returns = 'string',\n+    signature = 'histget({history} [, {index}])',\n+  },\n+  histnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is the Number of the current entry in {history}.\n+      See |hist-names| for the possible values of {history}.\n+      If an error occurred, -1 is returned.\n+\n+      Example: >\n+      \t:let inp_index = histnr(\"expr\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetHistory()->histnr()\n+      <\n+    ]=],\n+    name = 'histnr',\n+    params = { { 'history', 'any' } },\n+    returns = 'integer',\n+    signature = 'histnr({history})',\n+  },\n+  hlID = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the ID of the highlight group\n+      with name {name}.  When the highlight group doesn't exist,\n+      zero is returned.\n+      This can be used to retrieve information about the highlight\n+      group.  For example, to get the background color of the\n+      \"Comment\" group: >\n+      \t:echo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->hlID()\n+\n+    ]=],\n+    name = 'hlID',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'hlID({name})',\n+  },\n+  hlexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if a highlight group\n+      called {name} exists.  This is when the group has been\n+      defined in some way.  Not necessarily when highlighting has\n+      been defined for it, it may also have been used for a syntax\n+      item.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->hlexists()\n+      <\n+    ]=],\n+    name = 'hlexists',\n+    params = { { 'name', 'string' } },\n+    returns = '0|1',\n+    signature = 'hlexists({name})',\n+  },\n+  hostname = {\n+    desc = [=[\n+      The result is a String, which is the name of the machine on\n+      which Vim is currently running.  Machine names greater than\n+      256 characters long are truncated.\n+\n+    ]=],\n+    fast = true,\n+    name = 'hostname',\n+    params = {},\n+    returns = 'string',\n+    signature = 'hostname()',\n+  },\n+  iconv = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the text {string} converted\n+      from encoding {from} to encoding {to}.\n+      When the conversion completely fails an empty string is\n+      returned.  When some characters could not be converted they\n+      are replaced with \"?\".\n+      The encoding names are whatever the iconv() library function\n+      can accept, see \":!man 3 iconv\".\n+      Note that Vim uses UTF-8 for all Unicode encodings, conversion\n+      from/to UCS-2 is automatically changed to use UTF-8.  You\n+      cannot use UCS-2 in a string anyway, because of the NUL bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->iconv('latin1', 'utf-8')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'iconv',\n+    params = { { 'string', 'string' }, { 'from', 'any' }, { 'to', 'any' } },\n+    signature = 'iconv({string}, {from}, {to})',\n+  },\n+  id = {\n+    args = 1,\n+    desc = [=[\n+      Returns a |String| which is a unique identifier of the\n+      container type (|List|, |Dict|, |Blob| and |Partial|). It is\n+      guaranteed that for the mentioned types `id(v1) ==# id(v2)`\n+      returns true iff `type(v1) == type(v2) && v1 is v2`.\n+      Note that |v:_null_string|, |v:_null_list|, |v:_null_dict| and\n+      |v:_null_blob| have the same `id()` with different types\n+      because they are internally represented as NULL pointers.\n+      `id()` returns a hexadecimal representanion of the pointers to\n+      the containers (i.e. like `0x994a40`), same as `printf(\"%p\",\n+      {expr})`, but it is advised against counting on the exact\n+      format of the return value.\n+\n+      It is not guaranteed that `id(no_longer_existing_container)`\n+      will not be equal to some other `id()`: new containers may\n+      reuse identifiers of the garbage-collected ones.\n+\n+    ]=],\n+    name = 'id',\n+    params = { { 'expr', 'any' } },\n+    signature = 'id({expr})',\n+  },\n+  indent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      current buffer.  The indent is counted in spaces, the value\n+      of 'tabstop' is relevant.  {lnum} is used just like in\n+      |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->indent()\n+\n+    ]=],\n+    name = 'indent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'indent({lnum})',\n+  },\n+  index = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Find {expr} in {object} and return its index.  See\n+      |indexof()| for using a lambda to select the item.\n+\n+      If {object} is a |List| return the lowest index where the item\n+      has a value equal to {expr}.  There is no automatic\n+      conversion, so the String \"4\" is different from the Number 4.\n+      And the Number 4 is different from the Float 4.0.  The value\n+      of 'ignorecase' is not used here, case matters as indicated by\n+      the {ic} argument.\n+\n+      If {object} is a |Blob| return the lowest index where the byte\n+      value is equal to {expr}.\n+\n+      If {start} is given then start looking at the item with index\n+      {start} (may be negative for an item relative to the end).\n+\n+      When {ic} is given and it is |TRUE|, ignore case.  Otherwise\n+      case must match.\n+\n+      -1 is returned when {expr} is not found in {object}.\n+      Example: >\n+      \t:let idx = index(words, \"the\")\n+      \t:if index(numbers, 123) >= 0\n+\n+      <Can also be used as a |method|: >\n+      \tGetObject()->index(what)\n+\n+    ]=],\n+    name = 'index',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'start', 'any' }, { 'ic', 'any' } },\n+    signature = 'index({object}, {expr} [, {start} [, {ic}]])',\n+  },\n+  indexof = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Returns the index of an item in {object} where {expr} is\n+      v:true.  {object} must be a |List| or a |Blob|.\n+\n+      If {object} is a |List|, evaluate {expr} for each item in the\n+      List until the expression is v:true and return the index of\n+      this item.\n+\n+      If {object} is a |Blob| evaluate {expr} for each byte in the\n+      Blob until the expression is v:true and return the index of\n+      this byte.\n+\n+      {expr} must be a |string| or |Funcref|.\n+\n+      If {expr} is a |string|: If {object} is a |List|, inside\n+      {expr} |v:key| has the index of the current List item and\n+      |v:val| has the value of the item.  If {object} is a |Blob|,\n+      inside {expr} |v:key| has the index of the current byte and\n+      |v:val| has the byte value.\n+\n+      If {expr} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item is found and the\n+      search should stop.\n+\n+      The optional argument {opts} is a Dict and supports the\n+      following items:\n+          startidx\tstart evaluating {expr} at the item with this\n+      \t\tindex; may be negative for an item relative to\n+      \t\tthe end\n+      Returns -1 when {expr} evaluates to v:false for all the items.\n+      Example: >\n+      \t:let l = [#{n: 10}, #{n: 20}, #{n: 30}]\n+      \t:echo indexof(l, \"v:val.n == 20\")\n+      \t:echo indexof(l, {i, v -> v.n == 30})\n+      \t:echo indexof(l, \"v:val.n == 20\", #{startidx: 1})\n+\n+      <Can also be used as a |method|: >\n+      \tmylist->indexof(expr)\n+\n+    ]=],\n+    name = 'indexof',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'opts', 'table' } },\n+    signature = 'indexof({object}, {expr} [, {opts}])',\n+  },\n+  input = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = '',\n+    name = 'input',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' }, { 'completion', 'any' } },\n+    signature = 'input({prompt} [, {text} [, {completion}]])',\n+  },\n+  input__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is whatever the user typed on\n+      the command-line.  The {prompt} argument is either a prompt\n+      string, or a blank string (for no prompt).  A '\\n' can be used\n+      in the prompt to start a new line.\n+\n+      In the second form it accepts a single dictionary with the\n+      following keys, any of which may be omitted:\n+\n+      Key           Default  Description ~\n+      prompt        \"\"       Same as {prompt} in the first form.\n+      default       \"\"       Same as {text} in the first form.\n+      completion    nothing  Same as {completion} in the first form.\n+      cancelreturn  \"\"       The value returned when the dialog is\n+                             cancelled.\n+      highlight     nothing  Highlight handler: |Funcref|.\n+\n+      The highlighting set with |:echohl| is used for the prompt.\n+      The input is entered just like a command-line, with the same\n+      editing commands and mappings.  There is a separate history\n+      for lines typed for input().\n+      Example: >\n+      \t:if input(\"Coffee or beer? \") == \"beer\"\n+      \t:  echo \"Cheers!\"\n+      \t:endif\n+      <\n+      If the optional {text} argument is present and not empty, this\n+      is used for the default reply, as if the user typed this.\n+      Example: >\n+      \t:let color = input(\"Color? \", \"white\")\n+\n+      <The optional {completion} argument specifies the type of\n+      completion supported for the input.  Without it completion is\n+      not performed.  The supported completion types are the same as\n+      that can be supplied to a user-defined command using the\n+      \"-complete=\" argument.  Refer to |:command-completion| for\n+      more information.  Example: >\n+      \tlet fname = input(\"File: \", \"\", \"file\")\n+\n+      <\t\t\t*input()-highlight* *E5400* *E5402*\n+      The optional `highlight` key allows specifying function which\n+      will be used for highlighting user input.  This function\n+      receives user input as its only argument and must return\n+      a list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n+      where\n+      \thl_start_col is the first highlighted column,\n+      \thl_end_col is the last highlighted column (+ 1!),\n+      \thl_group is |:hi| group used for highlighting.\n+      \t\t\t      *E5403* *E5404* *E5405* *E5406*\n+      Both hl_start_col and hl_end_col + 1 must point to the start\n+      of the multibyte character (highlighting must not break\n+      multibyte characters), hl_end_col + 1 may be equal to the\n+      input length.  Start column must be in range [0, len(input)),\n+      end column must be in range (hl_start_col, len(input)],\n+      sections must be ordered so that next hl_start_col is greater\n+      then or equal to previous hl_end_col.\n+\n+      Example (try some input with parentheses): >\n+      \thighlight RBP1 guibg=Red ctermbg=red\n+      \thighlight RBP2 guibg=Yellow ctermbg=yellow\n+      \thighlight RBP3 guibg=Green ctermbg=green\n+      \thighlight RBP4 guibg=Blue ctermbg=blue\n+      \tlet g:rainbow_levels = 4\n+      \tfunction! RainbowParens(cmdline)\n+      \t  let ret = []\n+      \t  let i = 0\n+      \t  let lvl = 0\n+      \t  while i < len(a:cmdline)\n+      \t    if a:cmdline[i] is# '('\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t      let lvl += 1\n+      \t    elseif a:cmdline[i] is# ')'\n+      \t      let lvl -= 1\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t    endif\n+      \t    let i += 1\n+      \t  endwhile\n+      \t  return ret\n+      \tendfunction\n+      \tcall input({'prompt':'>','highlight':'RainbowParens'})\n+      <\n+      Highlight function is called at least once for each new\n+      displayed input string, before command-line is redrawn.  It is\n+      expected that function is pure for the duration of one input()\n+      call, i.e. it produces the same output for the same input, so\n+      output may be memoized.  Function is run like under |:silent|\n+      modifier. If the function causes any errors, it will be\n+      skipped for the duration of the current input() call.\n+\n+      Highlighting is disabled if command-line contains arabic\n+      characters.\n+\n+      NOTE: This function must not be used in a startup file, for\n+      the versions that only run in GUI mode (e.g., the Win32 GUI).\n+      Note: When input() is called from within a mapping it will\n+      consume remaining characters from that mapping, because a\n+      mapping is handled like the characters were typed.\n+      Use |inputsave()| before input() and |inputrestore()|\n+      after input() to avoid that.  Another solution is to avoid\n+      that further characters follow in the mapping, e.g., by using\n+      |:execute| or |:normal|.\n+\n+      Example with a mapping: >\n+      \t:nmap \\x :call GetFoo()<CR>:exe \"/\" .. Foo<CR>\n+      \t:function GetFoo()\n+      \t:  call inputsave()\n+      \t:  let g:Foo = input(\"enter search pattern: \")\n+      \t:  call inputrestore()\n+      \t:endfunction\n+\n+      <Can also be used as a |method|: >\n+      \tGetPrompt()->input()\n+\n+    ]=],\n+    name = 'input',\n+    params = { { 'opts', 'table' } },\n+    signature = 'input({opts})',\n+  },\n+  inputdialog = {\n+    args = { 1, 3 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Use |input()| instead.\n+    ]=],\n+    params = VARARGS,\n+    signature = 'input(...)',\n+  },\n+  inputlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      {textlist} must be a |List| of strings.  This |List| is\n+      displayed, one string per line.  The user will be prompted to\n+      enter a number, which is returned.\n+      The user can also select an item by clicking on it with the\n+      mouse, if the mouse is enabled in the command line ('mouse' is\n+      \"a\" or includes \"c\").  For the first string 0 is returned.\n+      When clicking above the first item a negative number is\n+      returned.  When clicking on the prompt one more than the\n+      length of {textlist} is returned.\n+      Make sure {textlist} has less than 'lines' entries, otherwise\n+      it won't work.  It's a good idea to put the entry number at\n+      the start of the string.  And put a prompt in the first item.\n+      Example: >\n+      \tlet color = inputlist(['Select color:', '1. red',\n+      \t\t\\ '2. green', '3. blue'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetChoices()->inputlist()\n+\n+    ]=],\n+    name = 'inputlist',\n+    params = { { 'textlist', 'any' } },\n+    signature = 'inputlist({textlist})',\n+  },\n+  inputrestore = {\n+    desc = [=[\n+      Restore typeahead that was saved with a previous |inputsave()|.\n+      Should be called the same number of times inputsave() is\n+      called.  Calling it more often is harmless though.\n+      Returns TRUE when there is nothing to restore, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputrestore',\n+    params = {},\n+    signature = 'inputrestore()',\n+  },\n+  inputsave = {\n+    desc = [=[\n+      Preserve typeahead (also from mappings) and clear it, so that\n+      a following prompt gets input from the user.  Should be\n+      followed by a matching inputrestore() after the prompt.  Can\n+      be used several times, in which case there must be just as\n+      many inputrestore() calls.\n+      Returns TRUE when out of memory, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputsave',\n+    params = {},\n+    signature = 'inputsave()',\n+  },\n+  inputsecret = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      This function acts much like the |input()| function with but\n+      two exceptions:\n+      a) the user's response will be displayed as a sequence of\n+      asterisks (\"*\") thereby keeping the entry secret, and\n+      b) the user's response will not be recorded on the input\n+      |history| stack.\n+      The result is a String, which is whatever the user actually\n+      typed on the command-line in response to the issued prompt.\n+      NOTE: Command-line completion is not supported.\n+\n+      Can also be used as a |method|: >\n+      \tGetPrompt()->inputsecret()\n+\n+    ]=],\n+    name = 'inputsecret',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' } },\n+    signature = 'inputsecret({prompt} [, {text}])',\n+  },\n+  insert = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When {object} is a |List| or a |Blob| insert {item} at the start\n+      of it.\n+\n+      If {idx} is specified insert {item} before the item with index\n+      {idx}.  If {idx} is zero it goes before the first item, just\n+      like omitting {idx}.  A negative {idx} is also possible, see\n+      |list-index|.  -1 inserts just before the last item.\n+\n+      Returns the resulting |List| or |Blob|.  Examples: >\n+      \t:let mylist = insert([2, 3, 5], 1)\n+      \t:call insert(mylist, 4, -1)\n+      \t:call insert(mylist, 6, len(mylist))\n+      <The last example can be done simpler with |add()|.\n+      Note that when {item} is a |List| it is inserted as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->insert(item)\n+\n+    ]=],\n+    name = 'insert',\n+    params = { { 'object', 'any' }, { 'item', 'any' }, { 'idx', 'integer' } },\n+    signature = 'insert({object}, {item} [, {idx}])',\n+  },\n+  interrupt = {\n+    args = 0,\n+    desc = [=[\n+      Interrupt script execution.  It works more or less like the\n+      user typing CTRL-C, most commands won't execute and control\n+      returns to the user.  This is useful to abort execution\n+      from lower down, e.g. in an autocommand.  Example: >\n+      :function s:check_typoname(file)\n+      :   if fnamemodify(a:file, ':t') == '['\n+      :       echomsg 'Maybe typo'\n+      :       call interrupt()\n+      :   endif\n+      :endfunction\n+      :au BufWritePre * call s:check_typoname(expand('<amatch>'))\n+\n+    ]=],\n+    name = 'interrupt',\n+    params = {},\n+    signature = 'interrupt()',\n+  },\n+  invert = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Bitwise invert.  The argument is converted to a number.  A\n+      List, Dict or Float argument causes an error.  Example: >\n+      \t:let bits = invert(bits)\n+      <Can also be used as a |method|: >\n+      \t:let bits = bits->invert()\n+\n+    ]=],\n+    name = 'invert',\n+    params = { { 'expr', 'any' } },\n+    signature = 'invert({expr})',\n+  },\n+  isdirectory = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a directory\n+      with the name {directory} exists.  If {directory} doesn't\n+      exist, or isn't a directory, the result is |FALSE|.  {directory}\n+      is any expression, which is used as a String.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->isdirectory()\n+\n+    ]=],\n+    fast = true,\n+    name = 'isdirectory',\n+    params = { { 'directory', 'any' } },\n+    returns = '0|1',\n+    signature = 'isdirectory({directory})',\n+  },\n+  isinf = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return 1 if {expr} is a positive infinity, or -1 a negative\n+      infinity, otherwise 0. >\n+      \t:echo isinf(1.0 / 0.0)\n+      <\t1 >\n+      \t:echo isinf(-1.0 / 0.0)\n+      <\t-1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isinf()\n+\n+    ]=],\n+    name = 'isinf',\n+    params = { { 'expr', 'any' } },\n+    returns = '1|0|-1',\n+    signature = 'isinf({expr})',\n+  },\n+  islocked = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when {expr} is the\n+      name of a locked variable.\n+      The string argument {expr} must be the name of a variable,\n+      |List| item or |Dictionary| entry, not the variable itself!\n+      Example: >\n+      \t:let alist = [0, ['a', 'b'], 2, 3]\n+      \t:lockvar 1 alist\n+      \t:echo islocked('alist')\t\t\" 1\n+      \t:echo islocked('alist[1]')\t\" 0\n+\n+      <When {expr} is a variable that does not exist you get an error\n+      message.  Use |exists()| to check for existence.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->islocked()\n+\n+    ]=],\n+    name = 'islocked',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'islocked({expr})',\n+    tags = { 'E786' },\n+  },\n+  isnan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return |TRUE| if {expr} is a float with value NaN. >\n+      \techo isnan(0.0 / 0.0)\n+      <\t1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isnan()\n+\n+    ]=],\n+    name = 'isnan',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'isnan({expr})',\n+  },\n+  items = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the key-value pairs of {dict}.  Each\n+      |List| item is a list with two items: the key of a {dict}\n+      entry and the value of this entry.  The |List| is in arbitrary\n+      order.  Also see |keys()| and |values()|.\n+      Example: >\n+      \tfor [key, value] in items(mydict)\n+      \t   echo key .. ': ' .. value\n+      \tendfor\n+\n+      <Can also be used as a |method|: >\n+      \tmydict->items()\n+\n+    ]=],\n+    name = 'items',\n+    params = { { 'dict', 'any' } },\n+    signature = 'items({dict})',\n+  },\n+  jobclose = {\n+    args = { 1, 2 },\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chanclose()|\n+    ]=],\n+    func = 'f_chanclose',\n+    params = VARARGS,\n+    signature = 'jobclose({id} [, {stream}])',\n+  },\n+  jobpid = {\n+    args = 1,\n+    desc = [=[\n+      Return the PID (process id) of |job-id| {job}.\n+\n+    ]=],\n+    name = 'jobpid',\n+    params = { { 'job', 'any' } },\n+    returns = 'integer',\n+    signature = 'jobpid({job})',\n+  },\n+  jobresize = {\n+    args = 3,\n+    desc = [=[\n+      Resize the pseudo terminal window of |job-id| {job} to {width}\n+      columns and {height} rows.\n+      Fails if the job was not started with `\"pty\":v:true`.\n+\n+    ]=],\n+    name = 'jobresize',\n+    params = { { 'job', 'any' }, { 'width', 'integer' }, { 'height', 'integer' } },\n+    signature = 'jobresize({job}, {width}, {height})',\n+  },\n+  jobsend = {\n+    args = 2,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chansend()|\n+    ]=],\n+    func = 'f_chansend',\n+    params = VARARGS,\n+    signature = 'jobsend({id}, {data})',\n+  },\n+  jobstart = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Note: Prefer |vim.system()| in Lua.\n+\n+      Spawns {cmd} as a job.\n+      If {cmd} is a List it runs directly (no 'shell').\n+      If {cmd} is a String it runs in the 'shell', like this: >\n+        :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n+      <(See |shell-unquoting| for details.)\n+\n+      Example: >\n+        :call jobstart('nvim -h', {'on_stdout':{j,d,e->append(line('.'),d)}})\n+      <\n+      Returns |job-id| on success, 0 on invalid arguments (or job\n+      table is full), -1 if {cmd}[0] or 'shell' is not executable.\n+      The returned job-id is a valid |channel-id| representing the\n+      job's stdio streams. Use |chansend()| (or |rpcnotify()| and\n+      |rpcrequest()| if \"rpc\" was enabled) to send data to stdin and\n+      |chanclose()| to close the streams without stopping the job.\n+\n+      See |job-control| and |RPC|.\n+\n+      NOTE: on Windows if {cmd} is a List:\n+        - cmd[0] must be an executable (not a \"built-in\"). If it is\n+          in $PATH it can be called by name, without an extension: >\n+            :call jobstart(['ping', 'neovim.io'])\n+      <    If it is a full or partial path, extension is required: >\n+            :call jobstart(['System32\\ping.exe', 'neovim.io'])\n+      <  - {cmd} is collapsed to a string of quoted args as expected\n+          by CommandLineToArgvW https://msdn.microsoft.com/bb776391\n+          unless cmd[0] is some form of \"cmd.exe\".\n+\n+      \t\t\t\t\t*jobstart-env*\n+      The job environment is initialized as follows:\n+        $NVIM                is set to |v:servername| of the parent Nvim\n+        $NVIM_LISTEN_ADDRESS is unset\n+        $NVIM_LOG_FILE       is unset\n+        $VIM                 is unset\n+        $VIMRUNTIME          is unset\n+      You can set these with the `env` option.\n+\n+      \t\t\t\t\t*jobstart-options*\n+      {opts} is a dictionary with these keys:\n+        clear_env:  (boolean) `env` defines the job environment\n+      \t      exactly, instead of merging current environment.\n+        cwd:\t      (string, default=|current-directory|) Working\n+      \t      directory of the job.\n+        detach:     (boolean) Detach the job process: it will not be\n+      \t      killed when Nvim exits. If the process exits\n+      \t      before Nvim, `on_exit` will be invoked.\n+        env:\t      (dict) Map of environment variable name:value\n+      \t      pairs extending (or replace with \"clear_env\")\n+      \t      the current environment. |jobstart-env|\n+        height:     (number) Height of the `pty` terminal.\n+        |on_exit|:    (function) Callback invoked when the job exits.\n+        |on_stdout|:  (function) Callback invoked when the job emits\n+      \t      stdout data.\n+        |on_stderr|:  (function) Callback invoked when the job emits\n+      \t      stderr data.\n+        overlapped: (boolean) Sets FILE_FLAG_OVERLAPPED for the\n+      \t      stdio passed to the child process. Only on\n+      \t      MS-Windows; ignored on other platforms.\n+        pty:\t      (boolean) Connect the job to a new pseudo\n+      \t      terminal, and its streams to the master file\n+      \t      descriptor. `on_stdout` receives all output,\n+      \t      `on_stderr` is ignored. |terminal-start|\n+        rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n+      \t      the job over stdio. Then `on_stdout` is ignored,\n+      \t      but `on_stderr` can still be used.\n+        stderr_buffered: (boolean) Collect data until EOF (stream closed)\n+      \t      before invoking `on_stderr`. |channel-buffered|\n+        stdout_buffered: (boolean) Collect data until EOF (stream\n+      \t      closed) before invoking `on_stdout`. |channel-buffered|\n+        stdin:      (string) Either \"pipe\" (default) to connect the\n+      \t      job's stdin to a channel or \"null\" to disconnect\n+      \t      stdin.\n+        width:      (number) Width of the `pty` terminal.\n+\n+      {opts} is passed as |self| dictionary to the callback; the\n+      caller may set other keys to pass application-specific data.\n+\n+      Returns:\n+        - |channel-id| on success\n+        - 0 on invalid arguments\n+        - -1 if {cmd}[0] is not executable.\n+      See also |job-control|, |channel|, |msgpack-rpc|.\n+\n+    ]=],\n+    name = 'jobstart',\n+    params = { { 'cmd', 'any' }, { 'opts', 'table' } },\n+    signature = 'jobstart({cmd} [, {opts}])',\n+  },\n+  jobstop = {\n+    args = 1,\n+    desc = [=[\n+      Stop |job-id| {id} by sending SIGTERM to the job process. If\n+      the process does not terminate after a timeout then SIGKILL\n+      will be sent. When the job terminates its |on_exit| handler\n+      (if any) will be invoked.\n+      See |job-control|.\n+\n+      Returns 1 for valid job id, 0 for invalid id, including jobs have\n+      exited or stopped.\n+\n+    ]=],\n+    name = 'jobstop',\n+    params = { { 'id', 'any' } },\n+    signature = 'jobstop({id})',\n+  },\n+  jobwait = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Waits for jobs and their |on_exit| handlers to complete.\n+\n+      {jobs} is a List of |job-id|s to wait for.\n+      {timeout} is the maximum waiting time in milliseconds. If\n+      omitted or -1, wait forever.\n+\n+      Timeout of 0 can be used to check the status of a job: >\n+      \tlet running = jobwait([{job-id}], 0)[0] == -1\n+      <\n+      During jobwait() callbacks for jobs not in the {jobs} list may\n+      be invoked. The screen will not redraw unless |:redraw| is\n+      invoked by a callback.\n+\n+      Returns a list of len({jobs}) integers, where each integer is\n+      the status of the corresponding job:\n+      \tExit-code, if the job exited\n+      \t-1 if the timeout was exceeded\n+      \t-2 if the job was interrupted (by |CTRL-C|)\n+      \t-3 if the job-id is invalid\n+\n+    ]=],\n+    name = 'jobwait',\n+    params = { { 'jobs', 'any' }, { 'timeout', 'integer' } },\n+    signature = 'jobwait({jobs} [, {timeout}])',\n+  },\n+  join = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Join the items in {list} together into one String.\n+      When {sep} is specified it is put in between the items.  If\n+      {sep} is omitted a single space is used.\n+      Note that {sep} is not added at the end.  You might want to\n+      add it there too: >\n+      \tlet lines = join(mylist, \"\\n\") .. \"\\n\"\n+      <String items are used as-is.  |Lists| and |Dictionaries| are\n+      converted into a string like with |string()|.\n+      The opposite function is |split()|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->join()\n+\n+    ]=],\n+    name = 'join',\n+    params = { { 'list', 'any' }, { 'sep', 'any' } },\n+    signature = 'join({list} [, {sep}])',\n+  },\n+  json_decode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} from JSON object.  Accepts |readfile()|-style\n+      list as the input, as well as regular string.  May output any\n+      Vim value. In the following cases it will output\n+      |msgpack-special-dict|:\n+      1. Dictionary contains duplicate key.\n+      2. Dictionary contains empty key.\n+      3. String contains NUL byte.  Two special dictionaries: for\n+         dictionary and for string will be emitted in case string\n+         with NUL byte was a dictionary key.\n+\n+      Note: function treats its input as UTF-8 always.  The JSON\n+      standard allows only a few encodings, of which UTF-8 is\n+      recommended and the only one required to be supported.\n+      Non-UTF-8 characters are an error.\n+\n+      Can also be used as a |method|: >\n+      \tReadObject()->json_decode()\n+\n+    ]=],\n+    name = 'json_decode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_decode({expr})',\n+  },\n+  json_encode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} into a JSON string.  Accepts\n+      |msgpack-special-dict| as the input.  Will not convert\n+      |Funcref|s, mappings with non-string keys (can be created as\n+      |msgpack-special-dict|), values with self-referencing\n+      containers, strings which contain non-UTF-8 characters,\n+      pseudo-UTF-8 strings which contain codepoints reserved for\n+      surrogate pairs (such strings are not valid UTF-8 strings).\n+      Non-printable characters are converted into \"\\u1234\" escapes\n+      or special escapes like \"\\t\", other are dumped as-is.\n+      |Blob|s are converted to arrays of the individual bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->json_encode()\n+\n+    ]=],\n+    name = 'json_encode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_encode({expr})',\n+  },\n+  keys = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the keys of {dict}.  The |List| is in\n+      arbitrary order.  Also see |items()| and |values()|.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->keys()\n+\n+    ]=],\n+    name = 'keys',\n+    params = { { 'dict', 'any' } },\n+    signature = 'keys({dict})',\n+  },\n+  keytrans = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Turn the internal byte representation of keys into a form that\n+      can be used for |:map|.  E.g. >\n+      \t:let xx = \"\\<C-Home>\"\n+      \t:echo keytrans(xx)\n+      <\t<C-Home>\n+\n+      Can also be used as a |method|: >\n+      \t\"\\<C-Home>\"->keytrans()\n+      <\n+    ]=],\n+    name = 'keytrans',\n+    params = { { 'string', 'string' } },\n+    signature = 'keytrans({string})',\n+  },\n+  last_buffer_nr = {\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for bufnr(\"$\").\n+    ]=],\n+    params = {},\n+    signature = 'last_buffer_nr()',\n+  },\n+  len = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a String or a Number the length in bytes is\n+      used, as with |strlen()|.\n+      When {expr} is a |List| the number of items in the |List| is\n+      returned.\n+      When {expr} is a |Blob| the number of bytes is returned.\n+      When {expr} is a |Dictionary| the number of entries in the\n+      |Dictionary| is returned.\n+      Otherwise an error is given and returns zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->len()\n+      <\n+    ]=],\n+    name = 'len',\n+    params = { { 'expr', 'any' } },\n+    signature = 'len({expr})',\n+    tags = { 'E701' },\n+  },\n+  libcall = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Call function {funcname} in the run-time library {libname}\n+      with single argument {argument}.\n+      This is useful to call functions in a library that you\n+      especially made to be used with Vim.  Since only one argument\n+      is possible, calling standard library functions is rather\n+      limited.\n+      The result is the String returned by the function.  If the\n+      function returns NULL, this will appear as an empty string \"\"\n+      to Vim.\n+      If the function returns a number, use libcallnr()!\n+      If {argument} is a number, it is passed to the function as an\n+      int; if {argument} is a string, it is passed as a\n+      null-terminated string.\n+\n+      libcall() allows you to write your own 'plug-in' extensions to\n+      Vim without having to recompile the program.  It is NOT a\n+      means to call system functions!  If you try to do so Vim will\n+      very probably crash.\n+\n+      For Win32, the functions you write must be placed in a DLL\n+      and use the normal C calling convention (NOT Pascal which is\n+      used in Windows System DLLs).  The function must take exactly\n+      one parameter, either a character pointer or a long integer,\n+      and must return a character pointer or NULL.  The character\n+      pointer returned must point to memory that will remain valid\n+      after the function has returned (e.g. in static data in the\n+      DLL).  If it points to allocated memory, that memory will\n+      leak away.  Using a static buffer in the function should work,\n+      it's then freed when the DLL is unloaded.\n+\n+      WARNING: If the function returns a non-valid pointer, Vim may\n+      crash!\tThis also happens if the function returns a number,\n+      because Vim thinks it's a pointer.\n+      For Win32 systems, {libname} should be the filename of the DLL\n+      without the \".DLL\" suffix.  A full path is only required if\n+      the DLL is not in the usual places.\n+      For Unix: When compiling your own plugins, remember that the\n+      object code must be compiled as position-independent ('PIC').\n+      Examples: >\n+      \t:echo libcall(\"libc.so\", \"getenv\", \"HOME\")\n+\n+      <Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcall(\"libc.so\", \"getenv\")\n+      <\n+    ]=],\n+    name = 'libcall',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcall({libname}, {funcname}, {argument})',\n+    tags = { 'E364', 'E368' },\n+  },\n+  libcallnr = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Just like |libcall()|, but used for a function that returns an\n+      int instead of a string.\n+      Examples: >\n+      \t:echo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n+      \t:call libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n+      \t:call libcallnr(\"libc.so\", \"sleep\", 10)\n+      <\n+      Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcallnr(\"libc.so\", \"printf\")\n+      <\n+    ]=],\n+    name = 'libcallnr',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcallnr({libname}, {funcname}, {argument})',\n+  },\n+  line = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the line number of the file\n+      position given with {expr}.  The {expr} argument is a string.\n+      The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the last line in the current buffer\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          w0\t    first line visible in current window (one if the\n+      \t    display isn't updated, e.g. in silent Ex mode)\n+          w$\t    last line visible in current window (this is one\n+      \t    less than \"w0\" if no lines are visible)\n+          v\t    In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Note that a mark in another file can be used.  The line number\n+      then applies to another buffer.\n+      To get the column number use |col()|.  To get both use\n+      |getpos()|.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      Returns 0 for invalid values of {expr} and {winid}.\n+      Examples: >\n+      \tline(\".\")\t\tline number of the cursor\n+      \tline(\".\", winid)\tidem, in window \"winid\"\n+      \tline(\"'t\")\t\tline number of mark t\n+      \tline(\"'\" .. marker)\tline number of mark marker\n+      <\n+      To jump to the last known position when opening a file see\n+      |last-position-jump|.\n+\n+      Can also be used as a |method|: >\n+      \tGetValue()->line()\n+\n+    ]=],\n+    name = 'line',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line({expr} [, {winid}])',\n+  },\n+  line2byte = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the byte count from the start of the buffer for line\n+      {lnum}.  This includes the end-of-line character, depending on\n+      the 'fileformat' option for the current buffer.  The first\n+      line returns 1. UTF-8 encoding is used, 'fileencoding' is\n+      ignored.  This can also be used to get the byte count for the\n+      line just below the last line: >\n+      \tline2byte(line(\"$\") + 1)\n+      <This is the buffer size plus one.  If 'fileencoding' is empty\n+      it is the file size plus one.  {lnum} is used like with\n+      |getline()|.  When {lnum} is invalid -1 is returned.\n+      Also see |byte2line()|, |go| and |:goto|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->line2byte()\n+\n+    ]=],\n+    name = 'line2byte',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line2byte({lnum})',\n+  },\n+  lispindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the lisp\n+      indenting rules, as with 'lisp'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid, -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->lispindent()\n+\n+    ]=],\n+    name = 'lispindent',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'lispindent({lnum})',\n+  },\n+  list2blob = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a Blob concatenating all the number values in {list}.\n+      Examples: >\n+      \tlist2blob([1, 2, 3, 4])\treturns 0z01020304\n+      \tlist2blob([])\t\treturns 0z\n+      <Returns an empty Blob on error.  If one of the numbers is\n+      negative or more than 255 error *E1239* is given.\n+\n+      |blob2list()| does the opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2blob()\n+\n+    ]=],\n+    name = 'list2blob',\n+    params = { { 'list', 'any' } },\n+    signature = 'list2blob({list})',\n+  },\n+  list2str = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Convert each number in {list} to a character string can\n+      concatenate them all.  Examples: >\n+      \tlist2str([32])\t\treturns \" \"\n+      \tlist2str([65, 66, 67])\treturns \"ABC\"\n+      <The same can be done (slowly) with: >\n+      \tjoin(map(list, {nr, val -> nr2char(val)}), '')\n+      <|str2list()| does the opposite.\n+\n+      UTF-8 encoding is always used, {utf8} option has no effect,\n+      and exists only for backwards-compatibility.\n+      With UTF-8 composing characters work as expected: >\n+      \tlist2str([97, 769])\treturns \"a\"\n+      <\n+      Returns an empty string on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2str()\n+\n+    ]=],\n+    name = 'list2str',\n+    params = { { 'list', 'any' }, { 'utf8', 'any' } },\n+    signature = 'list2str({list} [, {utf8}])',\n+  },\n+  localtime = {\n+    desc = [=[\n+      Return the current time, measured as seconds since 1st Jan\n+      1970.  See also |strftime()|, |strptime()| and |getftime()|.\n+    ]=],\n+    name = 'localtime',\n+    params = {},\n+    signature = 'localtime()',\n+  },\n+  log = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the natural logarithm (base e) of {expr} as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      (0, inf].\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log(10)\n+      <\t2.302585 >\n+      \t:echo log(exp(5))\n+      <\t5.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log()\n+\n+    ]=],\n+    float_func = 'log',\n+    name = 'log',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log({expr})',\n+  },\n+  log10 = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the logarithm of Float {expr} to base 10 as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log10(1000)\n+      <\t3.0 >\n+      \t:echo log10(0.01)\n+      <\t-2.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log10()\n+\n+    ]=],\n+    float_func = 'log10',\n+    name = 'log10',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log10({expr})',\n+  },\n+  luaeval = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Evaluate Lua expression {expr} and return its result converted\n+      to Vim data structures. See |lua-eval| for more details.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->luaeval()\n+      <\n+    ]=],\n+    lua = false,\n+    name = 'luaeval',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    signature = 'luaeval({expr} [, {expr}])',\n+  },\n+  map = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob| or |Dictionary|.\n+      Replace each item in {expr1} with the result of evaluating\n+      {expr2}.  For a |Blob| each byte is replaced.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+      Example: >\n+      \t:call map(mylist, '\"> \" .. v:val .. \" <\"')\n+      <This puts \"> \" before and \" <\" after each item in \"mylist\".\n+\n+      Note that {expr2} is the result of an expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.  You\n+      still have to double ' quotes\n+\n+      If {expr2} is a |Funcref| it is called with two arguments:\n+      \t1. The key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return the new value of the item. Example\n+      that changes each value by \"key-value\": >\n+      \tfunc KeyValue(key, val)\n+      \t  return a:key .. '-' .. a:val\n+      \tendfunc\n+      \tcall map(myDict, function('KeyValue'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall map(myDict, {key, val -> key .. '-' .. val})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall map(myDict, {key -> 'item: ' .. key})\n+      <If you do not use \"key\" you can use a short name: >\n+      \tcall map(myDict, {_, val -> 'item: ' .. val})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let tlist = map(copy(mylist), ' v:val .. \"\\t\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->map(expr2)\n+      <\n+    ]=],\n+    name = 'map',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'map({expr1}, {expr2})',\n+  },\n+  maparg = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {dict} is omitted or zero: Return the rhs of mapping\n+      {name} in mode {mode}.  The returned String has special\n+      characters translated like in the output of the \":map\" command\n+      listing.\n+\n+      When there is no mapping for {name}, an empty String is\n+      returned if {dict} is FALSE, otherwise returns an empty Dict.\n+      When the mapping for {name} is empty, then \"<Nop>\" is\n+      returned.\n+\n+      The {name} can have special key names, like in the \":map\"\n+      command.\n+\n+      {mode} can be one of these strings:\n+      \t\"n\"\tNormal\n+      \t\"v\"\tVisual (including Select)\n+      \t\"o\"\tOperator-pending\n+      \t\"i\"\tInsert\n+      \t\"c\"\tCmd-line\n+      \t\"s\"\tSelect\n+      \t\"x\"\tVisual\n+      \t\"l\"\tlangmap |language-mapping|\n+      \t\"t\"\tTerminal\n+      \t\"\"\tNormal, Visual and Operator-pending\n+      When {mode} is omitted, the modes for \"\" are used.\n+\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.\n+\n+      When {dict} is there and it is |TRUE| return a dictionary\n+      containing all the information of the mapping with the\n+      following items:\n+        \"lhs\"\t     The {lhs} of the mapping as it would be typed\n+        \"lhsraw\"   The {lhs} of the mapping as raw bytes\n+        \"lhsrawalt\" The {lhs} of the mapping as raw bytes, alternate\n+      \t      form, only present when it differs from \"lhsraw\"\n+        \"rhs\"\t     The {rhs} of the mapping as typed.\n+        \"silent\"   1 for a |:map-silent| mapping, else 0.\n+        \"noremap\"  1 if the {rhs} of the mapping is not remappable.\n+        \"script\"   1 if mapping was defined with <script>.\n+        \"expr\"     1 for an expression mapping (|:map-<expr>|).\n+        \"buffer\"   1 for a buffer local mapping (|:map-local|).\n+        \"mode\"     Modes for which the mapping is defined. In\n+      \t     addition to the modes mentioned above, these\n+      \t     characters will be used:\n+      \t     \" \"     Normal, Visual and Operator-pending\n+      \t     \"!\"     Insert and Commandline mode\n+      \t\t     (|mapmode-ic|)\n+        \"sid\"\t     The script local ID, used for <sid> mappings\n+      \t     (|<SID>|).  Negative for special contexts.\n+        \"lnum\"     The line number in \"sid\", zero if unknown.\n+        \"nowait\"   Do not wait for other, longer mappings.\n+      \t     (|:map-<nowait>|).\n+\n+      The dictionary can be used to restore a mapping with\n+      |mapset()|.\n+\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to map a key even when it's already\n+      mapped, and have it do the original mapping too.  Sketch: >\n+      \texe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')\n+\n+      <Can also be used as a |method|: >\n+      \tGetKey()->maparg('n')\n+\n+    ]=],\n+    name = 'maparg',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'boolean' }, { 'dict', 'boolean' } },\n+    returns = 'string|table<string,any>',\n+    signature = 'maparg({name} [, {mode} [, {abbr} [, {dict}]]])',\n+  },\n+  mapcheck = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Check if there is a mapping that matches with {name} in mode\n+      {mode}.  See |maparg()| for {mode} and special names in\n+      {name}.\n+      When {abbr} is there and it is non-zero use abbreviations\n+      instead of mappings.\n+      A match happens with a mapping that starts with {name} and\n+      with a mapping which is equal to the start of {name}.\n+\n+      \tmatches mapping \"a\"\t\"ab\"\t\"abc\" ~\n+         mapcheck(\"a\")\tyes\tyes\t yes\n+         mapcheck(\"abc\")\tyes\tyes\t yes\n+         mapcheck(\"ax\")\tyes\tno\t no\n+         mapcheck(\"b\")\tno\tno\t no\n+\n+      The difference with maparg() is that mapcheck() finds a\n+      mapping that matches with {name}, while maparg() only finds a\n+      mapping for {name} exactly.\n+      When there is no mapping that starts with {name}, an empty\n+      String is returned.  If there is one, the RHS of that mapping\n+      is returned.  If there are several mappings that start with\n+      {name}, the RHS of one of them is returned.  This will be\n+      \"<Nop>\" if the RHS is empty.\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to check if a mapping can be added\n+      without being ambiguous.  Example: >\n+      \t:if mapcheck(\"_vv\") == \"\"\n+      \t:   map _vv :set guifont=7x13<CR>\n+      \t:endif\n+      <This avoids adding the \"_vv\" mapping when there already is a\n+      mapping for \"_v\" or for \"_vvv\".\n+\n+      Can also be used as a |method|: >\n+      \tGetKey()->mapcheck('n')\n+\n+    ]=],\n+    name = 'mapcheck',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    signature = 'mapcheck({name} [, {mode} [, {abbr}]])',\n+  },\n+  mapset = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      Restore a mapping from a dictionary returned by |maparg()|.\n+      {mode} and {abbr} should be the same as for the call to\n+      |maparg()|. *E460*\n+      {mode} is used to define the mode in which the mapping is set,\n+      not the \"mode\" entry in {dict}.\n+      Example for saving and restoring a mapping: >\n+      \tlet save_map = maparg('K', 'n', 0, 1)\n+      \tnnoremap K somethingelse\n+      \t...\n+      \tcall mapset('n', 0, save_map)\n+      <Note that if you are going to replace a map in several modes,\n+      e.g. with `:map!`, you need to save the mapping for all of\n+      them, since they can differ.\n+    ]=],\n+    name = 'mapset',\n+    params = { { 'mode', 'string' }, { 'abbr', 'any' }, { 'dict', 'any' } },\n+    signature = 'mapset({mode}, {abbr}, {dict})',\n+  },\n+  match = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a |List| then this returns the index of the\n+      first item where {pat} matches.  Each item is used as a\n+      String, |Lists| and |Dictionaries| are used as echoed.\n+\n+      Otherwise, {expr} is used as a String.  The result is a\n+      Number, which gives the index (byte offset) in {expr} where\n+      {pat} matches.\n+\n+      A match at the first character or |List| item returns zero.\n+      If there is no match -1 is returned.\n+\n+      For getting submatches see |matchlist()|.\n+      Example: >\n+      \t:echo match(\"testing\", \"ing\")\t\" results in 4\n+      \t:echo match([1, 'x'], '\\a')\t\" results in 1\n+      <See |string-match| for how {pat} is used.\n+      \t\t\t\t\t\t*strpbrk()*\n+      Vim doesn't have a strpbrk() function.  But you can do: >\n+      \t:let sepidx = match(line, '[.,;: \\t]')\n+      <\t\t\t\t\t\t*strcasestr()*\n+      Vim doesn't have a strcasestr() function.  But you can add\n+      \"\\c\" to the pattern to ignore case: >\n+      \t:let idx = match(haystack, '\\cneedle')\n+      <\n+      If {start} is given, the search starts from byte index\n+      {start} in a String or item {start} in a |List|.\n+      The result, however, is still the index counted from the\n+      first character/item.  Example: >\n+      \t:echo match(\"testing\", \"ing\", 2)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"ing\", 4)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"t\", 2)\n+      <result is \"3\".\n+      For a String, if {start} > 0 then it is like the string starts\n+      {start} bytes later, thus \"^\" will match at {start}.  Except\n+      when {count} is given, then it's like matches before the\n+      {start} byte are ignored (this is a bit complicated to keep it\n+      backwards compatible).\n+      For a String, if {start} < 0, it will be set to 0.  For a list\n+      the index is counted from the end.\n+      If {start} is out of range ({start} > strlen({expr}) for a\n+      String or {start} > len({expr}) for a |List|) -1 is returned.\n+\n+      When {count} is given use the {count}th match.  When a match\n+      is found in a String the search for the next one starts one\n+      character further.  Thus this example results in 1: >\n+      \techo match(\"testing\", \"..\", 0, 2)\n+      <In a |List| the search continues in the next item.\n+      Note that when {count} is added the way {start} works changes,\n+      see above.\n+\n+      See |pattern| for the patterns that are accepted.\n+      The 'ignorecase' option is used to set the ignore-caseness of\n+      the pattern.  'smartcase' is NOT used.  The matching is always\n+      done like 'magic' is set and 'cpoptions' is empty.\n+      Note that a match at the start is preferred, thus when the\n+      pattern is using \"*\" (any number of matches) it tends to find\n+      zero matches at the start instead of a number of matches\n+      further down in the text.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->match('word')\n+      \tGetList()->match('word')\n+      <\n+    ]=],\n+    name = 'match',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'match({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchadd = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Defines a pattern to be highlighted in the current window (a\n+      \"match\").  It will be highlighted with {group}.  Returns an\n+      identification number (ID), which can be used to delete the\n+      match using |matchdelete()|.  The ID is bound to the window.\n+      Matching is case sensitive and magic, unless case sensitivity\n+      or magicness are explicitly overridden in {pattern}.  The\n+      'magic', 'smartcase' and 'ignorecase' options are not used.\n+      The \"Conceal\" value is special, it causes the match to be\n+      concealed.\n+\n+      The optional {priority} argument assigns a priority to the\n+      match.  A match with a high priority will have its\n+      highlighting overrule that of a match with a lower priority.\n+      A priority is specified as an integer (negative numbers are no\n+      exception).  If the {priority} argument is not specified, the\n+      default priority is 10.  The priority of 'hlsearch' is zero,\n+      hence all matches with a priority greater than zero will\n+      overrule it.  Syntax highlighting (see 'syntax') is a separate\n+      mechanism, and regardless of the chosen priority a match will\n+      always overrule syntax highlighting.\n+\n+      The optional {id} argument allows the request for a specific\n+      match ID.  If a specified ID is already taken, an error\n+      message will appear and the match will not be added.  An ID\n+      is specified as a positive integer (zero excluded).  IDs 1, 2\n+      and 3 are reserved for |:match|, |:2match| and |:3match|,\n+      respectively.  3 is reserved for use by the |matchparen|\n+      plugin.\n+      If the {id} argument is not specified or -1, |matchadd()|\n+      automatically chooses a free ID, which is at least 1000.\n+\n+      The optional {dict} argument allows for further custom\n+      values. Currently this is used to specify a match specific\n+      conceal character that will be shown for |hl-Conceal|\n+      highlighted matches. The dict can have the following members:\n+\n+      \tconceal\t    Special character to show instead of the\n+      \t\t    match (only for |hl-Conceal| highlighted\n+      \t\t    matches, see |:syn-cchar|)\n+      \twindow\t    Instead of the current window use the\n+      \t\t    window with this number or window ID.\n+\n+      The number of matches is not limited, as it is the case with\n+      the |:match| commands.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchadd(\"MyGroup\", \"TODO\")\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <A list of matches defined by |matchadd()| and |:match| are\n+      available from |getmatches()|.  All matches can be deleted in\n+      one operation by |clearmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchadd('TODO')\n+      <\n+    ]=],\n+    name = 'matchadd',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pattern', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    highlight_exists={\n-      args=1, base=1, func='f_hlexists',\n-      deprecated = { 'Obsolete name for |hlexists()|.' }\n+    signature = 'matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])',\n+    tags = { 'E798', 'E799', 'E801', 'E957' },\n+  },\n+  matchaddpos = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchadd()|, but requires a list of positions {pos}\n+      instead of a pattern. This command is faster than |matchadd()|\n+      because it does not require to handle regular expressions and\n+      sets buffer line boundaries to redraw screen. It is supposed\n+      to be used when fast match additions and deletions are\n+      required, for example to highlight matching parentheses.\n+      \t\t\t\t\t*E5030* *E5031*\n+      {pos} is a list of positions.  Each position can be one of\n+      these:\n+      - A number.  This whole line will be highlighted.  The first\n+        line has number 1.\n+      - A list with one number, e.g., [23]. The whole line with this\n+        number will be highlighted.\n+      - A list with two numbers, e.g., [23, 11]. The first number is\n+        the line number, the second one is the column number (first\n+        column is 1, the value must correspond to the byte index as\n+        |col()| would return).  The character at this position will\n+        be highlighted.\n+      - A list with three numbers, e.g., [23, 11, 3]. As above, but\n+        the third number gives the length of the highlight in bytes.\n+\n+      Entries with zero and negative line numbers are silently\n+      ignored, as well as entries with negative column numbers and\n+      lengths.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchaddpos(\"MyGroup\", [[23, 24], 34])\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <Matches added by |matchaddpos()| are returned by\n+      |getmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchaddpos([23, 11])\n+\n+    ]=],\n+    name = 'matchaddpos',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pos', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    histadd={args=2, base=2, returns=VIMBOOL},\n-    histdel={args={1, 2}, base=1, returns=VIMBOOL},\n-    histget={args={1, 2}, base=1, returns='string'},\n-    histnr={args=1, base=1, returns='integer'},\n-    hlID={args=1, base=1, returns='integer'},\n-    hlexists={args=1, base=1, returns=VIMBOOL},\n-    hostname={fast=true, returns='string'},\n-    iconv={args=3, base=1, fast=true},\n-    indent={args=1, base=1, returns='integer'},\n-    index={args={2, 4}, base=1},\n-    indexof={args={2, 3}, base=1},\n-    input={args={1, 3}, base=1},\n-    inputdialog={\n-      args={1, 3}, base=1,\n-      deprecated = { 'Use |input()| instead.' }\n+    signature = 'matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])',\n+  },\n+  matcharg = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Selects the {nr} match item, as set with a |:match|,\n+      |:2match| or |:3match| command.\n+      Return a |List| with two elements:\n+      \tThe name of the highlight group used\n+      \tThe pattern used.\n+      When {nr} is not 1, 2 or 3 returns an empty |List|.\n+      When there is no match item set returns ['', ''].\n+      This is useful to save and restore a |:match|.\n+      Highlighting matches using the |:match| commands are limited\n+      to three matches. |matchadd()| does not have this limitation.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matcharg()\n+\n+    ]=],\n+    name = 'matcharg',\n+    params = { { 'nr', 'integer' } },\n+    signature = 'matcharg({nr})',\n+  },\n+  matchdelete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Deletes a match with ID {id} previously defined by |matchadd()|\n+      or one of the |:match| commands.  Returns 0 if successful,\n+      otherwise -1.  See example for |matchadd()|.  All matches can\n+      be deleted in one operation by |clearmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matchdelete()\n+\n+    ]=],\n+    name = 'matchdelete',\n+    params = { { 'id', 'any' }, { 'win', 'any' } },\n+    signature = 'matchdelete({id} [, {win}])',\n+    tags = { 'E802', 'E803' },\n+  },\n+  matchend = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Same as |match()|, but return the index of first character\n+      after the match.  Example: >\n+      \t:echo matchend(\"testing\", \"ing\")\n+      <results in \"7\".\n+      \t\t\t\t\t*strspn()* *strcspn()*\n+      Vim doesn't have a strspn() or strcspn() function, but you can\n+      do it with matchend(): >\n+      \t:let span = matchend(line, '[a-zA-Z]')\n+      \t:let span = matchend(line, '[^a-zA-Z]')\n+      <Except that -1 is returned when there are no matches.\n+\n+      The {start}, if given, has the same meaning as for |match()|. >\n+      \t:echo matchend(\"testing\", \"ing\", 2)\n+      <results in \"7\". >\n+      \t:echo matchend(\"testing\", \"ing\", 5)\n+      <result is \"-1\".\n+      When {expr} is a |List| the result is equal to |match()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->matchend('word')\n+\n+    ]=],\n+    name = 'matchend',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'matchend({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchfuzzy = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      If {list} is a list of strings, then returns a |List| with all\n+      the strings in {list} that fuzzy match {str}. The strings in\n+      the returned list are sorted based on the matching score.\n+\n+      The optional {dict} argument always supports the following\n+      items:\n+          matchseq\tWhen this item is present return only matches\n+      \t\tthat contain the characters in {str} in the\n+      \t\tgiven sequence.\n+          limit\tMaximum number of matches in {list} to be\n+      \t\treturned.  Zero means no limit.\n+\n+      If {list} is a list of dictionaries, then the optional {dict}\n+      argument supports the following additional items:\n+          key\t\tKey of the item which is fuzzy matched against\n+      \t\t{str}. The value of this item should be a\n+      \t\tstring.\n+          text_cb\t|Funcref| that will be called for every item\n+      \t\tin {list} to get the text for fuzzy matching.\n+      \t\tThis should accept a dictionary item as the\n+      \t\targument and return the text for that item to\n+      \t\tuse for fuzzy matching.\n+\n+      {str} is treated as a literal string and regular expression\n+      matching is NOT supported.  The maximum supported {str} length\n+      is 256.\n+\n+      When {str} has multiple words each separated by white space,\n+      then the list of strings that have all the words is returned.\n+\n+      If there are no matching strings or there is an error, then an\n+      empty list is returned. If length of {str} is greater than\n+      256, then returns an empty list.\n+\n+      When {limit} is given, matchfuzzy() will find up to this\n+      number of matches in {list} and return them in sorted order.\n+\n+      Refer to |fuzzy-matching| for more information about fuzzy\n+      matching strings.\n+\n+      Example: >\n+         :echo matchfuzzy([\"clay\", \"crow\"], \"cay\")\n+      <results in [\"clay\"]. >\n+         :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy(\"ndl\")\n+      <results in a list of buffer names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"ndl\", {'key' : 'name'})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"spl\",\n+      \t\t\t\t\\ {'text_cb' : {v -> v.name}})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"spl\". >\n+         :echo v:oldfiles->matchfuzzy(\"test\")\n+      <results in a list of file names fuzzy matching \"test\". >\n+         :let l = readfile(\"buffer.c\")->matchfuzzy(\"str\")\n+      <results in a list of lines in \"buffer.c\" fuzzy matching \"str\". >\n+         :echo ['one two', 'two one']->matchfuzzy('two one')\n+      <results in `['two one', 'one two']` . >\n+         :echo ['one two', 'two one']->matchfuzzy('two one',\n+      \t\t\t\t\\ {'matchseq': 1})\n+      <results in `['two one']`.\n+\n+    ]=],\n+    name = 'matchfuzzy',\n+    params = { { 'list', 'any' }, { 'str', 'any' }, { 'dict', 'any' } },\n+    signature = 'matchfuzzy({list}, {str} [, {dict}])',\n+  },\n+  matchfuzzypos = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchfuzzy()|, but returns the list of matched\n+      strings, the list of character positions where characters\n+      in {str} matches and a list of matching scores.  You can\n+      use |byteidx()| to convert a character position to a byte\n+      position.\n+\n+      If {str} matches multiple times in a string, then only the\n+      positions for the best match is returned.\n+\n+      If there are no matching strings or there is an error, then a\n+      list with three empty list items is returned.\n+\n+      Example: >\n+      \t:echo matchfuzzypos(['testing'], 'tsg')\n+      <results in [[\"testing\"], [[0, 2, 6]], [99]] >\n+      \t:echo matchfuzzypos(['clay', 'lacy'], 'la')\n+      <results in [[\"lacy\", \"clay\"], [[0, 1], [1, 2]], [153, 133]] >\n+      \t:echo ",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277413909",
            "id": 1277413909,
            "in_reply_to_id": 1277413279,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI8oV",
            "original_commit_id": "9ae17e2a633d34f79ff0ac030b5abf3d979bc75c",
            "original_line": 8275,
            "original_position": 8490,
            "original_start_line": 7095,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1551882581,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413909/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-07-28T11:07:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277413909",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277421168"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277421168"
                }
            },
            "author_association": "MEMBER",
            "body": "This github suggestion looks broken. I think I've fixed this anyway.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T11:16:40Z",
            "diff_hunk": "@@ -11,502 +12,13421 @@\n ---       Defaults to BASE_NONE (function cannot be used as a method).\n --- @field func? string Name of the C function which implements the Vimscript function. Defaults to\n ---       `f_{funcname}`.\n+--- @field float_func? string\n --- @field fast? boolean Function can run in |api-fast| events. Defaults to false.\n---- @field deprecated? string[]\n+--- @field deprecated? true\n --- @field returns? string|false\n+--- @field signature string\n+--- @field desc? string\n+--- @field params {[1]:string, [2]:string}[]\n+--- @field lua? false Do not render type information\n+--- @field tags? string[] Extra tags\n+--- @field data? string Used by gen_eval.lua\n \n -- Usable with the base key: use the last function argument as the method base.\n -- Value is from funcs.h file. \"BASE_\" prefix is omitted.\n -- local LAST = \"BASE_LAST\" (currently unused after port of v8.2.1168)\n \n-local VIMBOOL = '0|1'\n-\n-return {\n-  --- @type table<string,vim.EvalFn>\n-  funcs={\n-    abs={args=1, base=1},\n-    acos={args=1, base=1, float_func=\"acos\", returns='number'},  -- WJMc\n-    add={args=2, base=1},\n-    ['and']={args=2, base=1},\n-    api_info={fast=true},\n-    append={args=2, base=2},\n-    appendbufline={args=3, base=3},\n-    argc={args={0, 1}, returns='integer'},\n-    argidx={returns='integer'},\n-    arglistid={args={0, 2}, returns='integer'},\n-    argv={args={0, 2}},\n-    asin={args=1, base=1, float_func=\"asin\"},  -- WJMc\n-    assert_beeps={args=1, base=1, returns=VIMBOOL},\n-    assert_equal={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_equalfile={args={2, 3}, base=1},\n-    assert_exception={args={1, 2}, returns=VIMBOOL},\n-    assert_fails={args={1, 5}, base=1, returns=VIMBOOL},\n-    assert_false={args={1, 2}, base=1, returns=VIMBOOL},\n-    assert_inrange={args={3, 4}, base=3, returns=VIMBOOL},\n-    assert_match={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_nobeep={args=1, base=1, returns=VIMBOOL},\n-    assert_notequal={args={2, 3}, base=2},\n-    assert_notmatch={args={2, 3}, base=2},\n-    assert_report={args=1, base=1},\n-    assert_true={args={1, 2}, base=1},\n-    atan={args=1, base=1, float_func=\"atan\", returns='number'},\n-    atan2={args=2, base=1, returns='number'},\n-    blob2list={args=1, base=1},\n-    browse={args=4},\n-    browsedir={args=2},\n-    bufadd={args=1, base=1, returns='integer'},\n-    bufexists={args=1, base=1, returns=VIMBOOL},\n-    buffer_exists={\n-      args=1, base=1, func='f_bufexists',\n-      deprecated = { 'Obsolete name for |bufexists()|.' }\n+local M = {}\n+\n+local VARARGS = { { '...', 'any' } }\n+\n+--- @type table<string,vim.EvalFn>\n+M.funcs = {\n+  abs = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the absolute value of {expr}.  When {expr} evaluates to\n+      a |Float| abs() returns a |Float|.  When {expr} can be\n+      converted to a |Number| abs() returns a |Number|.  Otherwise\n+      abs() gives an error message and returns -1.\n+      Examples: >\n+      \techo abs(1.456)\n+      <\t1.456  >\n+      \techo abs(-5.456)\n+      <\t5.456  >\n+      \techo abs(-4)\n+      <\t4\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->abs()\n+\n+    ]=],\n+    name = 'abs',\n+    params = { { 'expr', 'any' } },\n+    signature = 'abs({expr})',\n+    returns = 'number'\n+  },\n+  acos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc cosine of {expr} measured in radians, as a\n+      |Float| in the range of [0, pi].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo acos(0)\n+      <\t1.570796 >\n+      \t:echo acos(-0.5)\n+      <\t2.094395\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->acos()\n+\n+    ]=],\n+    float_func = 'acos',\n+    name = 'acos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'acos({expr})',\n+  },\n+  add = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Append the item {expr} to |List| or |Blob| {object}.  Returns\n+      the resulting |List| or |Blob|.  Examples: >\n+      \t:let alist = add([1, 2, 3], item)\n+      \t:call add(mylist, \"woodstock\")\n+      <Note that when {expr} is a |List| it is appended as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+      When {object} is a |Blob| then {expr} must be a number.\n+      Use |insert()| to add an item at another position.\n+      Returns 1 if {object} is not a |List| or a |Blob|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->add(val1)->add(val2)\n+\n+    ]=],\n+    name = 'add',\n+    params = { { 'object', 'any' }, { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'add({object}, {expr})',\n+  },\n+  ['and'] = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Bitwise AND on the two arguments.  The arguments are converted\n+      to a number.  A List, Dict or Float argument causes an error.\n+      Also see `or()` and `xor()`.\n+      Example: >\n+      \t:let flag = and(bits, 0x80)\n+      <Can also be used as a |method|: >\n+      \t:let flag = bits->and(0x80)\n+\n+    ]=],\n+    name = 'and',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    returns = 'integer',\n+    signature = 'and({expr}, {expr})',\n+  },\n+  api_info = {\n+    desc = [=[\n+      Returns Dictionary of |api-metadata|.\n+\n+      View it in a nice human-readable format: >\n+             :lua vim.print(vim.fn.api_info())\n+\n+    ]=],\n+    fast = true,\n+    name = 'api_info',\n+    params = {},\n+    returns = 'table',\n+    signature = 'api_info()',\n+  },\n+  append = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      When {text} is a |List|: Append each item of the |List| as a\n+      text line below line {lnum} in the current buffer.\n+      Otherwise append {text} as one text line below line {lnum} in\n+      the current buffer.\n+      Any type of item is accepted and converted to a String.\n+      {lnum} can be zero to insert a line before the first one.\n+      {lnum} is used like with |getline()|.\n+      Returns 1 for failure ({lnum} out of range or out of memory),\n+      0 for success.  Example: >\n+      \t:let failed = append(line('$'), \"# THE END\")\n+      \t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])\n+\n+      <Can also be used as a |method| after a List: >\n+      \tmylist->append(lnum)\n+\n+    ]=],\n+    name = 'append',\n+    params = { { 'lnum', 'integer' }, { 'text', 'any' } },\n+    returns = '0|1',\n+    signature = 'append({lnum}, {text})',\n+  },\n+  appendbufline = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Like |append()| but append the text in buffer {expr}.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()|.\n+\n+      {lnum} is the line number to append below.  Note that using\n+      |line()| would use the current buffer, not the one appending\n+      to.  Use \"$\" to append at the end of the buffer.  Other string\n+      values are not supported.\n+\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      If {buf} is not a valid buffer or {lnum} is not valid, an\n+      error message is given. Example: >\n+      \t:let failed = appendbufline(13, 0, \"# THE START\")\n+      <\n+      Can also be used as a |method| after a List: >\n+      \tmylist->appendbufline(buf, lnum)\n+\n+    ]=],\n+    name = 'appendbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'text', 'string' } },\n+    returns = '0|1',\n+    signature = 'appendbufline({buf}, {lnum}, {text})',\n+  },\n+  argc = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      The result is the number of files in the argument list.  See\n+      |arglist|.\n+      If {winid} is not supplied, the argument list of the current\n+      window is used.\n+      If {winid} is -1, the global argument list is used.\n+      Otherwise {winid} specifies the window of which the argument\n+      list is used: either the window number or the window ID.\n+      Returns -1 if the {winid} argument is invalid.\n+    ]=],\n+    name = 'argc',\n+    params = { { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'argc([{winid}])',\n+  },\n+  argidx = {\n+    desc = [=[\n+      The result is the current index in the argument list.  0 is\n+      the first file.  argc() - 1 is the last one.  See |arglist|.\n+    ]=],\n+    name = 'argidx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'argidx()',\n+  },\n+  arglistid = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      Return the argument list ID.  This is a number which\n+      identifies the argument list being used.  Zero is used for the\n+      global argument list.  See |arglist|.\n+      Returns -1 if the arguments are invalid.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.\n+      {winnr} can be the window number or the |window-ID|.\n+    ]=],\n+    name = 'arglistid',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'integer',\n+    signature = 'arglistid([{winnr} [, {tabnr}]])',\n+  },\n+  argv = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      The result is the {nr}th file in the argument list.  See\n+      |arglist|.  \"argv(0)\" is the first one.  Example: >\n+      \t:let i = 0\n+      \t:while i < argc()\n+      \t:  let f = escape(fnameescape(argv(i)), '.')\n+      \t:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'\n+      \t:  let i = i + 1\n+      \t:endwhile\n+      <Without the {nr} argument, or when {nr} is -1, a |List| with\n+      the whole |arglist| is returned.\n+\n+      The {winid} argument specifies the window ID, see |argc()|.\n+      For the Vim command line arguments see |v:argv|.\n+\n+      Returns an empty string if {nr}th argument is not present in\n+      the argument list.  Returns an empty List if the {winid}\n+      argument is invalid.\n+\n+    ]=],\n+    name = 'argv',\n+    params = { { 'nr', 'integer' }, { 'winid', 'integer' } },\n+    returns = 'string|string[]',\n+    signature = 'argv([{nr} [, {winid}]])',\n+  },\n+  asin = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc sine of {expr} measured in radians, as a |Float|\n+      in the range of [-pi/2, pi/2].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo asin(0.8)\n+      <\t0.927295 >\n+      \t:echo asin(-0.5)\n+      <\t-0.523599\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->asin()\n+      <\n+    ]=],\n+    float_func = 'asin',\n+    name = 'asin',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'asin({expr})',\n+  },\n+  assert_beeps = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce a beep or visual bell.\n+      Also see |assert_fails()|, |assert_nobeep()| and\n+      |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_beeps()\n+      <\n+    ]=],\n+    name = 'assert_beeps',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_beeps({cmd})',\n+  },\n+  assert_equal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {expected} and {actual} are not equal an error message is\n+      added to |v:errors| and 1 is returned.  Otherwise zero is\n+      returned. |assert-return|\n+      The error is in the form \"Expected {expected} but got\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      There is no automatic conversion, the String \"4\" is different\n+      from the Number 4.  And the number 4 is different from the\n+      Float 4.0.  The value of 'ignorecase' is not used here, case\n+      always matters.\n+      Example: >\n+      \tassert_equal('foo', 'bar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Expected 'foo' but got 'bar' ~\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_equal([1, 2, 3])\n+    ]=],\n+    name = 'assert_equal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_equal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_equalfile = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When the files {fname-one} and {fname-two} do not contain\n+      exactly the same text an error message is added to |v:errors|.\n+      Also see |assert-return|.\n+      When {fname-one} or {fname-two} does not exist the error will\n+      mention that.\n+\n+      Can also be used as a |method|: >\n+      \tGetLog()->assert_equalfile('expected.log')\n+    ]=],\n+    name = 'assert_equalfile',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'assert_equalfile({fname-one}, {fname-two})',\n+  },\n+  assert_exception = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      When v:exception does not contain the string {error} an error\n+      message is added to |v:errors|.  Also see |assert-return|.\n+      This can be used to assert that a command throws an exception.\n+      Using the error number, followed by a colon, avoids problems\n+      with translations: >\n+      \ttry\n+      \t  commandthatfails\n+      \t  call assert_false(1, 'command should have failed')\n+      \tcatch\n+      \t  call assert_exception('E492:')\n+      \tendtry\n+      <\n+    ]=],\n+    name = 'assert_exception',\n+    params = { { 'error', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_exception({error} [, {msg}])',\n+  },\n+  assert_fails = {\n+    args = { 1, 5 },\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce an error or when {error} is not found in the\n+      error message.  Also see |assert-return|.\n+\n+      When {error} is a string it must be found literally in the\n+      first reported error. Most often this will be the error code,\n+      including the colon, e.g. \"E123:\". >\n+      \tassert_fails('bad cmd', 'E987:')\n+      <\n+      When {error} is a |List| with one or two strings, these are\n+      used as patterns.  The first pattern is matched against the\n+      first reported error: >\n+      \tassert_fails('cmd', ['E987:.*expected bool'])\n+      <The second pattern, if present, is matched against the last\n+      reported error.  To only match the last error use an empty\n+      string for the first error: >\n+      \tassert_fails('cmd', ['', 'E987:'])\n+      <\n+      If {msg} is empty then it is not used.  Do this to get the\n+      default message when passing the {lnum} argument.\n+\n+      When {lnum} is present and not negative, and the {error}\n+      argument is present and matches, then this is compared with\n+      the line number at which the error was reported. That can be\n+      the line number in a function or in a script.\n+\n+      When {context} is present it is used as a pattern and matched\n+      against the context (script name or function name) where\n+      {lnum} is located in.\n+\n+      Note that beeping is not considered an error, and some failing\n+      commands only beep.  Use |assert_beeps()| for those.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_fails('E99:')\n+\n+    ]=],\n+    name = 'assert_fails',\n+    params = {\n+      { 'cmd', 'any' },\n+      { 'error', 'any' },\n+      { 'msg', 'any' },\n+      { 'lnum', 'integer' },\n+      { 'context', 'any' },\n     },\n-    buffer_name={\n-      args={0, 1}, base=1, func='f_bufname',\n-      deprecated = { 'Obsolete name for |bufname()|.' }\n+    returns = '0|1',\n+    signature = 'assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])',\n+  },\n+  assert_false = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not false an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      The error is in the form \"Expected False but got {actual}\".\n+      When {msg} is present it is prepended to that.\n+      Also see |assert-return|.\n+\n+      A value is false when it is zero. When {actual} is not a\n+      number the assert fails.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_false()\n+\n+    ]=],\n+    name = 'assert_false',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_false({actual} [, {msg}])',\n+  },\n+  assert_inrange = {\n+    args = { 3, 4 },\n+    base = 3,\n+    desc = [=[\n+      This asserts number and |Float| values.  When {actual}  is lower\n+      than {lower} or higher than {upper} an error message is added\n+      to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Expected range {lower} - {upper},\n+      but got {actual}\".  When {msg} is present it is prefixed to\n+      that.\n+    ]=],\n+    name = 'assert_inrange',\n+    params = { { 'lower', 'any' }, { 'upper', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_inrange({lower}, {upper}, {actual} [, {msg}])',\n+  },\n+  assert_match = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {pattern} does not match {actual} an error message is\n+      added to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Pattern {pattern} does not match\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      {pattern} is used as with |expr-=~|: The matching is always done\n+      like 'magic' was set and 'cpoptions' is empty, no matter what\n+      the actual value of 'magic' or 'cpoptions' is.\n+\n+      {actual} is used as a string, automatic conversion applies.\n+      Use \"^\" and \"$\" to match with the start and end of the text.\n+      Use both to match the whole text.\n+\n+      Example: >\n+      \tassert_match('^f.*o$', 'foobar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_match('foo.*')\n+      <\n+    ]=],\n+    name = 'assert_match',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_match({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_nobeep = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it\n+      produces a beep or visual bell.\n+      Also see |assert_beeps()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_nobeep()\n+      <\n+    ]=],\n+    name = 'assert_nobeep',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_nobeep({cmd})',\n+  },\n+  assert_notequal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_equal()`: add an error message to\n+      |v:errors| when {expected} and {actual} are equal.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_notequal([1, 2, 3])\n+\n+      <\n+    ]=],\n+    name = 'assert_notequal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notequal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_notmatch = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_match()`: add an error message to\n+      |v:errors| when {pattern} matches {actual}.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_notmatch('bar.*')\n+      <\n+    ]=],\n+    name = 'assert_notmatch',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notmatch({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_report = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Report a test failure directly, using String {msg}.\n+      Always returns one.\n+\n+      Can also be used as a |method|: >\n+      \tGetMessage()->assert_report()\n+      <\n+    ]=],\n+    name = 'assert_report',\n+    params = { { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_report({msg})',\n+  },\n+  assert_true = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not true an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      Also see |assert-return|.\n+      A value is |TRUE| when it is a non-zero number or |v:true|.\n+      When {actual} is not a number or |v:true| the assert fails.\n+      When {msg} is given it precedes the default message.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_true()\n+      <\n+    ]=],\n+    name = 'assert_true',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_true({actual} [, {msg}])',\n+  },\n+  atan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the principal value of the arc tangent of {expr}, in\n+      the range [-pi/2, +pi/2] radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo atan(100)\n+      <\t1.560797 >\n+      \t:echo atan(-4.01)\n+      <\t-1.326405\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan()\n+\n+    ]=],\n+    float_func = 'atan',\n+    name = 'atan',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'atan({expr})',\n+  },\n+  atan2 = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the arc tangent of {expr1} / {expr2}, measured in\n+      radians, as a |Float| in the range [-pi, pi].\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo atan2(-1, 1)\n+      <\t-0.785398 >\n+      \t:echo atan2(1, -1)\n+      <\t2.356194\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan2(1)\n+\n+    ]=],\n+    name = 'atan2',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    returns = 'number',\n+    signature = 'atan2({expr1}, {expr2})',\n+  },\n+  blob2list = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a List containing the number value of each byte in Blob\n+      {blob}.  Examples: >\n+      \tblob2list(0z0102.0304)\treturns [1, 2, 3, 4]\n+      \tblob2list(0z)\t\treturns []\n+      <Returns an empty List on error.  |list2blob()| does the\n+      opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetBlob()->blob2list()\n+      <\n+    ]=],\n+    name = 'blob2list',\n+    params = { { 'blob', 'any' } },\n+    returns = 'any[]',\n+    signature = 'blob2list({blob})',\n+  },\n+  browse = {\n+    args = 4,\n+    desc = [=[\n+      Put up a file requester.  This only works when \"has(\"browse\")\"\n+      returns |TRUE| (only in some GUI versions).\n+      The input fields are:\n+          {save}\twhen |TRUE|, select file to write\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+          {default}\tdefault file name\n+      An empty string is returned when the \"Cancel\" button is hit,\n+      something went wrong, or browsing is not possible.\n+    ]=],\n+    name = 'browse',\n+    params = { { 'save', 'any' }, { 'title', 'any' }, { 'initdir', 'any' }, { 'default', 'any' } },\n+    returns = '0|1',\n+    signature = 'browse({save}, {title}, {initdir}, {default})',\n+  },\n+  browsedir = {\n+    args = 2,\n+    desc = [=[\n+      Put up a directory requester.  This only works when\n+      \"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n+      On systems where a directory browser is not supported a file\n+      browser is used.  In that case: select a file in the directory\n+      to be used.\n+      The input fields are:\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+      When the \"Cancel\" button is hit, something went wrong, or\n+      browsing is not possible, an empty string is returned.\n+\n+    ]=],\n+    name = 'browsedir',\n+    params = { { 'title', 'any' }, { 'initdir', 'any' } },\n+    returns = '0|1',\n+    signature = 'browsedir({title}, {initdir})',\n+  },\n+  bufadd = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add a buffer to the buffer list with name {name} (must be a\n+      String).\n+      If a buffer for file {name} already exists, return that buffer\n+      number.  Otherwise return the buffer number of the newly\n+      created buffer.  When {name} is an empty string then a new\n+      buffer is always created.\n+      The buffer will not have 'buflisted' set and not be loaded\n+      yet.  To add some text to the buffer use this: >\n+      \tlet bufnr = bufadd('someName')\n+      \tcall bufload(bufnr)\n+      \tcall setbufline(bufnr, 1, ['some', 'text'])\n+      <Returns 0 on error.\n+      Can also be used as a |method|: >\n+      \tlet bufnr = 'somename'->bufadd()\n+\n+    ]=],\n+    name = 'bufadd',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'bufadd({name})',\n+  },\n+  bufexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists.\n+      If the {buf} argument is a number, buffer numbers are used.\n+      Number zero is the alternate buffer for the current window.\n+\n+      If the {buf} argument is a string it must match a buffer name\n+      exactly.  The name can be:\n+      - Relative to the current directory.\n+      - A full path.\n+      - The name of a buffer with 'buftype' set to \"nofile\".\n+      - A URL name.\n+      Unlisted buffers will be found.\n+      Note that help files are listed by their short name in the\n+      output of |:buffers|, but bufexists() requires using their\n+      long name to be able to find them.\n+      bufexists() may report a buffer exists, but to use the name\n+      with a |:buffer| command you may need to use |expand()|.  Esp\n+      for MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\n+      Use \"bufexists(0)\" to test for the existence of an alternate\n+      file name.\n+\n+      Can also be used as a |method|: >\n+      \tlet exists = 'somename'->bufexists()\n+\n+    ]=],\n+    name = 'bufexists',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufexists({buf})',\n+  },\n+  buffer_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufexists()|.\n+    ]=],\n+    func = 'f_bufexists',\n+    name = 'buffer_exists',\n+    params = VARARGS,\n+    returns = '0|1',\n+    signature = 'buffer_exists({buf})',\n+  },\n+  buffer_name = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufname()|.\n+    ]=],\n+    func = 'f_bufname',\n+    name = 'buffer_name',\n+    params = VARARGS,\n+    returns = 'string',\n+    signature = 'buffer_name([{buf}])',\n+  },\n+  buffer_number = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufnr()|.\n+    ]=],\n+    func = 'f_bufnr',\n+    name = 'buffer_number',\n+    params = VARARGS,\n+    returns = 'integer',\n+    signature = 'buffer_number([{buf} [, {create}]])',\n+  },\n+  buflisted = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is listed (has the 'buflisted' option set).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet listed = 'somename'->buflisted()\n+\n+    ]=],\n+    name = 'buflisted',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'buflisted({buf})',\n+  },\n+  bufload = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Ensure the buffer {buf} is loaded.  When the buffer name\n+      refers to an existing file then the file is read.  Otherwise\n+      the buffer will be empty.  If the buffer was already loaded\n+      then there is no change.  If the buffer is not related to a\n+      file the no file is read (e.g., when 'buftype' is \"nofile\").\n+      If there is an existing swap file for the file of the buffer,\n+      there will be no dialog, the buffer will be loaded anyway.\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \teval 'somename'->bufload()\n+\n+    ]=],\n+    name = 'bufload',\n+    params = { { 'buf', 'any' } },\n+    returns = false,\n+    signature = 'bufload({buf})',\n+  },\n+  bufloaded = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is loaded (shown in a window or hidden).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet loaded = 'somename'->bufloaded()\n+\n+    ]=],\n+    name = 'bufloaded',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufloaded({buf})',\n+  },\n+  bufname = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is the name of a buffer.  Mostly as it is displayed\n+      by the `:ls` command, but not using special names such as\n+      \"[No Name]\".\n+      If {buf} is omitted the current buffer is used.\n+      If {buf} is a Number, that buffer number's name is given.\n+      Number zero is the alternate buffer for the current window.\n+      If {buf} is a String, it is used as a |file-pattern| to match\n+      with the buffer names.  This is always done like 'magic' is\n+      set and 'cpoptions' is empty.  When there is more than one\n+      match an empty string is returned.\n+      \"\" or \"%\" can be used for the current buffer, \"#\" for the\n+      alternate buffer.\n+      A full match is preferred, otherwise a match at the start, end\n+      or middle of the buffer name is accepted.  If you only want a\n+      full match then put \"^\" at the start and \"$\" at the end of the\n+      pattern.\n+      Listed buffers are found first.  If there is a single match\n+      with a listed buffer, that one is returned.  Next unlisted\n+      buffers are searched for.\n+      If the {buf} is a String, but you want to use it as a buffer\n+      number, force it to be a Number by adding zero to it: >\n+      \t:echo bufname(\"3\" + 0)\n+      <Can also be used as a |method|: >\n+      \techo bufnr->bufname()\n+\n+      <If the buffer doesn't exist, or doesn't have a name, an empty\n+      string is returned. >\n+      \tbufname(\"#\")\t\talternate buffer name\n+      \tbufname(3)\t\tname of buffer 3\n+      \tbufname(\"%\")\t\tname of current buffer\n+      \tbufname(\"file2\")\tname of buffer where \"file2\" matches.\n+      <\n+    ]=],\n+    name = 'bufname',\n+    params = { { 'buf', 'any' } },\n+    returns = 'string',\n+    signature = 'bufname([{buf}])',\n+  },\n+  bufnr = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is the number of a buffer, as it is displayed by\n+      the `:ls` command.  For the use of {buf}, see |bufname()|\n+      above.\n+      If the buffer doesn't exist, -1 is returned.  Or, if the\n+      {create} argument is present and TRUE, a new, unlisted,\n+      buffer is created and its number is returned.\n+      bufnr(\"$\") is the last buffer: >\n+      \t:let last_buffer = bufnr(\"$\")\n+      <The result is a Number, which is the highest buffer number\n+      of existing buffers.  Note that not all buffers with a smaller\n+      number necessarily exist, because \":bwipeout\" may have removed\n+      them.  Use bufexists() to test for the existence of a buffer.\n+\n+      Can also be used as a |method|: >\n+      \techo bufref->bufnr()\n+\n+    ]=],\n+    name = 'bufnr',\n+    params = { { 'buf', 'any' }, { 'create', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufnr([{buf} [, {create}]])',\n+  },\n+  bufwinid = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the |window-ID| of the first\n+      window associated with buffer {buf}.  For the use of {buf},\n+      see |bufname()| above.  If buffer {buf} doesn't exist or\n+      there is no such window, -1 is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinid(1))\n+      <\n+      Only deals with the current tab page.  See |win_findbuf()| for\n+      finding more.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinid()\n+\n+    ]=],\n+    name = 'bufwinid',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinid({buf})',\n+  },\n+  bufwinnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Like |bufwinid()| but return the window number instead of the\n+      |window-ID|.\n+      If buffer {buf} doesn't exist or there is no such window, -1\n+      is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinnr(1))\n+\n+      <The number can be used with |CTRL-W_w| and \":wincmd w\"\n+      |:wincmd|.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinnr()\n+\n+    ]=],\n+    name = 'bufwinnr',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinnr({buf})',\n+  },\n+  byte2line = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the line number that contains the character at byte\n+      count {byte} in the current buffer.  This includes the\n+      end-of-line character, depending on the 'fileformat' option\n+      for the current buffer.  The first character has byte count\n+      one.\n+      Also see |line2byte()|, |go| and |:goto|.\n+\n+      Returns -1 if the {byte} value is invalid.\n+\n+      Can also be used as a |method|: >\n+      \tGetOffset()->byte2line()\n+\n+    ]=],\n+    name = 'byte2line',\n+    params = { { 'byte', 'any' } },\n+    returns = 'integer',\n+    signature = 'byte2line({byte})',\n+  },\n+  byteidx = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return byte index of the {nr}th character in the String\n+      {expr}.  Use zero for the first character, it then returns\n+      zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {nr}.\n+      Composing characters are not counted separately, their byte\n+      length is added to the preceding base character.  See\n+      |byteidxcomp()| below for counting composing characters\n+      separately.\n+      When {utf16} is present and TRUE, {nr} is used as the UTF-16\n+      index in the String {expr} instead of as the character index.\n+      The UTF-16 index is the index in the string when it is encoded\n+      with 16-bit words.  If the specified UTF-16 index is in the\n+      middle of a character (e.g. in a 4-byte character), then the\n+      byte index of the first byte in the character is returned.\n+      Refer to |string-offset-encoding| for more information.\n+      Example : >\n+      \techo matchstr(str, \".\", byteidx(str, 3))\n+      <will display the fourth character.  Another way to do the\n+      same: >\n+      \tlet s = strpart(str, byteidx(str, 3))\n+      \techo strpart(s, 0, byteidx(s, 1))\n+      <Also see |strgetchar()| and |strcharpart()|.\n+\n+      If there are less than {nr} characters -1 is returned.\n+      If there are exactly {nr} characters the length of the string\n+      in bytes is returned.\n+      See |charidx()| and |utf16idx()| for getting the character and\n+      UTF-16 index respectively from the byte index.\n+      Examples: >\n+      \techo byteidx('a', 2)\treturns 5\n+      \techo byteidx('a', 2, 1)\treturns 1\n+      \techo byteidx('a', 3, 1)\treturns 5\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidx(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidx',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidx({expr}, {nr} [, {utf16}])',\n+  },\n+  byteidxcomp = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like byteidx(), except that a composing character is counted\n+      as a separate character.  Example: >\n+      \tlet s = 'e' .. nr2char(0x301)\n+      \techo byteidx(s, 1)\n+      \techo byteidxcomp(s, 1)\n+      \techo byteidxcomp(s, 2)\n+      <The first and third echo result in 3 ('e' plus composing\n+      character is 3 bytes), the second echo results in 1 ('e' is\n+      one byte).\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidxcomp(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidxcomp',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidxcomp({expr}, {nr} [, {utf16}])',\n+  },\n+  call = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Call function {func} with the items in |List| {arglist} as\n+      arguments.\n+      {func} can either be a |Funcref| or the name of a function.\n+      a:firstline and a:lastline are set to the cursor line.\n+      Returns the return value of the called function.\n+      {dict} is for functions with the \"dict\" attribute.  It will be\n+      used to set the local variable \"self\". |Dictionary-function|\n+\n+      Can also be used as a |method|: >\n+      \tGetFunc()->call([arg, arg], dict)\n+      <\n+    ]=],\n+    name = 'call',\n+    params = { { 'func', 'any' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    returns = 'any',\n+    signature = 'call({func}, {arglist} [, {dict}])',\n+    tags = { 'E699' },\n+  },\n+  ceil = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the smallest integral value greater than or equal to\n+      {expr} as a |Float| (round up).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Examples: >\n+      \techo ceil(1.456)\n+      <\t2.0  >\n+      \techo ceil(-5.456)\n+      <\t-5.0  >\n+      \techo ceil(4.0)\n+      <\t4.0\n+\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->ceil()\n+      <\n+    ]=],\n+    float_func = 'ceil',\n+    name = 'ceil',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'ceil({expr})',\n+  },\n+  chanclose = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Close a channel or a specific stream associated with it.\n+      For a job, {stream} can be one of \"stdin\", \"stdout\",\n+      \"stderr\" or \"rpc\" (closes stdin/stdout for a job started\n+      with `\"rpc\":v:true`) If {stream} is omitted, all streams\n+      are closed. If the channel is a pty, this will then close the\n+      pty master, sending SIGHUP to the job process.\n+      For a socket, there is only one stream, and {stream} should be\n+      omitted.\n+    ]=],\n+    name = 'chanclose',\n+    params = { { 'id', 'any' }, { 'stream', 'any' } },\n+    returns = '0|1',\n+    signature = 'chanclose({id} [, {stream}])',\n+  },\n+  changenr = {\n+    desc = [=[\n+      Return the number of the most recent change.  This is the same\n+      number as what is displayed with |:undolist| and can be used\n+      with the |:undo| command.\n+      When a change was made it is the number of that change.  After\n+      redo it is the number of the redone change.  After undo it is\n+      one less than the number of the undone change.\n+      Returns 0 if the undo list is empty.\n+    ]=],\n+    name = 'changenr',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'changenr()',\n+  },\n+  chansend = {\n+    args = 2,\n+    desc = [=[\n+      Send data to channel {id}. For a job, it writes it to the\n+      stdin of the process. For the stdio channel |channel-stdio|,\n+      it writes to Nvim's stdout.  Returns the number of bytes\n+      written if the write succeeded, 0 otherwise.\n+      See |channel-bytes| for more information.\n+\n+      {data} may be a string, string convertible, |Blob|, or a list.\n+      If {data} is a list, the items will be joined by newlines; any\n+      newlines in an item will be sent as NUL. To send a final\n+      newline, include a final empty string. Example: >\n+      \t:call chansend(id, [\"abc\", \"123\\n456\", \"\"])\n+      <will send \"abc<NL>123<NUL>456<NL>\".\n+\n+      chansend() writes raw data, not RPC messages.  If the channel\n+      was created with `\"rpc\":v:true` then the channel expects RPC\n+      messages, use |rpcnotify()| and |rpcrequest()| instead.\n+\n+    ]=],\n+    name = 'chansend',\n+    params = { { 'id', 'any' }, { 'data', 'any' } },\n+    returns = '0|1',\n+    signature = 'chansend({id}, {data})',\n+  },\n+  char2nr = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Return Number value of the first char in {string}.\n+      Examples: >\n+      \tchar2nr(\" \")\t\treturns 32\n+      \tchar2nr(\"ABC\")\t\treturns 65\n+      \tchar2nr(\"\")\t\treturns 225\n+      \tchar2nr(\"\"[0])\t\treturns 195\n+      \tchar2nr(\"\\<M-x>\")\treturns 128\n+      <Non-ASCII characters are always treated as UTF-8 characters.\n+      {utf8} is ignored, it exists only for backwards-compatibility.\n+      A combining character is a separate character.\n+      |nr2char()| does the opposite.\n+\n+      Returns 0 if {string} is not a |String|.\n+\n+      Can also be used as a |method|: >\n+      \tGetChar()->char2nr()\n+\n+    ]=],\n+    fast = true,\n+    name = 'char2nr',\n+    params = { { 'string', 'string' }, { 'utf8', 'any' } },\n+    returns = '0|1',\n+    signature = 'char2nr({string} [, {utf8}])',\n+  },\n+  charclass = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the character class of the first character in {string}.\n+      The character class is one of:\n+      \t0\tblank\n+      \t1\tpunctuation\n+      \t2\tword character\n+      \t3\temoji\n+      \tother\tspecific Unicode class\n+      The class is used in patterns and word motions.\n+      Returns 0 if {string} is not a |String|.\n+    ]=],\n+    name = 'charclass',\n+    params = { { 'string', 'string' } },\n+    returns = \"0|1|2|3|'other'\",\n+    signature = 'charclass({string})',\n+  },\n+  charcol = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Same as |col()| but returns the character index of the column\n+      position given with {expr} instead of the byte position.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tcharcol('.')\t\treturns 3\n+      \tcol('.')\t\treturns 7\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+    ]=],\n+    name = 'charcol',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'charcol({expr} [, {winid}])',\n+  },\n+  charidx = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the character index of the byte at {idx} in {string}.\n+      The index of the first character is zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {idx}.\n+\n+      When {countcc} is omitted or |FALSE|, then composing characters\n+      are not counted separately, their byte length is added to the\n+      preceding base character.\n+      When {countcc} is |TRUE|, then composing characters are\n+      counted as separate characters.\n+\n+      When {utf16} is present and TRUE, {idx} is used as the UTF-16\n+      index in the String {expr} instead of as the byte index.\n+\n+      Returns -1 if the arguments are invalid or if there are less\n+      than {idx} bytes. If there are exactly {idx} bytes the length\n+      of the string in characters is returned.\n+\n+      An error is given and -1 is returned if the first argument is\n+      not a string, the second argument is not a number or when the\n+      third argument is present and is not zero or one.\n+\n+      See |byteidx()| and |byteidxcomp()| for getting the byte index\n+      from the character index and |utf16idx()| for getting the\n+      UTF-16 index from the character index.\n+      Refer to |string-offset-encoding| for more information.\n+      Examples: >\n+      \techo charidx('abc', 3)\t\treturns 1\n+      \techo charidx('abc', 6, 1)\treturns 4\n+      \techo charidx('abc', 16)\t\treturns -1\n+      \techo charidx('a', 4, 0, 1)\treturns 2\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->charidx(idx)\n+\n+    ]=],\n+    name = 'charidx',\n+    params = {\n+      { 'string', 'string' },\n+      { 'idx', 'integer' },\n+      { 'countcc', 'any' },\n+      { 'utf16', 'any' },\n     },\n-    buffer_number={\n-      args={0, 1}, base=1, func='f_bufnr',\n-      deprecated = { 'Obsolete name for |bufnr()|.' }\n+    returns = 'integer',\n+    signature = 'charidx({string}, {idx} [, {countcc} [, {utf16}]])',\n+  },\n+  chdir = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Change the current working directory to {dir}.  The scope of\n+      the directory change depends on the directory of the current\n+      window:\n+      \t- If the current window has a window-local directory\n+      \t  (|:lcd|), then changes the window local directory.\n+      \t- Otherwise, if the current tabpage has a local\n+      \t  directory (|:tcd|) then changes the tabpage local\n+      \t  directory.\n+      \t- Otherwise, changes the global directory.\n+      {dir} must be a String.\n+      If successful, returns the previous working directory.  Pass\n+      this to another chdir() to restore the directory.\n+      On failure, returns an empty string.\n+\n+      Example: >\n+      \tlet save_dir = chdir(newdir)\n+      \tif save_dir != \"\"\n+      \t   \" ... do some work\n+      \t   call chdir(save_dir)\n+      \tendif\n+\n+      <Can also be used as a |method|: >\n+      \tGetDir()->chdir()\n+      <\n+    ]=],\n+    name = 'chdir',\n+    params = { { 'dir', 'string' } },\n+    returns = 'string',\n+    signature = 'chdir({dir})',\n+  },\n+  cindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the C\n+      indenting rules, as with 'cindent'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+      See |C-indenting|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->cindent()\n+    ]=],\n+    name = 'cindent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'cindent({lnum})',\n+  },\n+  clearmatches = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Clears all matches previously defined for the current window\n+      by |matchadd()| and the |:match| commands.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetWin()->clearmatches()\n+      <\n+    ]=],\n+    name = 'clearmatches',\n+    params = { { 'win', 'any' } },\n+    returns = false,\n+    signature = 'clearmatches([{win}])',\n+  },\n+  col = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the byte index of the column\n+      position given with {expr}.  The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the end of the cursor line (the result is the\n+      \t    number of bytes in the cursor line plus one)\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          v       In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Additionally {expr} can be [lnum, col]: a |List| with the line\n+      and column number. Most useful when the column is \"$\", to get\n+      the last column of a specific line.  When \"lnum\" or \"col\" is\n+      out of range then col() returns zero.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      To get the line number use |line()|.  To get both use\n+      |getpos()|.\n+      For the screen column position use |virtcol()|.  For the\n+      character position use |charcol()|.\n+      Note that only marks in the current file can be used.\n+      Examples: >\n+      \tcol(\".\")\t\tcolumn of cursor\n+      \tcol(\"$\")\t\tlength of cursor line plus one\n+      \tcol(\"'t\")\t\tcolumn of mark t\n+      \tcol(\"'\" .. markname)\tcolumn of mark markname\n+      <The first column is 1.  Returns 0 if {expr} is invalid or when\n+      the window with ID {winid} is not found.\n+      For an uppercase mark the column may actually be in another\n+      buffer.\n+      For the cursor position, when 'virtualedit' is active, the\n+      column is one higher if the cursor is after the end of the\n+      line.  Also, when using a <Cmd> mapping the cursor isn't\n+      moved, this can be used to obtain the column in Insert mode: >\n+      \t:imap <F2> <Cmd>echo col(\".\")..\"\\n\"<CR>\n+\n+      <Can also be used as a |method|: >\n+      \tGetPos()->col()\n+      <\n+\n+    ]=],\n+    name = 'col',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'col({expr} [, {winid}])',\n+  },\n+  complete = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Set the matches for Insert mode completion.\n+      Can only be used in Insert mode.  You need to use a mapping\n+      with CTRL-R = (see |i_CTRL-R|).  It does not work after CTRL-O\n+      or with an expression mapping.\n+      {startcol} is the byte offset in the line where the completed\n+      text start.  The text up to the cursor is the original text\n+      that will be replaced by the matches.  Use col('.') for an\n+      empty string.  \"col('.') - 1\" will replace one character by a\n+      match.\n+      {matches} must be a |List|.  Each |List| item is one match.\n+      See |complete-items| for the kind of items that are possible.\n+      \"longest\" in 'completeopt' is ignored.\n+      Note that the after calling this function you need to avoid\n+      inserting anything that would cause completion to stop.\n+      The match can be selected with CTRL-N and CTRL-P as usual with\n+      Insert mode completion.  The popup menu will appear if\n+      specified, see |ins-completion-menu|.\n+      Example: >\n+      \tinoremap <F5> <C-R>=ListMonths()<CR>\n+\n+      \tfunc ListMonths()\n+      \t  call complete(col('.'), ['January', 'February', 'March',\n+      \t    \\ 'April', 'May', 'June', 'July', 'August', 'September',\n+      \t    \\ 'October', 'November', 'December'])\n+      \t  return ''\n+      \tendfunc\n+      <This isn't very useful, but it shows how it works.  Note that\n+      an empty string is returned to avoid a zero being inserted.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetMatches()->complete(col('.'))\n+\n+    ]=],\n+    name = 'complete',\n+    params = { { 'startcol', 'any' }, { 'matches', 'any' } },\n+    returns = false,\n+    signature = 'complete({startcol}, {matches})',\n+    tags = { 'E785' },\n+  },\n+  complete_add = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add {expr} to the list of matches.  Only to be used by the\n+      function specified with the 'completefunc' option.\n+      Returns 0 for failure (empty string or out of memory),\n+      1 when the match was added, 2 when the match was already in\n+      the list.\n+      See |complete-functions| for an explanation of {expr}.  It is\n+      the same as one item in the list that 'omnifunc' would return.\n+\n+      Can also be used as a |method|: >\n+      \tGetMoreMatches()->complete_add()\n+\n+    ]=],\n+    name = 'complete_add',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1|2',\n+    signature = 'complete_add({expr})',\n+  },\n+  complete_check = {\n+    desc = [=[\n+      Check for a key typed while looking for completion matches.\n+      This is to be used when looking for matches takes some time.\n+      Returns |TRUE| when searching for matches is to be aborted,\n+      zero otherwise.\n+      Only to be used by the function specified with the\n+      'completefunc' option.\n+    ]=],\n+    name = 'complete_check',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'complete_check()',\n+  },\n+  complete_info = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns a |Dictionary| with information about Insert mode\n+      completion.  See |ins-completion|.\n+      The items are:\n+         mode\t\tCurrent completion mode name string.\n+      \t\tSee |complete_info_mode| for the values.\n+         pum_visible\t|TRUE| if popup menu is visible.\n+      \t\tSee |pumvisible()|.\n+         items\tList of completion matches.  Each item is a\n+      \t\tdictionary containing the entries \"word\",\n+      \t\t\"abbr\", \"menu\", \"kind\", \"info\" and \"user_data\".\n+      \t\tSee |complete-items|.\n+         selected\tSelected item index.  First index is zero.\n+      \t\tIndex is -1 if no item is selected (showing\n+      \t\ttyped text only, or the last completion after\n+      \t\tno item is selected when using the <Up> or\n+      \t\t<Down> keys)\n+         inserted\tInserted string. [NOT IMPLEMENTED YET]\n+\n+      \t\t\t\t\t*complete_info_mode*\n+      mode values are:\n+         \"\"\t\t     Not in completion mode\n+         \"keyword\"\t     Keyword completion |i_CTRL-X_CTRL-N|\n+         \"ctrl_x\"\t     Just pressed CTRL-X |i_CTRL-X|\n+         \"scroll\"\t     Scrolling with |i_CTRL-X_CTRL-E| or\n+      \t\t     |i_CTRL-X_CTRL-Y|\n+         \"whole_line\"\t     Whole lines |i_CTRL-X_CTRL-L|\n+         \"files\"\t     File names |i_CTRL-X_CTRL-F|\n+         \"tags\"\t     Tags |i_CTRL-X_CTRL-]|\n+         \"path_defines\"    Definition completion |i_CTRL-X_CTRL-D|\n+         \"path_patterns\"   Include completion |i_CTRL-X_CTRL-I|\n+         \"dictionary\"\t     Dictionary |i_CTRL-X_CTRL-K|\n+         \"thesaurus\"\t     Thesaurus |i_CTRL-X_CTRL-T|\n+         \"cmdline\"\t     Vim Command line |i_CTRL-X_CTRL-V|\n+         \"function\"\t     User defined completion |i_CTRL-X_CTRL-U|\n+         \"omni\"\t     Omni completion |i_CTRL-X_CTRL-O|\n+         \"spell\"\t     Spelling suggestions |i_CTRL-X_s|\n+         \"eval\"\t     |complete()| completion\n+         \"unknown\"\t     Other internal modes\n+\n+      If the optional {what} list argument is supplied, then only\n+      the items listed in {what} are returned.  Unsupported items in\n+      {what} are silently ignored.\n+\n+      To get the position and size of the popup menu, see\n+      |pum_getpos()|. It's also available in |v:event| during the\n+      |CompleteChanged| event.\n+\n+      Returns an empty |Dictionary| on error.\n+\n+      Examples: >\n+      \t\" Get all items\n+      \tcall complete_info()\n+      \t\" Get only 'mode'\n+      \tcall complete_info(['mode'])\n+      \t\" Get only 'mode' and 'pum_visible'\n+      \tcall complete_info(['mode', 'pum_visible'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetItems()->complete_info()\n+      <\n+    ]=],\n+    name = 'complete_info',\n+    params = { { 'what', 'any' } },\n+    returns = 'table',\n+    signature = 'complete_info([{what}])',\n+  },\n+  confirm = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      confirm() offers the user a dialog, from which a choice can be\n+      made.  It returns the number of the choice.  For the first\n+      choice this is 1.\n+\n+      {msg} is displayed in a dialog with {choices} as the\n+      alternatives.  When {choices} is missing or empty, \"&OK\" is\n+      used (and translated).\n+      {msg} is a String, use '\\n' to include a newline.  Only on\n+      some systems the string is wrapped when it doesn't fit.\n+\n+      {choices} is a String, with the individual choices separated\n+      by '\\n', e.g. >\n+      \tconfirm(\"Save changes?\", \"&Yes\\n&No\\n&Cancel\")\n+      <The letter after the '&' is the shortcut key for that choice.\n+      Thus you can type 'c' to select \"Cancel\".  The shortcut does\n+      not need to be the first letter: >\n+      \tconfirm(\"file has been modified\", \"&Save\\nSave &All\")\n+      <For the console, the first letter of each choice is used as\n+      the default shortcut key.  Case is ignored.\n+\n+      The optional {type} String argument gives the type of dialog.\n+      It can be one of these values: \"Error\", \"Question\", \"Info\",\n+      \"Warning\" or \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      The optional {type} argument gives the type of dialog.  This\n+      is only used for the icon of the Win32 GUI.  It can be one of\n+      these values: \"Error\", \"Question\", \"Info\", \"Warning\" or\n+      \"Generic\".  Only the first character is relevant.\n+      When {type} is omitted, \"Generic\" is used.\n+\n+      If the user aborts the dialog by pressing <Esc>, CTRL-C,\n+      or another valid interrupt key, confirm() returns 0.\n+\n+      An example: >\n+         let choice = confirm(\"What do you want?\",\n+      \t\t\t\\ \"&Apples\\n&Oranges\\n&Bananas\", 2)\n+         if choice == 0\n+      \techo \"make up your mind!\"\n+         elseif choice == 3\n+      \techo \"tasteful\"\n+         else\n+      \techo \"I prefer bananas myself.\"\n+         endif\n+      <In a GUI dialog, buttons are used.  The layout of the buttons\n+      depends on the 'v' flag in 'guioptions'.  If it is included,\n+      the buttons are always put vertically.  Otherwise,  confirm()\n+      tries to put the buttons in one horizontal line.  If they\n+      don't fit, a vertical layout is used anyway.  For some systems\n+      the horizontal layout is always used.\n+\n+      Can also be used as a |method|in: >\n+      \tBuildMessage()->confirm(\"&Yes\\n&No\")\n+      <\n+    ]=],\n+    name = 'confirm',\n+    params = { { 'msg', 'any' }, { 'choices', 'any' }, { 'default', 'any' }, { 'type', 'any' } },\n+    returns = 'integer',\n+    signature = 'confirm({msg} [, {choices} [, {default} [, {type}]]])',\n+  },\n+  copy = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a shallow copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  But the items are identical, thus\n+      changing an item changes the contents of both |Lists|.\n+      A |Dictionary| is copied in a similar way as a |List|.\n+      Also see |deepcopy()|.\n+      Can also be used as a |method|: >\n+      \tmylist->copy()\n+    ]=],\n+    name = 'copy',\n+    params = { { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'copy({expr})',\n+  },\n+  cos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the cosine of {expr}, measured in radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cos(100)\n+      <\t0.862319 >\n+      \t:echo cos(-4.01)\n+      <\t-0.646043\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cos()\n+    ]=],\n+    float_func = 'cos',\n+    name = 'cos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cos({expr})',\n+  },\n+  cosh = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the hyperbolic cosine of {expr} as a |Float| in the range\n+      [1, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo cosh(0.5)\n+      <\t1.127626 >\n+      \t:echo cosh(-0.5)\n+      <\t-1.127626\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->cosh()\n+\n+    ]=],\n+    float_func = 'cosh',\n+    name = 'cosh',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'cosh({expr})',\n+  },\n+  count = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Return the number of times an item with value {expr} appears\n+      in |String|, |List| or |Dictionary| {comp}.\n+\n+      If {start} is given then start with the item with this index.\n+      {start} can only be used with a |List|.\n+\n+      When {ic} is given and it's |TRUE| then case is ignored.\n+\n+      When {comp} is a string then the number of not overlapping\n+      occurrences of {expr} is returned. Zero is returned when\n+      {expr} is an empty string.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->count(val)\n+      <\n+    ]=],\n+    name = 'count',\n+    params = { { 'comp', 'any' }, { 'expr', 'any' }, { 'ic', 'any' }, { 'start', 'any' } },\n+    returns = 'integer',\n+    signature = 'count({comp}, {expr} [, {ic} [, {start}]])',\n+  },\n+  ctxget = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |Dictionary| representing the |context| at {index}\n+      from the top of the |context-stack| (see |context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+    ]=],\n+    name = 'ctxget',\n+    params = { { 'index', 'any' } },\n+    returns = 'table',\n+    signature = 'ctxget([{index}])',\n+  },\n+  ctxpop = {\n+    desc = [=[\n+      Pops and restores the |context| at the top of the\n+      |context-stack|.\n+    ]=],\n+    name = 'ctxpop',\n+    params = {},\n+    signature = 'ctxpop()',\n+  },\n+  ctxpush = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Pushes the current editor state (|context|) on the\n+      |context-stack|.\n+      If {types} is given and is a |List| of |String|s, it specifies\n+      which |context-types| to include in the pushed context.\n+      Otherwise, all context types are included.\n+\n+    ]=],\n+    name = 'ctxpush',\n+    params = { { 'types', 'any' } },\n+    signature = 'ctxpush([{types}])',\n+  },\n+  ctxset = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Sets the |context| at {index} from the top of the\n+      |context-stack| to that represented by {context}.\n+      {context} is a Dictionary with context data (|context-dict|).\n+      If {index} is not given, it is assumed to be 0 (i.e.: top).\n+\n+    ]=],\n+    name = 'ctxset',\n+    params = { { 'context', 'any' }, { 'index', 'any' } },\n+    signature = 'ctxset({context} [, {index}])',\n+  },\n+  ctxsize = {\n+    desc = [=[\n+      Returns the size of the |context-stack|.\n+\n+    ]=],\n+    name = 'ctxsize',\n+    params = {},\n+    signature = 'ctxsize()',\n+  },\n+  cursor = {\n+    args = { 1, 3 },\n+    base = 1,\n+    name = 'cursor',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' }, { 'off', 'any' } },\n+    signature = 'cursor({lnum}, {col} [, {off}])',\n+  },\n+  cursor__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Positions the cursor at the column (byte count) {col} in the\n+      line {lnum}.  The first column is one.\n+\n+      When there is one argument {list} this is used as a |List|\n+      with two, three or four item:\n+      \t[{lnum}, {col}]\n+      \t[{lnum}, {col}, {off}]\n+      \t[{lnum}, {col}, {off}, {curswant}]\n+      This is like the return value of |getpos()| or |getcurpos()|,\n+      but without the first item.\n+\n+      To position the cursor using {col} as the character count, use\n+      |setcursorcharpos()|.\n+\n+      Does not change the jumplist.\n+      {lnum} is used like with |getline()|, except that if {lnum} is\n+      zero, the cursor will stay in the current line.\n+      If {lnum} is greater than the number of lines in the buffer,\n+      the cursor will be positioned at the last line in the buffer.\n+      If {col} is greater than the number of bytes in the line,\n+      the cursor will be positioned at the last character in the\n+      line.\n+      If {col} is zero, the cursor will stay in the current column.\n+      If {curswant} is given it is used to set the preferred column\n+      for vertical movement.  Otherwise {col} is used.\n+\n+      When 'virtualedit' is used {off} specifies the offset in\n+      screen columns from the start of the character.  E.g., a\n+      position within a <Tab> or after the last character.\n+      Returns 0 when the position could be set, -1 otherwise.\n+\n+      Can also be used as a |method|: >\n+      \tGetCursorPos()->cursor()\n+\n+    ]=],\n+    name = 'cursor',\n+    params = { { 'list', 'any' } },\n+    signature = 'cursor({list})',\n+  },\n+  debugbreak = {\n+    args = { 1, 1 },\n+    base = 1,\n+    desc = [=[\n+      Specifically used to interrupt a program being debugged.  It\n+      will cause process {pid} to get a SIGTRAP.  Behavior for other\n+      processes is undefined. See |terminal-debug|.\n+      (Sends a SIGINT to a process {pid} other than MS-Windows)\n+\n+      Returns |TRUE| if successfully interrupted the program.\n+      Otherwise returns |FALSE|.\n+\n+      Can also be used as a |method|: >\n+      \tGetPid()->debugbreak()\n+\n+    ]=],\n+    name = 'debugbreak',\n+    params = { { 'pid', 'any' } },\n+    signature = 'debugbreak({pid})',\n+  },\n+  deepcopy = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Make a copy of {expr}.  For Numbers and Strings this isn't\n+      different from using {expr} directly.\n+      When {expr} is a |List| a full copy is created.  This means\n+      that the original |List| can be changed without changing the\n+      copy, and vice versa.  When an item is a |List|, a copy for it\n+      is made, recursively.  Thus changing an item in the copy does\n+      not change the contents of the original |List|.\n+\n+      When {noref} is omitted or zero a contained |List| or\n+      |Dictionary| is only copied once.  All references point to\n+      this single copy.  With {noref} set to 1 every occurrence of a\n+      |List| or |Dictionary| results in a new copy.  This also means\n+      that a cyclic reference causes deepcopy() to fail.\n+      \t\t\t\t\t\t*E724*\n+      Nesting is possible up to 100 levels.  When there is an item\n+      that refers back to a higher level making a deep copy with\n+      {noref} set to 1 will fail.\n+      Also see |copy()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->deepcopy()\n+\n+    ]=],\n+    name = 'deepcopy',\n+    params = { { 'expr', 'any' }, { 'noref', 'any' } },\n+    signature = 'deepcopy({expr} [, {noref}])',\n+  },\n+  delete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {flags} or with {flags} empty: Deletes the file by the\n+      name {fname}.\n+\n+      This also works when {fname} is a symbolic link.  The symbolic\n+      link itself is deleted, not what it points to.\n+\n+      When {flags} is \"d\": Deletes the directory by the name\n+      {fname}.  This fails when directory {fname} is not empty.\n+\n+      When {flags} is \"rf\": Deletes the directory by the name\n+      {fname} and everything in it, recursively.  BE CAREFUL!\n+      Note: on MS-Windows it is not possible to delete a directory\n+      that is being used.\n+\n+      The result is a Number, which is 0/false if the delete\n+      operation was successful and -1/true when the deletion failed\n+      or partly failed.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->delete()\n+\n+    ]=],\n+    name = 'delete',\n+    params = { { 'fname', 'integer' }, { 'flags', 'string' } },\n+    returns = 'integer',\n+    signature = 'delete({fname} [, {flags}])',\n+  },\n+  deletebufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Delete lines {first} to {last} (inclusive) from buffer {buf}.\n+      If {last} is omitted then delete line {first} only.\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      {first} and {last} are used like with |getline()|. Note that\n+      when using |line()| this refers to the current buffer. Use \"$\"\n+      to refer to the last line in buffer {buf}.\n+\n+      Can also be used as a |method|: >\n+      \tGetBuffer()->deletebufline(1)\n+      <\n+    ]=],\n+    name = 'deletebufline',\n+    params = { { 'buf', 'any' }, { 'first', 'any' }, { 'last', 'any' } },\n+    signature = 'deletebufline({buf}, {first} [, {last}])',\n+  },\n+  dictwatcheradd = {\n+    args = 3,\n+    desc = [=[\n+      Adds a watcher to a dictionary. A dictionary watcher is\n+      identified by three components:\n+\n+      - A dictionary({dict});\n+      - A key pattern({pattern}).\n+      - A function({callback}).\n+\n+      After this is called, every change on {dict} and on keys\n+      matching {pattern} will result in {callback} being invoked.\n+\n+      For example, to watch all global variables: >\n+      \tsilent! call dictwatcherdel(g:, '*', 'OnDictChanged')\n+      \tfunction! OnDictChanged(d,k,z)\n+      \t  echomsg string(a:k) string(a:z)\n+      \tendfunction\n+      \tcall dictwatcheradd(g:, '*', 'OnDictChanged')\n+      <\n+      For now {pattern} only accepts very simple patterns that can\n+      contain a \"*\" at the end of the string, in which case it will\n+      match every key that begins with the substring before the \"*\".\n+      That means if \"*\" is not the last character of {pattern}, only\n+      keys that are exactly equal as {pattern} will be matched.\n+\n+      The {callback} receives three arguments:\n+\n+      - The dictionary being watched.\n+      - The key which changed.\n+      - A dictionary containing the new and old values for the key.\n+\n+      The type of change can be determined by examining the keys\n+      present on the third argument:\n+\n+      - If contains both `old` and `new`, the key was updated.\n+      - If it contains only `new`, the key was added.\n+      - If it contains only `old`, the key was deleted.\n+\n+      This function can be used by plugins to implement options with\n+      validation and parsing logic.\n+\n+    ]=],\n+    name = 'dictwatcheradd',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcheradd({dict}, {pattern}, {callback})',\n+  },\n+  dictwatcherdel = {\n+    args = 3,\n+    desc = [=[\n+      Removes a watcher added  with |dictwatcheradd()|. All three\n+      arguments must match the ones passed to |dictwatcheradd()| in\n+      order for the watcher to be successfully deleted.\n+    ]=],\n+    name = 'dictwatcherdel',\n+    params = { { 'dict', 'any' }, { 'pattern', 'any' }, { 'callback', 'any' } },\n+    signature = 'dictwatcherdel({dict}, {pattern}, {callback})',\n+  },\n+  did_filetype = {\n+    desc = [=[\n+      Returns |TRUE| when autocommands are being executed and the\n+      FileType event has been triggered at least once.  Can be used\n+      to avoid triggering the FileType event again in the scripts\n+      that detect the file type. |FileType|\n+      Returns |FALSE| when `:setf FALLBACK` was used.\n+      When editing another file, the counter is reset, thus this\n+      really checks if the FileType event has been triggered for the\n+      current buffer.  This allows an autocommand that starts\n+      editing another buffer to set 'filetype' and load a syntax\n+      file.\n+\n+    ]=],\n+    fast = true,\n+    name = 'did_filetype',\n+    params = {},\n+    signature = 'did_filetype()',\n+  },\n+  diff_filler = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the number of filler lines above line {lnum}.\n+      These are the lines that were inserted at this point in\n+      another diff'ed window.  These filler lines are shown in the\n+      display but don't exist in the buffer.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Returns 0 if the current window is not in diff mode.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_filler()\n+\n+    ]=],\n+    name = 'diff_filler',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'diff_filler({lnum})',\n+  },\n+  diff_hlID = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Returns the highlight ID for diff mode at line {lnum} column\n+      {col} (byte index).  When the current line does not have a\n+      diff change zero is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      {col} is 1 for the leftmost column, {lnum} is 1 for the first\n+      line.\n+      The highlight ID can be used with |synIDattr()| to obtain\n+      syntax information about the highlighting.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->diff_hlID(col)\n+      <\n+\n+    ]=],\n+    name = 'diff_hlID',\n+    params = { { 'lnum', 'integer' }, { 'col', 'integer' } },\n+    signature = 'diff_hlID({lnum}, {col})',\n+  },\n+  digraph_get = {\n+    args = 1,\n+    base = 1,\n+    tags = { 'E1214' },\n+    desc = [=[\n+      Return the digraph of {chars}.  This should be a string with\n+      exactly two characters.  If {chars} are not just two\n+      characters, or the digraph of {chars} does not exist, an error\n+      is given and an empty string is returned.\n+\n+      Also see |digraph_getlist()|.\n+\n+      Examples: >\n+      \" Get a built-in digraph\n+      :echo digraph_get('00')\t\t\" Returns ''\n+\n+      \" Get a user-defined digraph\n+      :call digraph_set('aa', '')\n+      :echo digraph_get('aa')\t\t\" Returns ''\n+      <\n+      Can also be used as a |method|: >\n+      \tGetChars()->digraph_get()\n+      <\n+\n+    ]=],\n+    name = 'digraph_get',\n+    params = { { 'chars', 'any' } },\n+    signature = 'digraph_get({chars})',\n+  },\n+  digraph_getlist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of digraphs.  If the {listall} argument is given\n+      and it is TRUE, return all digraphs, including the default\n+      digraphs.  Otherwise, return only user-defined digraphs.\n+\n+      Also see |digraph_get()|.\n+\n+      Examples: >\n+      \" Get user-defined digraphs\n+      :echo digraph_getlist()\n+\n+      \" Get all the digraphs, including default digraphs\n+      :echo digraph_getlist(1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetNumber()->digraph_getlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_getlist',\n+    params = { { 'listall', 'any' } },\n+    signature = 'digraph_getlist([{listall}])',\n+  },\n+  digraph_set = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Add digraph {chars} to the list.  {chars} must be a string\n+      with two characters.  {digraph} is a string with one UTF-8\n+      encoded character.  *E1215*\n+      Be careful, composing characters are NOT ignored.  This\n+      function is similar to |:digraphs| command, but useful to add\n+      digraphs start with a white space.\n+\n+      The function result is v:true if |digraph| is registered.  If\n+      this fails an error message is given and v:false is returned.\n+\n+      If you want to define multiple digraphs at once, you can use\n+      |digraph_setlist()|.\n+\n+      Example: >\n+      \tcall digraph_set('  ', '')\n+      <\n+      Can be used as a |method|: >\n+      \tGetString()->digraph_set('')\n+      <\n+\n+    ]=],\n+    name = 'digraph_set',\n+    params = { { 'chars', 'any' }, { 'digraph', 'any' } },\n+    signature = 'digraph_set({chars}, {digraph})',\n+  },\n+  digraph_setlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Similar to |digraph_set()| but this function can add multiple\n+      digraphs at once.  {digraphlist} is a list composed of lists,\n+      where each list contains two strings with {chars} and\n+      {digraph} as in |digraph_set()|. *E1216*\n+      Example: >\n+          call digraph_setlist([['aa', ''], ['ii', '']])\n+      <\n+      It is similar to the following: >\n+          for [chars, digraph] in [['aa', ''], ['ii', '']]\n+      \t  call digraph_set(chars, digraph)\n+          endfor\n+      <Except that the function returns after the first error,\n+      following digraphs will not be added.\n+\n+      Can be used as a |method|: >\n+          GetList()->digraph_setlist()\n+      <\n+\n+    ]=],\n+    name = 'digraph_setlist',\n+    params = { { 'digraphlist', 'any' } },\n+    signature = 'digraph_setlist({digraphlist})',\n+  },\n+  empty = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the Number 1 if {expr} is empty, zero otherwise.\n+      - A |List| or |Dictionary| is empty when it does not have any\n+        items.\n+      - A |String| is empty when its length is zero.\n+      - A |Number| and |Float| are empty when their value is zero.\n+      - |v:false| and |v:null| are empty, |v:true| is not.\n+      - A |Blob| is empty when its length is zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->empty()\n+\n+    ]=],\n+    name = 'empty',\n+    params = { { 'expr', 'any' } },\n+    signature = 'empty({expr})',\n+  },\n+  environ = {\n+    desc = [=[\n+      Return all of environment variables as dictionary. You can\n+      check if an environment variable exists like this: >\n+      \t:echo has_key(environ(), 'HOME')\n+      <Note that the variable name may be CamelCase; to ignore case\n+      use this: >\n+      \t:echo index(keys(environ()), 'HOME', 0, 1) != -1\n+\n+    ]=],\n+    fast = true,\n+    name = 'environ',\n+    params = {},\n+    signature = 'environ()',\n+  },\n+  escape = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Escape the characters in {chars} that occur in {string} with a\n+      backslash.  Example: >\n+      \t:echo escape('c:\\program files\\vim', ' \\')\n+      <results in: >\n+      \tc:\\\\program\\ files\\\\vim\n+      <Also see |shellescape()| and |fnameescape()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->escape(' \\')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'escape',\n+    params = { { 'string', 'string' }, { 'chars', 'any' } },\n+    signature = 'escape({string}, {chars})',\n+  },\n+  eval = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Evaluate {string} and return the result.  Especially useful to\n+      turn the result of |string()| back into the original value.\n+      This works for Numbers, Floats, Strings, Blobs and composites\n+      of them.  Also works for |Funcref|s that refer to existing\n+      functions.\n+\n+      Can also be used as a |method|: >\n+      \targv->join()->eval()\n+\n+    ]=],\n+    name = 'eval',\n+    params = { { 'string', 'string' } },\n+    signature = 'eval({string})',\n+  },\n+  eventhandler = {\n+    desc = [=[\n+      Returns 1 when inside an event handler.  That is that Vim got\n+      interrupted while waiting for the user to type a character,\n+      e.g., when dropping a file on Vim.  This means interactive\n+      commands cannot be used.  Otherwise zero is returned.\n+\n+    ]=],\n+    name = 'eventhandler',\n+    params = {},\n+    signature = 'eventhandler()',\n+  },\n+  executable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      This function checks if an executable with the name {expr}\n+      exists.  {expr} must be the name of the program without any\n+      arguments.\n+      executable() uses the value of $PATH and/or the normal\n+      searchpath for programs.\t\t*PATHEXT*\n+      On MS-Windows the \".exe\", \".bat\", etc. can optionally be\n+      included.  Then the extensions in $PATHEXT are tried.  Thus if\n+      \"foo.exe\" does not exist, \"foo.exe.bat\" can be found.  If\n+      $PATHEXT is not set then \".exe;.com;.bat;.cmd\" is used.  A dot\n+      by itself can be used in $PATHEXT to try using the name\n+      without an extension.  When 'shell' looks like a Unix shell,\n+      then the name is also tried without adding an extension.\n+      On MS-Windows it only checks if the file exists and is not a\n+      directory, not if it's really executable.\n+      On Windows an executable in the same directory as Vim is\n+      always found (it is added to $PATH at |startup|).\n+      The result is a Number:\n+      \t1\texists\n+      \t0\tdoes not exist\n+      \t-1\tnot implemented on this system\n+      |exepath()| can be used to get the full path of an executable.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->executable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'executable',\n+    params = { { 'expr', 'any' } },\n+    signature = 'executable({expr})',\n+  },\n+  execute = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Execute {command} and capture its output.\n+      If {command} is a |String|, returns {command} output.\n+      If {command} is a |List|, returns concatenated outputs.\n+      Line continuations in {command} are not recognized.\n+      Examples: >\n+      \techo execute('echon \"foo\"')\n+      <\tfoo >\n+      \techo execute(['echon \"foo\"', 'echon \"bar\"'])\n+      <\tfoobar\n+\n+      The optional {silent} argument can have these values:\n+      \t\"\"\t\tno `:silent` used\n+      \t\"silent\"\t`:silent` used\n+      \t\"silent!\"\t`:silent!` used\n+      The default is \"silent\".  Note that with \"silent!\", unlike\n+      `:redir`, error messages are dropped.\n+\n+      To get a list of lines use `split()` on the result: >\n+      \texecute('args')->split(\"\\n\")\n+\n+      <This function is not available in the |sandbox|.\n+      Note: If nested, an outer execute() will not observe output of\n+      the inner calls.\n+      Note: Text attributes (highlights) are not captured.\n+      To execute a command in another window than the current one\n+      use `win_execute()`.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->execute()\n+\n+    ]=],\n+    name = 'execute',\n+    params = { { 'command', 'any' }, { 'silent', 'boolean' } },\n+    signature = 'execute({command} [, {silent}])',\n+  },\n+  exepath = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the full path of {expr} if it is an executable and\n+      given as a (partial or full) path or is found in $PATH.\n+      Returns empty string otherwise.\n+      If {expr} starts with \"./\" the |current-directory| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetCommand()->exepath()\n+      <\n+    ]=],\n+    name = 'exepath',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exepath({expr})',\n+  },\n+  exists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if {expr} is\n+      defined, zero otherwise.\n+\n+      For checking for a supported feature use |has()|.\n+      For checking if a file exists use |filereadable()|.\n+\n+      The {expr} argument is a string, which contains one of these:\n+      \tvarname\t\tinternal variable (see\n+      \tdict.key\t|internal-variables|).  Also works\n+      \tlist[i]\t\tfor |curly-braces-names|, |Dictionary|\n+      \t\t\tentries, |List| items, etc.\n+      \t\t\tBeware that evaluating an index may\n+      \t\t\tcause an error message for an invalid\n+      \t\t\texpression.  E.g.: >\n+      \t\t\t   :let l = [1, 2, 3]\n+      \t\t\t   :echo exists(\"l[5]\")\n+      <\t\t\t   0 >\n+      \t\t\t   :echo exists(\"l[xx]\")\n+      <\t\t\t   E121: Undefined variable: xx\n+      \t\t\t   0\n+      \t&option-name\tVim option (only checks if it exists,\n+      \t\t\tnot if it really works)\n+      \t+option-name\tVim option that works.\n+      \t$ENVNAME\tenvironment variable (could also be\n+      \t\t\tdone by comparing with an empty\n+      \t\t\tstring)\n+      \t`*funcname`\tbuilt-in function (see |functions|)\n+      \t\t\tor user defined function (see\n+      \t\t\t|user-function|). Also works for a\n+      \t\t\tvariable that is a Funcref.\n+      \t:cmdname\tEx command: built-in command, user\n+      \t\t\tcommand or command modifier |:command|.\n+      \t\t\tReturns:\n+      \t\t\t1  for match with start of a command\n+      \t\t\t2  full match with a command\n+      \t\t\t3  matches several user commands\n+      \t\t\tTo check for a supported command\n+      \t\t\talways check the return value to be 2.\n+      \t:2match\t\tThe |:2match| command.\n+      \t:3match\t\tThe |:3match| command (but you\n+      \t\t\tprobably should not use it, it is\n+      \t\t\treserved for internal usage)\n+      \t#event\t\tautocommand defined for this event\n+      \t#event#pattern\tautocommand defined for this event and\n+      \t\t\tpattern (the pattern is taken\n+      \t\t\tliterally and compared to the\n+      \t\t\tautocommand patterns character by\n+      \t\t\tcharacter)\n+      \t#group\t\tautocommand group exists\n+      \t#group#event\tautocommand defined for this group and\n+      \t\t\tevent.\n+      \t#group#event#pattern\n+      \t\t\tautocommand defined for this group,\n+      \t\t\tevent and pattern.\n+      \t##event\t\tautocommand for this event is\n+      \t\t\tsupported.\n+\n+      Examples: >\n+      \texists(\"&mouse\")\n+      \texists(\"$HOSTNAME\")\n+      \texists(\"*strftime\")\n+      \texists(\"*s:MyFunc\")\n+      \texists(\"*MyFunc\")\n+      \texists(\"bufcount\")\n+      \texists(\":Make\")\n+      \texists(\"#CursorHold\")\n+      \texists(\"#BufReadPre#*.gz\")\n+      \texists(\"#filetypeindent\")\n+      \texists(\"#filetypeindent#FileType\")\n+      \texists(\"#filetypeindent#FileType#*\")\n+      \texists(\"##ColorScheme\")\n+      <There must be no space between the symbol (&/$/*/#) and the\n+      name.\n+      There must be no extra characters after the name, although in\n+      a few cases this is ignored.  That may become stricter in the\n+      future, thus don't count on it!\n+      Working example: >\n+      \texists(\":make\")\n+      <NOT working example: >\n+      \texists(\":make install\")\n+\n+      <Note that the argument must be a string, not the name of the\n+      variable itself.  For example: >\n+      \texists(bufcount)\n+      <This doesn't check for existence of the \"bufcount\" variable,\n+      but gets the value of \"bufcount\", and checks if that exists.\n+\n+      Can also be used as a |method|: >\n+      \tVarname()->exists()\n+\n+    ]=],\n+    name = 'exists',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'exists({expr})',\n+  },\n+  exp = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the exponential of {expr} as a |Float| in the range\n+      [0, inf].\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo exp(2)\n+      <\t7.389056 >\n+      \t:echo exp(-1)\n+      <\t0.367879\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->exp()\n+\n+    ]=],\n+    float_func = 'exp',\n+    name = 'exp',\n+    params = { { 'expr', 'any' } },\n+    signature = 'exp({expr})',\n+  },\n+  expand = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Expand wildcards and the following special keywords in\n+      {string}.  'wildignorecase' applies.\n+\n+      If {list} is given and it is |TRUE|, a List will be returned.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty string.  A name\n+      for a non-existing file is not included, unless {string} does\n+      not start with '%', '#' or '<', see below.\n+\n+      When {string} starts with '%', '#' or '<', the expansion is\n+      done like for the |cmdline-special| variables with their\n+      associated modifiers.  Here is a short overview:\n+\n+      \t%\t\tcurrent file name\n+      \t#\t\talternate file name\n+      \t#n\t\talternate file name n\n+      \t<cfile>\t\tfile name under the cursor\n+      \t<afile>\t\tautocmd file name\n+      \t<abuf>\t\tautocmd buffer number (as a String!)\n+      \t<amatch>\tautocmd matched name\n+      \t<cexpr>\t\tC expression under the cursor\n+      \t<sfile>\t\tsourced script file or function name\n+      \t<slnum>\t\tsourced script line number or function\n+      \t\t\tline number\n+      \t<sflnum>\tscript file line number, also when in\n+      \t\t\ta function\n+      \t<SID>\t\t\"<SNR>123_\"  where \"123\" is the\n+      \t\t\tcurrent script ID  |<SID>|\n+      \t<script>\tsourced script file, or script file\n+      \t\t\twhere the current function was defined\n+      \t<stack>\t\tcall stack\n+      \t<cword>\t\tword under the cursor\n+      \t<cWORD>\t\tWORD under the cursor\n+      \t<client>\tthe {clientid} of the last received\n+      \t\t\tmessage\n+      Modifiers:\n+      \t:p\t\texpand to full path\n+      \t:h\t\thead (last path component removed)\n+      \t:t\t\ttail (last path component only)\n+      \t:r\t\troot (one extension removed)\n+      \t:e\t\textension only\n+\n+      Example: >\n+      \t:let &tags = expand(\"%:p:h\") .. \"/tags\"\n+      <Note that when expanding a string that starts with '%', '#' or\n+      '<', any following text is ignored.  This does NOT work: >\n+      \t:let doesntwork = expand(\"%:h.bak\")\n+      <Use this: >\n+      \t:let doeswork = expand(\"%:h\") .. \".bak\"\n+      <Also note that expanding \"<cfile>\" and others only returns the\n+      referenced file name without further expansion.  If \"<cfile>\"\n+      is \"~/.cshrc\", you need to do another expand() to have the\n+      \"~/\" expanded into the path of the home directory: >\n+      \t:echo expand(expand(\"<cfile>\"))\n+      <\n+      There cannot be white space between the variables and the\n+      following modifier.  The |fnamemodify()| function can be used\n+      to modify normal file names.\n+\n+      When using '%' or '#', and the current or alternate file name\n+      is not defined, an empty string is used.  Using \"%:p\" in a\n+      buffer with no name, results in the current directory, with a\n+      '/' added.\n+      When 'verbose' is set then expanding '%', '#' and <> items\n+      will result in an error message if the argument cannot be\n+      expanded.\n+\n+      When {string} does not start with '%', '#' or '<', it is\n+      expanded like a file name is expanded on the command line.\n+      'suffixes' and 'wildignore' are used, unless the optional\n+      {nosuf} argument is given and it is |TRUE|.\n+      Names for non-existing files are included.  The \"**\" item can\n+      be used to search in a directory tree.  For example, to find\n+      all \"README\" files in the current directory and below: >\n+      \t:echo expand(\"**/README\")\n+      <\n+      expand() can also be used to expand variables and environment\n+      variables that are only known in a shell.  But this can be\n+      slow, because a shell may be used to do the expansion.  See\n+      |expr-env-expand|.\n+      The expanded variable is still handled like a list of file\n+      names.  When an environment variable cannot be expanded, it is\n+      left unchanged.  Thus \":echo expand('$FOOBAR')\" results in\n+      \"$FOOBAR\".\n+\n+      See |glob()| for finding existing files.  See |system()| for\n+      getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetpattern()->expand()\n+\n+    ]=],\n+    name = 'expand',\n+    params = { { 'string', 'string' }, { 'nosuf', 'boolean' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'expand({string} [, {nosuf} [, {list}]])',\n+  },\n+  expandcmd = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Expand special items in String {string} like what is done for\n+      an Ex command such as `:edit`.  This expands special keywords,\n+      like with |expand()|, and environment variables, anywhere in\n+      {string}.  \"~user\" and \"~/path\" are only expanded at the\n+      start.\n+\n+      The following items are supported in the {options} Dict\n+      argument:\n+          errmsg\tIf set to TRUE, error messages are displayed\n+      \t\tif an error is encountered during expansion.\n+      \t\tBy default, error messages are not displayed.\n+\n+      Returns the expanded string.  If an error is encountered\n+      during expansion, the unmodified {string} is returned.\n+\n+      Example: >\n+      \t:echo expandcmd('make %<.o')\n+      \tmake /path/runtime/doc/builtin.o\n+      \t:echo expandcmd('make %<.o', {'errmsg': v:true})\n+      <\n+      Can also be used as a |method|: >\n+      \tGetCommand()->expandcmd()\n+      <\n+    ]=],\n+    name = 'expandcmd',\n+    params = { { 'string', 'string' }, { 'options', 'table' } },\n+    signature = 'expandcmd({string} [, {options}])',\n+  },\n+  extend = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      {expr1} and {expr2} must be both |Lists| or both\n+      |Dictionaries|.\n+\n+      If they are |Lists|: Append {expr2} to {expr1}.\n+      If {expr3} is given insert the items of {expr2} before the\n+      item with index {expr3} in {expr1}.  When {expr3} is zero\n+      insert before the first item.  When {expr3} is equal to\n+      len({expr1}) then {expr2} is appended.\n+      Examples: >\n+      \t:echo sort(extend(mylist, [7, 5]))\n+      \t:call extend(mylist, [2, 3], 1)\n+      <When {expr1} is the same List as {expr2} then the number of\n+      items copied is equal to the original length of the List.\n+      E.g., when {expr3} is 1 you get N new copies of the first item\n+      (where N is the original length of the List).\n+      Use |add()| to concatenate one item to a list.  To concatenate\n+      two lists into a new list use the + operator: >\n+      \t:let newlist = [1, 2, 3] + [4, 5]\n+      <\n+      If they are |Dictionaries|:\n+      Add all entries from {expr2} to {expr1}.\n+      If a key exists in both {expr1} and {expr2} then {expr3} is\n+      used to decide what to do:\n+      {expr3} = \"keep\": keep the value of {expr1}\n+      {expr3} = \"force\": use the value of {expr2}\n+      {expr3} = \"error\": give an error message\t\t*E737*\n+      When {expr3} is omitted then \"force\" is assumed.\n+\n+      {expr1} is changed when {expr2} is not empty.  If necessary\n+      make a copy of {expr1} first.\n+      {expr2} remains unchanged.\n+      When {expr1} is locked and {expr2} is not empty the operation\n+      fails.\n+      Returns {expr1}.  Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->extend(otherlist)\n+      <\n+    ]=],\n+    name = 'extend',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extend({expr1}, {expr2} [, {expr3}])',\n+  },\n+  extendnew = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |extend()| but instead of adding items to {expr1} a new\n+      List or Dictionary is created and returned.  {expr1} remains\n+      unchanged.\n+    ]=],\n+    name = 'extendnew',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' }, { 'expr3', 'any' } },\n+    signature = 'extendnew({expr1}, {expr2} [, {expr3}])',\n+  },\n+  feedkeys = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Characters in {string} are queued for processing as if they\n+      come from a mapping or were typed by the user.\n+\n+      By default the string is added to the end of the typeahead\n+      buffer, thus if a mapping is still being executed the\n+      characters come after them.  Use the 'i' flag to insert before\n+      other characters, they will be executed next, before any\n+      characters from a mapping.\n+\n+      The function does not wait for processing of keys contained in\n+      {string}.\n+\n+      To include special keys into {string}, use double-quotes\n+      and \"\\...\" notation |expr-quote|. For example,\n+      feedkeys(\"\\<CR>\") simulates pressing of the <Enter> key. But\n+      feedkeys('\\<CR>') pushes 5 characters.\n+      The |<Ignore>| keycode may be used to exit the\n+      wait-for-character without doing anything.\n+\n+      {mode} is a String, which can contain these character flags:\n+      'm'\tRemap keys. This is default.  If {mode} is absent,\n+      \tkeys are remapped.\n+      'n'\tDo not remap keys.\n+      't'\tHandle keys as if typed; otherwise they are handled as\n+      \tif coming from a mapping.  This matters for undo,\n+      \topening folds, etc.\n+      'i'\tInsert the string instead of appending (see above).\n+      'x'\tExecute commands until typeahead is empty.  This is\n+      \tsimilar to using \":normal!\".  You can call feedkeys()\n+      \tseveral times without 'x' and then one time with 'x'\n+      \t(possibly with an empty {string}) to execute all the\n+      \ttypeahead.  Note that when Vim ends in Insert mode it\n+      \twill behave as if <Esc> is typed, to avoid getting\n+      \tstuck, waiting for a character to be typed before the\n+      \tscript continues.\n+      \tNote that if you manage to call feedkeys() while\n+      \texecuting commands, thus calling it recursively, then\n+      \tall typeahead will be consumed by the last call.\n+      '!'\tWhen used with 'x' will not end Insert mode. Can be\n+      \tused in a test when a timer is set to exit Insert mode\n+      \ta little later.  Useful for testing CursorHoldI.\n+\n+      Return value is always 0.\n+\n+      Can also be used as a |method|: >\n+      \tGetInput()->feedkeys()\n+\n+    ]=],\n+    name = 'feedkeys',\n+    params = { { 'string', 'string' }, { 'mode', 'string' } },\n+    signature = 'feedkeys({string} [, {mode}])',\n+  },\n+  file_readable = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |filereadable()|.\n+    ]=],\n+    func = 'f_filereadable',\n+    name = 'file_readable',\n+    params = { { 'file', 'string' } },\n+    signature = 'file_readable({file})',\n+  },\n+  filereadable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a file with the\n+      name {file} exists, and can be read.  If {file} doesn't exist,\n+      or is a directory, the result is |FALSE|.  {file} is any\n+      expression, which is used as a String.\n+      If you don't care about the file being readable you can use\n+      |glob()|.\n+      {file} is used as-is, you may want to expand wildcards first: >\n+      \techo filereadable('~/.vimrc')\n+      \t0\n+      \techo filereadable(expand('~/.vimrc'))\n+      \t1\n+\n+      <Can also be used as a |method|: >\n+      \tGetName()->filereadable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filereadable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filereadable({file})',\n+  },\n+  filewritable = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when a file with the\n+      name {file} exists, and can be written.  If {file} doesn't\n+      exist, or is not writable, the result is 0.  If {file} is a\n+      directory, and we can write to it, the result is 2.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->filewritable()\n+\n+    ]=],\n+    fast = true,\n+    name = 'filewritable',\n+    params = { { 'file', 'string' } },\n+    returns = '0|1',\n+    signature = 'filewritable({file})',\n+  },\n+  filter = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob|, or a |Dictionary|.\n+      For each item in {expr1} evaluate {expr2} and when the result\n+      is zero remove the item from the |List| or |Dictionary|. For a\n+      |Blob| each byte is removed.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+\n+      Examples: >\n+      \tcall filter(mylist, 'v:val !~ \"OLD\"')\n+      <Removes the items where \"OLD\" appears. >\n+      \tcall filter(mydict, 'v:key >= 8')\n+      <Removes the items with a key below 8. >\n+      \tcall filter(var, 0)\n+      <Removes all the items, thus clears the |List| or |Dictionary|.\n+\n+      Note that {expr2} is the result of expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.\n+\n+      If {expr2} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item should be kept.\n+      Example that keeps the odd items of a list: >\n+      \tfunc Odd(idx, val)\n+      \t  return a:idx % 2 == 1\n+      \tendfunc\n+      \tcall filter(mylist, function('Odd'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall filter(myList, {idx, val -> idx * val <= 42})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall filter(myList, {idx -> idx % 2 == 1})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let l = filter(copy(mylist), 'v:val =~ \"KEEP\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->filter(expr2)\n+\n+    ]=],\n+    name = 'filter',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'filter({expr1}, {expr2})',\n+  },\n+  finddir = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Find directory {name} in {path}.  Supports both downwards and\n+      upwards recursive directory searches.  See |file-searching|\n+      for the syntax of {path}.\n+\n+      Returns the path of the first found match.  When the found\n+      directory is below the current directory a relative path is\n+      returned.  Otherwise a full path is returned.\n+      If {path} is omitted or empty then 'path' is used.\n+\n+      If the optional {count} is given, find {count}'s occurrence of\n+      {name} in {path} instead of the first one.\n+      When {count} is negative return all the matches in a |List|.\n+\n+      Returns an empty string if the directory is not found.\n+\n+      This is quite similar to the ex-command `:find`.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->finddir()\n+\n+    ]=],\n+    name = 'finddir',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'finddir({name} [, {path} [, {count}]])',\n+  },\n+  findfile = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |finddir()|, but find a file instead of a directory.\n+      Uses 'suffixesadd'.\n+      Example: >\n+      \t:echo findfile(\"tags.vim\", \".;\")\n+      <Searches from the directory of the current file upwards until\n+      it finds the file \"tags.vim\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->findfile()\n+\n+    ]=],\n+    name = 'findfile',\n+    params = { { 'name', 'string' }, { 'path', 'string' }, { 'count', 'any' } },\n+    signature = 'findfile({name} [, {path} [, {count}]])',\n+  },\n+  flatten = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Flatten {list} up to {maxdepth} levels.  Without {maxdepth}\n+      the result is a |List| without nesting, as if {maxdepth} is\n+      a very large number.\n+      The {list} is changed in place, use |flattennew()| if you do\n+      not want that.\n+      \t\t\t\t\t\t*E900*\n+      {maxdepth} means how deep in nested lists changes are made.\n+      {list} is not modified when {maxdepth} is 0.\n+      {maxdepth} must be positive number.\n+\n+      If there is an error the number zero is returned.\n+\n+      Example: >\n+      \t:echo flatten([1, [2, [3, 4]], 5])\n+      <\t[1, 2, 3, 4, 5] >\n+      \t:echo flatten([1, [2, [3, 4]], 5], 1)\n+      <\t[1, 2, [3, 4], 5]\n+\n+      Can also be used as a |method|: >\n+      \tmylist->flatten()\n+      <\n+    ]=],\n+    name = 'flatten',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flatten({list} [, {maxdepth}])',\n+  },\n+  flattennew = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Like |flatten()| but first make a copy of {list}.\n+    ]=],\n+    name = 'flattennew',\n+    params = { { 'list', 'any' }, { 'maxdepth', 'any' } },\n+    returns = 'any[]|0',\n+    signature = 'flattennew({list} [, {maxdepth}])',\n+  },\n+  float2nr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} to a Number by omitting the part after the\n+      decimal point.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0 if {expr} is not a |Float| or a |Number|.\n+      When the value of {expr} is out of range for a |Number| the\n+      result is truncated to 0x7fffffff or -0x7fffffff (or when\n+      64-bit Number support is enabled, 0x7fffffffffffffff or\n+      -0x7fffffffffffffff).  NaN results in -0x80000000 (or when\n+      64-bit Number support is enabled, -0x8000000000000000).\n+      Examples: >\n+      \techo float2nr(3.95)\n+      <\t3  >\n+      \techo float2nr(-23.45)\n+      <\t-23  >\n+      \techo float2nr(1.0e100)\n+      <\t2147483647  (or 9223372036854775807) >\n+      \techo float2nr(-1.0e150)\n+      <\t-2147483647 (or -9223372036854775807) >\n+      \techo float2nr(1.0e-100)\n+      <\t0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->float2nr()\n+\n+    ]=],\n+    name = 'float2nr',\n+    params = { { 'expr', 'any' } },\n+    signature = 'float2nr({expr})',\n+  },\n+  floor = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the largest integral value less than or equal to\n+      {expr} as a |Float| (round down).\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \techo floor(1.856)\n+      <\t1.0  >\n+      \techo floor(-5.456)\n+      <\t-6.0  >\n+      \techo floor(4.0)\n+      <\t4.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->floor()\n+\n+    ]=],\n+    float_func = 'floor',\n+    name = 'floor',\n+    params = { { 'expr', 'any' } },\n+    signature = 'floor({expr})',\n+  },\n+  fmod = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the remainder of {expr1} / {expr2}, even if the\n+      division is not representable.  Returns {expr1} - i * {expr2}\n+      for some integer i such that if {expr2} is non-zero, the\n+      result has the same sign as {expr1} and magnitude less than\n+      the magnitude of {expr2}.  If {expr2} is zero, the value\n+      returned is zero.  The value returned is a |Float|.\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo fmod(12.33, 1.22)\n+      <\t0.13 >\n+      \t:echo fmod(-12.33, 1.22)\n+      <\t-0.13\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->fmod(1.22)\n+\n+    ]=],\n+    name = 'fmod',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'fmod({expr1}, {expr2})',\n+  },\n+  fnameescape = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Escape {string} for use as file name command argument.  All\n+      characters that have a special meaning, such as '%' and '|'\n+      are escaped with a backslash.\n+      For most systems the characters escaped are\n+      \" \\t\\n*?[{`$\\\\%#'\\\"|!<\".  For systems where a backslash\n+      appears in a filename, it depends on the value of 'isfname'.\n+      A leading '+' and '>' is also escaped (special after |:edit|\n+      and |:write|).  And a \"-\" by itself (special after |:cd|).\n+      Returns an empty string on error.\n+      Example: >\n+      \t:let fname = '+some str%nge|name'\n+      \t:exe \"edit \" .. fnameescape(fname)\n+      <results in executing: >\n+      \tedit \\+some\\ str\\%nge\\|name\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->fnameescape()\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnameescape',\n+    params = { { 'string', 'string' } },\n+    returns = 'string',\n+    signature = 'fnameescape({string})',\n+  },\n+  fnamemodify = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Modify file name {fname} according to {mods}.  {mods} is a\n+      string of characters like it is used for file names on the\n+      command line.  See |filename-modifiers|.\n+      Example: >\n+      \t:echo fnamemodify(\"main.c\", \":p:h\")\n+      <results in: >\n+      \t/home/user/vim/vim/src\n+      <If {mods} is empty or an unsupported modifier is used then\n+      {fname} is returned.\n+      When {fname} is empty then with {mods} \":h\" returns \".\", so\n+      that `:cd` can be used with it.  This is different from\n+      expand('%:h') without a buffer name, which returns an empty\n+      string.\n+      Note: Environment variables don't work in {fname}, use\n+      |expand()| first then.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fnamemodify(':p:h')\n+\n+    ]=],\n+    fast = true,\n+    name = 'fnamemodify',\n+    params = { { 'fname', 'integer' }, { 'mods', 'string' } },\n+    returns = 'string',\n+    signature = 'fnamemodify({fname}, {mods})',\n+  },\n+  foldclosed = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the first line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosed()\n+\n+    ]=],\n+    name = 'foldclosed',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosed({lnum})',\n+  },\n+  foldclosedend = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number.  If the line {lnum} is in a closed\n+      fold, the result is the number of the last line in that fold.\n+      If the line {lnum} is not in a closed fold, -1 is returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldclosedend()\n+\n+    ]=],\n+    name = 'foldclosedend',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldclosedend({lnum})',\n+  },\n+  foldlevel = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the foldlevel of line {lnum}\n+      in the current buffer.  For nested folds the deepest level is\n+      returned.  If there is no fold at line {lnum}, zero is\n+      returned.  It doesn't matter if the folds are open or closed.\n+      When used while updating folds (from 'foldexpr') -1 is\n+      returned for lines where folds are still to be updated and the\n+      foldlevel is unknown.  As a special case the level of the\n+      previous line is usually available.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldlevel()\n+      <\n+    ]=],\n+    name = 'foldlevel',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'foldlevel({lnum})',\n+  },\n+  foldtext = {\n+    desc = [=[\n+      Returns a String, to be displayed for a closed fold.  This is\n+      the default function used for the 'foldtext' option and should\n+      only be called from evaluating 'foldtext'.  It uses the\n+      |v:foldstart|, |v:foldend| and |v:folddashes| variables.\n+      The returned string looks like this: >\n+      \t+-- 45 lines: abcdef\n+      <The number of leading dashes depends on the foldlevel.  The\n+      \"45\" is the number of lines in the fold.  \"abcdef\" is the text\n+      in the first non-blank line of the fold.  Leading white space,\n+      \"//\" or \"/*\" and the text from the 'foldmarker' and\n+      'commentstring' options is removed.\n+      When used to draw the actual foldtext, the rest of the line\n+      will be filled with the fold char from the 'fillchars'\n+      setting.\n+      Returns an empty string when there is no fold.\n+\n+    ]=],\n+    name = 'foldtext',\n+    params = {},\n+    returns = 'string',\n+    signature = 'foldtext()',\n+  },\n+  foldtextresult = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Returns the text that is displayed for the closed fold at line\n+      {lnum}.  Evaluates 'foldtext' in the appropriate context.\n+      When there is no closed fold at {lnum} an empty string is\n+      returned.\n+      {lnum} is used like with |getline()|.  Thus \".\" is the current\n+      line, \"'m\" mark m, etc.\n+      Useful when exporting folded text, e.g., to HTML.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->foldtextresult()\n+      <\n+    ]=],\n+    name = 'foldtextresult',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'string',\n+    signature = 'foldtextresult({lnum})',\n+  },\n+  foreground = {\n+    lua = false,\n+  },\n+  fullcommand = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the full command name from a short abbreviated command\n+      name; see |20.2| for details on command abbreviations.\n+\n+      The string argument {name} may start with a `:` and can\n+      include a [range], these are skipped and not returned.\n+      Returns an empty string if a command doesn't exist or if it's\n+      ambiguous (for user-defined commands).\n+\n+      For example `fullcommand('s')`, `fullcommand('sub')`,\n+      `fullcommand(':%substitute')` all return \"substitute\".\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->fullcommand()\n+      <\n+    ]=],\n+    name = 'fullcommand',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'fullcommand({name})',\n+  },\n+  funcref = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Just like |function()|, but the returned Funcref will lookup\n+      the function by reference, not by name.  This matters when the\n+      function {name} is redefined later.\n+\n+      Unlike |function()|, {name} must be an existing user function.\n+      It only works for an autoloaded function if it has already\n+      been loaded (to avoid mistakenly loading the autoload script\n+      when only intending to use the function name, use |function()|\n+      instead). {name} cannot be a builtin function.\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->funcref([arg])\n+      <\n+    ]=],\n+    name = 'funcref',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'funcref({name} [, {arglist}] [, {dict}])',\n+  },\n+  ['function'] = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |Funcref| variable that refers to function {name}.\n+      {name} can be the name of a user defined function or an\n+      internal function.\n+\n+      {name} can also be a Funcref or a partial. When it is a\n+      partial the dict stored in it will be used and the {dict}\n+      argument is not allowed. E.g.: >\n+      \tlet FuncWithArg = function(dict.Func, [arg])\n+      \tlet Broken = function(dict.Func, [arg], dict)\n+      <\n+      When using the Funcref the function will be found by {name},\n+      also when it was redefined later. Use |funcref()| to keep the\n+      same function.\n+\n+      When {arglist} or {dict} is present this creates a partial.\n+      That means the argument list and/or the dictionary is stored in\n+      the Funcref and will be used when the Funcref is called.\n+\n+      The arguments are passed to the function in front of other\n+      arguments, but after any argument from |method|.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['one', 'two'])\n+      \t\"...\n+      \tcall Partial('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <With a |method|: >\n+      \tfunc Callback(one, two, three)\n+      \t\"...\n+      \tlet Partial = function('Callback', ['two'])\n+      \t\"...\n+      \teval 'one'->Partial('three')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'three')\n+\n+      <The function() call can be nested to add more arguments to the\n+      Funcref.  The extra arguments are appended to the list of\n+      arguments.  Example: >\n+      \tfunc Callback(arg1, arg2, name)\n+      \t\"...\n+      \tlet Func = function('Callback', ['one'])\n+      \tlet Func2 = function(Func, ['two'])\n+      \t\"...\n+      \tcall Func2('name')\n+      <Invokes the function as with: >\n+      \tcall Callback('one', 'two', 'name')\n+\n+      <The Dictionary is only useful when calling a \"dict\" function.\n+      In that case the {dict} is passed in as \"self\". Example: >\n+      \tfunction Callback() dict\n+      \t   echo \"called for \" .. self.name\n+      \tendfunction\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', context)\n+      \t\"...\n+      \tcall Func()\t\" will echo: called for example\n+      <The use of function() is not needed when there are no extra\n+      arguments, these two are equivalent, if Callback() is defined\n+      as context.Callback(): >\n+      \tlet Func = function('Callback', context)\n+      \tlet Func = context.Callback\n+\n+      <The argument list and the Dictionary can be combined: >\n+      \tfunction Callback(arg1, count) dict\n+      \t\"...\n+      \tlet context = {\"name\": \"example\"}\n+      \tlet Func = function('Callback', ['one'], context)\n+      \t\"...\n+      \tcall Func(500)\n+      <Invokes the function as with: >\n+      \tcall context.Callback('one', 500)\n+      <\n+      Returns 0 on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetFuncname()->function([arg])\n+\n+    ]=],\n+    name = 'function',\n+    params = { { 'name', 'string' }, { 'arglist', 'any' }, { 'dict', 'any' } },\n+    signature = 'function({name} [, {arglist}] [, {dict}])',\n+    tags = { 'partial', 'E700', 'E923' },\n+  },\n+  garbagecollect = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Cleanup unused |Lists| and |Dictionaries| that have circular\n+      references.\n+\n+      There is hardly ever a need to invoke this function, as it is\n+      automatically done when Vim runs out of memory or is waiting\n+      for the user to press a key after 'updatetime'.  Items without\n+      circular references are always freed when they become unused.\n+      This is useful if you have deleted a very big |List| and/or\n+      |Dictionary| with circular references in a script that runs\n+      for a long time.\n+\n+      When the optional {atexit} argument is one, garbage\n+      collection will also be done when exiting Vim, if it wasn't\n+      done before.  This is useful when checking for memory leaks.\n+\n+      The garbage collection is not done immediately but only when\n+      it's safe to perform.  This is when waiting for the user to\n+      type a character.\n+\n+    ]=],\n+    name = 'garbagecollect',\n+    params = { { 'atexit', 'any' } },\n+    signature = 'garbagecollect([{atexit}])',\n+  },\n+  get = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {idx} from |List| {list}.  When this item is not\n+      available return {default}.  Return zero when {default} is\n+      omitted.\n+      Can also be used as a |method|: >\n+      \tmylist->get(idx)\n+    ]=],\n+    name = 'get',\n+    params = { { 'list', 'any[]' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({list}, {idx} [, {default}])',\n+  },\n+  get__1 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get byte {idx} from |Blob| {blob}.  When this byte is not\n+      available return {default}.  Return -1 when {default} is\n+      omitted.\n+    ]=],\n+    name = 'get',\n+    params = { { 'blob', 'string' }, { 'idx', 'integer' }, { 'default', 'any' } },\n+    signature = 'get({blob}, {idx} [, {default}])',\n+  },\n+  get__2 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item with key {key} from |Dictionary| {dict}.  When this\n+      item is not available return {default}.  Return zero when\n+      {default} is omitted.  Useful example: >\n+      \tlet val = get(g:, 'var_name', 'default')\n+      <This gets the value of g:var_name if it exists, and uses\n+      \"default\" when it does not exist.\n+    ]=],\n+    name = 'get',\n+    params = { { 'dict', 'table<string,any>' }, { 'key', 'string' }, { 'default', 'any' } },\n+    signature = 'get({dict}, {key} [, {default}])',\n+  },\n+  get__3 = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get item {what} from Funcref {func}.  Possible values for\n+      {what} are:\n+      \t\"name\"\tThe function name\n+      \t\"func\"\tThe function\n+      \t\"dict\"\tThe dictionary\n+      \t\"args\"\tThe list with arguments\n+      Returns zero on error.\n+    ]=],\n+    name = 'get',\n+    params = { { 'func', 'function' }, { 'what', 'string' } },\n+    returns = 'any',\n+    signature = 'get({func}, {what})',\n+  },\n+  getbufinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    name = 'getbufinfo',\n+    params = { { 'buf', 'integer|string' } },\n+    signature = 'getbufinfo([{buf}])',\n+  },\n+  getbufinfo__1 = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get information about buffers as a List of Dictionaries.\n+\n+      Without an argument information about all the buffers is\n+      returned.\n+\n+      When the argument is a |Dictionary| only the buffers matching\n+      the specified criteria are returned.  The following keys can\n+      be specified in {dict}:\n+      \tbuflisted\tinclude only listed buffers.\n+      \tbufloaded\tinclude only loaded buffers.\n+      \tbufmodified\tinclude only modified buffers.\n+\n+      Otherwise, {buf} specifies a particular buffer to return\n+      information for.  For the use of {buf}, see |bufname()|\n+      above.  If the buffer is found the returned List has one item.\n+      Otherwise the result is an empty list.\n+\n+      Each returned List item is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tBuffer number.\n+      \tchanged\t\tTRUE if the buffer is modified.\n+      \tchangedtick\tNumber of changes made to the buffer.\n+      \thidden\t\tTRUE if the buffer is hidden.\n+      \tlastused\tTimestamp in seconds, like\n+      \t\t\t|localtime()|, when the buffer was\n+      \t\t\tlast used.\n+      \tlisted\t\tTRUE if the buffer is listed.\n+      \tlnum\t\tLine number used for the buffer when\n+      \t\t\topened in the current window.\n+      \t\t\tOnly valid if the buffer has been\n+      \t\t\tdisplayed in the window in the past.\n+      \t\t\tIf you want the line number of the\n+      \t\t\tlast known cursor position in a given\n+      \t\t\twindow, use |line()|: >\n+      \t\t\t\t:echo line('.', {winid})\n+      <\n+      \tlinecount\tNumber of lines in the buffer (only\n+      \t\t\tvalid when loaded)\n+      \tloaded\t\tTRUE if the buffer is loaded.\n+      \tname\t\tFull path to the file in the buffer.\n+      \tsigns\t\tList of signs placed in the buffer.\n+      \t\t\tEach list item is a dictionary with\n+      \t\t\tthe following fields:\n+      \t\t\t    id\t  sign identifier\n+      \t\t\t    lnum  line number\n+      \t\t\t    name  sign name\n+      \tvariables\tA reference to the dictionary with\n+      \t\t\tbuffer-local variables.\n+      \twindows\t\tList of |window-ID|s that display this\n+      \t\t\tbuffer\n+\n+      Examples: >\n+      \tfor buf in getbufinfo()\n+      \t    echo buf.name\n+      \tendfor\n+      \tfor buf in getbufinfo({'buflisted':1})\n+      \t    if buf.changed\n+      \t\t....\n+      \t    endif\n+      \tendfor\n+      <\n+      To get buffer-local options use: >\n+      \tgetbufvar({bufnr}, '&option_name')\n+      <\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getbufinfo()\n+      <\n+    ]=],\n+    name = 'getbufinfo',\n+    params = { { 'dict', 'table<string,any>' } },\n+    signature = 'getbufinfo([{dict}])',\n+  },\n+  getbufline = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with the lines starting from {lnum} to {end}\n+      (inclusive) in the buffer {buf}.  If {end} is omitted, a\n+      |List| with only the line {lnum} is returned.  See\n+      `getbufoneline()` for only getting the line.\n+\n+      For the use of {buf}, see |bufname()| above.\n+\n+      For {lnum} and {end} \"$\" can be used for the last line of the\n+      buffer.  Otherwise a number must be used.\n+\n+      When {lnum} is smaller than 1 or bigger than the number of\n+      lines in the buffer, an empty |List| is returned.\n+\n+      When {end} is greater than the number of lines in the buffer,\n+      it is treated as {end} is set to the number of lines in the\n+      buffer.  When {end} is before {lnum} an empty |List| is\n+      returned.\n+\n+      This function works only for loaded buffers.  For unloaded and\n+      non-existing buffers, an empty |List| is returned.\n+\n+      Example: >\n+      \t:let lines = getbufline(bufnr(\"myfile\"), 1, \"$\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufline(lnum)\n+      <\n+    ]=],\n+    name = 'getbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'end', 'integer' } },\n+    signature = 'getbufline({buf}, {lnum} [, {end}])',\n+  },\n+  getbufoneline = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Just like `getbufline()` but only get one line and return it\n+      as a string.\n+    ]=],\n+    name = 'getbufoneline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' } },\n+    signature = 'getbufoneline({buf}, {lnum})',\n+  },\n+  getbufvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is the value of option or local buffer variable\n+      {varname} in buffer {buf}.  Note that the name without \"b:\"\n+      must be used.\n+      The {varname} argument is a string.\n+      When {varname} is empty returns a |Dictionary| with all the\n+      buffer-local variables.\n+      When {varname} is equal to \"&\" returns a |Dictionary| with all\n+      the buffer-local options.\n+      Otherwise, when {varname} starts with \"&\" returns the value of\n+      a buffer-local option.\n+      This also works for a global or buffer-local option, but it\n+      doesn't work for a global variable, window-local variable or\n+      window-local option.\n+      For the use of {buf}, see |bufname()| above.\n+      When the buffer or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+      Examples: >\n+      \t:let bufmodified = getbufvar(1, \"&mod\")\n+      \t:echo \"todo myvar = \" .. getbufvar(\"todo\", \"myvar\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetBufnr()->getbufvar(varname)\n+      <\n+    ]=],\n+    name = 'getbufvar',\n+    params = { { 'buf', 'any' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getbufvar({buf}, {varname} [, {def}])',\n+  },\n+  getcellwidths = {\n+    desc = [=[\n+      Returns a |List| of cell widths of character ranges overridden\n+      by |setcellwidths()|.  The format is equal to the argument of\n+      |setcellwidths()|.  If no character ranges have their cell\n+      widths overridden, an empty List is returned.\n+    ]=],\n+    name = 'getcellwidths',\n+    params = {},\n+    signature = 'getcellwidths()',\n+  },\n+  getchangelist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |changelist| for the buffer {buf}. For the use\n+      of {buf}, see |bufname()| above. If buffer {buf} doesn't\n+      exist, an empty list is returned.\n+\n+      The returned list contains two entries: a list with the change\n+      locations and the current position in the list.  Each\n+      entry in the change list is a dictionary with the following\n+      entries:\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tlnum\t\tline number\n+      If buffer {buf} is the current buffer, then the current\n+      position refers to the position in the list. For other\n+      buffers, it is set to the length of the list.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getchangelist()\n+\n+    ]=],\n+    name = 'getchangelist',\n+    params = { { 'buf', 'integer|string' } },\n+    returns = 'table[]',\n+    signature = 'getchangelist([{buf}])',\n+  },\n+  getchar = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0, only get a character when one is available.\n+      \tReturn zero otherwise.\n+      If [expr] is 1, only check if a character is available, it is\n+      \tnot consumed.  Return zero if no character available.\n+      If you prefer always getting a string use |getcharstr()|.\n+\n+      Without [expr] and when [expr] is 0 a whole character or\n+      special key is returned.  If it is a single character, the\n+      result is a Number.  Use |nr2char()| to convert it to a String.\n+      Otherwise a String is returned with the encoded character.\n+      For a special key it's a String with a sequence of bytes\n+      starting with 0x80 (decimal: 128).  This is the same value as\n+      the String \"\\<Key>\", e.g., \"\\<Left>\".  The returned value is\n+      also a String when a modifier (shift, control, alt) was used\n+      that is not included in the character.\n+\n+      When [expr] is 0 and Esc is typed, there will be a short delay\n+      while Vim waits to see if this is the start of an escape\n+      sequence.\n+\n+      When [expr] is 1 only the first byte is returned.  For a\n+      one-byte character it is the character itself as a number.\n+      Use nr2char() to convert it to a String.\n+\n+      Use getcharmod() to obtain any additional modifiers.\n+\n+      When the user clicks a mouse button, the mouse event will be\n+      returned.  The position can then be found in |v:mouse_col|,\n+      |v:mouse_lnum|, |v:mouse_winid| and |v:mouse_win|.\n+      |getmousepos()| can also be used.  Mouse move events will be\n+      ignored.\n+      This example positions the mouse as it would normally happen: >\n+      \tlet c = getchar()\n+      \tif c == \"\\<LeftMouse>\" && v:mouse_win > 0\n+      \t  exe v:mouse_win .. \"wincmd w\"\n+      \t  exe v:mouse_lnum\n+      \t  exe \"normal \" .. v:mouse_col .. \"|\"\n+      \tendif\n+      <\n+      There is no prompt, you will somehow have to make clear to the\n+      user that a character has to be typed.  The screen is not\n+      redrawn, e.g. when resizing the window.\n+\n+      There is no mapping for the character.\n+      Key codes are replaced, thus when the user presses the <Del>\n+      key you get the code for the <Del> key, not the raw character\n+      sequence.  Examples: >\n+      \tgetchar() == \"\\<Del>\"\n+      \tgetchar() == \"\\<S-Left>\"\n+      <This example redefines \"f\" to ignore case: >\n+      \t:nmap f :call FindChar()<CR>\n+      \t:function FindChar()\n+      \t:  let c = nr2char(getchar())\n+      \t:  while col('.') < col('$') - 1\n+      \t:    normal l\n+      \t:    if getline('.')[col('.') - 1] ==? c\n+      \t:      break\n+      \t:    endif\n+      \t:  endwhile\n+      \t:endfunction\n+      <\n+    ]=],\n+    name = 'getchar',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getchar([expr])',\n+  },\n+  getcharmod = {\n+    desc = [=[\n+      The result is a Number which is the state of the modifiers for\n+      the last obtained character with getchar() or in another way.\n+      These values are added together:\n+      \t2\tshift\n+      \t4\tcontrol\n+      \t8\talt (meta)\n+      \t16\tmeta (when it's different from ALT)\n+      \t32\tmouse double click\n+      \t64\tmouse triple click\n+      \t96\tmouse quadruple click (== 32 + 64)\n+      \t128\tcommand (Macintosh only)\n+      Only the modifiers that have not been included in the\n+      character itself are obtained.  Thus Shift-a results in \"A\"\n+      without a modifier.  Returns 0 if no modifiers are used.\n+    ]=],\n+    name = 'getcharmod',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcharmod()',\n+  },\n+  getcharpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}. Same as |getpos()| but the\n+      column number in the returned List is a character index\n+      instead of a byte index.\n+      If |getpos()| returns a very large column number, equal to\n+      |v:maxcol|, then getcharpos() will return the character index\n+      of the last character.\n+\n+      Example:\n+      With the cursor on '' in line 5 with text \"\": >\n+      \tgetcharpos('.')\t\treturns [0, 5, 3, 0]\n+      \tgetpos('.')\t\treturns [0, 5, 7, 0]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetMark()->getcharpos()\n+      <\n+    ]=],\n+    name = 'getcharpos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'integer[]',\n+    signature = 'getcharpos({expr})',\n+  },\n+  getcharsearch = {\n+    desc = [=[\n+      Return the current character search information as a {dict}\n+      with the following entries:\n+\n+          char\tcharacter previously used for a character\n+      \t\tsearch (|t|, |f|, |T|, or |F|); empty string\n+      \t\tif no character search has been performed\n+          forward\tdirection of character search; 1 for forward,\n+      \t\t0 for backward\n+          until\ttype of character search; 1 for a |t| or |T|\n+      \t\tcharacter search, 0 for an |f| or |F|\n+      \t\tcharacter search\n+\n+      This can be useful to always have |;| and |,| search\n+      forward/backward regardless of the direction of the previous\n+      character search: >\n+      \t:nnoremap <expr> ; getcharsearch().forward ? ';' : ','\n+      \t:nnoremap <expr> , getcharsearch().forward ? ',' : ';'\n+      <Also see |setcharsearch()|.\n+    ]=],\n+    name = 'getcharsearch',\n+    params = {},\n+    returns = 'table[]',\n+    signature = 'getcharsearch()',\n+  },\n+  getcharstr = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Get a single character from the user or input stream as a\n+      string.\n+      If [expr] is omitted, wait until a character is available.\n+      If [expr] is 0 or false, only get a character when one is\n+      \tavailable.  Return an empty string otherwise.\n+      If [expr] is 1 or true, only check if a character is\n+      \tavailable, it is not consumed.  Return an empty string\n+      \tif no character is available.\n+      Otherwise this works like |getchar()|, except that a number\n+      result is converted to a string.\n+\n+    ]=],\n+    name = 'getcharstr',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcharstr([expr])',\n+  },\n+  getcmdcompltype = {\n+    desc = [=[\n+      Return the type of the current command-line completion.\n+      Only works when the command line is being edited, thus\n+      requires use of |c_CTRL-\\_e| or |c_CTRL-R_=|.\n+      See |:command-completion| for the return string.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+      Returns an empty string when completion is not defined.\n+\n+    ]=],\n+    name = 'getcmdcompltype',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdcompltype()',\n+  },\n+  getcmdline = {\n+    desc = [=[\n+      Return the current command-line.  Only works when the command\n+      line is being edited, thus requires use of |c_CTRL-\\_e| or\n+      |c_CTRL-R_=|.\n+      Example: >\n+      \t:cmap <F7> <C-\\>eescape(getcmdline(), ' \\')<CR>\n+      <Also see |getcmdtype()|, |getcmdpos()|, |setcmdpos()| and\n+      |setcmdline()|.\n+      Returns an empty string when entering a password or using\n+      |inputsecret()|.\n+    ]=],\n+    name = 'getcmdline',\n+    params = {},\n+    returns = 'string',\n+    signature = 'getcmdline()',\n+  },\n+  getcmdpos = {\n+    desc = [=[\n+      Return the position of the cursor in the command line as a\n+      byte count.  The first column is 1.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdtype()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+    ]=],\n+    name = 'getcmdpos',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getcmdpos()',\n+  },\n+  getcmdscreenpos = {\n+    desc = [=[\n+      Return the screen position of the cursor in the command line\n+      as a byte count.  The first column is 1.\n+      Instead of |getcmdpos()|, it adds the prompt position.\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns 0 otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()|, |getcmdline()| and\n+      |setcmdline()|.\n+\n+    ]=],\n+    name = 'getcmdscreenpos',\n+    params = {},\n+    signature = 'getcmdscreenpos()',\n+  },\n+  getcmdtype = {\n+    desc = [=[\n+      Return the current command-line type. Possible return values\n+      are:\n+          :\tnormal Ex command\n+          >\tdebug mode command |debug-mode|\n+          /\tforward search command\n+          ?\tbackward search command\n+          @\t|input()| command\n+          `-`\t|:insert| or |:append| command\n+          =\t|i_CTRL-R_=|\n+      Only works when editing the command line, thus requires use of\n+      |c_CTRL-\\_e| or |c_CTRL-R_=| or an expression mapping.\n+      Returns an empty string otherwise.\n+      Also see |getcmdpos()|, |setcmdpos()| and |getcmdline()|.\n+    ]=],\n+    name = 'getcmdtype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdtype()',\n+  },\n+  getcmdwintype = {\n+    desc = [=[\n+      Return the current |command-line-window| type. Possible return\n+      values are the same as |getcmdtype()|. Returns an empty string\n+      when not in the command-line window.\n+    ]=],\n+    name = 'getcmdwintype',\n+    params = {},\n+    returns = \"':'|'>'|'/'|'?'|'@'|'-'|'='\",\n+    signature = 'getcmdwintype()',\n+  },\n+  getcompletion = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return a list of command-line completion matches. The String\n+      {type} argument specifies what for.  The following completion\n+      types are supported:\n+\n+      arglist\t\tfile names in argument list\n+      augroup\t\tautocmd groups\n+      buffer\t\tbuffer names\n+      breakpoint\t|:breakadd| and |:breakdel| suboptions\n+      cmdline\t\t|cmdline-completion| result\n+      color\t\tcolor schemes\n+      command\t\tEx command\n+      compiler\tcompilers\n+      diff_buffer     |:diffget| and |:diffput| completion\n+      dir\t\tdirectory names\n+      environment\tenvironment variable names\n+      event\t\tautocommand events\n+      expression\tVim expression\n+      file\t\tfile and directory names\n+      file_in_path\tfile and directory names in |'path'|\n+      filetype\tfiletype names |'filetype'|\n+      function\tfunction name\n+      help\t\thelp subjects\n+      highlight\thighlight groups\n+      history\t\t|:history| suboptions\n+      locale\t\tlocale names (as output of locale -a)\n+      mapclear\tbuffer argument\n+      mapping\t\tmapping name\n+      menu\t\tmenus\n+      messages\t|:messages| suboptions\n+      option\t\toptions\n+      packadd\t\toptional package |pack-add| names\n+      runtime\t\t|:runtime| completion\n+      scriptnames\tsourced script names |:scriptnames|\n+      shellcmd\tShell command\n+      sign\t\t|:sign| suboptions\n+      syntax\t\tsyntax file names |'syntax'|\n+      syntime\t\t|:syntime| suboptions\n+      tag\t\ttags\n+      tag_listfiles\ttags, file names\n+      user\t\tuser names\n+      var\t\tuser variables\n+\n+      If {pat} is an empty string, then all the matches are\n+      returned.  Otherwise only items matching {pat} are returned.\n+      See |wildcards| for the use of special characters in {pat}.\n+\n+      If the optional {filtered} flag is set to 1, then 'wildignore'\n+      is applied to filter the results.  Otherwise all the matches\n+      are returned. The 'wildignorecase' option always applies.\n+\n+      If the 'wildoptions' option contains \"fuzzy\", then fuzzy\n+      matching is used to get the completion matches. Otherwise\n+      regular expression matching is used.  Thus this function\n+      follows the user preference, what happens on the command line.\n+      If you do not want this you can make 'wildoptions' empty\n+      before calling getcompletion() and restore it afterwards.\n+\n+      If {type} is \"cmdline\", then the |cmdline-completion| result is\n+      returned.  For example, to complete the possible values after\n+      a \":call\" command: >\n+      \techo getcompletion('call ', 'cmdline')\n+      <\n+      If there are no matches, an empty list is returned.  An\n+      invalid value for {type} produces an error.\n+\n+      Can also be used as a |method|: >\n+      \tGetPattern()->getcompletion('color')\n+      <\n+    ]=],\n+    name = 'getcompletion',\n+    params = { { 'pat', 'any' }, { 'type', 'any' }, { 'filtered', 'any' } },\n+    returns = 'string[]',\n+    signature = 'getcompletion({pat}, {type} [, {filtered}])',\n+  },\n+  getcurpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Get the position of the cursor.  This is like getpos('.'), but\n+      includes an extra \"curswant\" item in the list:\n+          [0, lnum, col, off, curswant] ~\n+      The \"curswant\" number is the preferred column when moving the\n+      cursor vertically.  After |$| command it will be a very large\n+      number equal to |v:maxcol|.  Also see |getcursorcharpos()| and\n+      |getpos()|.\n+      The first \"bufnum\" item is always zero. The byte position of\n+      the cursor is returned in \"col\". To get the character\n+      position, use |getcursorcharpos()|.\n+\n+      The optional {winid} argument can specify the window.  It can\n+      be the window number or the |window-ID|.  The last known\n+      cursor position is returned, this may be invalid for the\n+      current value of the buffer if it is not the current window.\n+      If {winid} is invalid a list with zeroes is returned.\n+\n+      This can be used to save and restore the cursor position: >\n+      \tlet save_cursor = getcurpos()\n+      \tMoveTheCursorAround\n+      \tcall setpos('.', save_cursor)\n+      <Note that this only works within the window.  See\n+      |winrestview()| for restoring more state.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcurpos()\n+      <\n+    ]=],\n+    name = 'getcurpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcurpos([{winid}])',\n+  },\n+  getcursorcharpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Same as |getcurpos()| but the column number in the returned\n+      List is a character index instead of a byte index.\n+\n+      Example:\n+      With the cursor on '' in line 3 with text \"\": >\n+      \tgetcursorcharpos()\treturns [0, 3, 2, 0, 3]\n+      \tgetcurpos()\t\treturns [0, 3, 4, 0, 3]\n+      <\n+      Can also be used as a |method|: >\n+      \tGetWinid()->getcursorcharpos()\n+\n+    ]=],\n+    name = 'getcursorcharpos',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getcursorcharpos([{winid}])',\n+  },\n+  getcwd = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      With no arguments, returns the name of the effective\n+      |current-directory|. With {winnr} or {tabnr} the working\n+      directory of that scope is returned, and 'autochdir' is\n+      ignored.\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing tab number implies 0.\n+      Thus the following are equivalent: >\n+      \tgetcwd(0)\n+      \tgetcwd(0, 0)\n+      <If {winnr} is -1 it is ignored, only the tab is resolved.\n+      {winnr} can be the window number or the |window-ID|.\n+      If both {winnr} and {tabnr} are -1 the global working\n+      directory is returned.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getcwd()\n+\n+    ]=],\n+    name = 'getcwd',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'string',\n+    signature = 'getcwd([{winnr} [, {tabnr}]])',\n+  },\n+  getenv = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the value of environment variable {name}.  The {name}\n+      argument is a string, without a leading '$'.  Example: >\n+      \tmyHome = getenv('HOME')\n+\n+      <When the variable does not exist |v:null| is returned.  That\n+      is different from a variable set to an empty string.\n+      See also |expr-env|.\n+\n+      Can also be used as a |method|: >\n+      \tGetVarname()->getenv()\n+\n+    ]=],\n+    name = 'getenv',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getenv({name})',\n+  },\n+  getfontname = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Without an argument returns the name of the normal font being\n+      used.  Like what is used for the Normal highlight group\n+      |hl-Normal|.\n+      With an argument a check is done whether String {name} is a\n+      valid font name.  If not then an empty string is returned.\n+      Otherwise the actual font name is returned, or {name} if the\n+      GUI does not support obtaining the real name.\n+      Only works when the GUI is running, thus not in your vimrc or\n+      gvimrc file.  Use the |GUIEnter| autocommand to use this\n+      function just after the GUI has started.\n+\n+    ]=],\n+    name = 'getfontname',\n+    params = { { 'name', 'string' } },\n+    returns = 'string',\n+    signature = 'getfontname([{name}])',\n+  },\n+  getfperm = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the read, write, and execute\n+      permissions of the given file {fname}.\n+      If {fname} does not exist or its directory cannot be read, an\n+      empty string is returned.\n+      The result is of the form \"rwxrwxrwx\", where each group of\n+      \"rwx\" flags represent, in turn, the permissions of the owner\n+      of the file, the group the file belongs to, and other users.\n+      If a user does not have a given permission the flag for this\n+      is replaced with the string \"-\".  Examples: >\n+      \t:echo getfperm(\"/etc/passwd\")\n+      \t:echo getfperm(expand(\"~/.config/nvim/init.vim\"))\n+      <This will hopefully (from a security point of view) display\n+      the string \"rw-r--r--\" or even \"rw-------\".\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfperm()\n+      <\n+      For setting permissions use |setfperm()|.\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfperm',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'string',\n+    signature = 'getfperm({fname})',\n+  },\n+  getfsize = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the size in bytes of the\n+      given file {fname}.\n+      If {fname} is a directory, 0 is returned.\n+      If the file {fname} can't be found, -1 is returned.\n+      If the size of {fname} is too big to fit in a Number then -2\n+      is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getfsize()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getfsize',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getfsize({fname})',\n+  },\n+  getftime = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the last modification time of\n+      the given file {fname}.  The value is measured as seconds\n+      since 1st Jan 1970, and may be passed to strftime().  See also\n+      |localtime()| and |strftime()|.\n+      If the file {fname} can't be found -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftime()\n+\n+    ]=],\n+    fast = true,\n+    name = 'getftime',\n+    params = { { 'fname', 'integer' } },\n+    returns = 'integer',\n+    signature = 'getftime({fname})',\n+  },\n+  getftype = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is a description of the kind of\n+      file of the given file {fname}.\n+      If {fname} does not exist an empty string is returned.\n+      Here is a table over different kinds of files and their\n+      results:\n+      \tNormal file\t\t\"file\"\n+      \tDirectory\t\t\"dir\"\n+      \tSymbolic link\t\t\"link\"\n+      \tBlock device\t\t\"bdev\"\n+      \tCharacter device\t\"cdev\"\n+      \tSocket\t\t\t\"socket\"\n+      \tFIFO\t\t\t\"fifo\"\n+      \tAll other\t\t\"other\"\n+      Example: >\n+      \tgetftype(\"/home\")\n+      <Note that a type such as \"link\" will only be returned on\n+      systems that support it.  On some systems only \"dir\" and\n+      \"file\" are returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetFilename()->getftype()\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'getftype',\n+    params = { { 'fname', 'integer' } },\n+    returns = \"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\",\n+    signature = 'getftype({fname})',\n+  },\n+  getjumplist = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      Returns the |jumplist| for the specified window.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      {winnr} can also be a |window-ID|.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.  If {winnr} or {tabnr} is invalid, an empty list is\n+      returned.\n+\n+      The returned list contains two entries: a list with the jump\n+      locations and the last used jump position number in the list.\n+      Each entry in the jump location list is a dictionary with\n+      the following entries:\n+      \tbufnr\t\tbuffer number\n+      \tcol\t\tcolumn number\n+      \tcoladd\t\tcolumn offset for 'virtualedit'\n+      \tfilename\tfilename if available\n+      \tlnum\t\tline number\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getjumplist()\n+      <\n+    ]=],\n+    name = 'getjumplist',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    signature = 'getjumplist([{winnr} [, {tabnr}]])',\n+  },\n+  getline = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Without {end} the result is a String, which is line {lnum}\n+      from the current buffer.  Example: >\n+      \tgetline(1)\n+      <When {lnum} is a String that doesn't start with a\n+      digit, |line()| is called to translate the String into a Number.\n+      To get the line under the cursor: >\n+      \tgetline(\".\")\n+      <When {lnum} is a number smaller than 1 or bigger than the\n+      number of lines in the buffer, an empty string is returned.\n+\n+      When {end} is given the result is a |List| where each item is\n+      a line from the current buffer in the range {lnum} to {end},\n+      including line {end}.\n+      {end} is used in the same way as {lnum}.\n+      Non-existing lines are silently omitted.\n+      When {end} is before {lnum} an empty |List| is returned.\n+      Example: >\n+      \t:let start = line('.')\n+      \t:let end = search(\"^$\") - 1\n+      \t:let lines = getline(start, end)\n+\n+      <Can also be used as a |method|: >\n+      \tComputeLnum()->getline()\n+\n+      <To get lines from another buffer see |getbufline()| and\n+      |getbufoneline()|\n+    ]=],\n+    name = 'getline',\n+    params = { { 'lnum', 'integer' }, { 'end', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getline({lnum} [, {end}])',\n+  },\n+  getloclist = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Returns a |List| with all the entries in the location list for\n+      window {nr}.  {nr} can be the window number or the |window-ID|.\n+      When {nr} is zero the current window is used.\n+\n+      For a location list window, the displayed location list is\n+      returned.  For an invalid window number {nr}, an empty list is\n+      returned. Otherwise, same as |getqflist()|.\n+\n+      If the optional {what} dictionary argument is supplied, then\n+      returns the items listed in {what} as a dictionary. Refer to\n+      |getqflist()| for the supported items in {what}.\n+\n+      In addition to the items supported by |getqflist()| in {what},\n+      the following item is supported by |getloclist()|:\n+\n+      \tfilewinid\tid of the window used to display files\n+      \t\t\tfrom the location list. This field is\n+      \t\t\tapplicable only when called from a\n+      \t\t\tlocation list window. See\n+      \t\t\t|location-list-file-window| for more\n+      \t\t\tdetails.\n+\n+      Returns a |Dictionary| with default values if there is no\n+      location list for the window {nr}.\n+      Returns an empty Dictionary if window {nr} does not exist.\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getloclist(3, {'all': 0})\n+      \t:echo getloclist(5, {'filewinid': 0})\n+      <\n+    ]=],\n+    name = 'getloclist',\n+    params = { { 'nr', 'integer' }, { 'what', 'any' } },\n+    signature = 'getloclist({nr} [, {what}])',\n+  },\n+  getmarklist = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Without the {buf} argument returns a |List| with information\n+      about all the global marks. |mark|\n+\n+      If the optional {buf} argument is specified, returns the\n+      local marks defined in buffer {buf}.  For the use of {buf},\n+      see |bufname()|.  If {buf} is invalid, an empty list is\n+      returned.\n+\n+      Each item in the returned List is a |Dict| with the following:\n+          mark   name of the mark prefixed by \"'\"\n+          pos\t   a |List| with the position of the mark:\n+      \t\t[bufnum, lnum, col, off]\n+      \t   Refer to |getpos()| for more information.\n+          file   file name\n+\n+      Refer to |getpos()| for getting information about a specific\n+      mark.\n+\n+      Can also be used as a |method|: >\n+      \tGetBufnr()->getmarklist()\n+\n+    ]=],\n+    name = 'getmarklist',\n+    params = { { 'buf', 'any' } },\n+    signature = 'getmarklist([{buf}])',\n+  },\n+  getmatches = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all matches previously defined for the\n+      current window by |matchadd()| and the |:match| commands.\n+      |getmatches()| is useful in combination with |setmatches()|,\n+      as |setmatches()| can restore a list of matches saved by\n+      |getmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.  If {win} is invalid,\n+      an empty list is returned.\n+      Example: >vim\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:let m = getmatches()\n+      \t:call clearmatches()\n+      \t:echo getmatches()\n+      < >\n+      \t[]\n+      < >vim\n+      \t:call setmatches(m)\n+      \t:echo getmatches()\n+      < >\n+      \t[{\"group\": \"MyGroup1\", \"pattern\": \"TODO\",\n+      \t\"priority\": 10, \"id\": 1}, {\"group\": \"MyGroup2\",\n+      \t\"pattern\": \"FIXME\", \"priority\": 10, \"id\": 2}]\n+      < >vim\n+      \t:unlet m\n+      <\n+    ]=],\n+    name = 'getmatches',\n+    params = { { 'win', 'any' } },\n+    signature = 'getmatches([{win}])',\n+  },\n+  getmousepos = {\n+    desc = [=[\n+      Returns a Dictionary with the last known position of the\n+      mouse.  This can be used in a mapping for a mouse click.  The\n+      items are:\n+      \tscreenrow\tscreen row\n+      \tscreencol\tscreen column\n+      \twinid\t\tWindow ID of the click\n+      \twinrow\t\trow inside \"winid\"\n+      \twincol\t\tcolumn inside \"winid\"\n+      \tline\t\ttext line inside \"winid\"\n+      \tcolumn\t\ttext column inside \"winid\"\n+      All numbers are 1-based.\n+\n+      If not over a window, e.g. when in the command line, then only\n+      \"screenrow\" and \"screencol\" are valid, the others are zero.\n+\n+      When on the status line below a window or the vertical\n+      separator right of a window, the \"line\" and \"column\" values\n+      are zero.\n+\n+      When the position is after the text then \"column\" is the\n+      length of the text in bytes plus one.\n+\n+      If the mouse is over a focusable floating window then that\n+      window is used.\n+\n+      When using |getchar()| the Vim variables |v:mouse_lnum|,\n+      |v:mouse_col| and |v:mouse_winid| also provide these values.\n+    ]=],\n+    name = 'getmousepos',\n+    params = {},\n+    signature = 'getmousepos()',\n+  },\n+  getpid = {\n+    desc = [=[\n+      Return a Number which is the process ID of the Vim process.\n+      This is a unique number, until Vim exits.\n+    ]=],\n+    fast = true,\n+    name = 'getpid',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getpid()',\n+  },\n+  getpos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the position for String {expr}.  For possible values of\n+      {expr} see |line()|.  For getting the cursor position see\n+      |getcurpos()|.\n+      The result is a |List| with four numbers:\n+          [bufnum, lnum, col, off]\n+      \"bufnum\" is zero, unless a mark like '0 or 'A is used, then it\n+      is the buffer number of the mark.\n+      \"lnum\" and \"col\" are the position in the buffer.  The first\n+      column is 1.\n+      The \"off\" number is zero, unless 'virtualedit' is used.  Then\n+      it is the offset in screen columns from the start of the\n+      character.  E.g., a position within a <Tab> or after the last\n+      character.\n+      Note that for '< and '> Visual mode matters: when it is \"V\"\n+      (visual line mode) the column of '< is zero and the column of\n+      '> is a large number equal to |v:maxcol|.\n+      The column number in the returned List is the byte position\n+      within the line. To get the character position in the line,\n+      use |getcharpos()|.\n+      A very large column number equal to |v:maxcol| can be returned,\n+      in which case it means \"after the end of the line\".\n+      If {expr} is invalid, returns a list with all zeros.\n+      This can be used to save and restore the position of a mark: >\n+      \tlet save_a_mark = getpos(\"'a\")\n+      \t...\n+      \tcall setpos(\"'a\", save_a_mark)\n+      <Also see |getcharpos()|, |getcurpos()| and |setpos()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetMark()->getpos()\n+      <\n+    ]=],\n+    name = 'getpos',\n+    params = { { 'expr', 'any' } },\n+    signature = 'getpos({expr})',\n+  },\n+  getqflist = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with all the current quickfix errors.  Each\n+      list item is a dictionary with these entries:\n+      \tbufnr\tnumber of buffer that has the file name, use\n+      \t\tbufname() to get the name\n+      \tmodule\tmodule name\n+      \tlnum\tline number in the buffer (first line is 1)\n+      \tend_lnum\n+      \t\tend of line number if the item is multiline\n+      \tcol\tcolumn number (first column is 1)\n+      \tend_col\tend of column number if the item has range\n+      \tvcol\t|TRUE|: \"col\" is visual column\n+      \t\t|FALSE|: \"col\" is byte index\n+      \tnr\terror number\n+      \tpattern\tsearch pattern used to locate the error\n+      \ttext\tdescription of the error\n+      \ttype\ttype of the error, 'E', '1', etc.\n+      \tvalid\t|TRUE|: recognized error message\n+\n+      When there is no error list or it's empty, an empty list is\n+      returned. Quickfix list entries with a non-existing buffer\n+      number are returned with \"bufnr\" set to zero (Note: some\n+      functions accept buffer number zero for the alternate buffer,\n+      you may need to explicitly check for zero).\n+\n+      Useful application: Find pattern matches in multiple files and\n+      do something with them: >\n+      \t:vimgrep /theword/jg *.c\n+      \t:for d in getqflist()\n+      \t:   echo bufname(d.bufnr) ':' d.lnum '=' d.text\n+      \t:endfor\n+      <\n+      If the optional {what} dictionary argument is supplied, then\n+      returns only the items listed in {what} as a dictionary. The\n+      following string items are supported in {what}:\n+      \tchangedtick\tget the total number of changes made\n+      \t\t\tto the list |quickfix-changedtick|\n+      \tcontext\tget the |quickfix-context|\n+      \tefm\terrorformat to use when parsing \"lines\". If\n+      \t\tnot present, then the 'errorformat' option\n+      \t\tvalue is used.\n+      \tid\tget information for the quickfix list with\n+      \t\t|quickfix-ID|; zero means the id for the\n+      \t\tcurrent list or the list specified by \"nr\"\n+      \tidx\tget information for the quickfix entry at this\n+      \t\tindex in the list specified by \"id\" or \"nr\".\n+      \t\tIf set to zero, then uses the current entry.\n+      \t\tSee |quickfix-index|\n+      \titems\tquickfix list entries\n+      \tlines\tparse a list of lines using 'efm' and return\n+      \t\tthe resulting entries.  Only a |List| type is\n+      \t\taccepted.  The current quickfix list is not\n+      \t\tmodified. See |quickfix-parse|.\n+      \tnr\tget information for this quickfix list; zero\n+      \t\tmeans the current quickfix list and \"$\" means\n+      \t\tthe last quickfix list\n+      \tqfbufnr number of the buffer displayed in the quickfix\n+      \t\twindow. Returns 0 if the quickfix buffer is\n+      \t\tnot present. See |quickfix-buffer|.\n+      \tsize\tnumber of entries in the quickfix list\n+      \ttitle\tget the list title |quickfix-title|\n+      \twinid\tget the quickfix |window-ID|\n+      \tall\tall of the above quickfix properties\n+      Non-string items in {what} are ignored. To get the value of a\n+      particular item, set it to zero.\n+      If \"nr\" is not present then the current quickfix list is used.\n+      If both \"nr\" and a non-zero \"id\" are specified, then the list\n+      specified by \"id\" is used.\n+      To get the number of lists in the quickfix stack, set \"nr\" to\n+      \"$\" in {what}. The \"nr\" value in the returned dictionary\n+      contains the quickfix stack size.\n+      When \"lines\" is specified, all the other items except \"efm\"\n+      are ignored.  The returned dictionary contains the entry\n+      \"items\" with the list of entries.\n+\n+      The returned dictionary contains the following entries:\n+      \tchangedtick\ttotal number of changes made to the\n+      \t\t\tlist |quickfix-changedtick|\n+      \tcontext\tquickfix list context. See |quickfix-context|\n+      \t\tIf not present, set to \"\".\n+      \tid\tquickfix list ID |quickfix-ID|. If not\n+      \t\tpresent, set to 0.\n+      \tidx\tindex of the quickfix entry in the list. If not\n+      \t\tpresent, set to 0.\n+      \titems\tquickfix list entries. If not present, set to\n+      \t\tan empty list.\n+      \tnr\tquickfix list number. If not present, set to 0\n+      \tqfbufnr\tnumber of the buffer displayed in the quickfix\n+      \t\twindow. If not present, set to 0.\n+      \tsize\tnumber of entries in the quickfix list. If not\n+      \t\tpresent, set to 0.\n+      \ttitle\tquickfix list title text. If not present, set\n+      \t\tto \"\".\n+      \twinid\tquickfix |window-ID|. If not present, set to 0\n+\n+      Examples (See also |getqflist-examples|): >\n+      \t:echo getqflist({'all': 1})\n+      \t:echo getqflist({'nr': 2, 'title': 1})\n+      \t:echo getqflist({'lines' : [\"F1:10:L10\"]})\n+      <\n+    ]=],\n+    name = 'getqflist',\n+    params = { { 'what', 'any' } },\n+    signature = 'getqflist([{what}])',\n+  },\n+  getreg = {\n+    args = { 0, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the contents of register\n+      {regname}.  Example: >\n+      \t:let cliptext = getreg('*')\n+      <When register {regname} was not set the result is an empty\n+      string.\n+      The {regname} argument must be a string.\n+\n+      getreg('=') returns the last evaluated value of the expression\n+      register.  (For use in maps.)\n+      getreg('=', 1) returns the expression itself, so that it can\n+      be restored with |setreg()|.  For other registers the extra\n+      argument is ignored, thus you can always give it.\n+\n+      If {list} is present and |TRUE|, the result type is changed\n+      to |List|. Each list item is one text line. Use it if you care\n+      about zero bytes possibly present inside register: without\n+      third argument both NLs and zero bytes are represented as NLs\n+      (see |NL-used-for-Nul|).\n+      When the register was not set an empty list is returned.\n+\n+      If {regname} is not specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreg()\n+\n+    ]=],\n+    name = 'getreg',\n+    params = { { 'regname', 'string' }, { 'list', 'any' } },\n+    returns = 'string|string[]',\n+    signature = 'getreg([{regname} [, 1 [, {list}]]])',\n+  },\n+  getreginfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns detailed information about register {regname} as a\n+      Dictionary with the following entries:\n+      \tregcontents\tList of lines contained in register\n+      \t\t\t{regname}, like\n+      \t\t\tgetreg({regname}, 1, 1).\n+      \tregtype\t\tthe type of register {regname}, as in\n+      \t\t\t|getregtype()|.\n+      \tisunnamed\tBoolean flag, v:true if this register\n+      \t\t\tis currently pointed to by the unnamed\n+      \t\t\tregister.\n+      \tpoints_to\tfor the unnamed register, gives the\n+      \t\t\tsingle letter name of the register\n+      \t\t\tcurrently pointed to (see |quotequote|).\n+      \t\t\tFor example, after deleting a line\n+      \t\t\twith `dd`, this field will be \"1\",\n+      \t\t\twhich is the register that got the\n+      \t\t\tdeleted text.\n+\n+      The {regname} argument is a string.  If {regname} is invalid\n+      or not set, an empty Dictionary will be returned.\n+      If {regname} is not specified, |v:register| is used.\n+      The returned Dictionary can be passed to |setreg()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getreginfo()\n+\n+    ]=],\n+    name = 'getreginfo',\n+    params = { { 'regname', 'string' } },\n+    returns = 'table',\n+    signature = 'getreginfo([{regname}])',\n+  },\n+  getregtype = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is type of register {regname}.\n+      The value will be one of:\n+          \"v\"\t\t\tfor |charwise| text\n+          \"V\"\t\t\tfor |linewise| text\n+          \"<CTRL-V>{width}\"\tfor |blockwise-visual| text\n+          \"\"\t\t\tfor an empty or unknown register\n+      <CTRL-V> is one character with value 0x16.\n+      The {regname} argument is a string.  If {regname} is not\n+      specified, |v:register| is used.\n+\n+      Can also be used as a |method|: >\n+      \tGetRegname()->getregtype()\n+\n+    ]=],\n+    name = 'getregtype',\n+    params = { { 'regname', 'string' } },\n+    returns = 'string',\n+    signature = 'getregtype([{regname}])',\n+  },\n+  getscriptinfo = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      Returns a |List| with information about all the sourced Vim\n+      scripts in the order they were sourced, like what\n+      `:scriptnames` shows.\n+\n+      The optional Dict argument {opts} supports the following\n+      optional items:\n+          name\tScript name match pattern. If specified,\n+      \t\tand \"sid\" is not specified, information about\n+      \t\tscripts with a name that match the pattern\n+      \t\t\"name\" are returned.\n+          sid\t\tScript ID |<SID>|.  If specified, only\n+      \t\tinformation about the script with ID \"sid\" is\n+      \t\treturned and \"name\" is ignored.\n+\n+      Each item in the returned List is a |Dict| with the following\n+      items:\n+          autoload\tAlways set to FALSE.\n+          functions   List of script-local function names defined in\n+      \t\tthe script.  Present only when a particular\n+      \t\tscript is specified using the \"sid\" item in\n+      \t\t{opts}.\n+          name\tVim script file name.\n+          sid\t\tScript ID |<SID>|.\n+          variables   A dictionary with the script-local variables.\n+      \t\tPresent only when a particular script is\n+      \t\tspecified using the \"sid\" item in {opts}.\n+      \t\tNote that this is a copy, the value of\n+      \t\tscript-local variables cannot be changed using\n+      \t\tthis dictionary.\n+          version\tVimscript version, always 1\n+\n+      Examples: >\n+      \t:echo getscriptinfo({'name': 'myscript'})\n+      \t:echo getscriptinfo({'sid': 15}).variables\n+      <\n+    ]=],\n+    name = 'getscriptinfo',\n+    params = { { 'opts', 'table' } },\n+    signature = 'getscriptinfo([{opts}])',\n+  },\n+  gettabinfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      If {tabnr} is not specified, then information about all the\n+      tab pages is returned as a |List|. Each List item is a\n+      |Dictionary|.  Otherwise, {tabnr} specifies the tab page\n+      number and information about that one is returned.  If the tab\n+      page does not exist an empty List is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \ttabnr\t\ttab page number.\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\ttabpage-local variables\n+      \twindows\t\tList of |window-ID|s in the tab page.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabinfo()\n+\n+    ]=],\n+    name = 'gettabinfo',\n+    params = { { 'tabnr', 'integer' } },\n+    signature = 'gettabinfo([{tabnr}])',\n+  },\n+  gettabvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of a tab-local variable {varname} in tab page\n+      {tabnr}. |t:var|\n+      Tabs are numbered starting with one.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all tab-local variables is returned.\n+      Note that the name without \"t:\" must be used.\n+      When the tab or variable doesn't exist {def} or an empty\n+      string is returned, there is no error message.\n+\n+      Can also be used as a |method|: >\n+      \tGetTabnr()->gettabvar(varname)\n+\n+    ]=],\n+    name = 'gettabvar',\n+    params = { { 'tabnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'gettabvar({tabnr}, {varname} [, {def}])',\n+  },\n+  gettabwinvar = {\n+    args = { 3, 4 },\n+    base = 1,\n+    desc = [=[\n+      Get the value of window-local variable {varname} in window\n+      {winnr} in tab page {tabnr}.\n+      The {varname} argument is a string.  When {varname} is empty a\n+      dictionary with all window-local variables is returned.\n+      When {varname} is equal to \"&\" get the values of all\n+      window-local options in a |Dictionary|.\n+      Otherwise, when {varname} starts with \"&\" get the value of a\n+      window-local option.\n+      Note that {varname} must be the name without \"w:\".\n+      Tabs are numbered starting with one.  For the current tabpage\n+      use |getwinvar()|.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is zero the current window is used.\n+      This also works for a global option, buffer-local option and\n+      window-local option, but it doesn't work for a global variable\n+      or buffer-local variable.\n+      When the tab, window or variable doesn't exist {def} or an\n+      empty string is returned, there is no error message.\n+      Examples: >\n+      \t:let list_is_on = gettabwinvar(1, 2, '&list')\n+      \t:echo \"myvar = \" .. gettabwinvar(3, 1, 'myvar')\n+      <\n+      To obtain all window-local variables use: >\n+      \tgettabwinvar({tabnr}, {winnr}, '&')\n+\n+      <Can also be used as a |method|: >\n+      \tGetTabnr()->gettabwinvar(winnr, varname)\n+\n+    ]=],\n+    name = 'gettabwinvar',\n+    params = {\n+      { 'tabnr', 'integer' },\n+      { 'winnr', 'integer' },\n+      { 'varname', 'string' },\n+      { 'def', 'any' },\n     },\n-    buflisted={args=1, base=1, returns=VIMBOOL},\n-    bufload={args=1, base=1, returns=false},\n-    bufloaded={args=1, base=1, returns=VIMBOOL},\n-    bufname={args={0, 1}, base=1, returns='string'},\n-    bufnr={args={0, 2}, base=1, returns='integer'},\n-    bufwinid={args=1, base=1, returns='integer'},\n-    bufwinnr={args=1, base=1, returns='integer'},\n-    byte2line={args=1, base=1, returns='integer'},\n-    byteidx={args={2, 3}, base=1, fast=true, returns='integer'},\n-    byteidxcomp={args={2, 3}, base=1, fast=true, returns='integer'},\n-    call={args={2, 3}, base=1},\n-    ceil={args=1, base=1, float_func=\"ceil\"},\n-    changenr={returns='integer'},\n-    chanclose={args={1, 2}},\n-    chansend={args=2},\n-    char2nr={args={1, 2}, base=1, fast=true},\n-    charclass={args=1, base=1},\n-    charcol={args={1, 2}, base=1},\n-    charidx={args={2, 4}, base=1},\n-    chdir={args=1, base=1},\n-    cindent={args=1, base=1},\n-    clearmatches={args={0, 1}, base=1},\n-    col={args={1, 2}, base=1, returns='integer'},\n-    complete={args=2, base=2, returns=false},\n-    complete_add={args=1, base=1, returns='0|1|2'},\n-    complete_check={returns=VIMBOOL},\n-    complete_info={args={0, 1}, base=1, returns='table'},\n-    confirm={args={1, 4}, base=1},\n-    copy={args=1, base=1},\n-    cos={args=1, base=1, float_func=\"cos\"},\n-    cosh={args=1, base=1, float_func=\"cosh\"},\n-    count={args={2, 4}, base=1},\n-    ctxget={args={0, 1}},\n-    ctxpop={},\n-    ctxpush={args={0, 1}},\n-    ctxset={args={1, 2}},\n-    ctxsize={},\n-    cursor={args={1, 3}, base=1},\n-    debugbreak={args={1, 1}, base=1},\n-    deepcopy={args={1, 2}, base=1},\n-    delete={args={1,2}, base=1, returns='integer'},\n-    deletebufline={args={2,3}, base=1},\n-    dictwatcheradd={args=3},\n-    dictwatcherdel={args=3},\n-    did_filetype={fast=true},\n-    diff_filler={args=1, base=1},\n-    diff_hlID={args=2, base=1},\n-    digraph_get={args=1, base=1},\n-    digraph_getlist={args={0, 1}, base=1},\n-    digraph_set={args=2, base=1},\n-    digraph_setlist={args=1, base=1},\n-    empty={args=1, base=1},\n-    environ={fast=true},\n-    escape={args=2, base=1, fast=true},\n-    eval={args=1, base=1},\n-    eventhandler={},\n-    executable={args=1, base=1, fast=true},\n-    execute={args={1, 2}, base=1},\n-    exepath={args=1, base=1},\n-    exists={args=1, base=1, returns=VIMBOOL},\n-    exp={args=1, base=1, float_func=\"exp\"},\n-    expand={args={1, 3}, base=1, returns='string|string[]'},\n-    expandcmd={args={1, 2}, base=1},\n-    extend={args={2, 3}, base=1},\n-    extendnew={args={2, 3}, base=1},\n-    feedkeys={args={1, 2}, base=1},\n-    file_readable={\n-      args=1, base=1, func='f_filereadable',\n-      deprecated = { 'Obsolete name for |filereadable()|.' }\n+    signature = 'gettabwinvar({tabnr}, {winnr}, {varname} [, {def}])',\n+  },\n+  gettagstack = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Dict, which is the tag stack of window {winnr}.\n+      {winnr} can be the window number or the |window-ID|.\n+      When {winnr} is not specified, the current window is used.\n+      When window {winnr} doesn't exist, an empty Dict is returned.\n+\n+      The returned dictionary contains the following entries:\n+      \tcuridx\t\tCurrent index in the stack. When at\n+      \t\t\ttop of the stack, set to (length + 1).\n+      \t\t\tIndex of bottom of the stack is 1.\n+      \titems\t\tList of items in the stack. Each item\n+      \t\t\tis a dictionary containing the\n+      \t\t\tentries described below.\n+      \tlength\t\tNumber of entries in the stack.\n+\n+      Each item in the stack is a dictionary with the following\n+      entries:\n+      \tbufnr\t\tbuffer number of the current jump\n+      \tfrom\t\tcursor position before the tag jump.\n+      \t\t\tSee |getpos()| for the format of the\n+      \t\t\treturned list.\n+      \tmatchnr\t\tcurrent matching tag number. Used when\n+      \t\t\tmultiple matching tags are found for a\n+      \t\t\tname.\n+      \ttagname\t\tname of the tag\n+\n+      See |tagstack| for more information about the tag stack.\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->gettagstack()\n+      <\n+    ]=],\n+    name = 'gettagstack',\n+    params = { { 'winnr', 'integer' } },\n+    signature = 'gettagstack([{winnr}])',\n+  },\n+  gettext = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Translate String {text} if possible.\n+      This is mainly for use in the distributed Vim scripts.  When\n+      generating message translations the {text} is extracted by\n+      xgettext, the translator can add the translated message in the\n+      .po file and Vim will lookup the translation when gettext() is\n+      called.\n+      For {text} double quoted strings are preferred, because\n+      xgettext does not understand escaping in single quoted\n+      strings.\n+    ]=],\n+    name = 'gettext',\n+    params = { { 'text', 'any' } },\n+    signature = 'gettext({text})',\n+  },\n+  getwininfo = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      Returns information about windows as a |List| with Dictionaries.\n+\n+      If {winid} is given Information about the window with that ID\n+      is returned, as a |List| with one item.  If the window does not\n+      exist the result is an empty list.\n+\n+      Without {winid} information about all the windows in all the\n+      tab pages is returned.\n+\n+      Each List item is a |Dictionary| with the following entries:\n+      \tbotline\t\tlast complete displayed buffer line\n+      \tbufnr\t\tnumber of buffer in the window\n+      \theight\t\twindow height (excluding winbar)\n+      \tloclist\t\t1 if showing a location list\n+      \tquickfix\t1 if quickfix or location list window\n+      \tterminal\t1 if a terminal window\n+      \ttabnr\t\ttab page number\n+      \ttopline\t\tfirst displayed buffer line\n+      \tvariables\ta reference to the dictionary with\n+      \t\t\twindow-local variables\n+      \twidth\t\twindow width\n+      \twinbar\t\t1 if the window has a toolbar, 0\n+      \t\t\totherwise\n+      \twincol\t\tleftmost screen column of the window;\n+      \t\t\t\"col\" from |win_screenpos()|\n+      \ttextoff\t\tnumber of columns occupied by any\n+      \t\t\t'foldcolumn', 'signcolumn' and line\n+      \t\t\tnumber in front of the text\n+      \twinid\t\t|window-ID|\n+      \twinnr\t\twindow number\n+      \twinrow\t\ttopmost screen line of the window;\n+      \t\t\t\"row\" from |win_screenpos()|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->getwininfo()\n+\n+    ]=],\n+    name = 'getwininfo',\n+    params = { { 'winid', 'integer' } },\n+    signature = 'getwininfo([{winid}])',\n+  },\n+  getwinpos = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is a |List| with two numbers, the result of\n+      |getwinposx()| and |getwinposy()| combined:\n+      \t[x-pos, y-pos]\n+      {timeout} can be used to specify how long to wait in msec for\n+      a response from the terminal.  When omitted 100 msec is used.\n+\n+      Use a longer time for a remote terminal.\n+      When using a value less than 10 and no response is received\n+      within that time, a previously reported position is returned,\n+      if available.  This can be used to poll for the position and\n+      do some work in the meantime: >\n+      \twhile 1\n+      \t  let res = getwinpos(1)\n+      \t  if res[0] >= 0\n+      \t    break\n+      \t  endif\n+      \t  \" Do some work here\n+      \tendwhile\n+      <\n+      Can also be used as a |method|: >\n+      \tGetTimeout()->getwinpos()\n+      <\n+    ]=],\n+    name = 'getwinpos',\n+    params = { { 'timeout', 'integer' } },\n+    signature = 'getwinpos([{timeout}])',\n+  },\n+  getwinposx = {\n+    desc = [=[\n+      The result is a Number, which is the X coordinate in pixels of\n+      the left hand side of the GUI Vim window.  The result will be\n+      -1 if the information is not available.\n+      The value can be used with `:winpos`.\n+    ]=],\n+    name = 'getwinposx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposx()',\n+  },\n+  getwinposy = {\n+    desc = [=[\n+      The result is a Number, which is the Y coordinate in pixels of\n+      the top of the GUI Vim window.  The result will be -1 if the\n+      information is not available.\n+      The value can be used with `:winpos`.\n+\n+    ]=],\n+    name = 'getwinposy',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'getwinposy()',\n+  },\n+  getwinvar = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like |gettabwinvar()| for the current tabpage.\n+      Examples: >\n+      \t:let list_is_on = getwinvar(2, '&list')\n+      \t:echo \"myvar = \" .. getwinvar(1, 'myvar')\n+\n+      <Can also be used as a |method|: >\n+      \tGetWinnr()->getwinvar(varname)\n+      <\n+    ]=],\n+    name = 'getwinvar',\n+    params = { { 'winnr', 'integer' }, { 'varname', 'string' }, { 'def', 'any' } },\n+    signature = 'getwinvar({winnr}, {varname} [, {def}])',\n+  },\n+  glob = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      Expand the file wildcards in {expr}.  See |wildcards| for the\n+      use of special characters.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+      'wildignorecase' always applies.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is,\n+      you also get filenames containing newlines correctly.\n+      Otherwise the result is a String and when there are several\n+      matches, they are separated by <NL> characters.\n+\n+      If the expansion fails, the result is an empty String or List.\n+\n+      You can also use |readdir()| if you need to do complicated\n+      things, such as limiting the number of matches.\n+\n+      A name for a non-existing file is not included.  A symbolic\n+      link is only included if it points to an existing file.\n+      However, when the {alllinks} argument is present and it is\n+      |TRUE| then all symbolic links are included.\n+\n+      For most systems backticks can be used to get files names from\n+      any external command.  Example: >\n+      \t:let tagfiles = glob(\"`find . -name tags -print`\")\n+      \t:let &tags = substitute(tagfiles, \"\\n\", \",\", \"g\")\n+      <The result of the program inside the backticks should be one\n+      item per line.  Spaces inside an item are allowed.\n+\n+      See |expand()| for expanding special Vim variables.  See\n+      |system()| for getting the raw output of an external command.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob()\n+\n+    ]=],\n+    name = 'glob',\n+    params = { { 'expr', 'any' }, { 'nosuf', 'boolean' }, { 'list', 'any' }, { 'alllinks', 'any' } },\n+    signature = 'glob({expr} [, {nosuf} [, {list} [, {alllinks}]]])',\n+  },\n+  glob2regpat = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert a file pattern, as used by glob(), into a search\n+      pattern.  The result can be used to match with a string that\n+      is a file name.  E.g. >\n+      \tif filename =~ glob2regpat('Make*.mak')\n+      <This is equivalent to: >\n+      \tif filename =~ '^Make.*\\.mak$'\n+      <When {string} is an empty string the result is \"^$\", match an\n+      empty string.\n+      Note that the result depends on the system.  On MS-Windows\n+      a backslash usually means a path separator.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->glob2regpat()\n+      <\n+    ]=],\n+    name = 'glob2regpat',\n+    params = { { 'string', 'string' } },\n+    signature = 'glob2regpat({string})',\n+  },\n+  globpath = {\n+    args = { 2, 5 },\n+    base = 2,\n+    desc = [=[\n+      Perform glob() for String {expr} on all directories in {path}\n+      and concatenate the results.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\")\n+      <\n+      {path} is a comma-separated list of directory names.  Each\n+      directory name is prepended to {expr} and expanded like with\n+      |glob()|.  A path separator is inserted when needed.\n+      To add a comma inside a directory name escape it with a\n+      backslash.  Note that on MS-Windows a directory may have a\n+      trailing backslash, remove it if you put a comma after it.\n+      If the expansion fails for one of the directories, there is no\n+      error message.\n+\n+      Unless the optional {nosuf} argument is given and is |TRUE|,\n+      the 'suffixes' and 'wildignore' options apply: Names matching\n+      one of the patterns in 'wildignore' will be skipped and\n+      'suffixes' affect the ordering of matches.\n+\n+      When {list} is present and it is |TRUE| the result is a |List|\n+      with all matching files. The advantage of using a List is, you\n+      also get filenames containing newlines correctly. Otherwise\n+      the result is a String and when there are several matches,\n+      they are separated by <NL> characters.  Example: >\n+      \t:echo globpath(&rtp, \"syntax/c.vim\", 0, 1)\n+      <\n+      {allinks} is used as with |glob()|.\n+\n+      The \"**\" item can be used to search in a directory tree.\n+      For example, to find all \"README.txt\" files in the directories\n+      in 'runtimepath' and below: >\n+      \t:echo globpath(&rtp, \"**/README.txt\")\n+      <Upwards search and limiting the depth of \"**\" is not\n+      supported, thus using 'path' will not always work properly.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetExpr()->globpath(&rtp)\n+      <\n+    ]=],\n+    name = 'globpath',\n+    params = {\n+      { 'path', 'string' },\n+      { 'expr', 'any' },\n+      { 'nosuf', 'boolean' },\n+      { 'list', 'any' },\n+      { 'allinks', 'any' },\n     },\n-    filereadable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filewritable={args=1, base=1, fast=true, returns=VIMBOOL},\n-    filter={args=2, base=1},\n-    finddir={args={1, 3}, base=1},\n-    findfile={args={1, 3}, base=1},\n-    flatten={args={1, 2}, base=1, returns='any[]|0'},\n-    flattennew={args={1, 2}, base=1, returns='any[]|0'},\n-    float2nr={args=1, base=1},\n-    floor={args=1, base=1, float_func=\"floor\"},\n-    fmod={args=2, base=1},\n-    fnameescape={args=1, base=1, fast=true, returns='string'},\n-    fnamemodify={args=2, base=1, fast=true, returns='string'},\n-    foldclosed={args=1, base=1, returns='integer'},\n-    foldclosedend={args=1, base=1, returns='integer'},\n-    foldlevel={args=1, base=1, returns='integer'},\n-    foldtext={returns='string'},\n-    foldtextresult={args=1, base=1, returns='string'},\n-    foreground={},\n-    fullcommand={args=1, base=1, returns='string'},\n-    funcref={args={1, 3}, base=1},\n-    ['function']={args={1, 3}, base=1},\n-    garbagecollect={args={0, 1}},\n-    get={args={2, 3}, base=1},\n-    getbufinfo={args={0, 1}, base=1},\n-    getbufline={args={2, 3}, base=1},\n-    getbufoneline={args=2, base=1},\n-    getbufvar={args={2, 3}, base=1},\n-    getcellwidths={},\n-    getchangelist={args={0, 1}, base=1},\n-    getchar={args={0, 1}, returns='integer'},\n-    getcharmod={returns='integer'},\n-    getcharpos={args=1, base=1},\n-    getcharsearch={},\n-    getcharstr={args={0, 1}, returns='string'},\n-    getcmdcompltype={returns='string'},\n-    getcmdline={returns='string'},\n-    getcmdpos={},\n-    getcmdscreenpos={},\n-    getcmdtype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcmdwintype={returns=\"':'|'>'|'/'|'?'|'@'|'-'|'='\"},\n-    getcompletion={args={2, 3}, base=1, returns='string[]'},\n-    getcurpos={args={0, 1}, base=1},\n-    getcursorcharpos={args={0, 1}, base=1},\n-    getcwd={args={0, 2}, base=1, returns='string'},\n-    getenv={args=1, base=1, returns='string'},\n-    getfontname={args={0, 1}, returns='string'},\n-    getfperm={args=1, base=1, fast=true, returns='string'},\n-    getfsize={args=1, base=1, fast=true, returns='integer'},\n-    getftime={args=1, base=1, fast=true, returns='integer'},\n-    getftype={args=1, base=1, fast=true, returns=\"'file'|'dir'|'link'|'bdev'|'cdev'|'socket'|'fifo'|'other'\"},\n-    getjumplist={args={0, 2}, base=1},\n-    getline={args={1, 2}, base=1},\n-    getloclist={args={1, 2}},\n-    getmarklist={args={0, 1}, base=1},\n-    getmatches={args={0, 1}},\n-    getmousepos={},\n-    getpid={fast=true, returns='integer'},\n-    getpos={args=1, base=1},\n-    getqflist={args={0, 1}},\n-    getreg={args={0, 3}, base=1, returns='string|string[]'},\n-    getreginfo={args={0, 1}, base=1, returns='table'},\n-    getregtype={args={0, 1}, base=1, returns='string'},\n-    gettabinfo={args={0, 1}, base=1},\n-    gettabvar={args={2, 3}, base=1},\n-    gettabwinvar={args={3, 4}, base=1},\n-    getscriptinfo={args={0, 1}},\n-    gettagstack={args={0, 1}, base=1},\n-    gettext={args=1, base=1},\n-    getwininfo={args={0, 1}, base=1},\n-    getwinpos={args={0, 1}, base=1},\n-    getwinposx={returns='integer'},\n-    getwinposy={returns='integer'},\n-    getwinvar={args={2, 3}, base=1},\n-    glob={args={1, 4}, base=1},\n-    glob2regpat={args=1, base=1},\n-    globpath={args={2, 5}, base=2},\n-    has={args=1, returns=VIMBOOL},\n-    has_key={args=2, base=1, returns=VIMBOOL},\n-    haslocaldir={args={0, 2}, base=1, returns=VIMBOOL},\n-    hasmapto={args={1, 3}, base=1, returns=VIMBOOL},\n-    highlightID={\n-      args=1, base=1, func='f_hlID',\n-      deprecated = { 'Obsolete name for |hlID()|.' }\n+    signature = 'globpath({path}, {expr} [, {nosuf} [, {list} [, {allinks}]]])',\n+  },\n+  has = {\n+    args = 1,\n+    desc = [=[\n+      Returns 1 if {feature} is supported, 0 otherwise.  The\n+      {feature} argument is a feature name like \"nvim-0.2.1\" or\n+      \"win32\", see below.  See also |exists()|.\n+\n+      To get the system name use |vim.uv|.os_uname() in Lua: >lua\n+      \tprint(vim.uv.os_uname().sysname)\n+\n+      <If the code has a syntax error then Vimscript may skip the\n+      rest of the line.  Put |:if| and |:endif| on separate lines to\n+      avoid the syntax error: >\n+      \tif has('feature')\n+      \t  let x = this->breaks->without->the->feature\n+      \tendif\n+      <\n+      Vim's compile-time feature-names (prefixed with \"+\") are not\n+      recognized because Nvim is always compiled with all possible\n+      features. |feature-compile|\n+\n+      Feature names can be:\n+      1.  Nvim version. For example the \"nvim-0.2.1\" feature means\n+          that Nvim is version 0.2.1 or later: >\n+      \t:if has(\"nvim-0.2.1\")\n+\n+      <2.  Runtime condition or other pseudo-feature. For example the\n+          \"win32\" feature checks if the current system is Windows: >\n+      \t:if has(\"win32\")\n+      <\t\t\t\t\t*feature-list*\n+          List of supported pseudo-feature names:\n+      \tacl\t\t|ACL| support.\n+      \tbsd\t\tBSD system (not macOS, use \"mac\" for that).\n+      \tclipboard\t|clipboard| provider is available.\n+      \tfname_case\tCase in file names matters (for Darwin and MS-Windows\n+      \t\t\tthis is not present).\n+                              gui_running\tNvim has a GUI.\n+      \ticonv\t\tCan use |iconv()| for conversion.\n+      \tlinux\t\tLinux system.\n+      \tmac\t\tMacOS system.\n+      \tnvim\t\tThis is Nvim.\n+      \tpython3\t\tLegacy Vim |python3| interface. |has-python|\n+      \tpythonx\t\tLegacy Vim |python_x| interface. |has-pythonx|\n+      \tsun\t\tSunOS system.\n+      \tttyin\t\tinput is a terminal (tty).\n+      \tttyout\t\toutput is a terminal (tty).\n+      \tunix\t\tUnix system.\n+      \t*vim_starting*\tTrue during |startup|.\n+      \twin32\t\tWindows system (32 or 64 bit).\n+      \twin64\t\tWindows system (64 bit).\n+      \twsl\t\tWSL (Windows Subsystem for Linux) system.\n+\n+      \t\t\t\t\t*has-patch*\n+      3.  Vim patch. For example the \"patch123\" feature means that\n+          Vim patch 123 at the current |v:version| was included: >\n+      \t:if v:version > 602 || v:version == 602 && has(\"patch148\")\n+\n+      <4.  Vim version. For example the \"patch-7.4.237\" feature means\n+          that Nvim is Vim-compatible to version 7.4.237 or later. >\n+      \t:if has(\"patch-7.4.237\")\n+      <\n+    ]=],\n+    name = 'has',\n+    params = { { 'feature', 'any' } },\n+    returns = '0|1',\n+    signature = 'has({feature})',\n+  },\n+  has_key = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if |Dictionary| {dict}\n+      has an entry with key {key}.  FALSE otherwise. The {key}\n+      argument is a string.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->has_key(key)\n+\n+    ]=],\n+    name = 'has_key',\n+    params = { { 'dict', 'any' }, { 'key', 'any' } },\n+    returns = '0|1',\n+    signature = 'has_key({dict}, {key})',\n+  },\n+  haslocaldir = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is 1 when the window has set a\n+      local path via |:lcd| or when {winnr} is -1 and the tabpage\n+      has set a local path via |:tcd|, otherwise 0.\n+\n+      Tabs and windows are identified by their respective numbers,\n+      0 means current tab or window. Missing argument implies 0.\n+      Thus the following are equivalent: >\n+      \thaslocaldir()\n+      \thaslocaldir(0)\n+      \thaslocaldir(0, 0)\n+      <With {winnr} use that window in the current tabpage.\n+      With {winnr} and {tabnr} use the window in that tabpage.\n+      {winnr} can be the window number or the |window-ID|.\n+      If {winnr} is -1 it is ignored, only the tab is resolved.\n+      Throw error if the arguments are invalid. |E5000| |E5001| |E5002|\n+\n+      Can also be used as a |method|: >\n+      \tGetWinnr()->haslocaldir()\n+\n+    ]=],\n+    name = 'haslocaldir',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = '0|1',\n+    signature = 'haslocaldir([{winnr} [, {tabnr}]])',\n+  },\n+  hasmapto = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if there is a mapping\n+      that contains {what} in somewhere in the rhs (what it is\n+      mapped to) and this mapping exists in one of the modes\n+      indicated by {mode}.\n+      The arguments {what} and {mode} are strings.\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.  Don't forget to specify Insert and/or\n+      Command-line mode.\n+      Both the global mappings and the mappings local to the current\n+      buffer are checked for a match.\n+      If no matching mapping is found FALSE is returned.\n+      The following characters are recognized in {mode}:\n+      \tn\tNormal mode\n+      \tv\tVisual and Select mode\n+      \tx\tVisual mode\n+      \ts\tSelect mode\n+      \to\tOperator-pending mode\n+      \ti\tInsert mode\n+      \tl\tLanguage-Argument (\"r\", \"f\", \"t\", etc.)\n+      \tc\tCommand-line mode\n+      When {mode} is omitted, \"nvo\" is used.\n+\n+      This function is useful to check if a mapping already exists\n+      to a function in a Vim script.  Example: >\n+      \t:if !hasmapto('\\ABCdoit')\n+      \t:   map <Leader>d \\ABCdoit\n+      \t:endif\n+      <This installs the mapping to \"\\ABCdoit\" only if there isn't\n+      already a mapping to \"\\ABCdoit\".\n+\n+      Can also be used as a |method|: >\n+      \tGetRHS()->hasmapto()\n+\n+    ]=],\n+    name = 'hasmapto',\n+    params = { { 'what', 'any' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    returns = '0|1',\n+    signature = 'hasmapto({what} [, {mode} [, {abbr}]])',\n+  },\n+  highlightID = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlID()|.\n+    ]=],\n+    func = 'f_hlID',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlightID({name})',\n+  },\n+  highlight_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |hlexists()|.\n+    ]=],\n+    func = 'f_hlexists',\n+    params = { { 'name', 'string' } },\n+    signature = 'highlight_exists({name})',\n+  },\n+  histadd = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      Add the String {item} to the history {history} which can be\n+      one of:\t\t\t\t\t*hist-names*\n+      \t\"cmd\"\t or \":\"\t  command line history\n+      \t\"search\" or \"/\"   search pattern history\n+      \t\"expr\"\t or \"=\"   typed expression history\n+      \t\"input\"  or \"@\"\t  input line history\n+      \t\"debug\"  or \">\"   debug command history\n+      \tempty\t\t  the current or last used history\n+      The {history} string does not need to be the whole name, one\n+      character is sufficient.\n+      If {item} does already exist in the history, it will be\n+      shifted to become the newest entry.\n+      The result is a Number: TRUE if the operation was successful,\n+      otherwise FALSE is returned.\n+\n+      Example: >\n+      \t:call histadd(\"input\", strftime(\"%Y %b %d\"))\n+      \t:let date=input(\"Enter date: \")\n+      <This function is not available in the |sandbox|.\n+\n+      Can also be used as a |method|, the base is passed as the\n+      second argument: >\n+      \tGetHistory()->histadd('search')\n+\n+    ]=],\n+    name = 'histadd',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histadd({history}, {item})',\n+  },\n+  histdel = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Clear {history}, i.e. delete all its entries.  See |hist-names|\n+      for the possible values of {history}.\n+\n+      If the parameter {item} evaluates to a String, it is used as a\n+      regular expression.  All entries matching that expression will\n+      be removed from the history (if there are any).\n+      Upper/lowercase must match, unless \"\\c\" is used |/\\c|.\n+      If {item} evaluates to a Number, it will be interpreted as\n+      an index, see |:history-indexing|.  The respective entry will\n+      be removed if it exists.\n+\n+      The result is TRUE for a successful operation, otherwise FALSE\n+      is returned.\n+\n+      Examples:\n+      Clear expression register history: >\n+      \t:call histdel(\"expr\")\n+      <\n+      Remove all entries starting with \"*\" from the search history: >\n+      \t:call histdel(\"/\", '^\\*')\n+      <\n+      The following three are equivalent: >\n+      \t:call histdel(\"search\", histnr(\"search\"))\n+      \t:call histdel(\"search\", -1)\n+      \t:call histdel(\"search\", '^' .. histget(\"search\", -1) .. '$')\n+      <\n+      To delete the last search pattern and use the last-but-one for\n+      the \"n\" command and 'hlsearch': >\n+      \t:call histdel(\"search\", -1)\n+      \t:let @/ = histget(\"search\", -1)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histdel()\n+\n+    ]=],\n+    name = 'histdel',\n+    params = { { 'history', 'any' }, { 'item', 'any' } },\n+    returns = '0|1',\n+    signature = 'histdel({history} [, {item}])',\n+  },\n+  histget = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, the entry with Number {index} from\n+      {history}.  See |hist-names| for the possible values of\n+      {history}, and |:history-indexing| for {index}.  If there is\n+      no such entry, an empty String is returned.  When {index} is\n+      omitted, the most recent item from the history is used.\n+\n+      Examples:\n+      Redo the second last search from history. >\n+      \t:execute '/' .. histget(\"search\", -2)\n+\n+      <Define an Ex command \":H {num}\" that supports re-execution of\n+      the {num}th entry from the output of |:history|. >\n+      \t:command -nargs=1 H execute histget(\"cmd\", 0+<args>)\n+      <\n+      Can also be used as a |method|: >\n+      \tGetHistory()->histget()\n+\n+    ]=],\n+    name = 'histget',\n+    params = { { 'history', 'any' }, { 'index', 'any' } },\n+    returns = 'string',\n+    signature = 'histget({history} [, {index}])',\n+  },\n+  histnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is the Number of the current entry in {history}.\n+      See |hist-names| for the possible values of {history}.\n+      If an error occurred, -1 is returned.\n+\n+      Example: >\n+      \t:let inp_index = histnr(\"expr\")\n+\n+      <Can also be used as a |method|: >\n+      \tGetHistory()->histnr()\n+      <\n+    ]=],\n+    name = 'histnr',\n+    params = { { 'history', 'any' } },\n+    returns = 'integer',\n+    signature = 'histnr({history})',\n+  },\n+  hlID = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the ID of the highlight group\n+      with name {name}.  When the highlight group doesn't exist,\n+      zero is returned.\n+      This can be used to retrieve information about the highlight\n+      group.  For example, to get the background color of the\n+      \"Comment\" group: >\n+      \t:echo synIDattr(synIDtrans(hlID(\"Comment\")), \"bg\")\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->hlID()\n+\n+    ]=],\n+    name = 'hlID',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'hlID({name})',\n+  },\n+  hlexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is TRUE if a highlight group\n+      called {name} exists.  This is when the group has been\n+      defined in some way.  Not necessarily when highlighting has\n+      been defined for it, it may also have been used for a syntax\n+      item.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->hlexists()\n+      <\n+    ]=],\n+    name = 'hlexists',\n+    params = { { 'name', 'string' } },\n+    returns = '0|1',\n+    signature = 'hlexists({name})',\n+  },\n+  hostname = {\n+    desc = [=[\n+      The result is a String, which is the name of the machine on\n+      which Vim is currently running.  Machine names greater than\n+      256 characters long are truncated.\n+\n+    ]=],\n+    fast = true,\n+    name = 'hostname',\n+    params = {},\n+    returns = 'string',\n+    signature = 'hostname()',\n+  },\n+  iconv = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is the text {string} converted\n+      from encoding {from} to encoding {to}.\n+      When the conversion completely fails an empty string is\n+      returned.  When some characters could not be converted they\n+      are replaced with \"?\".\n+      The encoding names are whatever the iconv() library function\n+      can accept, see \":!man 3 iconv\".\n+      Note that Vim uses UTF-8 for all Unicode encodings, conversion\n+      from/to UCS-2 is automatically changed to use UTF-8.  You\n+      cannot use UCS-2 in a string anyway, because of the NUL bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->iconv('latin1', 'utf-8')\n+      <\n+    ]=],\n+    fast = true,\n+    name = 'iconv',\n+    params = { { 'string', 'string' }, { 'from', 'any' }, { 'to', 'any' } },\n+    signature = 'iconv({string}, {from}, {to})',\n+  },\n+  id = {\n+    args = 1,\n+    desc = [=[\n+      Returns a |String| which is a unique identifier of the\n+      container type (|List|, |Dict|, |Blob| and |Partial|). It is\n+      guaranteed that for the mentioned types `id(v1) ==# id(v2)`\n+      returns true iff `type(v1) == type(v2) && v1 is v2`.\n+      Note that |v:_null_string|, |v:_null_list|, |v:_null_dict| and\n+      |v:_null_blob| have the same `id()` with different types\n+      because they are internally represented as NULL pointers.\n+      `id()` returns a hexadecimal representanion of the pointers to\n+      the containers (i.e. like `0x994a40`), same as `printf(\"%p\",\n+      {expr})`, but it is advised against counting on the exact\n+      format of the return value.\n+\n+      It is not guaranteed that `id(no_longer_existing_container)`\n+      will not be equal to some other `id()`: new containers may\n+      reuse identifiers of the garbage-collected ones.\n+\n+    ]=],\n+    name = 'id',\n+    params = { { 'expr', 'any' } },\n+    signature = 'id({expr})',\n+  },\n+  indent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      current buffer.  The indent is counted in spaces, the value\n+      of 'tabstop' is relevant.  {lnum} is used just like in\n+      |getline()|.\n+      When {lnum} is invalid -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->indent()\n+\n+    ]=],\n+    name = 'indent',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'indent({lnum})',\n+  },\n+  index = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Find {expr} in {object} and return its index.  See\n+      |indexof()| for using a lambda to select the item.\n+\n+      If {object} is a |List| return the lowest index where the item\n+      has a value equal to {expr}.  There is no automatic\n+      conversion, so the String \"4\" is different from the Number 4.\n+      And the Number 4 is different from the Float 4.0.  The value\n+      of 'ignorecase' is not used here, case matters as indicated by\n+      the {ic} argument.\n+\n+      If {object} is a |Blob| return the lowest index where the byte\n+      value is equal to {expr}.\n+\n+      If {start} is given then start looking at the item with index\n+      {start} (may be negative for an item relative to the end).\n+\n+      When {ic} is given and it is |TRUE|, ignore case.  Otherwise\n+      case must match.\n+\n+      -1 is returned when {expr} is not found in {object}.\n+      Example: >\n+      \t:let idx = index(words, \"the\")\n+      \t:if index(numbers, 123) >= 0\n+\n+      <Can also be used as a |method|: >\n+      \tGetObject()->index(what)\n+\n+    ]=],\n+    name = 'index',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'start', 'any' }, { 'ic', 'any' } },\n+    signature = 'index({object}, {expr} [, {start} [, {ic}]])',\n+  },\n+  indexof = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Returns the index of an item in {object} where {expr} is\n+      v:true.  {object} must be a |List| or a |Blob|.\n+\n+      If {object} is a |List|, evaluate {expr} for each item in the\n+      List until the expression is v:true and return the index of\n+      this item.\n+\n+      If {object} is a |Blob| evaluate {expr} for each byte in the\n+      Blob until the expression is v:true and return the index of\n+      this byte.\n+\n+      {expr} must be a |string| or |Funcref|.\n+\n+      If {expr} is a |string|: If {object} is a |List|, inside\n+      {expr} |v:key| has the index of the current List item and\n+      |v:val| has the value of the item.  If {object} is a |Blob|,\n+      inside {expr} |v:key| has the index of the current byte and\n+      |v:val| has the byte value.\n+\n+      If {expr} is a |Funcref| it must take two arguments:\n+      \t1. the key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return |TRUE| if the item is found and the\n+      search should stop.\n+\n+      The optional argument {opts} is a Dict and supports the\n+      following items:\n+          startidx\tstart evaluating {expr} at the item with this\n+      \t\tindex; may be negative for an item relative to\n+      \t\tthe end\n+      Returns -1 when {expr} evaluates to v:false for all the items.\n+      Example: >\n+      \t:let l = [#{n: 10}, #{n: 20}, #{n: 30}]\n+      \t:echo indexof(l, \"v:val.n == 20\")\n+      \t:echo indexof(l, {i, v -> v.n == 30})\n+      \t:echo indexof(l, \"v:val.n == 20\", #{startidx: 1})\n+\n+      <Can also be used as a |method|: >\n+      \tmylist->indexof(expr)\n+\n+    ]=],\n+    name = 'indexof',\n+    params = { { 'object', 'any' }, { 'expr', 'any' }, { 'opts', 'table' } },\n+    signature = 'indexof({object}, {expr} [, {opts}])',\n+  },\n+  input = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = '',\n+    name = 'input',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' }, { 'completion', 'any' } },\n+    signature = 'input({prompt} [, {text} [, {completion}]])',\n+  },\n+  input__1 = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      The result is a String, which is whatever the user typed on\n+      the command-line.  The {prompt} argument is either a prompt\n+      string, or a blank string (for no prompt).  A '\\n' can be used\n+      in the prompt to start a new line.\n+\n+      In the second form it accepts a single dictionary with the\n+      following keys, any of which may be omitted:\n+\n+      Key           Default  Description ~\n+      prompt        \"\"       Same as {prompt} in the first form.\n+      default       \"\"       Same as {text} in the first form.\n+      completion    nothing  Same as {completion} in the first form.\n+      cancelreturn  \"\"       The value returned when the dialog is\n+                             cancelled.\n+      highlight     nothing  Highlight handler: |Funcref|.\n+\n+      The highlighting set with |:echohl| is used for the prompt.\n+      The input is entered just like a command-line, with the same\n+      editing commands and mappings.  There is a separate history\n+      for lines typed for input().\n+      Example: >\n+      \t:if input(\"Coffee or beer? \") == \"beer\"\n+      \t:  echo \"Cheers!\"\n+      \t:endif\n+      <\n+      If the optional {text} argument is present and not empty, this\n+      is used for the default reply, as if the user typed this.\n+      Example: >\n+      \t:let color = input(\"Color? \", \"white\")\n+\n+      <The optional {completion} argument specifies the type of\n+      completion supported for the input.  Without it completion is\n+      not performed.  The supported completion types are the same as\n+      that can be supplied to a user-defined command using the\n+      \"-complete=\" argument.  Refer to |:command-completion| for\n+      more information.  Example: >\n+      \tlet fname = input(\"File: \", \"\", \"file\")\n+\n+      <\t\t\t*input()-highlight* *E5400* *E5402*\n+      The optional `highlight` key allows specifying function which\n+      will be used for highlighting user input.  This function\n+      receives user input as its only argument and must return\n+      a list of 3-tuples [hl_start_col, hl_end_col + 1, hl_group]\n+      where\n+      \thl_start_col is the first highlighted column,\n+      \thl_end_col is the last highlighted column (+ 1!),\n+      \thl_group is |:hi| group used for highlighting.\n+      \t\t\t      *E5403* *E5404* *E5405* *E5406*\n+      Both hl_start_col and hl_end_col + 1 must point to the start\n+      of the multibyte character (highlighting must not break\n+      multibyte characters), hl_end_col + 1 may be equal to the\n+      input length.  Start column must be in range [0, len(input)),\n+      end column must be in range (hl_start_col, len(input)],\n+      sections must be ordered so that next hl_start_col is greater\n+      then or equal to previous hl_end_col.\n+\n+      Example (try some input with parentheses): >\n+      \thighlight RBP1 guibg=Red ctermbg=red\n+      \thighlight RBP2 guibg=Yellow ctermbg=yellow\n+      \thighlight RBP3 guibg=Green ctermbg=green\n+      \thighlight RBP4 guibg=Blue ctermbg=blue\n+      \tlet g:rainbow_levels = 4\n+      \tfunction! RainbowParens(cmdline)\n+      \t  let ret = []\n+      \t  let i = 0\n+      \t  let lvl = 0\n+      \t  while i < len(a:cmdline)\n+      \t    if a:cmdline[i] is# '('\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t      let lvl += 1\n+      \t    elseif a:cmdline[i] is# ')'\n+      \t      let lvl -= 1\n+      \t      call add(ret, [i, i + 1, 'RBP' .. ((lvl % g:rainbow_levels) + 1)])\n+      \t    endif\n+      \t    let i += 1\n+      \t  endwhile\n+      \t  return ret\n+      \tendfunction\n+      \tcall input({'prompt':'>','highlight':'RainbowParens'})\n+      <\n+      Highlight function is called at least once for each new\n+      displayed input string, before command-line is redrawn.  It is\n+      expected that function is pure for the duration of one input()\n+      call, i.e. it produces the same output for the same input, so\n+      output may be memoized.  Function is run like under |:silent|\n+      modifier. If the function causes any errors, it will be\n+      skipped for the duration of the current input() call.\n+\n+      Highlighting is disabled if command-line contains arabic\n+      characters.\n+\n+      NOTE: This function must not be used in a startup file, for\n+      the versions that only run in GUI mode (e.g., the Win32 GUI).\n+      Note: When input() is called from within a mapping it will\n+      consume remaining characters from that mapping, because a\n+      mapping is handled like the characters were typed.\n+      Use |inputsave()| before input() and |inputrestore()|\n+      after input() to avoid that.  Another solution is to avoid\n+      that further characters follow in the mapping, e.g., by using\n+      |:execute| or |:normal|.\n+\n+      Example with a mapping: >\n+      \t:nmap \\x :call GetFoo()<CR>:exe \"/\" .. Foo<CR>\n+      \t:function GetFoo()\n+      \t:  call inputsave()\n+      \t:  let g:Foo = input(\"enter search pattern: \")\n+      \t:  call inputrestore()\n+      \t:endfunction\n+\n+      <Can also be used as a |method|: >\n+      \tGetPrompt()->input()\n+\n+    ]=],\n+    name = 'input',\n+    params = { { 'opts', 'table' } },\n+    signature = 'input({opts})',\n+  },\n+  inputdialog = {\n+    args = { 1, 3 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Use |input()| instead.\n+    ]=],\n+    params = VARARGS,\n+    signature = 'input(...)',\n+  },\n+  inputlist = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      {textlist} must be a |List| of strings.  This |List| is\n+      displayed, one string per line.  The user will be prompted to\n+      enter a number, which is returned.\n+      The user can also select an item by clicking on it with the\n+      mouse, if the mouse is enabled in the command line ('mouse' is\n+      \"a\" or includes \"c\").  For the first string 0 is returned.\n+      When clicking above the first item a negative number is\n+      returned.  When clicking on the prompt one more than the\n+      length of {textlist} is returned.\n+      Make sure {textlist} has less than 'lines' entries, otherwise\n+      it won't work.  It's a good idea to put the entry number at\n+      the start of the string.  And put a prompt in the first item.\n+      Example: >\n+      \tlet color = inputlist(['Select color:', '1. red',\n+      \t\t\\ '2. green', '3. blue'])\n+\n+      <Can also be used as a |method|: >\n+      \tGetChoices()->inputlist()\n+\n+    ]=],\n+    name = 'inputlist',\n+    params = { { 'textlist', 'any' } },\n+    signature = 'inputlist({textlist})',\n+  },\n+  inputrestore = {\n+    desc = [=[\n+      Restore typeahead that was saved with a previous |inputsave()|.\n+      Should be called the same number of times inputsave() is\n+      called.  Calling it more often is harmless though.\n+      Returns TRUE when there is nothing to restore, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputrestore',\n+    params = {},\n+    signature = 'inputrestore()',\n+  },\n+  inputsave = {\n+    desc = [=[\n+      Preserve typeahead (also from mappings) and clear it, so that\n+      a following prompt gets input from the user.  Should be\n+      followed by a matching inputrestore() after the prompt.  Can\n+      be used several times, in which case there must be just as\n+      many inputrestore() calls.\n+      Returns TRUE when out of memory, FALSE otherwise.\n+\n+    ]=],\n+    name = 'inputsave',\n+    params = {},\n+    signature = 'inputsave()',\n+  },\n+  inputsecret = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      This function acts much like the |input()| function with but\n+      two exceptions:\n+      a) the user's response will be displayed as a sequence of\n+      asterisks (\"*\") thereby keeping the entry secret, and\n+      b) the user's response will not be recorded on the input\n+      |history| stack.\n+      The result is a String, which is whatever the user actually\n+      typed on the command-line in response to the issued prompt.\n+      NOTE: Command-line completion is not supported.\n+\n+      Can also be used as a |method|: >\n+      \tGetPrompt()->inputsecret()\n+\n+    ]=],\n+    name = 'inputsecret',\n+    params = { { 'prompt', 'any' }, { 'text', 'any' } },\n+    signature = 'inputsecret({prompt} [, {text}])',\n+  },\n+  insert = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When {object} is a |List| or a |Blob| insert {item} at the start\n+      of it.\n+\n+      If {idx} is specified insert {item} before the item with index\n+      {idx}.  If {idx} is zero it goes before the first item, just\n+      like omitting {idx}.  A negative {idx} is also possible, see\n+      |list-index|.  -1 inserts just before the last item.\n+\n+      Returns the resulting |List| or |Blob|.  Examples: >\n+      \t:let mylist = insert([2, 3, 5], 1)\n+      \t:call insert(mylist, 4, -1)\n+      \t:call insert(mylist, 6, len(mylist))\n+      <The last example can be done simpler with |add()|.\n+      Note that when {item} is a |List| it is inserted as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->insert(item)\n+\n+    ]=],\n+    name = 'insert',\n+    params = { { 'object', 'any' }, { 'item', 'any' }, { 'idx', 'integer' } },\n+    signature = 'insert({object}, {item} [, {idx}])',\n+  },\n+  interrupt = {\n+    args = 0,\n+    desc = [=[\n+      Interrupt script execution.  It works more or less like the\n+      user typing CTRL-C, most commands won't execute and control\n+      returns to the user.  This is useful to abort execution\n+      from lower down, e.g. in an autocommand.  Example: >\n+      :function s:check_typoname(file)\n+      :   if fnamemodify(a:file, ':t') == '['\n+      :       echomsg 'Maybe typo'\n+      :       call interrupt()\n+      :   endif\n+      :endfunction\n+      :au BufWritePre * call s:check_typoname(expand('<amatch>'))\n+\n+    ]=],\n+    name = 'interrupt',\n+    params = {},\n+    signature = 'interrupt()',\n+  },\n+  invert = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Bitwise invert.  The argument is converted to a number.  A\n+      List, Dict or Float argument causes an error.  Example: >\n+      \t:let bits = invert(bits)\n+      <Can also be used as a |method|: >\n+      \t:let bits = bits->invert()\n+\n+    ]=],\n+    name = 'invert',\n+    params = { { 'expr', 'any' } },\n+    signature = 'invert({expr})',\n+  },\n+  isdirectory = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when a directory\n+      with the name {directory} exists.  If {directory} doesn't\n+      exist, or isn't a directory, the result is |FALSE|.  {directory}\n+      is any expression, which is used as a String.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->isdirectory()\n+\n+    ]=],\n+    fast = true,\n+    name = 'isdirectory',\n+    params = { { 'directory', 'any' } },\n+    returns = '0|1',\n+    signature = 'isdirectory({directory})',\n+  },\n+  isinf = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return 1 if {expr} is a positive infinity, or -1 a negative\n+      infinity, otherwise 0. >\n+      \t:echo isinf(1.0 / 0.0)\n+      <\t1 >\n+      \t:echo isinf(-1.0 / 0.0)\n+      <\t-1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isinf()\n+\n+    ]=],\n+    name = 'isinf',\n+    params = { { 'expr', 'any' } },\n+    returns = '1|0|-1',\n+    signature = 'isinf({expr})',\n+  },\n+  islocked = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| when {expr} is the\n+      name of a locked variable.\n+      The string argument {expr} must be the name of a variable,\n+      |List| item or |Dictionary| entry, not the variable itself!\n+      Example: >\n+      \t:let alist = [0, ['a', 'b'], 2, 3]\n+      \t:lockvar 1 alist\n+      \t:echo islocked('alist')\t\t\" 1\n+      \t:echo islocked('alist[1]')\t\" 0\n+\n+      <When {expr} is a variable that does not exist you get an error\n+      message.  Use |exists()| to check for existence.\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->islocked()\n+\n+    ]=],\n+    name = 'islocked',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'islocked({expr})',\n+    tags = { 'E786' },\n+  },\n+  isnan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return |TRUE| if {expr} is a float with value NaN. >\n+      \techo isnan(0.0 / 0.0)\n+      <\t1\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->isnan()\n+\n+    ]=],\n+    name = 'isnan',\n+    params = { { 'expr', 'any' } },\n+    returns = '0|1',\n+    signature = 'isnan({expr})',\n+  },\n+  items = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the key-value pairs of {dict}.  Each\n+      |List| item is a list with two items: the key of a {dict}\n+      entry and the value of this entry.  The |List| is in arbitrary\n+      order.  Also see |keys()| and |values()|.\n+      Example: >\n+      \tfor [key, value] in items(mydict)\n+      \t   echo key .. ': ' .. value\n+      \tendfor\n+\n+      <Can also be used as a |method|: >\n+      \tmydict->items()\n+\n+    ]=],\n+    name = 'items',\n+    params = { { 'dict', 'any' } },\n+    signature = 'items({dict})',\n+  },\n+  jobclose = {\n+    args = { 1, 2 },\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chanclose()|\n+    ]=],\n+    func = 'f_chanclose',\n+    params = VARARGS,\n+    signature = 'jobclose({id} [, {stream}])',\n+  },\n+  jobpid = {\n+    args = 1,\n+    desc = [=[\n+      Return the PID (process id) of |job-id| {job}.\n+\n+    ]=],\n+    name = 'jobpid',\n+    params = { { 'job', 'any' } },\n+    returns = 'integer',\n+    signature = 'jobpid({job})',\n+  },\n+  jobresize = {\n+    args = 3,\n+    desc = [=[\n+      Resize the pseudo terminal window of |job-id| {job} to {width}\n+      columns and {height} rows.\n+      Fails if the job was not started with `\"pty\":v:true`.\n+\n+    ]=],\n+    name = 'jobresize',\n+    params = { { 'job', 'any' }, { 'width', 'integer' }, { 'height', 'integer' } },\n+    signature = 'jobresize({job}, {width}, {height})',\n+  },\n+  jobsend = {\n+    args = 2,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |chansend()|\n+    ]=],\n+    func = 'f_chansend',\n+    params = VARARGS,\n+    signature = 'jobsend({id}, {data})',\n+  },\n+  jobstart = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Note: Prefer |vim.system()| in Lua.\n+\n+      Spawns {cmd} as a job.\n+      If {cmd} is a List it runs directly (no 'shell').\n+      If {cmd} is a String it runs in the 'shell', like this: >\n+        :call jobstart(split(&shell) + split(&shellcmdflag) + ['{cmd}'])\n+      <(See |shell-unquoting| for details.)\n+\n+      Example: >\n+        :call jobstart('nvim -h', {'on_stdout':{j,d,e->append(line('.'),d)}})\n+      <\n+      Returns |job-id| on success, 0 on invalid arguments (or job\n+      table is full), -1 if {cmd}[0] or 'shell' is not executable.\n+      The returned job-id is a valid |channel-id| representing the\n+      job's stdio streams. Use |chansend()| (or |rpcnotify()| and\n+      |rpcrequest()| if \"rpc\" was enabled) to send data to stdin and\n+      |chanclose()| to close the streams without stopping the job.\n+\n+      See |job-control| and |RPC|.\n+\n+      NOTE: on Windows if {cmd} is a List:\n+        - cmd[0] must be an executable (not a \"built-in\"). If it is\n+          in $PATH it can be called by name, without an extension: >\n+            :call jobstart(['ping', 'neovim.io'])\n+      <    If it is a full or partial path, extension is required: >\n+            :call jobstart(['System32\\ping.exe', 'neovim.io'])\n+      <  - {cmd} is collapsed to a string of quoted args as expected\n+          by CommandLineToArgvW https://msdn.microsoft.com/bb776391\n+          unless cmd[0] is some form of \"cmd.exe\".\n+\n+      \t\t\t\t\t*jobstart-env*\n+      The job environment is initialized as follows:\n+        $NVIM                is set to |v:servername| of the parent Nvim\n+        $NVIM_LISTEN_ADDRESS is unset\n+        $NVIM_LOG_FILE       is unset\n+        $VIM                 is unset\n+        $VIMRUNTIME          is unset\n+      You can set these with the `env` option.\n+\n+      \t\t\t\t\t*jobstart-options*\n+      {opts} is a dictionary with these keys:\n+        clear_env:  (boolean) `env` defines the job environment\n+      \t      exactly, instead of merging current environment.\n+        cwd:\t      (string, default=|current-directory|) Working\n+      \t      directory of the job.\n+        detach:     (boolean) Detach the job process: it will not be\n+      \t      killed when Nvim exits. If the process exits\n+      \t      before Nvim, `on_exit` will be invoked.\n+        env:\t      (dict) Map of environment variable name:value\n+      \t      pairs extending (or replace with \"clear_env\")\n+      \t      the current environment. |jobstart-env|\n+        height:     (number) Height of the `pty` terminal.\n+        |on_exit|:    (function) Callback invoked when the job exits.\n+        |on_stdout|:  (function) Callback invoked when the job emits\n+      \t      stdout data.\n+        |on_stderr|:  (function) Callback invoked when the job emits\n+      \t      stderr data.\n+        overlapped: (boolean) Sets FILE_FLAG_OVERLAPPED for the\n+      \t      stdio passed to the child process. Only on\n+      \t      MS-Windows; ignored on other platforms.\n+        pty:\t      (boolean) Connect the job to a new pseudo\n+      \t      terminal, and its streams to the master file\n+      \t      descriptor. `on_stdout` receives all output,\n+      \t      `on_stderr` is ignored. |terminal-start|\n+        rpc:\t      (boolean) Use |msgpack-rpc| to communicate with\n+      \t      the job over stdio. Then `on_stdout` is ignored,\n+      \t      but `on_stderr` can still be used.\n+        stderr_buffered: (boolean) Collect data until EOF (stream closed)\n+      \t      before invoking `on_stderr`. |channel-buffered|\n+        stdout_buffered: (boolean) Collect data until EOF (stream\n+      \t      closed) before invoking `on_stdout`. |channel-buffered|\n+        stdin:      (string) Either \"pipe\" (default) to connect the\n+      \t      job's stdin to a channel or \"null\" to disconnect\n+      \t      stdin.\n+        width:      (number) Width of the `pty` terminal.\n+\n+      {opts} is passed as |self| dictionary to the callback; the\n+      caller may set other keys to pass application-specific data.\n+\n+      Returns:\n+        - |channel-id| on success\n+        - 0 on invalid arguments\n+        - -1 if {cmd}[0] is not executable.\n+      See also |job-control|, |channel|, |msgpack-rpc|.\n+\n+    ]=],\n+    name = 'jobstart',\n+    params = { { 'cmd', 'any' }, { 'opts', 'table' } },\n+    signature = 'jobstart({cmd} [, {opts}])',\n+  },\n+  jobstop = {\n+    args = 1,\n+    desc = [=[\n+      Stop |job-id| {id} by sending SIGTERM to the job process. If\n+      the process does not terminate after a timeout then SIGKILL\n+      will be sent. When the job terminates its |on_exit| handler\n+      (if any) will be invoked.\n+      See |job-control|.\n+\n+      Returns 1 for valid job id, 0 for invalid id, including jobs have\n+      exited or stopped.\n+\n+    ]=],\n+    name = 'jobstop',\n+    params = { { 'id', 'any' } },\n+    signature = 'jobstop({id})',\n+  },\n+  jobwait = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      Waits for jobs and their |on_exit| handlers to complete.\n+\n+      {jobs} is a List of |job-id|s to wait for.\n+      {timeout} is the maximum waiting time in milliseconds. If\n+      omitted or -1, wait forever.\n+\n+      Timeout of 0 can be used to check the status of a job: >\n+      \tlet running = jobwait([{job-id}], 0)[0] == -1\n+      <\n+      During jobwait() callbacks for jobs not in the {jobs} list may\n+      be invoked. The screen will not redraw unless |:redraw| is\n+      invoked by a callback.\n+\n+      Returns a list of len({jobs}) integers, where each integer is\n+      the status of the corresponding job:\n+      \tExit-code, if the job exited\n+      \t-1 if the timeout was exceeded\n+      \t-2 if the job was interrupted (by |CTRL-C|)\n+      \t-3 if the job-id is invalid\n+\n+    ]=],\n+    name = 'jobwait',\n+    params = { { 'jobs', 'any' }, { 'timeout', 'integer' } },\n+    signature = 'jobwait({jobs} [, {timeout}])',\n+  },\n+  join = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Join the items in {list} together into one String.\n+      When {sep} is specified it is put in between the items.  If\n+      {sep} is omitted a single space is used.\n+      Note that {sep} is not added at the end.  You might want to\n+      add it there too: >\n+      \tlet lines = join(mylist, \"\\n\") .. \"\\n\"\n+      <String items are used as-is.  |Lists| and |Dictionaries| are\n+      converted into a string like with |string()|.\n+      The opposite function is |split()|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->join()\n+\n+    ]=],\n+    name = 'join',\n+    params = { { 'list', 'any' }, { 'sep', 'any' } },\n+    signature = 'join({list} [, {sep}])',\n+  },\n+  json_decode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} from JSON object.  Accepts |readfile()|-style\n+      list as the input, as well as regular string.  May output any\n+      Vim value. In the following cases it will output\n+      |msgpack-special-dict|:\n+      1. Dictionary contains duplicate key.\n+      2. Dictionary contains empty key.\n+      3. String contains NUL byte.  Two special dictionaries: for\n+         dictionary and for string will be emitted in case string\n+         with NUL byte was a dictionary key.\n+\n+      Note: function treats its input as UTF-8 always.  The JSON\n+      standard allows only a few encodings, of which UTF-8 is\n+      recommended and the only one required to be supported.\n+      Non-UTF-8 characters are an error.\n+\n+      Can also be used as a |method|: >\n+      \tReadObject()->json_decode()\n+\n+    ]=],\n+    name = 'json_decode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_decode({expr})',\n+  },\n+  json_encode = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Convert {expr} into a JSON string.  Accepts\n+      |msgpack-special-dict| as the input.  Will not convert\n+      |Funcref|s, mappings with non-string keys (can be created as\n+      |msgpack-special-dict|), values with self-referencing\n+      containers, strings which contain non-UTF-8 characters,\n+      pseudo-UTF-8 strings which contain codepoints reserved for\n+      surrogate pairs (such strings are not valid UTF-8 strings).\n+      Non-printable characters are converted into \"\\u1234\" escapes\n+      or special escapes like \"\\t\", other are dumped as-is.\n+      |Blob|s are converted to arrays of the individual bytes.\n+\n+      Can also be used as a |method|: >\n+      \tGetObject()->json_encode()\n+\n+    ]=],\n+    name = 'json_encode',\n+    params = { { 'expr', 'any' } },\n+    signature = 'json_encode({expr})',\n+  },\n+  keys = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a |List| with all the keys of {dict}.  The |List| is in\n+      arbitrary order.  Also see |items()| and |values()|.\n+\n+      Can also be used as a |method|: >\n+      \tmydict->keys()\n+\n+    ]=],\n+    name = 'keys',\n+    params = { { 'dict', 'any' } },\n+    signature = 'keys({dict})',\n+  },\n+  keytrans = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Turn the internal byte representation of keys into a form that\n+      can be used for |:map|.  E.g. >\n+      \t:let xx = \"\\<C-Home>\"\n+      \t:echo keytrans(xx)\n+      <\t<C-Home>\n+\n+      Can also be used as a |method|: >\n+      \t\"\\<C-Home>\"->keytrans()\n+      <\n+    ]=],\n+    name = 'keytrans',\n+    params = { { 'string', 'string' } },\n+    signature = 'keytrans({string})',\n+  },\n+  last_buffer_nr = {\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for bufnr(\"$\").\n+    ]=],\n+    params = {},\n+    signature = 'last_buffer_nr()',\n+  },\n+  len = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a String or a Number the length in bytes is\n+      used, as with |strlen()|.\n+      When {expr} is a |List| the number of items in the |List| is\n+      returned.\n+      When {expr} is a |Blob| the number of bytes is returned.\n+      When {expr} is a |Dictionary| the number of entries in the\n+      |Dictionary| is returned.\n+      Otherwise an error is given and returns zero.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->len()\n+      <\n+    ]=],\n+    name = 'len',\n+    params = { { 'expr', 'any' } },\n+    signature = 'len({expr})',\n+    tags = { 'E701' },\n+  },\n+  libcall = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Call function {funcname} in the run-time library {libname}\n+      with single argument {argument}.\n+      This is useful to call functions in a library that you\n+      especially made to be used with Vim.  Since only one argument\n+      is possible, calling standard library functions is rather\n+      limited.\n+      The result is the String returned by the function.  If the\n+      function returns NULL, this will appear as an empty string \"\"\n+      to Vim.\n+      If the function returns a number, use libcallnr()!\n+      If {argument} is a number, it is passed to the function as an\n+      int; if {argument} is a string, it is passed as a\n+      null-terminated string.\n+\n+      libcall() allows you to write your own 'plug-in' extensions to\n+      Vim without having to recompile the program.  It is NOT a\n+      means to call system functions!  If you try to do so Vim will\n+      very probably crash.\n+\n+      For Win32, the functions you write must be placed in a DLL\n+      and use the normal C calling convention (NOT Pascal which is\n+      used in Windows System DLLs).  The function must take exactly\n+      one parameter, either a character pointer or a long integer,\n+      and must return a character pointer or NULL.  The character\n+      pointer returned must point to memory that will remain valid\n+      after the function has returned (e.g. in static data in the\n+      DLL).  If it points to allocated memory, that memory will\n+      leak away.  Using a static buffer in the function should work,\n+      it's then freed when the DLL is unloaded.\n+\n+      WARNING: If the function returns a non-valid pointer, Vim may\n+      crash!\tThis also happens if the function returns a number,\n+      because Vim thinks it's a pointer.\n+      For Win32 systems, {libname} should be the filename of the DLL\n+      without the \".DLL\" suffix.  A full path is only required if\n+      the DLL is not in the usual places.\n+      For Unix: When compiling your own plugins, remember that the\n+      object code must be compiled as position-independent ('PIC').\n+      Examples: >\n+      \t:echo libcall(\"libc.so\", \"getenv\", \"HOME\")\n+\n+      <Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcall(\"libc.so\", \"getenv\")\n+      <\n+    ]=],\n+    name = 'libcall',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcall({libname}, {funcname}, {argument})',\n+    tags = { 'E364', 'E368' },\n+  },\n+  libcallnr = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Just like |libcall()|, but used for a function that returns an\n+      int instead of a string.\n+      Examples: >\n+      \t:echo libcallnr(\"/usr/lib/libc.so\", \"getpid\", \"\")\n+      \t:call libcallnr(\"libc.so\", \"printf\", \"Hello World!\\n\")\n+      \t:call libcallnr(\"libc.so\", \"sleep\", 10)\n+      <\n+      Can also be used as a |method|, the base is passed as the\n+      third argument: >\n+      \tGetValue()->libcallnr(\"libc.so\", \"printf\")\n+      <\n+    ]=],\n+    name = 'libcallnr',\n+    params = { { 'libname', 'string' }, { 'funcname', 'string' }, { 'argument', 'any' } },\n+    signature = 'libcallnr({libname}, {funcname}, {argument})',\n+  },\n+  line = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the line number of the file\n+      position given with {expr}.  The {expr} argument is a string.\n+      The accepted positions are:\n+          .\t    the cursor position\n+          $\t    the last line in the current buffer\n+          'x\t    position of mark x (if the mark is not set, 0 is\n+      \t    returned)\n+          w0\t    first line visible in current window (one if the\n+      \t    display isn't updated, e.g. in silent Ex mode)\n+          w$\t    last line visible in current window (this is one\n+      \t    less than \"w0\" if no lines are visible)\n+          v\t    In Visual mode: the start of the Visual area (the\n+      \t    cursor is the end).  When not in Visual mode\n+      \t    returns the cursor position.  Differs from |'<| in\n+      \t    that it's updated right away.\n+      Note that a mark in another file can be used.  The line number\n+      then applies to another buffer.\n+      To get the column number use |col()|.  To get both use\n+      |getpos()|.\n+      With the optional {winid} argument the values are obtained for\n+      that window instead of the current window.\n+      Returns 0 for invalid values of {expr} and {winid}.\n+      Examples: >\n+      \tline(\".\")\t\tline number of the cursor\n+      \tline(\".\", winid)\tidem, in window \"winid\"\n+      \tline(\"'t\")\t\tline number of mark t\n+      \tline(\"'\" .. marker)\tline number of mark marker\n+      <\n+      To jump to the last known position when opening a file see\n+      |last-position-jump|.\n+\n+      Can also be used as a |method|: >\n+      \tGetValue()->line()\n+\n+    ]=],\n+    name = 'line',\n+    params = { { 'expr', 'any' }, { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line({expr} [, {winid}])',\n+  },\n+  line2byte = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the byte count from the start of the buffer for line\n+      {lnum}.  This includes the end-of-line character, depending on\n+      the 'fileformat' option for the current buffer.  The first\n+      line returns 1. UTF-8 encoding is used, 'fileencoding' is\n+      ignored.  This can also be used to get the byte count for the\n+      line just below the last line: >\n+      \tline2byte(line(\"$\") + 1)\n+      <This is the buffer size plus one.  If 'fileencoding' is empty\n+      it is the file size plus one.  {lnum} is used like with\n+      |getline()|.  When {lnum} is invalid -1 is returned.\n+      Also see |byte2line()|, |go| and |:goto|.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->line2byte()\n+\n+    ]=],\n+    name = 'line2byte',\n+    params = { { 'lnum', 'integer' } },\n+    returns = 'integer',\n+    signature = 'line2byte({lnum})',\n+  },\n+  lispindent = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Get the amount of indent for line {lnum} according the lisp\n+      indenting rules, as with 'lisp'.\n+      The indent is counted in spaces, the value of 'tabstop' is\n+      relevant.  {lnum} is used just like in |getline()|.\n+      When {lnum} is invalid, -1 is returned.\n+\n+      Can also be used as a |method|: >\n+      \tGetLnum()->lispindent()\n+\n+    ]=],\n+    name = 'lispindent',\n+    params = { { 'lnum', 'integer' } },\n+    signature = 'lispindent({lnum})',\n+  },\n+  list2blob = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a Blob concatenating all the number values in {list}.\n+      Examples: >\n+      \tlist2blob([1, 2, 3, 4])\treturns 0z01020304\n+      \tlist2blob([])\t\treturns 0z\n+      <Returns an empty Blob on error.  If one of the numbers is\n+      negative or more than 255 error *E1239* is given.\n+\n+      |blob2list()| does the opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2blob()\n+\n+    ]=],\n+    name = 'list2blob',\n+    params = { { 'list', 'any' } },\n+    signature = 'list2blob({list})',\n+  },\n+  list2str = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Convert each number in {list} to a character string can\n+      concatenate them all.  Examples: >\n+      \tlist2str([32])\t\treturns \" \"\n+      \tlist2str([65, 66, 67])\treturns \"ABC\"\n+      <The same can be done (slowly) with: >\n+      \tjoin(map(list, {nr, val -> nr2char(val)}), '')\n+      <|str2list()| does the opposite.\n+\n+      UTF-8 encoding is always used, {utf8} option has no effect,\n+      and exists only for backwards-compatibility.\n+      With UTF-8 composing characters work as expected: >\n+      \tlist2str([97, 769])\treturns \"a\"\n+      <\n+      Returns an empty string on error.\n+\n+      Can also be used as a |method|: >\n+      \tGetList()->list2str()\n+\n+    ]=],\n+    name = 'list2str',\n+    params = { { 'list', 'any' }, { 'utf8', 'any' } },\n+    signature = 'list2str({list} [, {utf8}])',\n+  },\n+  localtime = {\n+    desc = [=[\n+      Return the current time, measured as seconds since 1st Jan\n+      1970.  See also |strftime()|, |strptime()| and |getftime()|.\n+    ]=],\n+    name = 'localtime',\n+    params = {},\n+    signature = 'localtime()',\n+  },\n+  log = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the natural logarithm (base e) of {expr} as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      (0, inf].\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log(10)\n+      <\t2.302585 >\n+      \t:echo log(exp(5))\n+      <\t5.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log()\n+\n+    ]=],\n+    float_func = 'log',\n+    name = 'log',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log({expr})',\n+  },\n+  log10 = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the logarithm of Float {expr} to base 10 as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo log10(1000)\n+      <\t3.0 >\n+      \t:echo log10(0.01)\n+      <\t-2.0\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->log10()\n+\n+    ]=],\n+    float_func = 'log10',\n+    name = 'log10',\n+    params = { { 'expr', 'any' } },\n+    signature = 'log10({expr})',\n+  },\n+  luaeval = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Evaluate Lua expression {expr} and return its result converted\n+      to Vim data structures. See |lua-eval| for more details.\n+\n+      Can also be used as a |method|: >\n+      \tGetExpr()->luaeval()\n+      <\n+    ]=],\n+    lua = false,\n+    name = 'luaeval',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    signature = 'luaeval({expr} [, {expr}])',\n+  },\n+  map = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      {expr1} must be a |List|, |Blob| or |Dictionary|.\n+      Replace each item in {expr1} with the result of evaluating\n+      {expr2}.  For a |Blob| each byte is replaced.\n+\n+      {expr2} must be a |string| or |Funcref|.\n+\n+      If {expr2} is a |string|, inside {expr2} |v:val| has the value\n+      of the current item.  For a |Dictionary| |v:key| has the key\n+      of the current item and for a |List| |v:key| has the index of\n+      the current item.  For a |Blob| |v:key| has the index of the\n+      current byte.\n+      Example: >\n+      \t:call map(mylist, '\"> \" .. v:val .. \" <\"')\n+      <This puts \"> \" before and \" <\" after each item in \"mylist\".\n+\n+      Note that {expr2} is the result of an expression and is then\n+      used as an expression again.  Often it is good to use a\n+      |literal-string| to avoid having to double backslashes.  You\n+      still have to double ' quotes\n+\n+      If {expr2} is a |Funcref| it is called with two arguments:\n+      \t1. The key or the index of the current item.\n+      \t2. the value of the current item.\n+      The function must return the new value of the item. Example\n+      that changes each value by \"key-value\": >\n+      \tfunc KeyValue(key, val)\n+      \t  return a:key .. '-' .. a:val\n+      \tendfunc\n+      \tcall map(myDict, function('KeyValue'))\n+      <It is shorter when using a |lambda|: >\n+      \tcall map(myDict, {key, val -> key .. '-' .. val})\n+      <If you do not use \"val\" you can leave it out: >\n+      \tcall map(myDict, {key -> 'item: ' .. key})\n+      <If you do not use \"key\" you can use a short name: >\n+      \tcall map(myDict, {_, val -> 'item: ' .. val})\n+      <\n+      The operation is done in-place.  If you want a |List| or\n+      |Dictionary| to remain unmodified make a copy first: >\n+      \t:let tlist = map(copy(mylist), ' v:val .. \"\\t\"')\n+\n+      <Returns {expr1}, the |List|, |Blob| or |Dictionary| that was\n+      filtered.  When an error is encountered while evaluating\n+      {expr2} no further items in {expr1} are processed.  When\n+      {expr2} is a Funcref errors inside a function are ignored,\n+      unless it was defined with the \"abort\" flag.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->map(expr2)\n+      <\n+    ]=],\n+    name = 'map',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    signature = 'map({expr1}, {expr2})',\n+  },\n+  maparg = {\n+    args = { 1, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {dict} is omitted or zero: Return the rhs of mapping\n+      {name} in mode {mode}.  The returned String has special\n+      characters translated like in the output of the \":map\" command\n+      listing.\n+\n+      When there is no mapping for {name}, an empty String is\n+      returned if {dict} is FALSE, otherwise returns an empty Dict.\n+      When the mapping for {name} is empty, then \"<Nop>\" is\n+      returned.\n+\n+      The {name} can have special key names, like in the \":map\"\n+      command.\n+\n+      {mode} can be one of these strings:\n+      \t\"n\"\tNormal\n+      \t\"v\"\tVisual (including Select)\n+      \t\"o\"\tOperator-pending\n+      \t\"i\"\tInsert\n+      \t\"c\"\tCmd-line\n+      \t\"s\"\tSelect\n+      \t\"x\"\tVisual\n+      \t\"l\"\tlangmap |language-mapping|\n+      \t\"t\"\tTerminal\n+      \t\"\"\tNormal, Visual and Operator-pending\n+      When {mode} is omitted, the modes for \"\" are used.\n+\n+      When {abbr} is there and it is |TRUE| use abbreviations\n+      instead of mappings.\n+\n+      When {dict} is there and it is |TRUE| return a dictionary\n+      containing all the information of the mapping with the\n+      following items:\n+        \"lhs\"\t     The {lhs} of the mapping as it would be typed\n+        \"lhsraw\"   The {lhs} of the mapping as raw bytes\n+        \"lhsrawalt\" The {lhs} of the mapping as raw bytes, alternate\n+      \t      form, only present when it differs from \"lhsraw\"\n+        \"rhs\"\t     The {rhs} of the mapping as typed.\n+        \"silent\"   1 for a |:map-silent| mapping, else 0.\n+        \"noremap\"  1 if the {rhs} of the mapping is not remappable.\n+        \"script\"   1 if mapping was defined with <script>.\n+        \"expr\"     1 for an expression mapping (|:map-<expr>|).\n+        \"buffer\"   1 for a buffer local mapping (|:map-local|).\n+        \"mode\"     Modes for which the mapping is defined. In\n+      \t     addition to the modes mentioned above, these\n+      \t     characters will be used:\n+      \t     \" \"     Normal, Visual and Operator-pending\n+      \t     \"!\"     Insert and Commandline mode\n+      \t\t     (|mapmode-ic|)\n+        \"sid\"\t     The script local ID, used for <sid> mappings\n+      \t     (|<SID>|).  Negative for special contexts.\n+        \"lnum\"     The line number in \"sid\", zero if unknown.\n+        \"nowait\"   Do not wait for other, longer mappings.\n+      \t     (|:map-<nowait>|).\n+\n+      The dictionary can be used to restore a mapping with\n+      |mapset()|.\n+\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to map a key even when it's already\n+      mapped, and have it do the original mapping too.  Sketch: >\n+      \texe 'nnoremap <Tab> ==' .. maparg('<Tab>', 'n')\n+\n+      <Can also be used as a |method|: >\n+      \tGetKey()->maparg('n')\n+\n+    ]=],\n+    name = 'maparg',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'boolean' }, { 'dict', 'boolean' } },\n+    returns = 'string|table<string,any>',\n+    signature = 'maparg({name} [, {mode} [, {abbr} [, {dict}]]])',\n+  },\n+  mapcheck = {\n+    args = { 1, 3 },\n+    base = 1,\n+    desc = [=[\n+      Check if there is a mapping that matches with {name} in mode\n+      {mode}.  See |maparg()| for {mode} and special names in\n+      {name}.\n+      When {abbr} is there and it is non-zero use abbreviations\n+      instead of mappings.\n+      A match happens with a mapping that starts with {name} and\n+      with a mapping which is equal to the start of {name}.\n+\n+      \tmatches mapping \"a\"\t\"ab\"\t\"abc\" ~\n+         mapcheck(\"a\")\tyes\tyes\t yes\n+         mapcheck(\"abc\")\tyes\tyes\t yes\n+         mapcheck(\"ax\")\tyes\tno\t no\n+         mapcheck(\"b\")\tno\tno\t no\n+\n+      The difference with maparg() is that mapcheck() finds a\n+      mapping that matches with {name}, while maparg() only finds a\n+      mapping for {name} exactly.\n+      When there is no mapping that starts with {name}, an empty\n+      String is returned.  If there is one, the RHS of that mapping\n+      is returned.  If there are several mappings that start with\n+      {name}, the RHS of one of them is returned.  This will be\n+      \"<Nop>\" if the RHS is empty.\n+      The mappings local to the current buffer are checked first,\n+      then the global mappings.\n+      This function can be used to check if a mapping can be added\n+      without being ambiguous.  Example: >\n+      \t:if mapcheck(\"_vv\") == \"\"\n+      \t:   map _vv :set guifont=7x13<CR>\n+      \t:endif\n+      <This avoids adding the \"_vv\" mapping when there already is a\n+      mapping for \"_v\" or for \"_vvv\".\n+\n+      Can also be used as a |method|: >\n+      \tGetKey()->mapcheck('n')\n+\n+    ]=],\n+    name = 'mapcheck',\n+    params = { { 'name', 'string' }, { 'mode', 'string' }, { 'abbr', 'any' } },\n+    signature = 'mapcheck({name} [, {mode} [, {abbr}]])',\n+  },\n+  mapset = {\n+    args = 3,\n+    base = 1,\n+    desc = [=[\n+      Restore a mapping from a dictionary returned by |maparg()|.\n+      {mode} and {abbr} should be the same as for the call to\n+      |maparg()|. *E460*\n+      {mode} is used to define the mode in which the mapping is set,\n+      not the \"mode\" entry in {dict}.\n+      Example for saving and restoring a mapping: >\n+      \tlet save_map = maparg('K', 'n', 0, 1)\n+      \tnnoremap K somethingelse\n+      \t...\n+      \tcall mapset('n', 0, save_map)\n+      <Note that if you are going to replace a map in several modes,\n+      e.g. with `:map!`, you need to save the mapping for all of\n+      them, since they can differ.\n+    ]=],\n+    name = 'mapset',\n+    params = { { 'mode', 'string' }, { 'abbr', 'any' }, { 'dict', 'any' } },\n+    signature = 'mapset({mode}, {abbr}, {dict})',\n+  },\n+  match = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      When {expr} is a |List| then this returns the index of the\n+      first item where {pat} matches.  Each item is used as a\n+      String, |Lists| and |Dictionaries| are used as echoed.\n+\n+      Otherwise, {expr} is used as a String.  The result is a\n+      Number, which gives the index (byte offset) in {expr} where\n+      {pat} matches.\n+\n+      A match at the first character or |List| item returns zero.\n+      If there is no match -1 is returned.\n+\n+      For getting submatches see |matchlist()|.\n+      Example: >\n+      \t:echo match(\"testing\", \"ing\")\t\" results in 4\n+      \t:echo match([1, 'x'], '\\a')\t\" results in 1\n+      <See |string-match| for how {pat} is used.\n+      \t\t\t\t\t\t*strpbrk()*\n+      Vim doesn't have a strpbrk() function.  But you can do: >\n+      \t:let sepidx = match(line, '[.,;: \\t]')\n+      <\t\t\t\t\t\t*strcasestr()*\n+      Vim doesn't have a strcasestr() function.  But you can add\n+      \"\\c\" to the pattern to ignore case: >\n+      \t:let idx = match(haystack, '\\cneedle')\n+      <\n+      If {start} is given, the search starts from byte index\n+      {start} in a String or item {start} in a |List|.\n+      The result, however, is still the index counted from the\n+      first character/item.  Example: >\n+      \t:echo match(\"testing\", \"ing\", 2)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"ing\", 4)\n+      <result is again \"4\". >\n+      \t:echo match(\"testing\", \"t\", 2)\n+      <result is \"3\".\n+      For a String, if {start} > 0 then it is like the string starts\n+      {start} bytes later, thus \"^\" will match at {start}.  Except\n+      when {count} is given, then it's like matches before the\n+      {start} byte are ignored (this is a bit complicated to keep it\n+      backwards compatible).\n+      For a String, if {start} < 0, it will be set to 0.  For a list\n+      the index is counted from the end.\n+      If {start} is out of range ({start} > strlen({expr}) for a\n+      String or {start} > len({expr}) for a |List|) -1 is returned.\n+\n+      When {count} is given use the {count}th match.  When a match\n+      is found in a String the search for the next one starts one\n+      character further.  Thus this example results in 1: >\n+      \techo match(\"testing\", \"..\", 0, 2)\n+      <In a |List| the search continues in the next item.\n+      Note that when {count} is added the way {start} works changes,\n+      see above.\n+\n+      See |pattern| for the patterns that are accepted.\n+      The 'ignorecase' option is used to set the ignore-caseness of\n+      the pattern.  'smartcase' is NOT used.  The matching is always\n+      done like 'magic' is set and 'cpoptions' is empty.\n+      Note that a match at the start is preferred, thus when the\n+      pattern is using \"*\" (any number of matches) it tends to find\n+      zero matches at the start instead of a number of matches\n+      further down in the text.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->match('word')\n+      \tGetList()->match('word')\n+      <\n+    ]=],\n+    name = 'match',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'match({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchadd = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Defines a pattern to be highlighted in the current window (a\n+      \"match\").  It will be highlighted with {group}.  Returns an\n+      identification number (ID), which can be used to delete the\n+      match using |matchdelete()|.  The ID is bound to the window.\n+      Matching is case sensitive and magic, unless case sensitivity\n+      or magicness are explicitly overridden in {pattern}.  The\n+      'magic', 'smartcase' and 'ignorecase' options are not used.\n+      The \"Conceal\" value is special, it causes the match to be\n+      concealed.\n+\n+      The optional {priority} argument assigns a priority to the\n+      match.  A match with a high priority will have its\n+      highlighting overrule that of a match with a lower priority.\n+      A priority is specified as an integer (negative numbers are no\n+      exception).  If the {priority} argument is not specified, the\n+      default priority is 10.  The priority of 'hlsearch' is zero,\n+      hence all matches with a priority greater than zero will\n+      overrule it.  Syntax highlighting (see 'syntax') is a separate\n+      mechanism, and regardless of the chosen priority a match will\n+      always overrule syntax highlighting.\n+\n+      The optional {id} argument allows the request for a specific\n+      match ID.  If a specified ID is already taken, an error\n+      message will appear and the match will not be added.  An ID\n+      is specified as a positive integer (zero excluded).  IDs 1, 2\n+      and 3 are reserved for |:match|, |:2match| and |:3match|,\n+      respectively.  3 is reserved for use by the |matchparen|\n+      plugin.\n+      If the {id} argument is not specified or -1, |matchadd()|\n+      automatically chooses a free ID, which is at least 1000.\n+\n+      The optional {dict} argument allows for further custom\n+      values. Currently this is used to specify a match specific\n+      conceal character that will be shown for |hl-Conceal|\n+      highlighted matches. The dict can have the following members:\n+\n+      \tconceal\t    Special character to show instead of the\n+      \t\t    match (only for |hl-Conceal| highlighted\n+      \t\t    matches, see |:syn-cchar|)\n+      \twindow\t    Instead of the current window use the\n+      \t\t    window with this number or window ID.\n+\n+      The number of matches is not limited, as it is the case with\n+      the |:match| commands.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchadd(\"MyGroup\", \"TODO\")\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <A list of matches defined by |matchadd()| and |:match| are\n+      available from |getmatches()|.  All matches can be deleted in\n+      one operation by |clearmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchadd('TODO')\n+      <\n+    ]=],\n+    name = 'matchadd',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pattern', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    highlight_exists={\n-      args=1, base=1, func='f_hlexists',\n-      deprecated = { 'Obsolete name for |hlexists()|.' }\n+    signature = 'matchadd({group}, {pattern} [, {priority} [, {id} [, {dict}]]])',\n+    tags = { 'E798', 'E799', 'E801', 'E957' },\n+  },\n+  matchaddpos = {\n+    args = { 2, 5 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchadd()|, but requires a list of positions {pos}\n+      instead of a pattern. This command is faster than |matchadd()|\n+      because it does not require to handle regular expressions and\n+      sets buffer line boundaries to redraw screen. It is supposed\n+      to be used when fast match additions and deletions are\n+      required, for example to highlight matching parentheses.\n+      \t\t\t\t\t*E5030* *E5031*\n+      {pos} is a list of positions.  Each position can be one of\n+      these:\n+      - A number.  This whole line will be highlighted.  The first\n+        line has number 1.\n+      - A list with one number, e.g., [23]. The whole line with this\n+        number will be highlighted.\n+      - A list with two numbers, e.g., [23, 11]. The first number is\n+        the line number, the second one is the column number (first\n+        column is 1, the value must correspond to the byte index as\n+        |col()| would return).  The character at this position will\n+        be highlighted.\n+      - A list with three numbers, e.g., [23, 11, 3]. As above, but\n+        the third number gives the length of the highlight in bytes.\n+\n+      Entries with zero and negative line numbers are silently\n+      ignored, as well as entries with negative column numbers and\n+      lengths.\n+\n+      Returns -1 on error.\n+\n+      Example: >\n+      \t:highlight MyGroup ctermbg=green guibg=green\n+      \t:let m = matchaddpos(\"MyGroup\", [[23, 24], 34])\n+      <Deletion of the pattern: >\n+      \t:call matchdelete(m)\n+\n+      <Matches added by |matchaddpos()| are returned by\n+      |getmatches()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetGroup()->matchaddpos([23, 11])\n+\n+    ]=],\n+    name = 'matchaddpos',\n+    params = {\n+      { 'group', 'any' },\n+      { 'pos', 'any' },\n+      { 'priority', 'any' },\n+      { 'id', 'any' },\n+      { 'dict', 'any' },\n     },\n-    histadd={args=2, base=2, returns=VIMBOOL},\n-    histdel={args={1, 2}, base=1, returns=VIMBOOL},\n-    histget={args={1, 2}, base=1, returns='string'},\n-    histnr={args=1, base=1, returns='integer'},\n-    hlID={args=1, base=1, returns='integer'},\n-    hlexists={args=1, base=1, returns=VIMBOOL},\n-    hostname={fast=true, returns='string'},\n-    iconv={args=3, base=1, fast=true},\n-    indent={args=1, base=1, returns='integer'},\n-    index={args={2, 4}, base=1},\n-    indexof={args={2, 3}, base=1},\n-    input={args={1, 3}, base=1},\n-    inputdialog={\n-      args={1, 3}, base=1,\n-      deprecated = { 'Use |input()| instead.' }\n+    signature = 'matchaddpos({group}, {pos} [, {priority} [, {id} [, {dict}]]])',\n+  },\n+  matcharg = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Selects the {nr} match item, as set with a |:match|,\n+      |:2match| or |:3match| command.\n+      Return a |List| with two elements:\n+      \tThe name of the highlight group used\n+      \tThe pattern used.\n+      When {nr} is not 1, 2 or 3 returns an empty |List|.\n+      When there is no match item set returns ['', ''].\n+      This is useful to save and restore a |:match|.\n+      Highlighting matches using the |:match| commands are limited\n+      to three matches. |matchadd()| does not have this limitation.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matcharg()\n+\n+    ]=],\n+    name = 'matcharg',\n+    params = { { 'nr', 'integer' } },\n+    signature = 'matcharg({nr})',\n+  },\n+  matchdelete = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      Deletes a match with ID {id} previously defined by |matchadd()|\n+      or one of the |:match| commands.  Returns 0 if successful,\n+      otherwise -1.  See example for |matchadd()|.  All matches can\n+      be deleted in one operation by |clearmatches()|.\n+      If {win} is specified, use the window with this number or\n+      window ID instead of the current window.\n+\n+      Can also be used as a |method|: >\n+      \tGetMatch()->matchdelete()\n+\n+    ]=],\n+    name = 'matchdelete',\n+    params = { { 'id', 'any' }, { 'win', 'any' } },\n+    signature = 'matchdelete({id} [, {win}])',\n+    tags = { 'E802', 'E803' },\n+  },\n+  matchend = {\n+    args = { 2, 4 },\n+    base = 1,\n+    desc = [=[\n+      Same as |match()|, but return the index of first character\n+      after the match.  Example: >\n+      \t:echo matchend(\"testing\", \"ing\")\n+      <results in \"7\".\n+      \t\t\t\t\t*strspn()* *strcspn()*\n+      Vim doesn't have a strspn() or strcspn() function, but you can\n+      do it with matchend(): >\n+      \t:let span = matchend(line, '[a-zA-Z]')\n+      \t:let span = matchend(line, '[^a-zA-Z]')\n+      <Except that -1 is returned when there are no matches.\n+\n+      The {start}, if given, has the same meaning as for |match()|. >\n+      \t:echo matchend(\"testing\", \"ing\", 2)\n+      <results in \"7\". >\n+      \t:echo matchend(\"testing\", \"ing\", 5)\n+      <result is \"-1\".\n+      When {expr} is a |List| the result is equal to |match()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetText()->matchend('word')\n+\n+    ]=],\n+    name = 'matchend',\n+    params = { { 'expr', 'any' }, { 'pat', 'any' }, { 'start', 'any' }, { 'count', 'any' } },\n+    signature = 'matchend({expr}, {pat} [, {start} [, {count}]])',\n+  },\n+  matchfuzzy = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      If {list} is a list of strings, then returns a |List| with all\n+      the strings in {list} that fuzzy match {str}. The strings in\n+      the returned list are sorted based on the matching score.\n+\n+      The optional {dict} argument always supports the following\n+      items:\n+          matchseq\tWhen this item is present return only matches\n+      \t\tthat contain the characters in {str} in the\n+      \t\tgiven sequence.\n+          limit\tMaximum number of matches in {list} to be\n+      \t\treturned.  Zero means no limit.\n+\n+      If {list} is a list of dictionaries, then the optional {dict}\n+      argument supports the following additional items:\n+          key\t\tKey of the item which is fuzzy matched against\n+      \t\t{str}. The value of this item should be a\n+      \t\tstring.\n+          text_cb\t|Funcref| that will be called for every item\n+      \t\tin {list} to get the text for fuzzy matching.\n+      \t\tThis should accept a dictionary item as the\n+      \t\targument and return the text for that item to\n+      \t\tuse for fuzzy matching.\n+\n+      {str} is treated as a literal string and regular expression\n+      matching is NOT supported.  The maximum supported {str} length\n+      is 256.\n+\n+      When {str} has multiple words each separated by white space,\n+      then the list of strings that have all the words is returned.\n+\n+      If there are no matching strings or there is an error, then an\n+      empty list is returned. If length of {str} is greater than\n+      256, then returns an empty list.\n+\n+      When {limit} is given, matchfuzzy() will find up to this\n+      number of matches in {list} and return them in sorted order.\n+\n+      Refer to |fuzzy-matching| for more information about fuzzy\n+      matching strings.\n+\n+      Example: >\n+         :echo matchfuzzy([\"clay\", \"crow\"], \"cay\")\n+      <results in [\"clay\"]. >\n+         :echo getbufinfo()->map({_, v -> v.name})->matchfuzzy(\"ndl\")\n+      <results in a list of buffer names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"ndl\", {'key' : 'name'})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"ndl\". >\n+         :echo getbufinfo()->matchfuzzy(\"spl\",\n+      \t\t\t\t\\ {'text_cb' : {v -> v.name}})\n+      <results in a list of buffer information dicts with buffer\n+      names fuzzy matching \"spl\". >\n+         :echo v:oldfiles->matchfuzzy(\"test\")\n+      <results in a list of file names fuzzy matching \"test\". >\n+         :let l = readfile(\"buffer.c\")->matchfuzzy(\"str\")\n+      <results in a list of lines in \"buffer.c\" fuzzy matching \"str\". >\n+         :echo ['one two', 'two one']->matchfuzzy('two one')\n+      <results in `['two one', 'one two']` . >\n+         :echo ['one two', 'two one']->matchfuzzy('two one',\n+      \t\t\t\t\\ {'matchseq': 1})\n+      <results in `['two one']`.\n+\n+    ]=],\n+    name = 'matchfuzzy',\n+    params = { { 'list', 'any' }, { 'str', 'any' }, { 'dict', 'any' } },\n+    signature = 'matchfuzzy({list}, {str} [, {dict}])',\n+  },\n+  matchfuzzypos = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Same as |matchfuzzy()|, but returns the list of matched\n+      strings, the list of character positions where characters\n+      in {str} matches and a list of matching scores.  You can\n+      use |byteidx()| to convert a character position to a byte\n+      position.\n+\n+      If {str} matches multiple times in a string, then only the\n+      positions for the best match is returned.\n+\n+      If there are no matching strings or there is an error, then a\n+      list with three empty list items is returned.\n+\n+      Example: >\n+      \t:echo matchfuzzypos(['testing'], 'tsg')\n+      <results in [[\"testing\"], [[0, 2, 6]], [99]] >\n+      \t:echo matchfuzzypos(['clay', 'lacy'], 'la')\n+      <results in [[\"lacy\", \"clay\"], [[0, 1], [1, 2]], [153, 133]] >\n+      \t:echo ",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277421168",
            "id": 1277421168,
            "in_reply_to_id": 1277413279,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MI-Zw",
            "original_commit_id": "9ae17e2a633d34f79ff0ac030b5abf3d979bc75c",
            "original_line": 8275,
            "original_position": 8490,
            "original_start_line": 7095,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1551901908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277421168/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-07-28T11:16:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277421168",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277469439"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277469439"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      <\r\n```",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T12:08:48Z",
            "diff_hunk": "@@ -11,502 +12,13428 @@\n ---       Defaults to BASE_NONE (function cannot be used as a method).\n --- @field func? string Name of the C function which implements the Vimscript function. Defaults to\n ---       `f_{funcname}`.\n+--- @field float_func? string\n --- @field fast? boolean Function can run in |api-fast| events. Defaults to false.\n---- @field deprecated? string[]\n+--- @field deprecated? true\n --- @field returns? string|false\n+--- @field signature string\n+--- @field desc? string\n+--- @field params {[1]:string, [2]:string}[]\n+--- @field lua? false Do not render type information\n+--- @field tags? string[] Extra tags\n+--- @field data? string Used by gen_eval.lua\n \n -- Usable with the base key: use the last function argument as the method base.\n -- Value is from funcs.h file. \"BASE_\" prefix is omitted.\n -- local LAST = \"BASE_LAST\" (currently unused after port of v8.2.1168)\n \n-local VIMBOOL = '0|1'\n-\n-return {\n-  --- @type table<string,vim.EvalFn>\n-  funcs={\n-    abs={args=1, base=1},\n-    acos={args=1, base=1, float_func=\"acos\", returns='number'},  -- WJMc\n-    add={args=2, base=1},\n-    ['and']={args=2, base=1},\n-    api_info={fast=true},\n-    append={args=2, base=2},\n-    appendbufline={args=3, base=3},\n-    argc={args={0, 1}, returns='integer'},\n-    argidx={returns='integer'},\n-    arglistid={args={0, 2}, returns='integer'},\n-    argv={args={0, 2}},\n-    asin={args=1, base=1, float_func=\"asin\"},  -- WJMc\n-    assert_beeps={args=1, base=1, returns=VIMBOOL},\n-    assert_equal={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_equalfile={args={2, 3}, base=1},\n-    assert_exception={args={1, 2}, returns=VIMBOOL},\n-    assert_fails={args={1, 5}, base=1, returns=VIMBOOL},\n-    assert_false={args={1, 2}, base=1, returns=VIMBOOL},\n-    assert_inrange={args={3, 4}, base=3, returns=VIMBOOL},\n-    assert_match={args={2, 3}, base=2, returns=VIMBOOL},\n-    assert_nobeep={args=1, base=1, returns=VIMBOOL},\n-    assert_notequal={args={2, 3}, base=2},\n-    assert_notmatch={args={2, 3}, base=2},\n-    assert_report={args=1, base=1},\n-    assert_true={args={1, 2}, base=1},\n-    atan={args=1, base=1, float_func=\"atan\", returns='number'},\n-    atan2={args=2, base=1, returns='number'},\n-    blob2list={args=1, base=1},\n-    browse={args=4},\n-    browsedir={args=2},\n-    bufadd={args=1, base=1, returns='integer'},\n-    bufexists={args=1, base=1, returns=VIMBOOL},\n-    buffer_exists={\n-      args=1, base=1, func='f_bufexists',\n-      deprecated = { 'Obsolete name for |bufexists()|.' }\n+local M = {}\n+\n+local VARARGS = { { '...', 'any' } }\n+\n+--- @type table<string,vim.EvalFn>\n+M.funcs = {\n+  abs = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the absolute value of {expr}.  When {expr} evaluates to\n+      a |Float| abs() returns a |Float|.  When {expr} can be\n+      converted to a |Number| abs() returns a |Number|.  Otherwise\n+      abs() gives an error message and returns -1.\n+      Examples: >\n+      \techo abs(1.456)\n+      <\t1.456  >\n+      \techo abs(-5.456)\n+      <\t5.456  >\n+      \techo abs(-4)\n+      <\t4\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->abs()\n+\n+    ]=],\n+    name = 'abs',\n+    params = { { 'expr', 'any' } },\n+    signature = 'abs({expr})',\n+    returns = 'number'\n+  },\n+  acos = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc cosine of {expr} measured in radians, as a\n+      |Float| in the range of [0, pi].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo acos(0)\n+      <\t1.570796 >\n+      \t:echo acos(-0.5)\n+      <\t2.094395\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->acos()\n+\n+    ]=],\n+    float_func = 'acos',\n+    name = 'acos',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'acos({expr})',\n+  },\n+  add = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Append the item {expr} to |List| or |Blob| {object}.  Returns\n+      the resulting |List| or |Blob|.  Examples: >\n+      \t:let alist = add([1, 2, 3], item)\n+      \t:call add(mylist, \"woodstock\")\n+      <Note that when {expr} is a |List| it is appended as a single\n+      item.  Use |extend()| to concatenate |Lists|.\n+      When {object} is a |Blob| then {expr} must be a number.\n+      Use |insert()| to add an item at another position.\n+      Returns 1 if {object} is not a |List| or a |Blob|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->add(val1)->add(val2)\n+\n+    ]=],\n+    name = 'add',\n+    params = { { 'object', 'any' }, { 'expr', 'any' } },\n+    returns = 'any',\n+    signature = 'add({object}, {expr})',\n+  },\n+  ['and'] = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Bitwise AND on the two arguments.  The arguments are converted\n+      to a number.  A List, Dict or Float argument causes an error.\n+      Also see `or()` and `xor()`.\n+      Example: >\n+      \t:let flag = and(bits, 0x80)\n+      <Can also be used as a |method|: >\n+      \t:let flag = bits->and(0x80)\n+\n+    ]=],\n+    name = 'and',\n+    params = { { 'expr', 'any' }, { 'expr', 'any' } },\n+    returns = 'integer',\n+    signature = 'and({expr}, {expr})',\n+  },\n+  api_info = {\n+    desc = [=[\n+      Returns Dictionary of |api-metadata|.\n+\n+      View it in a nice human-readable format: >\n+             :lua vim.print(vim.fn.api_info())\n+\n+    ]=],\n+    fast = true,\n+    name = 'api_info',\n+    params = {},\n+    returns = 'table',\n+    signature = 'api_info()',\n+  },\n+  append = {\n+    args = 2,\n+    base = 2,\n+    desc = [=[\n+      When {text} is a |List|: Append each item of the |List| as a\n+      text line below line {lnum} in the current buffer.\n+      Otherwise append {text} as one text line below line {lnum} in\n+      the current buffer.\n+      Any type of item is accepted and converted to a String.\n+      {lnum} can be zero to insert a line before the first one.\n+      {lnum} is used like with |getline()|.\n+      Returns 1 for failure ({lnum} out of range or out of memory),\n+      0 for success.  Example: >\n+      \t:let failed = append(line('$'), \"# THE END\")\n+      \t:let failed = append(0, [\"Chapter 1\", \"the beginning\"])\n+\n+      <Can also be used as a |method| after a List: >\n+      \tmylist->append(lnum)\n+\n+    ]=],\n+    name = 'append',\n+    params = { { 'lnum', 'integer' }, { 'text', 'any' } },\n+    returns = '0|1',\n+    signature = 'append({lnum}, {text})',\n+  },\n+  appendbufline = {\n+    args = 3,\n+    base = 3,\n+    desc = [=[\n+      Like |append()| but append the text in buffer {expr}.\n+\n+      This function works only for loaded buffers. First call\n+      |bufload()| if needed.\n+\n+      For the use of {buf}, see |bufname()|.\n+\n+      {lnum} is the line number to append below.  Note that using\n+      |line()| would use the current buffer, not the one appending\n+      to.  Use \"$\" to append at the end of the buffer.  Other string\n+      values are not supported.\n+\n+      On success 0 is returned, on failure 1 is returned.\n+\n+      If {buf} is not a valid buffer or {lnum} is not valid, an\n+      error message is given. Example: >\n+      \t:let failed = appendbufline(13, 0, \"# THE START\")\n+      <\n+      Can also be used as a |method| after a List: >\n+      \tmylist->appendbufline(buf, lnum)\n+\n+    ]=],\n+    name = 'appendbufline',\n+    params = { { 'buf', 'any' }, { 'lnum', 'integer' }, { 'text', 'string' } },\n+    returns = '0|1',\n+    signature = 'appendbufline({buf}, {lnum}, {text})',\n+  },\n+  argc = {\n+    args = { 0, 1 },\n+    desc = [=[\n+      The result is the number of files in the argument list.  See\n+      |arglist|.\n+      If {winid} is not supplied, the argument list of the current\n+      window is used.\n+      If {winid} is -1, the global argument list is used.\n+      Otherwise {winid} specifies the window of which the argument\n+      list is used: either the window number or the window ID.\n+      Returns -1 if the {winid} argument is invalid.\n+    ]=],\n+    name = 'argc',\n+    params = { { 'winid', 'integer' } },\n+    returns = 'integer',\n+    signature = 'argc([{winid}])',\n+  },\n+  argidx = {\n+    desc = [=[\n+      The result is the current index in the argument list.  0 is\n+      the first file.  argc() - 1 is the last one.  See |arglist|.\n+    ]=],\n+    name = 'argidx',\n+    params = {},\n+    returns = 'integer',\n+    signature = 'argidx()',\n+  },\n+  arglistid = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      Return the argument list ID.  This is a number which\n+      identifies the argument list being used.  Zero is used for the\n+      global argument list.  See |arglist|.\n+      Returns -1 if the arguments are invalid.\n+\n+      Without arguments use the current window.\n+      With {winnr} only use this window in the current tab page.\n+      With {winnr} and {tabnr} use the window in the specified tab\n+      page.\n+      {winnr} can be the window number or the |window-ID|.\n+    ]=],\n+    name = 'arglistid',\n+    params = { { 'winnr', 'integer' }, { 'tabnr', 'integer' } },\n+    returns = 'integer',\n+    signature = 'arglistid([{winnr} [, {tabnr}]])',\n+  },\n+  argv = {\n+    args = { 0, 2 },\n+    desc = [=[\n+      The result is the {nr}th file in the argument list.  See\n+      |arglist|.  \"argv(0)\" is the first one.  Example: >\n+      \t:let i = 0\n+      \t:while i < argc()\n+      \t:  let f = escape(fnameescape(argv(i)), '.')\n+      \t:  exe 'amenu Arg.' .. f .. ' :e ' .. f .. '<CR>'\n+      \t:  let i = i + 1\n+      \t:endwhile\n+      <Without the {nr} argument, or when {nr} is -1, a |List| with\n+      the whole |arglist| is returned.\n+\n+      The {winid} argument specifies the window ID, see |argc()|.\n+      For the Vim command line arguments see |v:argv|.\n+\n+      Returns an empty string if {nr}th argument is not present in\n+      the argument list.  Returns an empty List if the {winid}\n+      argument is invalid.\n+\n+    ]=],\n+    name = 'argv',\n+    params = { { 'nr', 'integer' }, { 'winid', 'integer' } },\n+    returns = 'string|string[]',\n+    signature = 'argv([{nr} [, {winid}]])',\n+  },\n+  asin = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the arc sine of {expr} measured in radians, as a |Float|\n+      in the range of [-pi/2, pi/2].\n+      {expr} must evaluate to a |Float| or a |Number| in the range\n+      [-1, 1].\n+      Returns NaN if {expr} is outside the range [-1, 1].  Returns\n+      0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo asin(0.8)\n+      <\t0.927295 >\n+      \t:echo asin(-0.5)\n+      <\t-0.523599\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->asin()\n+      <\n+    ]=],\n+    float_func = 'asin',\n+    name = 'asin',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'asin({expr})',\n+  },\n+  assert_beeps = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce a beep or visual bell.\n+      Also see |assert_fails()|, |assert_nobeep()| and\n+      |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_beeps()\n+      <\n+    ]=],\n+    name = 'assert_beeps',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_beeps({cmd})',\n+  },\n+  assert_equal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {expected} and {actual} are not equal an error message is\n+      added to |v:errors| and 1 is returned.  Otherwise zero is\n+      returned. |assert-return|\n+      The error is in the form \"Expected {expected} but got\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      There is no automatic conversion, the String \"4\" is different\n+      from the Number 4.  And the number 4 is different from the\n+      Float 4.0.  The value of 'ignorecase' is not used here, case\n+      always matters.\n+      Example: >\n+      \tassert_equal('foo', 'bar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Expected 'foo' but got 'bar' ~\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_equal([1, 2, 3])\n+    ]=],\n+    name = 'assert_equal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_equal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_equalfile = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      When the files {fname-one} and {fname-two} do not contain\n+      exactly the same text an error message is added to |v:errors|.\n+      Also see |assert-return|.\n+      When {fname-one} or {fname-two} does not exist the error will\n+      mention that.\n+\n+      Can also be used as a |method|: >\n+      \tGetLog()->assert_equalfile('expected.log')\n+    ]=],\n+    name = 'assert_equalfile',\n+    params = {},\n+    returns = '0|1',\n+    signature = 'assert_equalfile({fname-one}, {fname-two})',\n+  },\n+  assert_exception = {\n+    args = { 1, 2 },\n+    desc = [=[\n+      When v:exception does not contain the string {error} an error\n+      message is added to |v:errors|.  Also see |assert-return|.\n+      This can be used to assert that a command throws an exception.\n+      Using the error number, followed by a colon, avoids problems\n+      with translations: >\n+      \ttry\n+      \t  commandthatfails\n+      \t  call assert_false(1, 'command should have failed')\n+      \tcatch\n+      \t  call assert_exception('E492:')\n+      \tendtry\n+      <\n+    ]=],\n+    name = 'assert_exception',\n+    params = { { 'error', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_exception({error} [, {msg}])',\n+  },\n+  assert_fails = {\n+    args = { 1, 5 },\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it does\n+      NOT produce an error or when {error} is not found in the\n+      error message.  Also see |assert-return|.\n+\n+      When {error} is a string it must be found literally in the\n+      first reported error. Most often this will be the error code,\n+      including the colon, e.g. \"E123:\". >\n+      \tassert_fails('bad cmd', 'E987:')\n+      <\n+      When {error} is a |List| with one or two strings, these are\n+      used as patterns.  The first pattern is matched against the\n+      first reported error: >\n+      \tassert_fails('cmd', ['E987:.*expected bool'])\n+      <The second pattern, if present, is matched against the last\n+      reported error.  To only match the last error use an empty\n+      string for the first error: >\n+      \tassert_fails('cmd', ['', 'E987:'])\n+      <\n+      If {msg} is empty then it is not used.  Do this to get the\n+      default message when passing the {lnum} argument.\n+\n+      When {lnum} is present and not negative, and the {error}\n+      argument is present and matches, then this is compared with\n+      the line number at which the error was reported. That can be\n+      the line number in a function or in a script.\n+\n+      When {context} is present it is used as a pattern and matched\n+      against the context (script name or function name) where\n+      {lnum} is located in.\n+\n+      Note that beeping is not considered an error, and some failing\n+      commands only beep.  Use |assert_beeps()| for those.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_fails('E99:')\n+\n+    ]=],\n+    name = 'assert_fails',\n+    params = {\n+      { 'cmd', 'any' },\n+      { 'error', 'any' },\n+      { 'msg', 'any' },\n+      { 'lnum', 'integer' },\n+      { 'context', 'any' },\n     },\n-    buffer_name={\n-      args={0, 1}, base=1, func='f_bufname',\n-      deprecated = { 'Obsolete name for |bufname()|.' }\n+    returns = '0|1',\n+    signature = 'assert_fails({cmd} [, {error} [, {msg} [, {lnum} [, {context}]]]])',\n+  },\n+  assert_false = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not false an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      The error is in the form \"Expected False but got {actual}\".\n+      When {msg} is present it is prepended to that.\n+      Also see |assert-return|.\n+\n+      A value is false when it is zero. When {actual} is not a\n+      number the assert fails.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_false()\n+\n+    ]=],\n+    name = 'assert_false',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_false({actual} [, {msg}])',\n+  },\n+  assert_inrange = {\n+    args = { 3, 4 },\n+    base = 3,\n+    desc = [=[\n+      This asserts number and |Float| values.  When {actual}  is lower\n+      than {lower} or higher than {upper} an error message is added\n+      to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Expected range {lower} - {upper},\n+      but got {actual}\".  When {msg} is present it is prefixed to\n+      that.\n+    ]=],\n+    name = 'assert_inrange',\n+    params = { { 'lower', 'any' }, { 'upper', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_inrange({lower}, {upper}, {actual} [, {msg}])',\n+  },\n+  assert_match = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      When {pattern} does not match {actual} an error message is\n+      added to |v:errors|.  Also see |assert-return|.\n+      The error is in the form \"Pattern {pattern} does not match\n+      {actual}\".  When {msg} is present it is prefixed to that.\n+\n+      {pattern} is used as with |expr-=~|: The matching is always done\n+      like 'magic' was set and 'cpoptions' is empty, no matter what\n+      the actual value of 'magic' or 'cpoptions' is.\n+\n+      {actual} is used as a string, automatic conversion applies.\n+      Use \"^\" and \"$\" to match with the start and end of the text.\n+      Use both to match the whole text.\n+\n+      Example: >\n+      \tassert_match('^f.*o$', 'foobar')\n+      <Will result in a string to be added to |v:errors|:\n+      \ttest.vim line 12: Pattern '^f.*o$' does not match 'foobar' ~\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_match('foo.*')\n+      <\n+    ]=],\n+    name = 'assert_match',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_match({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_nobeep = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Run {cmd} and add an error message to |v:errors| if it\n+      produces a beep or visual bell.\n+      Also see |assert_beeps()|.\n+\n+      Can also be used as a |method|: >\n+      \tGetCmd()->assert_nobeep()\n+      <\n+    ]=],\n+    name = 'assert_nobeep',\n+    params = { { 'cmd', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_nobeep({cmd})',\n+  },\n+  assert_notequal = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_equal()`: add an error message to\n+      |v:errors| when {expected} and {actual} are equal.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tmylist->assert_notequal([1, 2, 3])\n+\n+      <\n+    ]=],\n+    name = 'assert_notequal',\n+    params = { { 'expected', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notequal({expected}, {actual} [, {msg}])',\n+  },\n+  assert_notmatch = {\n+    args = { 2, 3 },\n+    base = 2,\n+    desc = [=[\n+      The opposite of `assert_match()`: add an error message to\n+      |v:errors| when {pattern} matches {actual}.\n+      Also see |assert-return|.\n+\n+      Can also be used as a |method|: >\n+      \tgetFile()->assert_notmatch('bar.*')\n+      <\n+    ]=],\n+    name = 'assert_notmatch',\n+    params = { { 'pattern', 'any' }, { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_notmatch({pattern}, {actual} [, {msg}])',\n+  },\n+  assert_report = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Report a test failure directly, using String {msg}.\n+      Always returns one.\n+\n+      Can also be used as a |method|: >\n+      \tGetMessage()->assert_report()\n+      <\n+    ]=],\n+    name = 'assert_report',\n+    params = { { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_report({msg})',\n+  },\n+  assert_true = {\n+    args = { 1, 2 },\n+    base = 1,\n+    desc = [=[\n+      When {actual} is not true an error message is added to\n+      |v:errors|, like with |assert_equal()|.\n+      Also see |assert-return|.\n+      A value is |TRUE| when it is a non-zero number or |v:true|.\n+      When {actual} is not a number or |v:true| the assert fails.\n+      When {msg} is given it precedes the default message.\n+\n+      Can also be used as a |method|: >\n+      \tGetResult()->assert_true()\n+      <\n+    ]=],\n+    name = 'assert_true',\n+    params = { { 'actual', 'any' }, { 'msg', 'any' } },\n+    returns = '0|1',\n+    signature = 'assert_true({actual} [, {msg}])',\n+  },\n+  atan = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the principal value of the arc tangent of {expr}, in\n+      the range [-pi/2, +pi/2] radians, as a |Float|.\n+      {expr} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr} is not a |Float| or a |Number|.\n+      Examples: >\n+      \t:echo atan(100)\n+      <\t1.560797 >\n+      \t:echo atan(-4.01)\n+      <\t-1.326405\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan()\n+\n+    ]=],\n+    float_func = 'atan',\n+    name = 'atan',\n+    params = { { 'expr', 'any' } },\n+    returns = 'number',\n+    signature = 'atan({expr})',\n+  },\n+  atan2 = {\n+    args = 2,\n+    base = 1,\n+    desc = [=[\n+      Return the arc tangent of {expr1} / {expr2}, measured in\n+      radians, as a |Float| in the range [-pi, pi].\n+      {expr1} and {expr2} must evaluate to a |Float| or a |Number|.\n+      Returns 0.0 if {expr1} or {expr2} is not a |Float| or a\n+      |Number|.\n+      Examples: >\n+      \t:echo atan2(-1, 1)\n+      <\t-0.785398 >\n+      \t:echo atan2(1, -1)\n+      <\t2.356194\n+\n+      Can also be used as a |method|: >\n+      \tCompute()->atan2(1)\n+\n+    ]=],\n+    name = 'atan2',\n+    params = { { 'expr1', 'any' }, { 'expr2', 'any' } },\n+    returns = 'number',\n+    signature = 'atan2({expr1}, {expr2})',\n+  },\n+  blob2list = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return a List containing the number value of each byte in Blob\n+      {blob}.  Examples: >\n+      \tblob2list(0z0102.0304)\treturns [1, 2, 3, 4]\n+      \tblob2list(0z)\t\treturns []\n+      <Returns an empty List on error.  |list2blob()| does the\n+      opposite.\n+\n+      Can also be used as a |method|: >\n+      \tGetBlob()->blob2list()\n+      <\n+    ]=],\n+    name = 'blob2list',\n+    params = { { 'blob', 'any' } },\n+    returns = 'any[]',\n+    signature = 'blob2list({blob})',\n+  },\n+  browse = {\n+    args = 4,\n+    desc = [=[\n+      Put up a file requester.  This only works when \"has(\"browse\")\"\n+      returns |TRUE| (only in some GUI versions).\n+      The input fields are:\n+          {save}\twhen |TRUE|, select file to write\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+          {default}\tdefault file name\n+      An empty string is returned when the \"Cancel\" button is hit,\n+      something went wrong, or browsing is not possible.\n+    ]=],\n+    name = 'browse',\n+    params = { { 'save', 'any' }, { 'title', 'any' }, { 'initdir', 'any' }, { 'default', 'any' } },\n+    returns = '0|1',\n+    signature = 'browse({save}, {title}, {initdir}, {default})',\n+  },\n+  browsedir = {\n+    args = 2,\n+    desc = [=[\n+      Put up a directory requester.  This only works when\n+      \"has(\"browse\")\" returns |TRUE| (only in some GUI versions).\n+      On systems where a directory browser is not supported a file\n+      browser is used.  In that case: select a file in the directory\n+      to be used.\n+      The input fields are:\n+          {title}\ttitle for the requester\n+          {initdir}\tdirectory to start browsing in\n+      When the \"Cancel\" button is hit, something went wrong, or\n+      browsing is not possible, an empty string is returned.\n+\n+    ]=],\n+    name = 'browsedir',\n+    params = { { 'title', 'any' }, { 'initdir', 'any' } },\n+    returns = '0|1',\n+    signature = 'browsedir({title}, {initdir})',\n+  },\n+  bufadd = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Add a buffer to the buffer list with name {name} (must be a\n+      String).\n+      If a buffer for file {name} already exists, return that buffer\n+      number.  Otherwise return the buffer number of the newly\n+      created buffer.  When {name} is an empty string then a new\n+      buffer is always created.\n+      The buffer will not have 'buflisted' set and not be loaded\n+      yet.  To add some text to the buffer use this: >\n+      \tlet bufnr = bufadd('someName')\n+      \tcall bufload(bufnr)\n+      \tcall setbufline(bufnr, 1, ['some', 'text'])\n+      <Returns 0 on error.\n+      Can also be used as a |method|: >\n+      \tlet bufnr = 'somename'->bufadd()\n+\n+    ]=],\n+    name = 'bufadd',\n+    params = { { 'name', 'string' } },\n+    returns = 'integer',\n+    signature = 'bufadd({name})',\n+  },\n+  bufexists = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists.\n+      If the {buf} argument is a number, buffer numbers are used.\n+      Number zero is the alternate buffer for the current window.\n+\n+      If the {buf} argument is a string it must match a buffer name\n+      exactly.  The name can be:\n+      - Relative to the current directory.\n+      - A full path.\n+      - The name of a buffer with 'buftype' set to \"nofile\".\n+      - A URL name.\n+      Unlisted buffers will be found.\n+      Note that help files are listed by their short name in the\n+      output of |:buffers|, but bufexists() requires using their\n+      long name to be able to find them.\n+      bufexists() may report a buffer exists, but to use the name\n+      with a |:buffer| command you may need to use |expand()|.  Esp\n+      for MS-Windows 8.3 names in the form \"c:\\DOCUME~1\"\n+      Use \"bufexists(0)\" to test for the existence of an alternate\n+      file name.\n+\n+      Can also be used as a |method|: >\n+      \tlet exists = 'somename'->bufexists()\n+\n+    ]=],\n+    name = 'bufexists',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufexists({buf})',\n+  },\n+  buffer_exists = {\n+    args = 1,\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufexists()|.\n+    ]=],\n+    func = 'f_bufexists',\n+    name = 'buffer_exists',\n+    params = VARARGS,\n+    returns = '0|1',\n+    signature = 'buffer_exists({buf})',\n+  },\n+  buffer_name = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufname()|.\n+    ]=],\n+    func = 'f_bufname',\n+    name = 'buffer_name',\n+    params = VARARGS,\n+    returns = 'string',\n+    signature = 'buffer_name([{buf}])',\n+  },\n+  buffer_number = {\n+    args = { 0, 1 },\n+    base = 1,\n+    deprecated = true,\n+    desc = [=[\n+      Obsolete name for |bufnr()|.\n+    ]=],\n+    func = 'f_bufnr',\n+    name = 'buffer_number',\n+    params = VARARGS,\n+    returns = 'integer',\n+    signature = 'buffer_number([{buf} [, {create}]])',\n+  },\n+  buflisted = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is listed (has the 'buflisted' option set).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet listed = 'somename'->buflisted()\n+\n+    ]=],\n+    name = 'buflisted',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'buflisted({buf})',\n+  },\n+  bufload = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Ensure the buffer {buf} is loaded.  When the buffer name\n+      refers to an existing file then the file is read.  Otherwise\n+      the buffer will be empty.  If the buffer was already loaded\n+      then there is no change.  If the buffer is not related to a\n+      file the no file is read (e.g., when 'buftype' is \"nofile\").\n+      If there is an existing swap file for the file of the buffer,\n+      there will be no dialog, the buffer will be loaded anyway.\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \teval 'somename'->bufload()\n+\n+    ]=],\n+    name = 'bufload',\n+    params = { { 'buf', 'any' } },\n+    returns = false,\n+    signature = 'bufload({buf})',\n+  },\n+  bufloaded = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is |TRUE| if a buffer called\n+      {buf} exists and is loaded (shown in a window or hidden).\n+      The {buf} argument is used like with |bufexists()|.\n+\n+      Can also be used as a |method|: >\n+      \tlet loaded = 'somename'->bufloaded()\n+\n+    ]=],\n+    name = 'bufloaded',\n+    params = { { 'buf', 'any' } },\n+    returns = '0|1',\n+    signature = 'bufloaded({buf})',\n+  },\n+  bufname = {\n+    args = { 0, 1 },\n+    base = 1,\n+    desc = [=[\n+      The result is the name of a buffer.  Mostly as it is displayed\n+      by the `:ls` command, but not using special names such as\n+      \"[No Name]\".\n+      If {buf} is omitted the current buffer is used.\n+      If {buf} is a Number, that buffer number's name is given.\n+      Number zero is the alternate buffer for the current window.\n+      If {buf} is a String, it is used as a |file-pattern| to match\n+      with the buffer names.  This is always done like 'magic' is\n+      set and 'cpoptions' is empty.  When there is more than one\n+      match an empty string is returned.\n+      \"\" or \"%\" can be used for the current buffer, \"#\" for the\n+      alternate buffer.\n+      A full match is preferred, otherwise a match at the start, end\n+      or middle of the buffer name is accepted.  If you only want a\n+      full match then put \"^\" at the start and \"$\" at the end of the\n+      pattern.\n+      Listed buffers are found first.  If there is a single match\n+      with a listed buffer, that one is returned.  Next unlisted\n+      buffers are searched for.\n+      If the {buf} is a String, but you want to use it as a buffer\n+      number, force it to be a Number by adding zero to it: >\n+      \t:echo bufname(\"3\" + 0)\n+      <Can also be used as a |method|: >\n+      \techo bufnr->bufname()\n+\n+      <If the buffer doesn't exist, or doesn't have a name, an empty\n+      string is returned. >\n+      \tbufname(\"#\")\t\talternate buffer name\n+      \tbufname(3)\t\tname of buffer 3\n+      \tbufname(\"%\")\t\tname of current buffer\n+      \tbufname(\"file2\")\tname of buffer where \"file2\" matches.\n+      <\n+    ]=],\n+    name = 'bufname',\n+    params = { { 'buf', 'any' } },\n+    returns = 'string',\n+    signature = 'bufname([{buf}])',\n+  },\n+  bufnr = {\n+    args = { 0, 2 },\n+    base = 1,\n+    desc = [=[\n+      The result is the number of a buffer, as it is displayed by\n+      the `:ls` command.  For the use of {buf}, see |bufname()|\n+      above.\n+      If the buffer doesn't exist, -1 is returned.  Or, if the\n+      {create} argument is present and TRUE, a new, unlisted,\n+      buffer is created and its number is returned.\n+      bufnr(\"$\") is the last buffer: >\n+      \t:let last_buffer = bufnr(\"$\")\n+      <The result is a Number, which is the highest buffer number\n+      of existing buffers.  Note that not all buffers with a smaller\n+      number necessarily exist, because \":bwipeout\" may have removed\n+      them.  Use bufexists() to test for the existence of a buffer.\n+\n+      Can also be used as a |method|: >\n+      \techo bufref->bufnr()\n+\n+    ]=],\n+    name = 'bufnr',\n+    params = { { 'buf', 'any' }, { 'create', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufnr([{buf} [, {create}]])',\n+  },\n+  bufwinid = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      The result is a Number, which is the |window-ID| of the first\n+      window associated with buffer {buf}.  For the use of {buf},\n+      see |bufname()| above.  If buffer {buf} doesn't exist or\n+      there is no such window, -1 is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinid(1))\n+      <\n+      Only deals with the current tab page.  See |win_findbuf()| for\n+      finding more.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinid()\n+\n+    ]=],\n+    name = 'bufwinid',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinid({buf})',\n+  },\n+  bufwinnr = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Like |bufwinid()| but return the window number instead of the\n+      |window-ID|.\n+      If buffer {buf} doesn't exist or there is no such window, -1\n+      is returned.  Example: >\n+\n+      \techo \"A window containing buffer 1 is \" .. (bufwinnr(1))\n+\n+      <The number can be used with |CTRL-W_w| and \":wincmd w\"\n+      |:wincmd|.\n+\n+      Can also be used as a |method|: >\n+      \tFindBuffer()->bufwinnr()\n+\n+    ]=],\n+    name = 'bufwinnr',\n+    params = { { 'buf', 'any' } },\n+    returns = 'integer',\n+    signature = 'bufwinnr({buf})',\n+  },\n+  byte2line = {\n+    args = 1,\n+    base = 1,\n+    desc = [=[\n+      Return the line number that contains the character at byte\n+      count {byte} in the current buffer.  This includes the\n+      end-of-line character, depending on the 'fileformat' option\n+      for the current buffer.  The first character has byte count\n+      one.\n+      Also see |line2byte()|, |go| and |:goto|.\n+\n+      Returns -1 if the {byte} value is invalid.\n+\n+      Can also be used as a |method|: >\n+      \tGetOffset()->byte2line()\n+\n+    ]=],\n+    name = 'byte2line',\n+    params = { { 'byte', 'any' } },\n+    returns = 'integer',\n+    signature = 'byte2line({byte})',\n+  },\n+  byteidx = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Return byte index of the {nr}th character in the String\n+      {expr}.  Use zero for the first character, it then returns\n+      zero.\n+      If there are no multibyte characters the returned value is\n+      equal to {nr}.\n+      Composing characters are not counted separately, their byte\n+      length is added to the preceding base character.  See\n+      |byteidxcomp()| below for counting composing characters\n+      separately.\n+      When {utf16} is present and TRUE, {nr} is used as the UTF-16\n+      index in the String {expr} instead of as the character index.\n+      The UTF-16 index is the index in the string when it is encoded\n+      with 16-bit words.  If the specified UTF-16 index is in the\n+      middle of a character (e.g. in a 4-byte character), then the\n+      byte index of the first byte in the character is returned.\n+      Refer to |string-offset-encoding| for more information.\n+      Example : >\n+      \techo matchstr(str, \".\", byteidx(str, 3))\n+      <will display the fourth character.  Another way to do the\n+      same: >\n+      \tlet s = strpart(str, byteidx(str, 3))\n+      \techo strpart(s, 0, byteidx(s, 1))\n+      <Also see |strgetchar()| and |strcharpart()|.\n+\n+      If there are less than {nr} characters -1 is returned.\n+      If there are exactly {nr} characters the length of the string\n+      in bytes is returned.\n+      See |charidx()| and |utf16idx()| for getting the character and\n+      UTF-16 index respectively from the byte index.\n+      Examples: >\n+      \techo byteidx('a', 2)\treturns 5\n+      \techo byteidx('a', 2, 1)\treturns 1\n+      \techo byteidx('a', 3, 1)\treturns 5\n+      <\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidx(idx)\n+\n+    ]=],\n+    fast = true,\n+    name = 'byteidx',\n+    params = { { 'expr', 'any' }, { 'nr', 'integer' }, { 'utf16', 'any' } },\n+    returns = 'integer',\n+    signature = 'byteidx({expr}, {nr} [, {utf16}])',\n+  },\n+  byteidxcomp = {\n+    args = { 2, 3 },\n+    base = 1,\n+    desc = [=[\n+      Like byteidx(), except that a composing character is counted\n+      as a separate character.  Example: >\n+      \tlet s = 'e' .. nr2char(0x301)\n+      \techo byteidx(s, 1)\n+      \techo byteidxcomp(s, 1)\n+      \techo byteidxcomp(s, 2)\n+      <The first and third echo result in 3 ('e' plus composing\n+      character is 3 bytes), the second echo results in 1 ('e' is\n+      one byte).\n+\n+      Can also be used as a |method|: >\n+      \tGetName()->byteidxcomp(idx)\n+",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277469439",
            "id": 1277469439,
            "line": 1050,
            "node_id": "PRRC_kwDOAPphoM5MJKL_",
            "original_commit_id": "dff6723a2ea460e59394b61814bb00673fb100dc",
            "original_line": 1050,
            "original_position": 1091,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": 1091,
            "pull_request_review_id": 1551998355,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277469439/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T12:08:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277469439",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277486549"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277486549"
                }
            },
            "author_association": "MEMBER",
            "body": "I'd prefer to keep these, for better treesitter parseability. ",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T12:25:17Z",
            "diff_hunk": "@@ -1047,7 +1047,7 @@ M.funcs = {\n \n       Can also be used as a |method|: >\n       \tGetName()->byteidxcomp(idx)\n-      <",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277486549",
            "id": 1277486549,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MJOXV",
            "original_commit_id": "6e6cc0b13126897dc126da11a8aa61d5ef957feb",
            "original_line": 1050,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1552020195,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277486549/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T12:25:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277486549",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277490323"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277490323"
                }
            },
            "author_association": "MEMBER",
            "body": "What \"keep\"? They weren't present in the first place.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T12:29:43Z",
            "diff_hunk": "@@ -1047,7 +1047,7 @@ M.funcs = {\n \n       Can also be used as a |method|: >\n       \tGetName()->byteidxcomp(idx)\n-      <",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277490323",
            "id": 1277490323,
            "in_reply_to_id": 1277486549,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MJPST",
            "original_commit_id": "6e6cc0b13126897dc126da11a8aa61d5ef957feb",
            "original_line": 1050,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1552026373,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277490323/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T12:30:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277490323",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277496521"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277496521"
                }
            },
            "author_association": "MEMBER",
            "body": "Like I said, we can fix all this in follow ups. For this PR the aim is to have a minimal diff.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T12:36:49Z",
            "diff_hunk": "@@ -1047,7 +1047,7 @@ M.funcs = {\n \n       Can also be used as a |method|: >\n       \tGetName()->byteidxcomp(idx)\n-      <",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277496521",
            "id": 1277496521,
            "in_reply_to_id": 1277486549,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MJQzJ",
            "original_commit_id": "6e6cc0b13126897dc126da11a8aa61d5ef957feb",
            "original_line": 1050,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1552036485,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277496521/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T12:36:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277496521",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277538341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277538341"
                }
            },
            "author_association": "MEMBER",
            "body": "Well, quite a few were added, so consistency is good (if you add them anyway). My point is since they _were_ already added, explicitly removing them again just for the sake of minimizing the diff is a net loss.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T13:19:23Z",
            "diff_hunk": "@@ -1047,7 +1047,7 @@ M.funcs = {\n \n       Can also be used as a |method|: >\n       \tGetName()->byteidxcomp(idx)\n-      <",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277538341",
            "id": 1277538341,
            "in_reply_to_id": 1277486549,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MJbAl",
            "original_commit_id": "6e6cc0b13126897dc126da11a8aa61d5ef957feb",
            "original_line": 1050,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1552107102,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277538341/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T13:19:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277538341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/24493#discussion_r1277567929"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/24493"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277567929"
                }
            },
            "author_association": "MEMBER",
            "body": " . They will all get fixed anyway.",
            "commit_id": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
            "created_at": "2023-07-28T13:48:15Z",
            "diff_hunk": "@@ -1047,7 +1047,7 @@ M.funcs = {\n \n       Can also be used as a |method|: >\n       \tGetName()->byteidxcomp(idx)\n-      <",
            "html_url": "https://github.com/neovim/neovim/pull/24493#discussion_r1277567929",
            "id": 1277567929,
            "in_reply_to_id": 1277486549,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5MJiO5",
            "original_commit_id": "6e6cc0b13126897dc126da11a8aa61d5ef957feb",
            "original_line": 1050,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/eval.lua",
            "position": null,
            "pull_request_review_id": 1552161541,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277567929/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-07-28T13:48:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1277567929",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Now that we own `builtin.txt`, can we add language annotations to the code blocks?",
            "created_at": "2023-07-26T14:04:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1651876239",
            "id": 1651876239,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5idaGP",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651876239/reactions"
            },
            "updated_at": "2023-07-26T14:04:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651876239",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Nice! Could put these in a fully-generated file (`eval_funcs.txt` ?) to avoid needing to \"insert\" into builtin.txt. And maybe the rest of builtin.txt could go back into eval.txt.\r\n\r\n> Removed \"Overview\" section from `builtin.txt` ... Can generate this is we _really_ want it.\r\n\r\nYeah, can be a TODO for now. Easy to generate if people actually want it.\r\n\r\nEventually we could have a `Parameters` list for each function (as in `api.txt`), that would be a great improvement vs the old format.",
            "created_at": "2023-07-26T15:00:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1651987991",
            "id": 1651987991,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5id1YX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651987991/reactions"
            },
            "updated_at": "2023-07-26T15:01:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651987991",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Nice! Could put these in a fully-generated file (eval_funcs.txt ?) to avoid needing to \"insert\" into builtin.txt. And maybe the rest of builtin.txt could go back into eval.txt.\r\n\r\nThere's no insertion, `builtin.txt` is completely overwritten each time. We just need to include the `*string-match*` section at the bottom which I've inlined into `scripts/gen_builtin_doc.lua`\r\n",
            "created_at": "2023-07-26T15:07:21Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1651999626",
            "id": 1651999626,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5id4OK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651999626/reactions"
            },
            "updated_at": "2023-07-26T15:07:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1651999626",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Eventually we could have a Parameters list for each function (as in api.txt), that would be a great improvement vs the old format.\r\n\r\nYes, this would be really easy to do, just need to fill out all the param types in `eval.lua`. Atm they are mostly all `any`.",
            "created_at": "2023-07-26T15:08:43Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1652001865",
            "id": 1652001865,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5id4xJ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652001865/reactions"
            },
            "updated_at": "2023-07-26T15:08:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652001865",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Ok, we could just move any static sections such as `*string-match*` to eval.txt.\r\n\r\n`eval_funcs.txt` seems like a better name, no? ",
            "created_at": "2023-07-26T15:09:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1652003847",
            "id": 1652003847,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5id5QH",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652003847/reactions"
            },
            "updated_at": "2023-07-26T15:10:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652003847",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> eval_funcs.txt seems like a better name, no?\r\n\r\nsure\r\n\r\nIf we are renaming, can I normalise all the tabs too?",
            "created_at": "2023-07-26T15:21:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1652025481",
            "id": 1652025481,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5id-iJ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652025481/reactions"
            },
            "updated_at": "2023-07-26T15:22:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1652025481",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> This looks unmaintainable. With eval.lua as the source of truth, to update the docs of a function you'll have to modify, add or delete individual strings in eval.lua, instead of just editing builtin.txt.\n\nI'm not sure how that is significantly different? The only difference is that strings in `eval.lua` have `'` (quote) at the start and end. A similar difference applies to doc comments in code which have a `///` at the start of every line.\n\nThe benefit of this format is it makes tooling for rendering other formats much simpler. As opposed to maintaining doc comments which need extra processing (or third party tools), or scraping help files which need even more processing since that format is so lax.\n\nEventually I imagine other parts of the descriptions to be pulled out into other structured fields in eval.lua. e.g. examples, return values, parameters, additional tags.\n\nOnce the descriptions have been normalised to remove most of the vimhelp specific stuff, we could then  render the docs into even more formats like markdown.",
            "created_at": "2023-07-27T07:11:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653032680",
            "id": 1653032680,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ih0bo",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653032680/reactions"
            },
            "updated_at": "2023-07-27T07:11:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653032680",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> The only difference is that strings in `eval.lua` have `'` (quote) at the start and end. \r\n\r\nIs that not a significant difference? Breaking a line in comments is easy because of 'formatoptions' and 'comments' options, but these strings are not comments.",
            "created_at": "2023-07-27T08:40:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653165780",
            "id": 1653165780,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5iiU7U",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653165780/reactions"
            },
            "updated_at": "2023-07-27T08:40:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653165780",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "To me, not really. Do you edit `builtin.txt` often enough that you need to rely on built-in vim options to make it easier?\r\n\r\nThe point of moving everything to `eval.lua` is because the docs for almost all of these functions are effectively frozen and aren't likely to get many updates. What's important for us now is that we can leverage this information in more places via automation.\r\n\r\nIf you can think of a better format to aid in this automation (that isn't vimdoc), then we are of course open to suggestions.",
            "created_at": "2023-07-27T09:01:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653198372",
            "id": 1653198372,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5iic4k",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653198372/reactions"
            },
            "updated_at": "2023-07-27T09:01:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653198372",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I agree that the current -- preformatted -- format for `desc` is not ideal, but the pros of having introspection for this much outweigh the cons.\r\n\r\nThat being said, maybe an alternative would be to have the `desc` as a literal (`[[...]]`) string in emmylua/doxygen docstring format that is piped through `gen_vimdoc.py`? Is that feasible?",
            "created_at": "2023-07-27T09:54:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653287227",
            "id": 1653287227,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5iiyk7",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653287227/reactions"
            },
            "updated_at": "2023-07-27T09:55:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653287227",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> That being said, maybe an alternative would be to have the desc as a literal ([[...]]) string in emmylua/doxygen docstring format that is piped through gen_vimdoc.py? Is that feasible?\r\n\r\nWe could use `[[...]]` if others think that's an improvement. I'm personally content with string lists since it involves less processing and makes `eval.lua` have better formatting.\r\n\r\nI'm not sure if piping through doxygen/gen_vimdoc.py gets us anything.",
            "created_at": "2023-07-27T10:00:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653296639",
            "id": 1653296639,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii03_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653296639/reactions"
            },
            "updated_at": "2023-07-27T10:00:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653296639",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Well, auto-(re)wrap, is what I was thinking. More processing is a _positive_ if it reduces required _manual_ processing (in this case, rewrapping after making changes).\r\n\r\nI am with @zeertzjq on this: there is zero historical basis for assuming that `builtin.txt` is effectively frozen -- I had to touch it on nearly every single runtime files update in the past years.\r\n\r\nOf course, we can make the conscious decision to freeze it and no longer pull in upstream changes at all, although I'd consider that throwing the baby out with the bathwater.\r\n",
            "created_at": "2023-07-27T10:01:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653298203",
            "id": 1653298203,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii1Qb",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653298203/reactions"
            },
            "updated_at": "2023-07-27T10:05:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653298203",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "The rewrap can get in the way more than it helps, especially with some of a weird formatting in builtin.txt for table-like sections.\n ",
            "created_at": "2023-07-27T10:04:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653304476",
            "id": 1653304476,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii2yc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653304476/reactions"
            },
            "updated_at": "2023-07-27T10:04:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653304476",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "True, but we could still have multiple strings that are individually rewrapped -- basically \"one string per paragraph\" instead of \"one string per line\". Would be more complicated, admittedly.",
            "created_at": "2023-07-27T10:06:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653307916",
            "id": 1653307916,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii3oM",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653307916/reactions"
            },
            "updated_at": "2023-07-27T10:06:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653307916",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> True, but we could still have multiple strings that are individually rewrapped -- basically \"one string per paragraph\" instead of \"one string per line\". Would be more complicated, admittedly.\r\n\r\nA lot more complicated since I don't know how we could automate or bootstrap this.\r\n\r\nRight now we can reasonably convert between `eval.lua` <-> `builtin.txt` since the text is taken verbatim, which allows us to boostrap other formats. That's how I populated `eval.lua` to begin with. If we make this more complicated then the <-> becomes ->.",
            "created_at": "2023-07-27T10:12:34Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653316563",
            "id": 1653316563,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii5vT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653316563/reactions"
            },
            "updated_at": "2023-07-27T10:12:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653316563",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I guess we should then spend some time thinking how to integrate this `<->` into the `vim-patch` workflow (which has become frustrating enough due to increasing manual intervention).",
            "created_at": "2023-07-27T10:16:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653322214",
            "id": 1653322214,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ii7Hm",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653322214/reactions"
            },
            "updated_at": "2023-07-27T10:16:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653322214",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Again, a prerequisite of this change is that the eval funcs get little churn. If we need to maintain vim-patch automation, then this isn't worth doing. Or at least outside the scope of this PR.\r\n\r\nSee https://github.com/neovim/neovim/pull/24473#issuecomment-1649841255",
            "created_at": "2023-07-27T13:08:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653595258",
            "id": 1653595258,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ij9x6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653595258/reactions"
            },
            "updated_at": "2023-07-27T13:12:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653595258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Yeah, I don't agree with that assessment (from my position at the \"coal face\", at least documentation-wise) -- unless _we_ freeze it. (Which I'm personally not arguing against, for the record; I just want this to be a reasoned decision under full information rather than an off-hand dismissal of concerns.)\r\n\r\nI also don't agree that this would make it \"not worth doing\"; but the fact is that this change makes other work more difficult, and the voice of the people doing that work (zeertzjq) deserves to be taken seriously, even if after serious deliberation that seems the best course of action.",
            "created_at": "2023-07-27T14:02:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653690939",
            "id": 1653690939,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ikVI7",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653690939/reactions"
            },
            "updated_at": "2023-07-27T14:06:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653690939",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I've made it so the `desc` field is now a multi line Lua string.\r\n\r\nHopefully this is an acceptable compromise.",
            "created_at": "2023-07-27T14:36:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653752368",
            "id": 1653752368,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ikkIw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653752368/reactions"
            },
            "updated_at": "2023-07-27T14:36:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653752368",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Looks like this has a problem with tags on a previous line:\r\n```\r\n\t\t\t\t\t\t\t*max()*\r\nmax({expr})\tReturn the maximum value of all items in {expr}. Example:  \r\n\t\t\techo max([apples, pears, oranges])\r\n\r\n \t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\r\n```\r\nbecomes\r\n```\r\nmax({expr})\t\t\t\t\t\t\t*max()*\r\n\t\techo max([apples, pears, oranges])\r\n\r\n<\t\t{expr} can be a |List| or a |Dictionary|.  For a Dictionary,\r\n```\r\n\r\n(and similarly with `min()`, `mode()`, etc. -- first line gets stripped).\r\n",
            "created_at": "2023-07-27T15:58:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653905340",
            "id": 1653905340,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilJe8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653905340/reactions"
            },
            "updated_at": "2023-07-27T15:59:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653905340",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There also looks to be an issue with the auto-inserted closing codeblock tags, e.g.,\r\n```\r\n\r\n<returns >\r\n```\r\ninstead of\r\n```\r\n<\r\nreturns >\r\n```",
            "created_at": "2023-07-27T16:01:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653911328",
            "id": 1653911328,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilK8g",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653911328/reactions"
            },
            "updated_at": "2023-07-27T16:01:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653911328",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Where? From the example I'm looking at, it is the same as it was before.\r\n\r\nThe diff on builtin.txt is 90% the same.",
            "created_at": "2023-07-27T16:04:32Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653915843",
            "id": 1653915843,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilMDD",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653915843/reactions"
            },
            "updated_at": "2023-07-27T16:05:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653915843",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "also affected:\r\n* [x]`copy()`\r\n* [x] `did_filetype()`\r\n* [x] `eval()`\r\n* [x] `exists()`\r\n* [x] `foldtext()`\r\n* [x] `getpid()`\r\n* [x] `getpos()`\r\n* [x] `getwinpos{x,y}()`\r\n* [x] `has()`\r\n* [x] `hlID()`\r\n* [x] `string()`\r\n* [x] `tagfiles()`\r\n* [x] `winbufnr()`\r\n* [x] `wincol()`\r\n* [x] `winline()`\r\n* [x] `winnr()`\r\n* [x] `winrestcmd()`\r\n* [x] `winsaveview()`\r\n\r\n(Any function where the description starts on the same line as the function name.)\r\n",
            "created_at": "2023-07-27T16:11:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653927547",
            "id": 1653927547,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilO57",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653927547/reactions"
            },
            "updated_at": "2023-07-27T16:25:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653927547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Where? From the example I'm looking at, it is the same as it was before.\r\n> \r\n> The diff on builtin.txt is 90% the same.\r\n\r\nHmm, can't find it anymore. (It was one of the codeblock markers that was not in `builtin.txt`.)",
            "created_at": "2023-07-27T16:13:54Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653930872",
            "id": 1653930872,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilPt4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653930872/reactions"
            },
            "updated_at": "2023-07-27T16:13:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653930872",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "And can we normalize to spaces? (Btw, the normalization is what triggers the oldtest failures. Maybe that's one test worth dropping/commenting out...)",
            "created_at": "2023-07-27T16:15:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653932881",
            "id": 1653932881,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilQNR",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653932881/reactions"
            },
            "updated_at": "2023-07-27T16:15:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653932881",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "For this PR I'd prefer if we can minimise the diff to `builtin.txt` as much as possible. We can juice up the formatting as follow ups.",
            "created_at": "2023-07-27T16:20:42Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1653942982",
            "id": 1653942982,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ilSrG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653942982/reactions"
            },
            "updated_at": "2023-07-27T16:20:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1653942982",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There are also still some missing help tags.",
            "created_at": "2023-07-28T10:12:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1655436327",
            "id": 1655436327,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5iq_Qn",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655436327/reactions"
            },
            "updated_at": "2023-07-28T10:12:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655436327",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "I've intentionally removed some tags. See PR description.",
            "created_at": "2023-07-28T10:28:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1655453713",
            "id": 1655453713,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5irDgR",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655453713/reactions"
            },
            "updated_at": "2023-07-28T10:28:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655453713",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "is it expected that when the tags are on two lines that sometimes they're right aligned, sometimes left aligned, and sometimes not aligned at all?",
            "created_at": "2023-07-28T11:26:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1655524169",
            "id": 1655524169,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5irUtJ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655524169/reactions"
            },
            "updated_at": "2023-07-28T11:26:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655524169",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/81827001?v=4",
                "events_url": "https://api.github.com/users/max397574/events{/privacy}",
                "followers_url": "https://api.github.com/users/max397574/followers",
                "following_url": "https://api.github.com/users/max397574/following{/other_user}",
                "gists_url": "https://api.github.com/users/max397574/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/max397574",
                "id": 81827001,
                "login": "max397574",
                "node_id": "MDQ6VXNlcjgxODI3MDAx",
                "organizations_url": "https://api.github.com/users/max397574/orgs",
                "received_events_url": "https://api.github.com/users/max397574/received_events",
                "repos_url": "https://api.github.com/users/max397574/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/max397574/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/max397574/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/max397574"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "There is only basic alignment logic in order to minimise the diffs with the previous inconsistent formatting.\r\n\r\nI'll fix the alignment of tags in a follow up PR when we also remove all the tabs.",
            "created_at": "2023-07-28T11:27:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1655525396",
            "id": 1655525396,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5irVAU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655525396/reactions"
            },
            "updated_at": "2023-07-28T11:27:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1655525396",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Again, a prerequisite of this change is that the eval funcs get little churn. If we need to maintain vim-patch automation, then this isn't worth doing. Or at least outside the scope of this PR.\r\n> \r\n> See [#24473 (comment)](https://github.com/neovim/neovim/pull/24473#issuecomment-1649841255)\r\n\r\nYes. We should consider builtin.txt frozen for purposes of vim-patch. And we should strongly avoid adding new vimscript functions. \r\n\r\nIf upstream vim tests start depending on vimscript functions we don't have, then we either need https://github.com/tjdevries/vim9jit to \"shim\" that, or we shouldn't add the tests. \r\n\r\nGoing forward, most of the value in vim patches should be in these areas:\r\n\r\n- editor features (normal mode, buffer/window/tab, undo, etc)\r\n- quickfix\r\n- vim regex bug fixes\r\n- (If I forgot something, LMK)\r\n\r\nMost other vim patches should be marked as N/A. ",
            "created_at": "2023-07-28T18:37:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1656165238",
            "id": 1656165238,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5itxN2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656165238/reactions"
            },
            "updated_at": "2023-07-28T18:37:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656165238",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "runtime file updates (which technically aren't vim patches), which can have (useful!) documentation updates.\r\n",
            "created_at": "2023-07-28T18:43:13Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1656172849",
            "id": 1656172849,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5itzEx",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656172849/reactions"
            },
            "updated_at": "2023-07-28T18:43:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656172849",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> This looks unmaintainable. With `eval.lua` as the source of truth, to update the docs of a function you'll have to modify, add or delete individual strings in `eval.lua`, instead of just editing `builtin.txt`.\r\n\r\nI am noticing now that `eval.lua` is pretty redundant with `_meta/vimfn.lua`. \r\n\r\nNow that `_meta/vimfn.lua` is bootstrapped, do we still need the docs in `eval.lua`? Although presumably `eval.lua` is more easily used by plugins like [whichkey](https://github.com/folke/which-key.nvim). But docstrings are our annotation \"source of truth\" in general. I also don't see anything in `eval.lua` that is not captured in luals docstrings.\r\n\r\n(Yes, eval.lua is still needed for C generation, but do we need the _docstrings_ in there now?)",
            "created_at": "2023-07-29T23:07:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1656948663",
            "id": 1656948663,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5iwwe3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656948663/reactions"
            },
            "updated_at": "2023-07-29T23:07:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1656948663",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "We don't *need* them, but parsing vimfn.lua to extract them would just require a bit more work.",
            "created_at": "2023-07-30T06:26:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1657056552",
            "id": 1657056552,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ixK0o",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1657056552/reactions"
            },
            "updated_at": "2023-07-30T06:26:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1657056552",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> We don't _need_ them, but parsing vimfn.lua to extract them would just require a bit more work.\r\n\r\nOk, but thinking about the long-term answer for [(quasi) introspection](https://github.com/neovim/neovim/issues/19918), I'm trying to decide if we want to expose `eval.lua` as a public `runtime/` resource. It seems like that would be a mistake because it's redundant with our `_meta/*` annotations.\r\n\r\nWould it be higher-leverage to have a builtin way to iterate luals annotations? Or alternatively, `gen_vimdoc.py` could generate `runtime/eval.lua` from `_meta/` ?",
            "created_at": "2023-07-30T13:46:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1657177977",
            "id": 1657177977,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5ixod5",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1657177977/reactions"
            },
            "updated_at": "2023-07-30T13:48:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1657177977",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> trying to decide if we want to expose `eval.lua` as a public `runtime/` resource\r\n\r\nAfter more thought: conclusion is \"don't expose `eval.lua`\". _Internally_, `eval.lua` can be the source of truth indefinitely, but our answer for external quasi-introspection is \"use the docstrings\". That implies that eventually Nvim will ship a treesitter-based utility to help parse luals docstrings.\r\n\r\nSee also:\r\n\r\n- #23189\r\n- #19918",
            "created_at": "2023-08-01T10:09:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/24493#issuecomment-1659999798",
            "id": 1659999798,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
            "node_id": "IC_kwDOAPphoM5i8ZY2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1659999798/reactions"
            },
            "updated_at": "2023-08-02T18:35:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1659999798",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/24493/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/24493/commits",
    "created_at": "2023-07-26T13:59:13Z",
    "diff_url": "https://github.com/neovim/neovim/pull/24493.diff",
    "draft": false,
    "head": {
        "label": "lewis6991:feat/builtindocgen",
        "ref": "feat/builtindocgen",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/lewis6991/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/lewis6991/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/lewis6991/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/lewis6991/neovim/branches{/branch}",
            "clone_url": "https://github.com/lewis6991/neovim.git",
            "collaborators_url": "https://api.github.com/repos/lewis6991/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/lewis6991/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/lewis6991/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/lewis6991/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/lewis6991/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/lewis6991/neovim/contributors",
            "created_at": "2020-11-24T21:47:43Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/lewis6991/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/lewis6991/neovim/downloads",
            "events_url": "https://api.github.com/repos/lewis6991/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/lewis6991/neovim/forks",
            "full_name": "lewis6991/neovim",
            "git_commits_url": "https://api.github.com/repos/lewis6991/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/lewis6991/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/lewis6991/neovim/git/tags{/sha}",
            "git_url": "git://github.com/lewis6991/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/lewis6991/neovim/hooks",
            "html_url": "https://github.com/lewis6991/neovim",
            "id": 315760150,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/lewis6991/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/lewis6991/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/lewis6991/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/lewis6991/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/lewis6991/neovim/labels{/name}",
            "language": "Vim script",
            "languages_url": "https://api.github.com/repos/lewis6991/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/lewis6991/neovim/merges",
            "milestones_url": "https://api.github.com/repos/lewis6991/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzMTU3NjAxNTA=",
            "notifications_url": "https://api.github.com/repos/lewis6991/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/lewis6991/neovim/pulls{/number}",
            "pushed_at": "2023-08-02T17:32:44Z",
            "releases_url": "https://api.github.com/repos/lewis6991/neovim/releases{/id}",
            "size": 243717,
            "ssh_url": "git@github.com:lewis6991/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/lewis6991/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/lewis6991/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/lewis6991/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/lewis6991/neovim/subscription",
            "svn_url": "https://github.com/lewis6991/neovim",
            "tags_url": "https://api.github.com/repos/lewis6991/neovim/tags",
            "teams_url": "https://api.github.com/repos/lewis6991/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/lewis6991/neovim/git/trees{/sha}",
            "updated_at": "2023-01-31T18:36:52Z",
            "url": "https://api.github.com/repos/lewis6991/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "858eef76bb621fc65c666e6c3e786e1b4a614c23",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
            "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
            "followers_url": "https://api.github.com/users/lewis6991/followers",
            "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
            "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/lewis6991",
            "id": 7904185,
            "login": "lewis6991",
            "node_id": "MDQ6VXNlcjc5MDQxODU=",
            "organizations_url": "https://api.github.com/users/lewis6991/orgs",
            "received_events_url": "https://api.github.com/users/lewis6991/received_events",
            "repos_url": "https://api.github.com/users/lewis6991/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/lewis6991"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/24493",
    "id": 1450329169,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/24493",
    "labels": [
        {
            "color": "c5def5",
            "default": true,
            "description": "",
            "id": 84744038,
            "name": "documentation",
            "node_id": "MDU6TGFiZWw4NDc0NDAzOA==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/documentation"
        },
        {
            "color": "c7def8",
            "default": false,
            "description": "",
            "id": 109899557,
            "name": "vimscript",
            "node_id": "MDU6TGFiZWwxMDk4OTk1NTc=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/vimscript"
        }
    ],
    "locked": true,
    "merge_commit_sha": "42333ea98dfcd2994ee128a3467dfe68205154cd",
    "merged_at": "2023-07-28T13:48:42Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5WckRR",
    "number": 24493,
    "patch_url": "https://github.com/neovim/neovim/pull/24493.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/24493/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/858eef76bb621fc65c666e6c3e786e1b4a614c23",
    "title": "feat(docs): generate builtin.txt",
    "updated_at": "2023-08-02T18:35:50Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/24493",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
        "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
        "followers_url": "https://api.github.com/users/lewis6991/followers",
        "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
        "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/lewis6991",
        "id": 7904185,
        "login": "lewis6991",
        "node_id": "MDQ6VXNlcjc5MDQxODU=",
        "organizations_url": "https://api.github.com/users/lewis6991/orgs",
        "received_events_url": "https://api.github.com/users/lewis6991/received_events",
        "repos_url": "https://api.github.com/users/lewis6991/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/lewis6991"
    }
}