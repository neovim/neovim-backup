{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/36219/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36219/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/36219"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/36219"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36219/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/6353a3fed03d4861e3e75e56a19c75f940472da2"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6460,
            "forks_count": 6460,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 2031,
            "open_issues_count": 2031,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-12-15T23:50:03Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 355921,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 94967,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-12-16T02:41:18Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 94967,
            "watchers_count": 94967,
            "web_commit_signoff_required": false
        },
        "sha": "df849f6541ca6e6b9619ee350722e9b45c946f56",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Closes #36181.\r\n\r\nProvides a `vim.lsp.inlay_hint.apply_action()` function that can be used to create keymaps for interacting with attributes of [`inlayHints`](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#inlayHint):\r\n\r\n- `textEdits`: insert texts from the inlayhint into the buffer. basedpyright provides this attribute.\r\n- `location`: `lsp.Location` of a class/struct/function parameter in the hint. If there are more than 1 of them in the inlay hint, users will be prompted to choose one via `vim.ui.select`. `lua_ls` provides this attribute.\r\n- `command`: use a `workspace/executeCommand` request to execute `lsp.Command`. If there are multiple commands in an inlay hint, users would be prompted to choose one via `vim.ui.select. _I haven't been able to find a LSP that provides this. Recommendations would be welcomed. We could also omit this from this PR, if a feature that hasn't been tested on an actual server is not acceptable._\r\n- `tooltip`: opens a `vim.lsp.buf.hover()` like window that contains the tooltips in the inlayhint object _as well as_ available commands.\r\n\r\nThis is adapted from https://github.com/Davidyz/inlayhint-filler.nvim.\r\n\r\nNote: as a proof of concept, the `command` and `tooltip` actions only works with one inlayhint, so that the UI would be simpler to work with. Once the interface is agreed I can expand them to support visual mode.\r\n\r\nExample `minimal.lua` using [basedpyright](https://docs.basedpyright.com/latest/) and [lua_ls](https://github.com/LuaLS/lua-language-server):\r\n```lua\r\nlocal capabilities = (vim.lsp.protocol.make_client_capabilities())\r\n\r\nlocal enable_hint_for_buf = function(_, bufnr)\r\n  vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })\r\nend\r\nvim.lsp.config(\r\n  'basedpyright',\r\n  ---@type vim.lsp.Config\r\n  {\r\n    cmd = { 'basedpyright-langserver', '--stdio' },\r\n    filetypes = { 'python' },\r\n    settings = {\r\n      basedpyright = {\r\n        analysis = {\r\n          inlayHints = {\r\n            callArgumentNames = 'all',\r\n            functionReturnTypes = true,\r\n            variableTypes = true,\r\n            genericTypes = true,\r\n            useTypingExtensions = true,\r\n            callArgumentNamesMatching = true,\r\n          },\r\n        },\r\n      },\r\n    },\r\n    capabilities = capabilities,\r\n    on_attach = enable_hint_for_buf,\r\n  }\r\n)\r\n\r\nvim.lsp.config('lua_ls', {\r\n  capabilities = capabilities,\r\n  on_attach = enable_hint_for_buf,\r\n  cmd = { 'lua-language-server' },\r\n  filetypes = { 'lua' },\r\n  name = 'lua_ls',\r\n  root_markers = {\r\n    '.luarc.json',\r\n    '.luarc.jsonc',\r\n    '.luacheckrc',\r\n    '.stylua.toml',\r\n    'stylua.toml',\r\n    'selene.toml',\r\n    'selene.yml',\r\n    '.git',\r\n  },\r\n  settings = {\r\n    Lua = {\r\n      hint = {\r\n        enable = true,\r\n        setType = true,\r\n      },\r\n      type = {\r\n        inferParamType = true,\r\n      },\r\n      workspace = { library = { vim.env.VIMRUNTIME } },\r\n    },\r\n  },\r\n  single_file_support = true,\r\n})\r\n\r\nvim.lsp.enable('basedpyright', true)\r\nvim.lsp.enable('lua_ls', true)\r\nvim.lsp.inlay_hint.enable(true)\r\n\r\nfor _, mode in ipairs({ 'n', 'v' }) do\r\n  vim.keymap.set(mode, 'gie', function()\r\n    vim.lsp.inlay_hint.apply_action('textEdits')\r\n  end, { desc = 'Apply text[E]dits' })\r\n\r\n  vim.keymap.set(mode, 'gil', function()\r\n    vim.lsp.inlay_hint.apply_action('location')\r\n  end, { desc = 'Jump to [l]ocation' })\r\n\r\n  vim.keymap.set(mode, 'gic', function()\r\n    vim.lsp.inlay_hint.apply_action('command')\r\n  end, { desc = 'LSP [c]ommand' })\r\n\r\n  vim.keymap.set(mode, 'git', function()\r\n    vim.lsp.inlay_hint.apply_action('tooltip')\r\n  end, { desc = '[t]ooltips' })\r\nend\r\n```",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440203509"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440203509"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n      util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n```\n",
            "commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "created_at": "2025-10-17T14:21:32Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440203509",
            "id": 2440203509,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rcoz1",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 517,
            "original_position": 90,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350601238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440203509/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:29:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440203509",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440205352"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440205352"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    local start_pos = fn.getpos('v')\n    local end_pos = fn.getpos('.')\n```\n",
            "commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "created_at": "2025-10-17T14:22:11Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440205352",
            "id": 2440205352,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RcpQo",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 490,
            "original_position": 63,
            "original_start_line": 489,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350601238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440205352/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-10-17T14:29:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440205352",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440206452"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440206452"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n```\n\nthis was for debugging im guessing?\n",
            "commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "created_at": "2025-10-17T14:22:35Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440206452",
            "id": 2440206452,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rcph0",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 501,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350601238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440206452/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:29:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440206452",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440218000"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440218000"
                }
            },
            "author_association": "MEMBER",
            "body": "Wouldn't this be handled by the one who creates a keybind for this func?",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-17T14:26:34Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440218000",
            "id": 2440218000,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RcsWQ",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 470,
            "original_position": 43,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350601238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440218000/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:29:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440218000",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440224450"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440224450"
                }
            },
            "author_association": "MEMBER",
            "body": "Why refetch over reading bufstate.client_hints?",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-10-17T14:28:52Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+\n+    client:request(\n+      'textDocument/inlayHint',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440224450",
            "id": 2440224450,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rct7C",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 1072,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350601238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440224450/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:29:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440224450",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440241587"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440241587"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Ah yes sorry about that. ",
            "commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "created_at": "2025-10-17T14:34:55Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440241587",
            "id": 2440241587,
            "in_reply_to_id": 2440206452,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RcyGz",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 501,
            "original_position": 74,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350649912,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440241587/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:34:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440241587",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440253777"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440253777"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "because bufstate.client_hints uses the default handlers, which can be overridden by UI decorations, etc.\r\n\r\nhttps://github.com/neovim/neovim/issues/36181#issuecomment-3404616670",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-10-17T14:39:22Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+\n+    client:request(\n+      'textDocument/inlayHint',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440253777",
            "id": 2440253777,
            "in_reply_to_id": 2440224450,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rc1FR",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 1072,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350664917,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440253777/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:39:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440253777",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440264180"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440264180"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "When you follow the docstring to configure dot-repeat using `operatorfunc`, the argument will be a string that contains motion info. Maybe we could work around this by creating a wrapper function that is dedicated to dot-repeat? ",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-17T14:42:49Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440264180",
            "id": 2440264180,
            "in_reply_to_id": 2440218000,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rc3n0",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 470,
            "original_position": 43,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350679816,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440264180/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:42:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440264180",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2440267324"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440267324"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Idk why but some tests failed after this change. I'll figure them out and push the cleanup altogether.",
            "commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "created_at": "2025-10-17T14:43:50Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2440267324",
            "id": 2440267324,
            "in_reply_to_id": 2440203509,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rc4Y8",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 517,
            "original_position": 90,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3350683911,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440267324/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T14:43:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2440267324",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441442466"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441442466"
                }
            },
            "author_association": "MEMBER",
            "body": "Looks like `_comment.lua` has a good example",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-17T23:29:17Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441442466",
            "id": 2441442466,
            "in_reply_to_id": 2440218000,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhXSi",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 470,
            "original_position": 43,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352374825,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441442466/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T23:29:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441442466",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441445702"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441445702"
                }
            },
            "author_association": "MEMBER",
            "body": "We should probably skip calling `resolve` if the hint has already set the text edits field? Not sure if this adds too much complexity.",
            "commit_id": "adf5b0554c316196ce5e6907f46cd9d5209f9ebe",
            "created_at": "2025-10-17T23:33:56Z",
            "diff_hunk": "@@ -561,22 +586,41 @@ function M.apply_text_edits(opts)\n                 return true\n               end\n             )\n-            :map(\n-              ---@param hint lsp.InlayHint\n-              function(hint)\n-                return hint.textEdits\n-              end\n-            )\n-            :flatten(1)\n             :totable()\n-          if #text_edits > 0 then\n-            return vim.schedule(function()\n-              util.apply_text_edits(text_edits, bufnr, client.offset_encoding)\n-            end)\n+          if #hints > 0 then\n+            if not support_resolve then\n+              if apply_edits(client, hints) == 0 then\n+                -- no edits applied. proceed with the iteration.\n+                return do_insert(next(clients, idx))\n+              else\n+                -- we're done with the edits.\n+                return\n+              end\n+            elseif support_resolve then\n+              ---@type integer\n+              local num_processed = 0\n+\n+              for i, h in ipairs(hints) do\n+                client:request('inlayHint/resolve', h, function(_, _result, _, _)",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441445702",
            "id": 2441445702,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhYFG",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 604,
            "original_position": 95,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352380089,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441445702/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-17T23:34:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441445702",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441549530"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549530"
                }
            },
            "author_association": "MEMBER",
            "body": "Why should we make this an option? Intuitively I would expect this to only resolve the inlay hints under the cursor.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T03:24:02Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441549530",
            "id": 2441549530,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rhxba",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2182,
            "original_position": 18,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352506470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549530/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:33:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549530",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441549853"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549853"
                }
            },
            "author_association": "MEMBER",
            "body": "This feels a bit niche. I would leave it out of the docs.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T03:24:51Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441549853",
            "id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rhxgd",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352506470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549853/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:33:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441549853",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441550004"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441550004"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, { desc = \"Apply inlay hint edits\" })\n```",
            "commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "created_at": "2025-10-18T03:25:19Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441550004",
            "id": 2441550004,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rhxi0",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2195,
            "original_position": 31,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352506470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441550004/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:33:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441550004",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441552305"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552305"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmm I agree with @ribru17 here. Triggering another inlay hint request here feels strange considering that users will usually apply the edits from the currently displayed hints.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-10-18T03:32:00Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+\n+    client:request(\n+      'textDocument/inlayHint',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441552305",
            "id": 2441552305,
            "in_reply_to_id": 2440224450,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhyGx",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 1072,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352506470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552305/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:33:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552305",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441552796"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552796"
                }
            },
            "author_association": "MEMBER",
            "body": "I doubt that multiple clients will be providing inlay hints for the same range. And even if it does happen, I think people would like to apply the edits from a single client. Perhaps we should add a client filter option?",
            "commit_id": "a2d2be6e5f371056fbaf6fe1a14123e5b4782246",
            "created_at": "2025-10-18T03:33:45Z",
            "diff_hunk": "@@ -435,4 +436,197 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = fn.getpos('v')\n+    local end_pos = fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  --- returns the number of edits applied.\n+  ---@param client vim.lsp.Client\n+  ---@param hints lsp.InlayHint\n+  ---@return integer\n+  local function apply_edits(client, hints)\n+    ---@type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(hints)\n+      :filter(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :map(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, bufnr, client.offset_encoding)\n+      end)\n+    end\n+    return #text_edits\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+    local support_resolve = client:supports_method('inlayHint/resolve', bufnr)\n+\n+    client:request(\n+      'textDocument/inlayHint',\n+      params,\n+      ---@param result lsp.InlayHint[]?\n+      function(_, result, _, _)\n+        if result ~= nil then\n+          ---@type lsp.InlayHint[]\n+          local hints = vim\n+            .iter(result)\n+            :filter(\n+              ---@param hint lsp.InlayHint\n+              function(hint)\n+                if opts.post_filtering then\n+                  local hint_pos = hint.position\n+                  if\n+                    hint_pos.line < params.range.start.line\n+                    or hint_pos.line > params.range['end'].line\n+                  then\n+                    -- outside of line range\n+                    return false\n+                  end\n+\n+                  if hint_pos.line == params.range.start.line then\n+                    -- pos is in the same line as range.start\n+                    if hint_pos.line == params.range['end'].line then\n+                      -- range.start in the same line as range.end\n+                      return params.range.start.character <= hint_pos.character\n+                        and hint_pos.character <= params.range['end'].character\n+                    end\n+                    return hint_pos.character >= params.range.start.character\n+                  end\n+\n+                  if hint_pos.line == params.range['end'].line then\n+                    return hint_pos.character <= params.range['end'].character\n+                  end\n+                end\n+                return true\n+              end\n+            )\n+            :totable()\n+          if #hints > 0 then\n+            if not support_resolve then\n+              if apply_edits(client, hints) == 0 then\n+                -- no edits applied. proceed with the iteration.\n+                return do_insert(next(clients, idx))\n+              else\n+                -- we're done with the edits.\n+                return\n+              end\n+            elseif support_resolve then\n+              ---@type integer\n+              local num_processed = 0\n+\n+              for i, h in ipairs(hints) do\n+                client:request('inlayHint/resolve', h, function(_, _result, _, _)\n+                  if _result ~= nil then\n+                    hints[i] = _result\n+                  end\n+                  num_processed = num_processed + 1\n+\n+                  if num_processed == #hints then\n+                    apply_edits(client, hints)\n+                  end\n+                end, bufnr)\n+              end\n+            end\n+          else\n+            -- no hints in the given range.\n+            return do_insert(next(clients, idx))\n+          end\n+        else\n+          -- result is nil. Proceed to next client.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441552796",
            "id": 2441552796,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhyOc",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 902,
            "original_position": 194,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352506470,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552796/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:33:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441552796",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441553446"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441553446"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> I would expect this to only resolve the inlay hints under the cursor.\r\n\r\nI thought so too, but when experimenting with basedpyright, I found that it always resolves the whole line, not just under the cursor.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T03:36:23Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441553446",
            "id": 2441553446,
            "in_reply_to_id": 2441549530,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhyYm",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2182,
            "original_position": 18,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352511318,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441553446/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:36:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441553446",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441555905"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441555905"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "@ribru17 what do you think about this? if we're dropping this section from the doc, I might as well just drop [this `if` block here](https://github.com/Davidyz/neovim/blob/52fb934668c922c13a579367024cc01bf7885197/runtime/lua/vim/lsp/inlay_hint.lua#L469).",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T03:41:43Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441555905",
            "id": 2441555905,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rhy_B",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352514098,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441555905/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:41:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441555905",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441556268"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441556268"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "it does only insert from a single client. The `do_insert(next(...))` thing only proceed if the previous client doesn't provide any edit. If `apply_edits` inserted at least 1 edit, the iteration stops.",
            "commit_id": "a2d2be6e5f371056fbaf6fe1a14123e5b4782246",
            "created_at": "2025-10-18T03:43:08Z",
            "diff_hunk": "@@ -435,4 +436,197 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = fn.getpos('v')\n+    local end_pos = fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  --- returns the number of edits applied.\n+  ---@param client vim.lsp.Client\n+  ---@param hints lsp.InlayHint\n+  ---@return integer\n+  local function apply_edits(client, hints)\n+    ---@type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(hints)\n+      :filter(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :map(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, bufnr, client.offset_encoding)\n+      end)\n+    end\n+    return #text_edits\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+    local support_resolve = client:supports_method('inlayHint/resolve', bufnr)\n+\n+    client:request(\n+      'textDocument/inlayHint',\n+      params,\n+      ---@param result lsp.InlayHint[]?\n+      function(_, result, _, _)\n+        if result ~= nil then\n+          ---@type lsp.InlayHint[]\n+          local hints = vim\n+            .iter(result)\n+            :filter(\n+              ---@param hint lsp.InlayHint\n+              function(hint)\n+                if opts.post_filtering then\n+                  local hint_pos = hint.position\n+                  if\n+                    hint_pos.line < params.range.start.line\n+                    or hint_pos.line > params.range['end'].line\n+                  then\n+                    -- outside of line range\n+                    return false\n+                  end\n+\n+                  if hint_pos.line == params.range.start.line then\n+                    -- pos is in the same line as range.start\n+                    if hint_pos.line == params.range['end'].line then\n+                      -- range.start in the same line as range.end\n+                      return params.range.start.character <= hint_pos.character\n+                        and hint_pos.character <= params.range['end'].character\n+                    end\n+                    return hint_pos.character >= params.range.start.character\n+                  end\n+\n+                  if hint_pos.line == params.range['end'].line then\n+                    return hint_pos.character <= params.range['end'].character\n+                  end\n+                end\n+                return true\n+              end\n+            )\n+            :totable()\n+          if #hints > 0 then\n+            if not support_resolve then\n+              if apply_edits(client, hints) == 0 then\n+                -- no edits applied. proceed with the iteration.\n+                return do_insert(next(clients, idx))\n+              else\n+                -- we're done with the edits.\n+                return\n+              end\n+            elseif support_resolve then\n+              ---@type integer\n+              local num_processed = 0\n+\n+              for i, h in ipairs(hints) do\n+                client:request('inlayHint/resolve', h, function(_, _result, _, _)\n+                  if _result ~= nil then\n+                    hints[i] = _result\n+                  end\n+                  num_processed = num_processed + 1\n+\n+                  if num_processed == #hints then\n+                    apply_edits(client, hints)\n+                  end\n+                end, bufnr)\n+              end\n+            end\n+          else\n+            -- no hints in the given range.\n+            return do_insert(next(clients, idx))\n+          end\n+        else\n+          -- result is nil. Proceed to next client.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441556268",
            "id": 2441556268,
            "in_reply_to_id": 2441552796,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RhzEs",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 902,
            "original_position": 194,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352514537,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441556268/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T03:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441556268",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441564243"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441564243"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "But reading from `bufstate.client_hints` means that the `vim.lsp.inlay_hint.apply_text_edits` function will break if the default inlay hint handler (`vim.lsp.handlers['textDocument/inlayHint']`) is overwritten by users/plugins. I've had a user reporting this exact problem when working with https://github.com/Davidyz/inlayhint-filler.nvim (the issue wasn't filed on GitHub). That's the reason I decided to drop `vim.lsp.inlay_hint.get` and write my own requests.\r\n\r\nAfter all, the cached hints in `bufstate` are mostly used for UI (virtual texts, etc.), and it's not uncommon for users to want to customise that. `textEdits` is a different story. Just like completions, you usually just want to apply whatever the LSP server provides. I think it's not a good experience if a user overwrites the default handler for UI customisation and discovers that the text edits break.\r\n\r\n> users will usually apply the edits from the currently displayed hints.\r\n\r\nPlugins/user configs like https://github.com/chrisgrieser/nvim-lsp-endhints will modify the displayed position of the hints and prevent updating `bufstate`. This makes the hints from bufstate unreliable for text edits.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-10-18T04:12:48Z",
            "diff_hunk": "@@ -435,4 +436,154 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class vim.lsp.inlay_hint.apply_text_edits.Opts\n+--- Whether to filter the inlay hints to strictly include the ones in the range.\n+--- @field post_filtering boolean?\n+\n+--- For supported LSP servers, apply the `textEdit`s in the inlay hint to the buffer.\n+---\n+--- - In |Normal-mode|, this function inserts inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, this function inserts inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+--- ```\n+---\n+--- For dot-repeat, you can set up the keymap like the following:\n+--- ```lua\n+--- vim.keymap.set(\n+---   \"n\",\n+---   \"gI\",\n+---   function()\n+---     vim.o.operatorfunc = \"v:lua.vim.lsp.inlay_hint.apply_text_edits\"\n+---     return vim.api.nvim_input(\"g@ \")\n+---   end,\n+---   {}\n+--- )\n+--- ```\n+---\n+---\n+--- @param opts? vim.lsp.inlay_hint.apply_text_edits.Opts|string\n+function M.apply_text_edits(opts)\n+  if type(opts) ~= 'table' then\n+    -- TODO: how to handle dot-repeat special arg?\n+    opts = {}\n+  end\n+  opts = vim.tbl_deep_extend('force', { post_filtering = true }, opts or {})\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = vim.fn.getpos('v')\n+    local end_pos = vim.fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    vim.schedule_wrap(vim.notify)(vim.inspect(range))\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      vim.lsp.util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+\n+    client:request(\n+      'textDocument/inlayHint',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441564243",
            "id": 2441564243,
            "in_reply_to_id": 2440224450,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rh1BT",
            "original_commit_id": "ff21f996bfee9da03843f2bde61b2e6f47ab9040",
            "original_line": 1072,
            "original_position": 93,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3352525209,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441564243/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T04:12:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441564243",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441566051"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441566051"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah we should defer to the opinion of @MariaSolOs here. Tbh I don't fully get the need for dot repeat here- dot repeat is meant for operations that act over a motion, but it looks like this one doesn't (in normal mode, it just works on adjacent inlay hints). ",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T04:18:51Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441566051",
            "id": 2441566051,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rh1dj",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352528989,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441566051/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T04:18:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441566051",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441567313"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441567313"
                }
            },
            "author_association": "MEMBER",
            "body": "Or at least if it seems that useful, is there a way for the public function itself to set the operatorfunc to some inner function which does the actual logic? So users can just set that function to a keybind and have dot repeat just workTM? (unsure if this is possible, just curious)",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T04:23:18Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441567313",
            "id": 2441567313,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rh1xR",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352530230,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441567313/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T04:23:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441567313",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441585966"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441585966"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> is there a way for the public function itself to set the operatorfunc to some inner function which does the actual logic?\r\n\r\nIt is possible, and that's actually how it's done in my plugin: https://github.com/Davidyz/inlayhint-filler.nvim/blob/832456c81586653a6892d983e6709337558f944c/lua/inlayhint-filler.lua#L208\r\n\r\nI wanted to keep things contained in one single function, but I guess it just makes things more complicated than needed.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T05:30:17Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441585966",
            "id": 2441585966,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6Rh6Uu",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352558477,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441585966/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T05:30:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441585966",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2441760827"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441760827"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think I'll just drop built-in dot-repeat, because it's tricky (and maybe too complicated) to get it to play nicely with `opts`. Users can always create a wrapper for the `apply_text_edits` function with the preferred options and use the wrapper with `operatorfunc`.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T08:04:06Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2441760827",
            "id": 2441760827,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RilA7",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3352753592,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441760827/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T08:04:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2441760827",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2442460375"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442460375"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe then the option should be removed, and the additional filtering always performed",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-18T15:13:42Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2442460375",
            "id": 2442460375,
            "in_reply_to_id": 2441549530,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RlPzX",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2182,
            "original_position": 18,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3353626518,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442460375/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-18T15:13:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442460375",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2442702504"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442702504"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah, I say we should just remove this option and keep the current logic of applying the edits under the cursor when in normal mode and then allowing for a more controlled application of the edits with visual mode.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-19T00:51:17Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2442702504",
            "id": 2442702504,
            "in_reply_to_id": 2441549530,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RmK6o",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2182,
            "original_position": 18,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3353905245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442702504/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-19T00:51:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442702504",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2442703446"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442703446"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah dot-repeat isn't something that we should worry about in the initial implementation of LSP features.",
            "commit_id": "e7ec0b2033e86ba7f33bd9ef9157584ab7f25509",
            "created_at": "2025-10-19T00:54:51Z",
            "diff_hunk": "@@ -2176,6 +2176,40 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+*vim.lsp.inlay_hint.apply_text_edits.Opts*\n+\n+    Fields: ~\n+       {post_filtering}  (`boolean?`) Whether to filter the inlay hints to\n+                          strictly include the ones in the range.\n+\n+\n+apply_text_edits({opts})               *vim.lsp.inlay_hint.apply_text_edits()*\n+    For supported LSP servers, apply the `textEdit`s in the inlay hint to the\n+    buffer.\n+     In |Normal-mode|, this function inserts inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, this function inserts inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\"n\", \"gI\", vim.lsp.inlay_hint.apply_text_edits, {})\n+<\n+\n+    For dot-repeat, you can set up the keymap like the following: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2442703446",
            "id": 2442703446,
            "in_reply_to_id": 2441549853,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6RmLJW",
            "original_commit_id": "52fb934668c922c13a579367024cc01bf7885197",
            "original_line": 2198,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3353905904,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442703446/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-10-19T00:54:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2442703446",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2563082915"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563082915"
                }
            },
            "author_association": "MEMBER",
            "body": "please see if `vim.pos` can be used to do position/range comparisons.\n\n(in all parts of this PR, where appropriate)",
            "commit_id": "bdd5cdc4928eae0e3d80b21714a81710ba7e83d5",
            "created_at": "2025-11-26T04:51:37Z",
            "diff_hunk": "@@ -435,4 +436,212 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @alias vim.lsp.inlay_hint.action.callback fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer\n+\n+--- @alias vim.lsp.inlay_hint.action.name\n+---| 'textEdits' -- apply_text_edits\n+---| 'tooltip' -- string (plain text or markdown): hover?\n+---| 'command' -- 'workspace/executeCommand'\n+---| 'location' -- jump to location?\n+\n+--- @alias vim.lsp.inlay_hint.action\n+---| vim.lsp.inlay_hint.action.name\n+---| vim.lsp.inlay_hint.action.callback\n+\n+--- @class vim.lsp.inlay_hint.action.context\n+--- @inlinedoc\n+--- @field bufnr integer\n+--- @field client vim.lsp.Client\n+\n+---@type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.callback>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx)\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    ---@type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+}\n+\n+--- For supported LSP servers, apply one of the following actions provided by inlayhints in the\n+--- selected range.\n+---\n+--- - In |Normal-mode|, the action applies to inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, the action applies to inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\n+---   'n',\n+---   'gI',\n+---   function()\n+---     vim.lsp.inlay_hint.apply_action(\"textEdits\")\n+---   end,\n+---   { desc = 'Apply inlay hint edits' }\n+--- )\n+--- ```\n+---\n+--- @param action vim.lsp.inlay_hint.action\n+---\n+--- Possible actions: `\"textEdits\"`, `\"tooltip\"`, `\"location\"`, `\"command\"` and a custom callback:\n+--- `fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer`, which accepts the resolved inlayhints in the range and some context, perform some actions and returns the number of hints on which the actions were taken.\n+function M.apply_action(action)\n+  local action_callback = action\n+  if type(action) == 'string' then\n+    action_callback = inlayhint_actions[action]\n+    ---@cast action_callback -vim.lsp.inlay_hint.action.name\n+  end\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = fn.getpos('v')\n+    local end_pos = fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+    local support_resolve = client:supports_method('inlayHint/resolve', bufnr)\n+\n+    client:request(\n+      'textDocument/inlayHint',\n+      params,\n+      ---@param result lsp.InlayHint[]?\n+      function(_, result, _, _)\n+        if result ~= nil then\n+          ---@type lsp.InlayHint[]\n+          local hints = vim\n+            .iter(result)\n+            :filter(\n+              ---@param hint lsp.InlayHint\n+              function(hint)\n+                local hint_pos = hint.position\n+                if\n+                  hint_pos.line < params.range.start.line\n+                  or hint_pos.line > params.range['end'].line\n+                then\n+                  -- outside of line range\n+                  return false\n+                end\n+\n+                if hint_pos.line == params.range.start.line then\n+                  -- pos is in the same line as range.start\n+                  if hint_pos.line == params.range['end'].line then\n+                    -- range.start in the same line as range.end\n+                    return params.range.start.character <= hint_pos.character\n+                      and hint_pos.character <= params.range['end'].character\n+                  end\n+                  return hint_pos.character >= params.range.start.character",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2563082915",
            "id": 2563082915,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6YxYqj",
            "original_commit_id": "8411d54cfae6a940034f16356e90d37347faa73e",
            "original_line": 856,
            "original_position": 163,
            "original_start_line": 583,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3508673397,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563082915/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-11-26T04:51:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563082915",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2563090258"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563090258"
                }
            },
            "author_association": "MEMBER",
            "body": "needs a docstring. it obviously isn't merely just \"inserting stuff\", so the docstring should say why it exists and what it does.",
            "commit_id": "a965cb5944f2a9c34d6c23359c03b464c4a35010",
            "created_at": "2025-11-26T04:53:19Z",
            "diff_hunk": "@@ -435,4 +436,212 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @alias vim.lsp.inlay_hint.action.callback fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer\n+\n+--- @alias vim.lsp.inlay_hint.action.name\n+---| 'textEdits' -- apply_text_edits\n+---| 'tooltip' -- string (plain text or markdown): hover?\n+---| 'command' -- 'workspace/executeCommand'\n+---| 'location' -- jump to location?\n+\n+--- @alias vim.lsp.inlay_hint.action\n+---| vim.lsp.inlay_hint.action.name\n+---| vim.lsp.inlay_hint.action.callback\n+\n+--- @class vim.lsp.inlay_hint.action.context\n+--- @inlinedoc\n+--- @field bufnr integer\n+--- @field client vim.lsp.Client\n+\n+---@type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.callback>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx)\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    ---@type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+}\n+\n+--- For supported LSP servers, apply one of the following actions provided by inlayhints in the\n+--- selected range.\n+---\n+--- - In |Normal-mode|, the action applies to inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, the action applies to inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\n+---   'n',\n+---   'gI',\n+---   function()\n+---     vim.lsp.inlay_hint.apply_action(\"textEdits\")\n+---   end,\n+---   { desc = 'Apply inlay hint edits' }\n+--- )\n+--- ```\n+---\n+--- @param action vim.lsp.inlay_hint.action\n+---\n+--- Possible actions: `\"textEdits\"`, `\"tooltip\"`, `\"location\"`, `\"command\"` and a custom callback:\n+--- `fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer`, which accepts the resolved inlayhints in the range and some context, perform some actions and returns the number of hints on which the actions were taken.\n+function M.apply_action(action)\n+  local action_callback = action\n+  if type(action) == 'string' then\n+    action_callback = inlayhint_actions[action]\n+    ---@cast action_callback -vim.lsp.inlay_hint.action.name\n+  end\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = fn.getpos('v')\n+    local end_pos = fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2563090258",
            "id": 2563090258,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6YxadS",
            "original_commit_id": "8411d54cfae6a940034f16356e90d37347faa73e",
            "original_line": 884,
            "original_position": 126,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3508682183,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563090258/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-26T04:53:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2563090258",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572554383"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572554383"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    inlay hints in the selected range.\n```",
            "commit_id": "19240762e7012c718842648dc76d77794dd7650e",
            "created_at": "2025-11-28T21:35:06Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*\n+    For supported LSP servers, apply one of the following actions provided by\n+    inlayhints in the selected range.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572554383",
            "id": 2572554383,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVhCP",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2173,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572554383/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572554383",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572556094"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572556094"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    Apply one of the following actions provided by\n```\nIt is already implied that this will use language servers that support the feature.",
            "commit_id": "19240762e7012c718842648dc76d77794dd7650e",
            "created_at": "2025-11-28T21:36:14Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*\n+    For supported LSP servers, apply one of the following actions provided by",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572556094",
            "id": 2572556094,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVhc-",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2172,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572556094/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572556094",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572557033"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557033"
                }
            },
            "author_association": "MEMBER",
            "body": "Since the command works in both normal and visual mode, I would modify the example to feature that.",
            "commit_id": "bcd72c7b10826a6f3acab4f718ec73d85bd1c9f4",
            "created_at": "2025-11-28T21:36:58Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*\n+    For supported LSP servers, apply one of the following actions provided by\n+    inlayhints in the selected range.\n+     In |Normal-mode|, the action applies to inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, the action applies to inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          'n',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572557033",
            "id": 2572557033,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVhrp",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2181,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557033/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557033",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572557398"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557398"
                }
            },
            "author_association": "MEMBER",
            "body": "Nit:\n```suggestion\n            vim.lsp.inlay_hint.apply_action('textEdits')\n```",
            "commit_id": "19240762e7012c718842648dc76d77794dd7650e",
            "created_at": "2025-11-28T21:37:13Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*\n+    For supported LSP servers, apply one of the following actions provided by\n+    inlayhints in the selected range.\n+     In |Normal-mode|, the action applies to inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, the action applies to inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          'n',\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action(\"textEdits\")",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572557398",
            "id": 2572557398,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVhxW",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2184,
            "original_position": 17,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557398/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572557398",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572558503"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572558503"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n                  which accepts the resolved inlay hints in the range and some\n```",
            "commit_id": "19240762e7012c718842648dc76d77794dd7650e",
            "created_at": "2025-11-28T21:37:49Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*\n+    For supported LSP servers, apply one of the following actions provided by\n+    inlayhints in the selected range.\n+     In |Normal-mode|, the action applies to inlay hints that are adjacent to\n+      the cursor.\n+     In |Visual-mode|, the action applies to inlay hints that are in the\n+      visually selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          'n',\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action(\"textEdits\")\n+          end,\n+          { desc = 'Apply inlay hint edits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}  (`vim.lsp.inlay_hint.action`)\n+\n+                  Possible actions: `\"textEdits\"`, `\"tooltip\"`, `\"location\"`,\n+                  `\"command\"` or a custom callback:\n+                  `fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer`,\n+                  which accepts the resolved inlayhints in the range and some",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572558503",
            "id": 2572558503,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZViCn",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2196,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572558503/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572558503",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572560069"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560069"
                }
            },
            "author_association": "MEMBER",
            "body": "I would rename this to `apply` (WDYT @justinmk?) as this applies everything from a text edit, a command or display a tooltip.",
            "commit_id": "52a071f2f0380a10076c3496732ff0724d8421e0",
            "created_at": "2025-11-28T21:39:02Z",
            "diff_hunk": "@@ -2168,6 +2168,37 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+apply_action({action}, {opts})             *vim.lsp.inlay_hint.apply_action()*",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572560069",
            "id": 2572560069,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVibF",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 2173,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560069/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560069",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2572560994"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560994"
                }
            },
            "author_association": "MEMBER",
            "body": "For easier reviewing could you please remove the unrelated whitespace changes?",
            "commit_id": "3acc46ba4ee409d29b44fa0439b130efe72ae5c5",
            "created_at": "2025-11-28T21:39:39Z",
            "diff_hunk": "@@ -1,21 +1,22 @@\n local util = require('vim.lsp.util')\n local log = require('vim.lsp.log')\n local api = vim.api\n+local fn = vim.fn\n local M = {}\n \n----@class (private) vim.lsp.inlay_hint.globalstate Global state for inlay hints\n----@field enabled boolean Whether inlay hints are enabled for this scope\n----@type vim.lsp.inlay_hint.globalstate\n+--- @class (private) vim.lsp.inlay_hint.globalstate Global state for inlay hints",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2572560994",
            "id": 2572560994,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ZVipi",
            "original_commit_id": "7ade43f2a2cf8b150e97d64eb8cf9d4fa0604f85",
            "original_line": 7,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3520097132,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560994/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-11-28T21:41:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2572560994",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2588839148"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2588839148"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "done.",
            "commit_id": "bdd5cdc4928eae0e3d80b21714a81710ba7e83d5",
            "created_at": "2025-12-04T12:16:17Z",
            "diff_hunk": "@@ -435,4 +436,212 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @alias vim.lsp.inlay_hint.action.callback fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer\n+\n+--- @alias vim.lsp.inlay_hint.action.name\n+---| 'textEdits' -- apply_text_edits\n+---| 'tooltip' -- string (plain text or markdown): hover?\n+---| 'command' -- 'workspace/executeCommand'\n+---| 'location' -- jump to location?\n+\n+--- @alias vim.lsp.inlay_hint.action\n+---| vim.lsp.inlay_hint.action.name\n+---| vim.lsp.inlay_hint.action.callback\n+\n+--- @class vim.lsp.inlay_hint.action.context\n+--- @inlinedoc\n+--- @field bufnr integer\n+--- @field client vim.lsp.Client\n+\n+---@type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.callback>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx)\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    ---@type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        ---@param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+}\n+\n+--- For supported LSP servers, apply one of the following actions provided by inlayhints in the\n+--- selected range.\n+---\n+--- - In |Normal-mode|, the action applies to inlay hints that are adjacent to the cursor.\n+--- - In |Visual-mode|, the action applies to inlay hints that are in the visually selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\n+---   'n',\n+---   'gI',\n+---   function()\n+---     vim.lsp.inlay_hint.apply_action(\"textEdits\")\n+---   end,\n+---   { desc = 'Apply inlay hint edits' }\n+--- )\n+--- ```\n+---\n+--- @param action vim.lsp.inlay_hint.action\n+---\n+--- Possible actions: `\"textEdits\"`, `\"tooltip\"`, `\"location\"`, `\"command\"` and a custom callback:\n+--- `fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context):integer`, which accepts the resolved inlayhints in the range and some context, perform some actions and returns the number of hints on which the actions were taken.\n+function M.apply_action(action)\n+  local action_callback = action\n+  if type(action) == 'string' then\n+    action_callback = inlayhint_actions[action]\n+    ---@cast action_callback -vim.lsp.inlay_hint.action.name\n+  end\n+  local bufnr = api.nvim_get_current_buf()\n+  local winid = fn.bufwinid(bufnr)\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = 'textDocument/inlayHint' })\n+\n+  local mode = fn.mode()\n+\n+  -- mark position, (1, 0) indexed, end-inclusive\n+  ---@type {start: [integer, integer], end: [integer, integer]}\n+  local range = {}\n+\n+  if mode == 'n' then\n+    local cursor = api.nvim_win_get_cursor(winid)\n+    range.start = cursor\n+    range['end'] = cursor\n+  else\n+    local start_pos = fn.getpos('v')\n+    local end_pos = fn.getpos('.')\n+    if start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3]) then\n+      ---@type [integer, integer, integer, integer]\n+      start_pos, end_pos = end_pos, start_pos\n+    end\n+\n+    range = {\n+      start = { start_pos[2], start_pos[3] - 1 },\n+      ['end'] = { end_pos[2], end_pos[3] - 2 },\n+    }\n+\n+    if mode == 'V' or mode == 'Vs' then\n+      range.start[2] = 0\n+      range['end'][1] = range['end'][1] + 1\n+      range['end'][2] = 0\n+    end\n+  end\n+\n+  ---@param idx? integer\n+  ---@param client vim.lsp.Client\n+  local function do_insert(idx, client)\n+    if idx == nil then\n+      return\n+    end\n+\n+    local params =\n+      util.make_given_range_params(range.start, range['end'], bufnr, client.offset_encoding)\n+    local support_resolve = client:supports_method('inlayHint/resolve', bufnr)\n+\n+    client:request(\n+      'textDocument/inlayHint',\n+      params,\n+      ---@param result lsp.InlayHint[]?\n+      function(_, result, _, _)\n+        if result ~= nil then\n+          ---@type lsp.InlayHint[]\n+          local hints = vim\n+            .iter(result)\n+            :filter(\n+              ---@param hint lsp.InlayHint\n+              function(hint)\n+                local hint_pos = hint.position\n+                if\n+                  hint_pos.line < params.range.start.line\n+                  or hint_pos.line > params.range['end'].line\n+                then\n+                  -- outside of line range\n+                  return false\n+                end\n+\n+                if hint_pos.line == params.range.start.line then\n+                  -- pos is in the same line as range.start\n+                  if hint_pos.line == params.range['end'].line then\n+                    -- range.start in the same line as range.end\n+                    return params.range.start.character <= hint_pos.character\n+                      and hint_pos.character <= params.range['end'].character\n+                  end\n+                  return hint_pos.character >= params.range.start.character",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2588839148",
            "id": 2588839148,
            "in_reply_to_id": 2563082915,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6aTozs",
            "original_commit_id": "8411d54cfae6a940034f16356e90d37347faa73e",
            "original_line": 856,
            "original_position": 163,
            "original_start_line": 583,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 1,
            "pull_request_review_id": 3539730655,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2588839148/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-04T12:16:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2588839148",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2607478793"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607478793"
                }
            },
            "author_association": "MEMBER",
            "body": "This test is almost identical to the one above. Easy to deduplicate. \n\nAre there other tests that can be less verbose? \n\nOver-abstraction is a cost, but basic mechanisms for reducing verbosity, greatly increases readability + maintainability without too much indirection.",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-10T16:59:29Z",
            "diff_hunk": "@@ -452,3 +453,732 @@ test text\n     api.nvim_exec_autocmds('VimLeavePre', { modeline = false })\n   end)\n end)\n+\n+describe('vim.lsp.inlay_hint.apply_action', function()\n+  ---@type table<string, {lines: string[], name: string, filetype: string, bufnr: integer?, uri: string}>\n+  local mocked_files = {\n+    main = {\n+      lines = {\n+        'use dummy::MyStruct;',\n+        '',\n+        'fn process_my_struct(data: MyStruct) {',\n+        '    println!(\"Received MyStruct with value: {}\", data.value);',\n+        '}',\n+        '',\n+        'fn main() {',\n+        '    let my_instance = MyStruct::new(42);',\n+        '    let _MyInstance = MyStruct::new(43);',\n+        '    process_my_struct(my_instance);',\n+        '}',\n+      },\n+      name = 'src/main.rs',\n+      uri = 'file:///src/main.rs',\n+      filetype = 'rust',\n+      bufnr = nil,\n+    },\n+    lib = {\n+      lines = {\n+        'pub struct MyStruct {',\n+        '    pub value: i32,',\n+        '}',\n+        '',\n+        'impl MyStruct {',\n+        '    pub fn new(value: i32) -> Self {',\n+        '        MyStruct { value }',\n+        '    }',\n+        '}',\n+      },\n+      name = 'src/lib.rs',\n+      uri = 'file:///src/lib.rs',\n+      filetype = 'rust',\n+      bufnr = nil,\n+    },\n+  }\n+\n+  ---@type lsp.InlayHint[]\n+  local resolved_response = {\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          command = { title = 'Dummy command', command = 'dummy_command' },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 7,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 7,\n+            },\n+            start = {\n+              character = 19,\n+              line = 7,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 1 },\n+    },\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 8,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 8,\n+            },\n+            start = {\n+              character = 19,\n+              line = 8,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 2 },\n+    },\n+    {\n+      kind = 2,\n+      label = {\n+        {\n+          value = 'data:',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = true,\n+      position = {\n+        character = 22,\n+        line = 9,\n+      },\n+      data = { id = 3 },\n+    },\n+  }\n+\n+  -- this is taken from basedpyright\n+  ---@type lsp.InlayHint[]\n+  local orig_response = {\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          value = 'MyStruct',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 7,\n+      },\n+      data = { id = 1 },\n+    },\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 8,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 8,\n+            },\n+            start = {\n+              character = 19,\n+              line = 8,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 2 },\n+    },\n+    {\n+      kind = 2,\n+      label = {\n+        {\n+          value = 'data:',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = true,\n+      position = {\n+        character = 22,\n+        line = 9,\n+      },\n+      data = { id = 3 },\n+    },\n+  }\n+\n+  local curr_winid ---@type integer?\n+  local offset_encoding = 'utf-8'\n+\n+  -- set a large wait time so that the async operations have time to complete\n+  -- in practice, the `vim.wait` calls should use a callback to make the wait stop early.\n+  local wait_time = 1000000\n+  before_each(function()\n+    clear_notrace()\n+\n+    exec_lua(create_server_definition)\n+\n+    mocked_files = exec_lua(function()\n+      for _, item in pairs(mocked_files) do\n+        item.bufnr = vim.uri_to_bufnr(item.uri)\n+        local full_path = vim.uri_to_fname(item.uri)\n+        vim.api.nvim_buf_set_name(item.bufnr, full_path)\n+        vim.api.nvim_buf_set_lines(item.bufnr, 0, -1, false, item.lines)\n+        vim.api.nvim_cmd({ cmd = 'edit', args = { full_path }, bang = true }, {})\n+      end\n+      return mocked_files\n+    end)\n+\n+    exec_lua(function()\n+      _G.command_called = {}\n+      _G.server = _G._create_server({\n+        capabilities = {\n+          inlayHintProvider = { resolveProvider = true },\n+        },\n+        handlers = {\n+          ['workspace/executeCommand'] = function(_, param, callback)\n+            table.insert(_G.command_called, param)\n+            callback(nil, {})\n+          end,\n+          ---@param param lsp.InlayHintParams\n+          ['textDocument/inlayHint'] = function(_, param, callback)\n+            local buf = vim.uri_to_bufnr(param.textDocument.uri)\n+            local requested_range = vim.range.lsp(buf, param.range, offset_encoding)\n+            local filtered_hints = vim\n+              .iter(orig_response)\n+              :filter(\n+                ---@param hint lsp.InlayHint\n+                function(hint)\n+                  local hint_pos = vim.pos.lsp(buf, hint.position, offset_encoding)\n+                  return hint_pos >= requested_range.start and hint_pos < requested_range.end_\n+                end\n+              )\n+              :totable()\n+            return callback(nil, filtered_hints)\n+          end,\n+          ---@param params lsp.InlayHint\n+          ['inlayHint/resolve'] = function(_, params, callback)\n+            if params.data and params.data.id then\n+              callback(nil, resolved_response[params.data.id])\n+            else\n+              callback(nil, params)\n+            end\n+          end,\n+          ---@param params lsp.HoverParams\n+          ['textDocument/hover'] = function(_, params, callback)\n+            local pos = params.position\n+            if\n+              params.textDocument.uri == mocked_files.lib.uri\n+              and pos.line == 0\n+              and pos.character >= 11\n+              and pos.character < 19\n+            then\n+              callback(nil, {\n+                contents = {\n+                  kind = 'markdown',\n+                  value = '\\n```rust\\ndummy\\n```\\n\\n```rust\\npub struct MyStruct {\\n    pub value: i32,\\n}\\n```\\n\\n---\\n\\nsize = 4, align = 0x4',\n+                },\n+                range = {\n+                  ['end'] = {\n+                    character = 19,\n+                    line = 0,\n+                  },\n+                  start = {\n+                    character = 11,\n+                    line = 0,\n+                  },\n+                },\n+              })\n+            else\n+              callback()\n+            end\n+          end,\n+        },\n+      })\n+\n+      local client_id =\n+        vim.lsp.start({ name = 'dummy', cmd = _G.server.cmd, offset_encoding = offset_encoding })\n+      vim.wait(wait_time, function()\n+        return vim.lsp.get_client_by_id(assert(client_id)).initialized\n+      end)\n+      if client_id then\n+        vim.lsp.buf_attach_client(mocked_files.main.bufnr, client_id)\n+        vim.lsp.buf_attach_client(mocked_files.lib.bufnr, client_id)\n+      end\n+    end)\n+\n+    exec_lua(function()\n+      vim.api.nvim_cmd({ cmd = 'buf', args = { tostring(mocked_files.main.bufnr) } }, {})\n+      curr_winid = vim.api.nvim_get_current_win()\n+    end)\n+  end)\n+\n+  after_each(function()\n+    api.nvim_exec_autocmds('VimLeavePre', { modeline = false })\n+  end)\n+\n+  it('should fetch hint in normal mode', function()\n+    local done = false\n+    assert(curr_winid)\n+    local hint_count = exec_lua(function()\n+      local hint_count ---@type integer?\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 18 })\n+      vim.lsp.inlay_hint.apply_action(function(hints, ctx, cb)\n+        hint_count = #hints\n+        if #hints > 0 then\n+          cb({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+        return hint_count\n+      end, {}, function()\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+\n+      assert(done)\n+      return hint_count\n+    end)\n+\n+    eq(1, hint_count)\n+  end)\n+\n+  it('should fetch hints in visual mode', function()\n+    assert(curr_winid)\n+    local done = false\n+    local fetched_hint_count = exec_lua(function()\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 0 })\n+      vim.cmd.normal('v')\n+      vim.api.nvim_win_set_cursor(curr_winid, { 9, 30 })\n+\n+      local hint_count ---@type integer?\n+      vim.lsp.inlay_hint.apply_action(function(_hints, ctx, cb)\n+        hint_count = #_hints\n+        if #_hints > 0 then\n+          cb({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+        return hint_count\n+      end, {}, function()\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+      assert(done)\n+      return hint_count\n+    end)\n+\n+    eq(2, fetched_hint_count)\n+  end)\n+\n+  it('should exit when no clients', function()\n+    local done = false\n+    assert(curr_winid)\n+    ---@type table\n+    local ctx = exec_lua(function()\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 18 })\n+      local on_finish_ctx ---@type table?\n+      vim.lsp.inlay_hint.apply_action(function()\n+        return 0\n+      end, { clients = {} }, function(ctx)\n+        on_finish_ctx = ctx\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+\n+      assert(done)\n+      return on_finish_ctx or { client = true } -- `on_finish_ctx` should be set to the actual ctx, and `client` should be `nil`\n+    end)\n+\n+    eq(nil, ctx.client)\n+  end)\n+\n+  describe('textEdits', function()\n+    it('should insert textEdits', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'textEdits',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(8, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(\n+        'let my_instance: MyStruct = MyStruct::new(42);',\n+        vim.trim(api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false)[8])\n+      )\n+      eq(\n+        'let _MyInstance: MyStruct = MyStruct::new(43);',\n+        vim.trim(api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false)[9])\n+      )\n+    end)\n+\n+    it(\"should NOT insert when there's no textEdits\", function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'textEdits',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.main.lines, api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false))\n+    end)\n+  end)\n+\n+  describe('location', function()\n+    it('should jump when location is provided', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'location',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.lib.bufnr, api.nvim_get_current_buf())\n+    end)\n+\n+    it('should NOT jump when location is not provided', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'location',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.main.bufnr, api.nvim_get_current_buf())\n+    end)\n+  end)\n+\n+  describe('tooltip', function()\n+    local ref_tooltip = {\n+      '# `: MyStruct`',\n+      '',\n+      'plaintext markup tooltip',\n+      '',\n+      '## `MyStruct`',\n+      '',\n+      'string tooltip',\n+      '_Location_: `/src/lib.rs`:0',\n+      '_Command_: Dummy command',\n+    }\n+    it('should show tooltip when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local tooltip_buf, tooltip_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'tooltip',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local tooltip_lines = api.nvim_buf_get_lines(tooltip_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, tooltip_buf)\n+      neq(curr_winid, tooltip_win)\n+\n+      eq(ref_tooltip, tooltip_lines)\n+    end)\n+\n+    it('should NOT show tooltip when not available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local buf_count = #api.nvim_list_bufs()\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'tooltip',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(buf_count, #api.nvim_list_bufs())\n+    end)\n+  end)\n+\n+  describe('hover', function()\n+    local ref_hover = {\n+      '# `MyStruct`',\n+      '```rust',\n+      'dummy',\n+      '```',\n+      '',\n+      '```rust',\n+      'pub struct MyStruct {',\n+      '    pub value: i32,',\n+      '}',\n+      '```',\n+      '',\n+      '---',\n+      '',\n+      'size = 4, align = 0x4',\n+    }\n+    it('should show hover when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local hover_buf, hover_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local hover_lines = api.nvim_buf_get_lines(hover_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, hover_buf)\n+      neq(curr_winid, hover_win)\n+\n+      eq(ref_hover, hover_lines)\n+    end)\n+\n+    it('should deduplicate same locations', function()\n+      -- this test whether `action_helpers.add_new_label` is correctly avoiding\n+      -- duplicated locations.\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local hover_buf, hover_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(8, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local hover_lines = api.nvim_buf_get_lines(hover_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, hover_buf)\n+      neq(curr_winid, hover_win)\n+\n+      eq(ref_hover, hover_lines)\n+    end)\n+\n+    it('should NOT show hover when not available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local buf_count = #api.nvim_list_bufs()\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(buf_count, #api.nvim_list_bufs())\n+    end)\n+  end)\n+\n+  describe('command', function()\n+    it('execute command when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local command_called = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'command',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return _G.command_called\n+      end)\n+      eq(1, #command_called)\n+    end)\n+\n+    it('should NOT execute command when not available', function()",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2607478793",
            "id": 2607478793,
            "line": 1157,
            "node_id": "PRRC_kwDOAPphoM6bavgJ",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 1155,
            "original_position": 719,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/inlay_hint_spec.lua",
            "position": 713,
            "pull_request_review_id": 3563577014,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607478793/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-10T16:59:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607478793",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2607499609"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607499609"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there a way to list the available inlay-hint actions? (Is that just \"list the inlay hints\"?)\n\nSeems like it would make sense to include these in the `gra` menu, similar to https://github.com/neovim/neovim/issues/34813 which proposes including codelense actions. That way, by default, users only need to reach for `gra` to get all available actions for a position/range.",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-10T17:05:13Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2607499609",
            "id": 2607499609,
            "line": 2184,
            "node_id": "PRRC_kwDOAPphoM6ba0lZ",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2184,
            "original_position": 11,
            "original_start_line": 2180,
            "path": "runtime/doc/lsp.txt",
            "position": 10,
            "pull_request_review_id": 3563603767,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607499609/reactions"
            },
            "side": "RIGHT",
            "start_line": 2179,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-10T17:06:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607499609",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2607512427"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607512427"
                }
            },
            "author_association": "MEMBER",
            "body": "Is it common for servers to provide inlay-hint actions that are not also already included in the list of code-actions? ",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-10T17:08:25Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2607512427",
            "id": 2607512427,
            "in_reply_to_id": 2607499609,
            "line": 2184,
            "node_id": "PRRC_kwDOAPphoM6ba3tr",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2184,
            "original_position": 11,
            "original_start_line": 2180,
            "path": "runtime/doc/lsp.txt",
            "position": 10,
            "pull_request_review_id": 3563622043,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607512427/reactions"
            },
            "side": "RIGHT",
            "start_line": 2179,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-10T17:08:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607512427",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2607713215"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607713215"
                }
            },
            "author_association": "MEMBER",
            "body": "The `range` and `clients` options seem redundant with the filter of `vim.lsp.inlay_hint.get()` which is maybe what @MariaSolOs was driving at in [this comment](https://github.com/neovim/neovim/pull/36219#issuecomment-3419114076).\n\nDon't think we should duplicate the filtering interface amongst these functions. `get()` is the workhorse for that.\n\nSo then `apply_action` would take an `inlay_hint(s)` param (the thing returned by `get()`. Or maybe the thing returned by `get()` could have a `:apply()` method. See also `vim.lsp.buf.code_action()`.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-12-10T18:10:47Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action('textEdits')\n+          end,\n+          { desc = 'Apply inlay hint textEdits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}    (`vim.lsp.inlay_hint.action`) Possible actions:\n+                     `\"textEdits\"`: insert `textEdits` that comes with the\n+                      inlay hints.\n+                     `\"location\"`: jump to one of the locations associated\n+                      with the inlay hints.\n+                     `\"command\"`: execute one of the `lsp.Command`s that\n+                      comes with the inlay hint.\n+                     `\"hover\"`: if there are some locations associated with\n+                      the inlay hint, show the hover information of the\n+                      identifiers at those locations.\n+                     `\"tooltip\"`: show a hover-like window that contains the\n+                      `tooltip`, available `command`s and `location`s that\n+                      comes with the inlay hint.\n+                     a custom handler with 3 parameters:\n+                       `hints`: `lsp.InlayHint[]` a list of inlay hints in\n+                        the requested range.\n+                       `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the\n+                        buffer number on which the action is taken, and the\n+                        LSP client that provides `hints`.\n+                       `on_finish`:\n+                        `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})`\n+                        see the `callback` parameter of\n+                        `vim.lsp.inlay_hint.apply_action`. When implementing a\n+                        custom handler, the `on_finish` callback should be\n+                        called when the handler is returning a non-zero value.\n+                      This custom handler should also return the number of\n+                      items in `hints` that contributed to the action. For\n+                      example, the `location` handler should return `1` on a\n+                      successful jump because the target location is from 1\n+                      inlay hint object, regardless of the number of hints in\n+                      `hints`.\n+       {opts}      (`table?`) A table with the following fields:\n+                     {range}? (`vim.Range`) Use this option to specify the\n+                      range from which the inlay hints should be requested.\n+                      When not specified:\n+                       in |Normal-mode|, it requests for hints on either side\n+                        of the cursor.\n+                       in |Visual-mode|, it requests for hints inside the\n+                        selected range.\n+                     {clients}? (`vim.lsp.Client[]`) The clients used to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2607713215",
            "id": 2607713215,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6bbou_",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2233,
            "original_position": 59,
            "original_start_line": 2225,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3563879394,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607713215/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-10T18:10:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2607713215",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2608821333"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608821333"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "The \"action\" here isn't the same as code actions. These are attributes of the inlay hints that we can \"take actions on\" (locations, textedits, tooltips, etc.). \r\n\r\n> Is there a way to list the available inlay-hint actions? (Is that just \"list the inlay hints\"?)\r\n\r\n`vim.lsp.inlay_hint.apply_action(\"tooltip\")` does this (more or less). It shows the available locations and commands alongside the tooltips in a float window. This'll tell the user, for example, where they might be able to jump to by calling `vim.lsp.inlay_hint.apply_action(\"location\")`.\r\n<img width=\"1180\" height=\"453\" alt=\"image\" src=\"https://github.com/user-attachments/assets/96952141-c5a1-4c22-9f9c-1c8d43afb054\" />\r\n\r\n `textEdits` aren't included here, because users can just apply it to see the change and `:undo` it if they don't like it.\r\n\r\nAs for the `command` attribute of the inlay hint, I've yet to find a server that actually provides it, so I can't say much about it.",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-11T01:39:13Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2608821333",
            "id": 2608821333,
            "in_reply_to_id": 2607499609,
            "line": 2184,
            "node_id": "PRRC_kwDOAPphoM6bf3RV",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2184,
            "original_position": 11,
            "original_start_line": 2180,
            "path": "runtime/doc/lsp.txt",
            "position": 10,
            "pull_request_review_id": 3565264107,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608821333/reactions"
            },
            "side": "RIGHT",
            "start_line": 2179,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-11T01:39:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608821333",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2608889467"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608889467"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I've mentioned [here](https://github.com/neovim/neovim/pull/36219?notification_referrer_id=NT_kwDOAdhHQrQxOTcxMTQwNDczMzozMDk1MTIzNA#discussion_r2441564243) that re-using the `vim.lsp.inlay_hint.get()` results would require that the built-in inlay-hint handler is not overridden, because it populates `bufstates`. Since [the doc explicitly mentioned such usage](https://github.com/neovim/neovim/blob/78bbe53f7615e8b38d5289d9ce0579996109579b/runtime/doc/lsp.txt#L413), I take it that we shouldn't expect the built-in handler to be always available and functional. Also, the `bufstates` that stores the hints is a `local` variable and is inaccessible by custom handlers.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-12-11T02:24:07Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action('textEdits')\n+          end,\n+          { desc = 'Apply inlay hint textEdits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}    (`vim.lsp.inlay_hint.action`) Possible actions:\n+                     `\"textEdits\"`: insert `textEdits` that comes with the\n+                      inlay hints.\n+                     `\"location\"`: jump to one of the locations associated\n+                      with the inlay hints.\n+                     `\"command\"`: execute one of the `lsp.Command`s that\n+                      comes with the inlay hint.\n+                     `\"hover\"`: if there are some locations associated with\n+                      the inlay hint, show the hover information of the\n+                      identifiers at those locations.\n+                     `\"tooltip\"`: show a hover-like window that contains the\n+                      `tooltip`, available `command`s and `location`s that\n+                      comes with the inlay hint.\n+                     a custom handler with 3 parameters:\n+                       `hints`: `lsp.InlayHint[]` a list of inlay hints in\n+                        the requested range.\n+                       `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the\n+                        buffer number on which the action is taken, and the\n+                        LSP client that provides `hints`.\n+                       `on_finish`:\n+                        `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})`\n+                        see the `callback` parameter of\n+                        `vim.lsp.inlay_hint.apply_action`. When implementing a\n+                        custom handler, the `on_finish` callback should be\n+                        called when the handler is returning a non-zero value.\n+                      This custom handler should also return the number of\n+                      items in `hints` that contributed to the action. For\n+                      example, the `location` handler should return `1` on a\n+                      successful jump because the target location is from 1\n+                      inlay hint object, regardless of the number of hints in\n+                      `hints`.\n+       {opts}      (`table?`) A table with the following fields:\n+                     {range}? (`vim.Range`) Use this option to specify the\n+                      range from which the inlay hints should be requested.\n+                      When not specified:\n+                       in |Normal-mode|, it requests for hints on either side\n+                        of the cursor.\n+                       in |Visual-mode|, it requests for hints inside the\n+                        selected range.\n+                     {clients}? (`vim.lsp.Client[]`) The clients used to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2608889467",
            "id": 2608889467,
            "in_reply_to_id": 2607713215,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6bgH57",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2233,
            "original_position": 59,
            "original_start_line": 2225,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3565340250,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608889467/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-11T02:24:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2608889467",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2611535766"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611535766"
                }
            },
            "author_association": "MEMBER",
            "body": "> The \"action\" here isn't the same as code actions. These are attributes of the inlay hints that we can \"take actions on\" (locations, textedits, tooltips, etc.).\r\n\r\nOf course it's not exactly the same, but the concept is the same: a list of actions that actions on a range or nearby position.\r\n\r\n> > Is there a way to list the available inlay-hint actions? (Is that just \"list the inlay hints\"?)\r\n> \r\n> `vim.lsp.inlay_hint.apply_action(\"tooltip\")` does this ... This'll tell the user\r\n\r\nNo, I mean a programmatic way to list stuff.",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-11T17:53:37Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2611535766",
            "id": 2611535766,
            "in_reply_to_id": 2607499609,
            "line": 2184,
            "node_id": "PRRC_kwDOAPphoM6bqN-W",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2184,
            "original_position": 11,
            "original_start_line": 2180,
            "path": "runtime/doc/lsp.txt",
            "position": 10,
            "pull_request_review_id": 3568637398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611535766/reactions"
            },
            "side": "RIGHT",
            "start_line": 2179,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-11T17:53:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611535766",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2611538458"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611538458"
                }
            },
            "author_association": "MEMBER",
            "body": "> re-using the `vim.lsp.inlay_hint.get()` results would require that the built-in inlay-hint handler is not overridden, because it populates `bufstates`\r\n\r\nIf something overrides a core feature then yes it's required behave correctly. Overrides are often expected to also call the original handler, which would preserve `bufstates` management.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-12-11T17:54:35Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action('textEdits')\n+          end,\n+          { desc = 'Apply inlay hint textEdits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}    (`vim.lsp.inlay_hint.action`) Possible actions:\n+                     `\"textEdits\"`: insert `textEdits` that comes with the\n+                      inlay hints.\n+                     `\"location\"`: jump to one of the locations associated\n+                      with the inlay hints.\n+                     `\"command\"`: execute one of the `lsp.Command`s that\n+                      comes with the inlay hint.\n+                     `\"hover\"`: if there are some locations associated with\n+                      the inlay hint, show the hover information of the\n+                      identifiers at those locations.\n+                     `\"tooltip\"`: show a hover-like window that contains the\n+                      `tooltip`, available `command`s and `location`s that\n+                      comes with the inlay hint.\n+                     a custom handler with 3 parameters:\n+                       `hints`: `lsp.InlayHint[]` a list of inlay hints in\n+                        the requested range.\n+                       `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the\n+                        buffer number on which the action is taken, and the\n+                        LSP client that provides `hints`.\n+                       `on_finish`:\n+                        `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})`\n+                        see the `callback` parameter of\n+                        `vim.lsp.inlay_hint.apply_action`. When implementing a\n+                        custom handler, the `on_finish` callback should be\n+                        called when the handler is returning a non-zero value.\n+                      This custom handler should also return the number of\n+                      items in `hints` that contributed to the action. For\n+                      example, the `location` handler should return `1` on a\n+                      successful jump because the target location is from 1\n+                      inlay hint object, regardless of the number of hints in\n+                      `hints`.\n+       {opts}      (`table?`) A table with the following fields:\n+                     {range}? (`vim.Range`) Use this option to specify the\n+                      range from which the inlay hints should be requested.\n+                      When not specified:\n+                       in |Normal-mode|, it requests for hints on either side\n+                        of the cursor.\n+                       in |Visual-mode|, it requests for hints inside the\n+                        selected range.\n+                     {clients}? (`vim.lsp.Client[]`) The clients used to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2611538458",
            "id": 2611538458,
            "in_reply_to_id": 2607713215,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6bqOoa",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2233,
            "original_position": 59,
            "original_start_line": 2225,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3568640391,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611538458/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-11T17:55:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2611538458",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2613072510"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2613072510"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Ah I see. The thing is, we need to preserve the \"hierarchy\" of the attributes and differentiate \"attributes of an inlay hint\" and \"attributes of a label part\". Thus, I decided that it wasn't necessary to come up with a new data structure to store the data, and just pass the filtered and `inlayHint/resolve`ed hints as the argument to the handler. This also helps unify the interface of the handler. If [people want to customise the actions, they can write their own handlers and pass them as the `action` argument](https://github.com/Davidyz/hover.nvim/blob/c25e0316c8555ade596028c5ba1e3d5653a0c739/lua/hover/providers/inlay_hint.lua#L53).\r\n\r\nIf the purpose of \"programmatically listing stuff\" is for continuation (#31206), we could update the definition of the [`callback`](https://github.com/Davidyz/neovim/blob/7bc422457e838e2ed826c35d662c188c37d4658c/runtime/lua/vim/lsp/inlay_hint.lua#L986) to make the `ctx` include the inlay hint objects that _contributed_ to the action (for example, for `textEdits`, it'll include inlay hints which contain text edits and were successfully applied).",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-12T06:22:30Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2613072510",
            "id": 2613072510,
            "in_reply_to_id": 2607499609,
            "line": 2184,
            "node_id": "PRRC_kwDOAPphoM6bwFJ-",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2184,
            "original_position": 11,
            "original_start_line": 2180,
            "path": "runtime/doc/lsp.txt",
            "position": 10,
            "pull_request_review_id": 3570481785,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2613072510/reactions"
            },
            "side": "RIGHT",
            "start_line": 2179,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-12T06:22:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2613072510",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2616033980"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616033980"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I've refactored the code (and updated the tests) so that it now:\r\n1. use inlay hints from `vim.lsp.inlay_hint.get()`;\r\n2. When users don't specify ranges, it defaults to the original normal/visual mode detection\r\n3. users can manually acquire inlay hints from `vim.lsp.inlay_hint.get()` with their desired filtering (range, lsp clients, etc.) and pass the results to `opts.hints`. In this case, `vim.lsp.inlay_hint.action` will only act on the supplied hints.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-12-13T03:32:37Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action('textEdits')\n+          end,\n+          { desc = 'Apply inlay hint textEdits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}    (`vim.lsp.inlay_hint.action`) Possible actions:\n+                     `\"textEdits\"`: insert `textEdits` that comes with the\n+                      inlay hints.\n+                     `\"location\"`: jump to one of the locations associated\n+                      with the inlay hints.\n+                     `\"command\"`: execute one of the `lsp.Command`s that\n+                      comes with the inlay hint.\n+                     `\"hover\"`: if there are some locations associated with\n+                      the inlay hint, show the hover information of the\n+                      identifiers at those locations.\n+                     `\"tooltip\"`: show a hover-like window that contains the\n+                      `tooltip`, available `command`s and `location`s that\n+                      comes with the inlay hint.\n+                     a custom handler with 3 parameters:\n+                       `hints`: `lsp.InlayHint[]` a list of inlay hints in\n+                        the requested range.\n+                       `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the\n+                        buffer number on which the action is taken, and the\n+                        LSP client that provides `hints`.\n+                       `on_finish`:\n+                        `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})`\n+                        see the `callback` parameter of\n+                        `vim.lsp.inlay_hint.apply_action`. When implementing a\n+                        custom handler, the `on_finish` callback should be\n+                        called when the handler is returning a non-zero value.\n+                      This custom handler should also return the number of\n+                      items in `hints` that contributed to the action. For\n+                      example, the `location` handler should return `1` on a\n+                      successful jump because the target location is from 1\n+                      inlay hint object, regardless of the number of hints in\n+                      `hints`.\n+       {opts}      (`table?`) A table with the following fields:\n+                     {range}? (`vim.Range`) Use this option to specify the\n+                      range from which the inlay hints should be requested.\n+                      When not specified:\n+                       in |Normal-mode|, it requests for hints on either side\n+                        of the cursor.\n+                       in |Visual-mode|, it requests for hints inside the\n+                        selected range.\n+                     {clients}? (`vim.lsp.Client[]`) The clients used to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2616033980",
            "id": 2616033980,
            "in_reply_to_id": 2607713215,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6b7YK8",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2233,
            "original_position": 59,
            "original_start_line": 2225,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3574148993,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616033980/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-13T03:32:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616033980",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2616055514"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616055514"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> Or maybe the thing returned by `get()` could have a `:apply()` method.\r\n\r\nbtw, I decided against this because this'll change the signature of `get()`. `vim.islist(ret)` would become `false` if we add the `:apply()` method, and it'll break existing use of the `get()` resultts with `vim.iter()`, which handles lists and dictionaries differently. I don't know if that's what we want for this PR.",
            "commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "created_at": "2025-12-13T04:20:46Z",
            "diff_hunk": "@@ -2175,6 +2175,78 @@ is_enabled({bufnr})                      *vim.lsp.document_color.is_enabled()*\n ==============================================================================\n Lua module: vim.lsp.inlay_hint                                *lsp-inlay_hint*\n \n+                                           *vim.lsp.inlay_hint.apply_action()*\n+apply_action({action}, {opts}, {callback})\n+    Apply some actions provided by inlay hints in the selected range.\n+\n+    Example usage: >lua\n+        vim.keymap.set(\n+          { 'n', 'v' },\n+          'gI',\n+          function()\n+            vim.lsp.inlay_hint.apply_action('textEdits')\n+          end,\n+          { desc = 'Apply inlay hint textEdits' }\n+        )\n+<\n+\n+    Parameters: ~\n+       {action}    (`vim.lsp.inlay_hint.action`) Possible actions:\n+                     `\"textEdits\"`: insert `textEdits` that comes with the\n+                      inlay hints.\n+                     `\"location\"`: jump to one of the locations associated\n+                      with the inlay hints.\n+                     `\"command\"`: execute one of the `lsp.Command`s that\n+                      comes with the inlay hint.\n+                     `\"hover\"`: if there are some locations associated with\n+                      the inlay hint, show the hover information of the\n+                      identifiers at those locations.\n+                     `\"tooltip\"`: show a hover-like window that contains the\n+                      `tooltip`, available `command`s and `location`s that\n+                      comes with the inlay hint.\n+                     a custom handler with 3 parameters:\n+                       `hints`: `lsp.InlayHint[]` a list of inlay hints in\n+                        the requested range.\n+                       `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the\n+                        buffer number on which the action is taken, and the\n+                        LSP client that provides `hints`.\n+                       `on_finish`:\n+                        `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})`\n+                        see the `callback` parameter of\n+                        `vim.lsp.inlay_hint.apply_action`. When implementing a\n+                        custom handler, the `on_finish` callback should be\n+                        called when the handler is returning a non-zero value.\n+                      This custom handler should also return the number of\n+                      items in `hints` that contributed to the action. For\n+                      example, the `location` handler should return `1` on a\n+                      successful jump because the target location is from 1\n+                      inlay hint object, regardless of the number of hints in\n+                      `hints`.\n+       {opts}      (`table?`) A table with the following fields:\n+                     {range}? (`vim.Range`) Use this option to specify the\n+                      range from which the inlay hints should be requested.\n+                      When not specified:\n+                       in |Normal-mode|, it requests for hints on either side\n+                        of the cursor.\n+                       in |Visual-mode|, it requests for hints inside the\n+                        selected range.\n+                     {clients}? (`vim.lsp.Client[]`) The clients used to",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2616055514",
            "id": 2616055514,
            "in_reply_to_id": 2607713215,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6b7dba",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 2233,
            "original_position": 59,
            "original_start_line": 2225,
            "path": "runtime/doc/lsp.txt",
            "position": 1,
            "pull_request_review_id": 3574168653,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616055514/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-13T04:20:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2616055514",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2618668416"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2618668416"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I encapsulated the `action` calls for each of the actions. The individual test cases (the `it()` ones) should now be a lot more concise and easy to follow.",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T09:37:12Z",
            "diff_hunk": "@@ -452,3 +453,732 @@ test text\n     api.nvim_exec_autocmds('VimLeavePre', { modeline = false })\n   end)\n end)\n+\n+describe('vim.lsp.inlay_hint.apply_action', function()\n+  ---@type table<string, {lines: string[], name: string, filetype: string, bufnr: integer?, uri: string}>\n+  local mocked_files = {\n+    main = {\n+      lines = {\n+        'use dummy::MyStruct;',\n+        '',\n+        'fn process_my_struct(data: MyStruct) {',\n+        '    println!(\"Received MyStruct with value: {}\", data.value);',\n+        '}',\n+        '',\n+        'fn main() {',\n+        '    let my_instance = MyStruct::new(42);',\n+        '    let _MyInstance = MyStruct::new(43);',\n+        '    process_my_struct(my_instance);',\n+        '}',\n+      },\n+      name = 'src/main.rs',\n+      uri = 'file:///src/main.rs',\n+      filetype = 'rust',\n+      bufnr = nil,\n+    },\n+    lib = {\n+      lines = {\n+        'pub struct MyStruct {',\n+        '    pub value: i32,',\n+        '}',\n+        '',\n+        'impl MyStruct {',\n+        '    pub fn new(value: i32) -> Self {',\n+        '        MyStruct { value }',\n+        '    }',\n+        '}',\n+      },\n+      name = 'src/lib.rs',\n+      uri = 'file:///src/lib.rs',\n+      filetype = 'rust',\n+      bufnr = nil,\n+    },\n+  }\n+\n+  ---@type lsp.InlayHint[]\n+  local resolved_response = {\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          command = { title = 'Dummy command', command = 'dummy_command' },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 7,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 7,\n+            },\n+            start = {\n+              character = 19,\n+              line = 7,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 1 },\n+    },\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 8,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 8,\n+            },\n+            start = {\n+              character = 19,\n+              line = 8,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 2 },\n+    },\n+    {\n+      kind = 2,\n+      label = {\n+        {\n+          value = 'data:',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = true,\n+      position = {\n+        character = 22,\n+        line = 9,\n+      },\n+      data = { id = 3 },\n+    },\n+  }\n+\n+  -- this is taken from basedpyright\n+  ---@type lsp.InlayHint[]\n+  local orig_response = {\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          value = 'MyStruct',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 7,\n+      },\n+      data = { id = 1 },\n+    },\n+    {\n+      kind = 1,\n+      label = {\n+        {\n+          value = ': ',\n+        },\n+        {\n+          location = {\n+            range = {\n+              ['end'] = {\n+                character = 19,\n+                line = 0,\n+              },\n+              start = {\n+                character = 11,\n+                line = 0,\n+              },\n+            },\n+            uri = mocked_files.lib.uri,\n+          },\n+          tooltip = 'string tooltip',\n+          value = 'MyStruct',\n+        },\n+      },\n+      tooltip = { kind = 'plaintext', value = 'plaintext markup tooltip' },\n+      paddingLeft = false,\n+      paddingRight = false,\n+      position = {\n+        character = 19,\n+        line = 8,\n+      },\n+      textEdits = {\n+        {\n+          newText = ': MyStruct',\n+          range = {\n+            ['end'] = {\n+              character = 19,\n+              line = 8,\n+            },\n+            start = {\n+              character = 19,\n+              line = 8,\n+            },\n+          },\n+        },\n+      },\n+      data = { id = 2 },\n+    },\n+    {\n+      kind = 2,\n+      label = {\n+        {\n+          value = 'data:',\n+        },\n+      },\n+      paddingLeft = false,\n+      paddingRight = true,\n+      position = {\n+        character = 22,\n+        line = 9,\n+      },\n+      data = { id = 3 },\n+    },\n+  }\n+\n+  local curr_winid ---@type integer?\n+  local offset_encoding = 'utf-8'\n+\n+  -- set a large wait time so that the async operations have time to complete\n+  -- in practice, the `vim.wait` calls should use a callback to make the wait stop early.\n+  local wait_time = 1000000\n+  before_each(function()\n+    clear_notrace()\n+\n+    exec_lua(create_server_definition)\n+\n+    mocked_files = exec_lua(function()\n+      for _, item in pairs(mocked_files) do\n+        item.bufnr = vim.uri_to_bufnr(item.uri)\n+        local full_path = vim.uri_to_fname(item.uri)\n+        vim.api.nvim_buf_set_name(item.bufnr, full_path)\n+        vim.api.nvim_buf_set_lines(item.bufnr, 0, -1, false, item.lines)\n+        vim.api.nvim_cmd({ cmd = 'edit', args = { full_path }, bang = true }, {})\n+      end\n+      return mocked_files\n+    end)\n+\n+    exec_lua(function()\n+      _G.command_called = {}\n+      _G.server = _G._create_server({\n+        capabilities = {\n+          inlayHintProvider = { resolveProvider = true },\n+        },\n+        handlers = {\n+          ['workspace/executeCommand'] = function(_, param, callback)\n+            table.insert(_G.command_called, param)\n+            callback(nil, {})\n+          end,\n+          ---@param param lsp.InlayHintParams\n+          ['textDocument/inlayHint'] = function(_, param, callback)\n+            local buf = vim.uri_to_bufnr(param.textDocument.uri)\n+            local requested_range = vim.range.lsp(buf, param.range, offset_encoding)\n+            local filtered_hints = vim\n+              .iter(orig_response)\n+              :filter(\n+                ---@param hint lsp.InlayHint\n+                function(hint)\n+                  local hint_pos = vim.pos.lsp(buf, hint.position, offset_encoding)\n+                  return hint_pos >= requested_range.start and hint_pos < requested_range.end_\n+                end\n+              )\n+              :totable()\n+            return callback(nil, filtered_hints)\n+          end,\n+          ---@param params lsp.InlayHint\n+          ['inlayHint/resolve'] = function(_, params, callback)\n+            if params.data and params.data.id then\n+              callback(nil, resolved_response[params.data.id])\n+            else\n+              callback(nil, params)\n+            end\n+          end,\n+          ---@param params lsp.HoverParams\n+          ['textDocument/hover'] = function(_, params, callback)\n+            local pos = params.position\n+            if\n+              params.textDocument.uri == mocked_files.lib.uri\n+              and pos.line == 0\n+              and pos.character >= 11\n+              and pos.character < 19\n+            then\n+              callback(nil, {\n+                contents = {\n+                  kind = 'markdown',\n+                  value = '\\n```rust\\ndummy\\n```\\n\\n```rust\\npub struct MyStruct {\\n    pub value: i32,\\n}\\n```\\n\\n---\\n\\nsize = 4, align = 0x4',\n+                },\n+                range = {\n+                  ['end'] = {\n+                    character = 19,\n+                    line = 0,\n+                  },\n+                  start = {\n+                    character = 11,\n+                    line = 0,\n+                  },\n+                },\n+              })\n+            else\n+              callback()\n+            end\n+          end,\n+        },\n+      })\n+\n+      local client_id =\n+        vim.lsp.start({ name = 'dummy', cmd = _G.server.cmd, offset_encoding = offset_encoding })\n+      vim.wait(wait_time, function()\n+        return vim.lsp.get_client_by_id(assert(client_id)).initialized\n+      end)\n+      if client_id then\n+        vim.lsp.buf_attach_client(mocked_files.main.bufnr, client_id)\n+        vim.lsp.buf_attach_client(mocked_files.lib.bufnr, client_id)\n+      end\n+    end)\n+\n+    exec_lua(function()\n+      vim.api.nvim_cmd({ cmd = 'buf', args = { tostring(mocked_files.main.bufnr) } }, {})\n+      curr_winid = vim.api.nvim_get_current_win()\n+    end)\n+  end)\n+\n+  after_each(function()\n+    api.nvim_exec_autocmds('VimLeavePre', { modeline = false })\n+  end)\n+\n+  it('should fetch hint in normal mode', function()\n+    local done = false\n+    assert(curr_winid)\n+    local hint_count = exec_lua(function()\n+      local hint_count ---@type integer?\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 18 })\n+      vim.lsp.inlay_hint.apply_action(function(hints, ctx, cb)\n+        hint_count = #hints\n+        if #hints > 0 then\n+          cb({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+        return hint_count\n+      end, {}, function()\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+\n+      assert(done)\n+      return hint_count\n+    end)\n+\n+    eq(1, hint_count)\n+  end)\n+\n+  it('should fetch hints in visual mode', function()\n+    assert(curr_winid)\n+    local done = false\n+    local fetched_hint_count = exec_lua(function()\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 0 })\n+      vim.cmd.normal('v')\n+      vim.api.nvim_win_set_cursor(curr_winid, { 9, 30 })\n+\n+      local hint_count ---@type integer?\n+      vim.lsp.inlay_hint.apply_action(function(_hints, ctx, cb)\n+        hint_count = #_hints\n+        if #_hints > 0 then\n+          cb({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+        return hint_count\n+      end, {}, function()\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+      assert(done)\n+      return hint_count\n+    end)\n+\n+    eq(2, fetched_hint_count)\n+  end)\n+\n+  it('should exit when no clients', function()\n+    local done = false\n+    assert(curr_winid)\n+    ---@type table\n+    local ctx = exec_lua(function()\n+      vim.api.nvim_win_set_cursor(curr_winid, { 8, 18 })\n+      local on_finish_ctx ---@type table?\n+      vim.lsp.inlay_hint.apply_action(function()\n+        return 0\n+      end, { clients = {} }, function(ctx)\n+        on_finish_ctx = ctx\n+        done = true\n+      end)\n+      vim.wait(wait_time, function()\n+        return done\n+      end)\n+\n+      assert(done)\n+      return on_finish_ctx or { client = true } -- `on_finish_ctx` should be set to the actual ctx, and `client` should be `nil`\n+    end)\n+\n+    eq(nil, ctx.client)\n+  end)\n+\n+  describe('textEdits', function()\n+    it('should insert textEdits', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'textEdits',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(8, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(\n+        'let my_instance: MyStruct = MyStruct::new(42);',\n+        vim.trim(api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false)[8])\n+      )\n+      eq(\n+        'let _MyInstance: MyStruct = MyStruct::new(43);',\n+        vim.trim(api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false)[9])\n+      )\n+    end)\n+\n+    it(\"should NOT insert when there's no textEdits\", function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'textEdits',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.main.lines, api.nvim_buf_get_lines(mocked_files.main.bufnr, 0, -1, false))\n+    end)\n+  end)\n+\n+  describe('location', function()\n+    it('should jump when location is provided', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'location',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.lib.bufnr, api.nvim_get_current_buf())\n+    end)\n+\n+    it('should NOT jump when location is not provided', function()\n+      assert(curr_winid)\n+      local done = false\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'location',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(mocked_files.main.bufnr, api.nvim_get_current_buf())\n+    end)\n+  end)\n+\n+  describe('tooltip', function()\n+    local ref_tooltip = {\n+      '# `: MyStruct`',\n+      '',\n+      'plaintext markup tooltip',\n+      '',\n+      '## `MyStruct`',\n+      '',\n+      'string tooltip',\n+      '_Location_: `/src/lib.rs`:0',\n+      '_Command_: Dummy command',\n+    }\n+    it('should show tooltip when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local tooltip_buf, tooltip_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'tooltip',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local tooltip_lines = api.nvim_buf_get_lines(tooltip_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, tooltip_buf)\n+      neq(curr_winid, tooltip_win)\n+\n+      eq(ref_tooltip, tooltip_lines)\n+    end)\n+\n+    it('should NOT show tooltip when not available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local buf_count = #api.nvim_list_bufs()\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'tooltip',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(buf_count, #api.nvim_list_bufs())\n+    end)\n+  end)\n+\n+  describe('hover', function()\n+    local ref_hover = {\n+      '# `MyStruct`',\n+      '```rust',\n+      'dummy',\n+      '```',\n+      '',\n+      '```rust',\n+      'pub struct MyStruct {',\n+      '    pub value: i32,',\n+      '}',\n+      '```',\n+      '',\n+      '---',\n+      '',\n+      'size = 4, align = 0x4',\n+    }\n+    it('should show hover when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local hover_buf, hover_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local hover_lines = api.nvim_buf_get_lines(hover_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, hover_buf)\n+      neq(curr_winid, hover_win)\n+\n+      eq(ref_hover, hover_lines)\n+    end)\n+\n+    it('should deduplicate same locations', function()\n+      -- this test whether `action_helpers.add_new_label` is correctly avoiding\n+      -- duplicated locations.\n+      assert(curr_winid)\n+      local done = false\n+      ---@type integer, integer\n+      local hover_buf, hover_win = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        local on_finish_ctx = {} ---@type vim.lsp.inlay_hint.action.on_finish.context|{}\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(8, 20, { buf = bufnr })) },\n+          function(ctx)\n+            on_finish_ctx = ctx\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return on_finish_ctx.bufnr, vim.fn.winbufnr(on_finish_ctx.bufnr)\n+      end)\n+      local hover_lines = api.nvim_buf_get_lines(hover_buf, 0, -1, false)\n+\n+      neq(mocked_files.main.bufnr, hover_buf)\n+      neq(curr_winid, hover_win)\n+\n+      eq(ref_hover, hover_lines)\n+    end)\n+\n+    it('should NOT show hover when not available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local buf_count = #api.nvim_list_bufs()\n+      exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'hover',\n+          { range = vim.range(vim.pos(9, 21, { buf = bufnr }), vim.pos(9, 24, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+      end)\n+      eq(buf_count, #api.nvim_list_bufs())\n+    end)\n+  end)\n+\n+  describe('command', function()\n+    it('execute command when available', function()\n+      assert(curr_winid)\n+      local done = false\n+      local command_called = exec_lua(function()\n+        local bufnr = mocked_files.main.bufnr\n+        vim.lsp.inlay_hint.apply_action(\n+          'command',\n+          { range = vim.range(vim.pos(7, 18, { buf = bufnr }), vim.pos(7, 20, { buf = bufnr })) },\n+          function(_)\n+            done = true\n+          end\n+        )\n+        vim.wait(wait_time, function()\n+          return done\n+        end)\n+        assert(done)\n+        return _G.command_called\n+      end)\n+      eq(1, #command_called)\n+    end)\n+\n+    it('should NOT execute command when not available', function()",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2618668416",
            "id": 2618668416,
            "in_reply_to_id": 2607478793,
            "line": 1157,
            "node_id": "PRRC_kwDOAPphoM6cFbWA",
            "original_commit_id": "7bc422457e838e2ed826c35d662c188c37d4658c",
            "original_line": 1155,
            "original_position": 719,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/inlay_hint_spec.lua",
            "position": 713,
            "pull_request_review_id": 3577261792,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2618668416/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T09:37:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2618668416",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619837178"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619837178"
                }
            },
            "author_association": "NONE",
            "body": "This seems to be unused.\r\nAm I missing something?",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T15:14:33Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619837178",
            "id": 2619837178,
            "line": 443,
            "node_id": "PRRC_kwDOAPphoM6cJ4r6",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 443,
            "original_position": 16,
            "original_start_line": 439,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 16,
            "pull_request_review_id": 3578743995,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619837178/reactions"
            },
            "side": "RIGHT",
            "start_line": 439,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-12-15T15:14:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619837178",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619854297"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619854297"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n  --- the attributes needed for the action, proceed to the next client. Otherwise, the action is\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T15:20:21Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location' })\n+    if hint_labels == nil then\n+      return 0\n+    end\n+\n+    ---@type string[]\n+    local lines = {}\n+\n+    --- Go though the labels to build the content of the hover\n+    ---@param idx integer?\n+    ---@param item vim.lsp.inlay_hint.action.hint_label?\n+    local function get_hover(idx, item)\n+      if idx == nil or item == nil then\n+        -- all locations have been processed\n+        -- open the hover window\n+        if #lines == 0 then\n+          lines = { 'Empty' }\n+        end\n+        local float_buf, _ = util.open_floating_preview(lines, 'markdown')\n+        if on_finish then\n+          on_finish({ client = ctx.client, bufnr = float_buf })\n+        end\n+        return\n+      end\n+\n+      -- `get_hint_labels` makes sure `item.label` has location attribute\n+      local label_loc = assert(item.label.location)\n+      ---@type lsp.HoverParams\n+      local hover_param = {\n+        textDocument = { uri = label_loc.uri },\n+        position = label_loc.range.start,\n+      }\n+      ctx.client:request(\n+        'textDocument/hover',\n+        hover_param,\n+        ---@param result lsp.Hover?\n+        function(_, result, _, _)\n+          if result then\n+            local md_lines = util.convert_input_to_markdown_lines(result.contents)\n+            if #md_lines > 0 then\n+              if #lines > 0 then\n+                -- blank line between label parts\n+                lines[#lines + 1] = ''\n+              end\n+              lines[#lines + 1] = string.format('# `%s`', item.label.value)\n+              vim.list_extend(lines, md_lines)\n+            end\n+          end\n+          get_hover(next(hint_labels, idx))\n+        end,\n+        ctx.bufnr\n+      )\n+    end\n+\n+    get_hover(next(hint_labels))\n+    return 1\n+  end,\n+\n+  tooltip = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location', 'command' })\n+\n+    -- the level 1 heading is the full hint object\n+    local lines = { string.format('# `%s`', action_helpers.get_label_text(hint, false)), '' }\n+\n+    if hint.tooltip then\n+      util.convert_input_to_markdown_lines(hint.tooltip, lines)\n+    end\n+\n+    if hint_labels then\n+      vim.iter(hint_labels):each(\n+        --- @param hint_label vim.lsp.inlay_hint.action.hint_label\n+        function(hint_label)\n+          local label = hint_label.label\n+          lines[#lines + 1] = ''\n+          -- each of the level 2 headings is the text of a label part\n+          lines[#lines + 1] = string.format('## `%s`', label.value)\n+          lines[#lines + 1] = ''\n+          if label.tooltip then\n+            -- borrowed from `vim.lsp.buf.hover()`\n+            util.convert_input_to_markdown_lines(label.tooltip, lines)\n+          end\n+          if label.location then\n+            -- include the location in this label part\n+            lines[#lines + 1] = string.format(\n+              '_Location_: `%s`:%d',\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+          if label.command then\n+            -- include the command associated to this label part\n+            local command_line = string.format('_Command_: %s', label.command.title)\n+            if label.command.tooltip then\n+              command_line = command_line .. string.format(' (%s)', label.command.tooltip)\n+            end\n+            lines[#lines + 1] = command_line\n+          end\n+        end\n+      )\n+    end\n+\n+    if #lines == 2 then\n+      -- no tooltip/command/location has been found. Skip this hint.\n+      return 0\n+    end\n+\n+    ---@type integer, integer\n+    local buf, _ = util.open_floating_preview(lines, 'markdown')\n+\n+    if on_finish then\n+      on_finish({ bufnr = buf, client = ctx.client })\n+    end\n+    return 1\n+  end,\n+\n+  command = function(hints, ctx, on_finish)\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"command\") only supports showing commands for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    if #hints == 0 then\n+      return 0\n+    end\n+    local hint_labels = action_helpers.get_hint_labels(assert(hints[1]), { 'command' })\n+    if hint_labels == nil or #hint_labels == 0 then\n+      -- no commands in this hint\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param item vim.lsp.inlay_hint.action.hint_label\n+          function(item)\n+            local label = item.label\n+            local entry_line = string.format('%s: %s', label.value, assert(label.command).title)\n+            if label.tooltip then\n+              entry_line = entry_line .. string.format(' (%s)', label.tooltip)\n+            end\n+            return entry_line\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Command to execute' },\n+      function(_, idx)\n+        if idx == nil then\n+          -- `vim.ui.select` was cancelled\n+          if on_finish then\n+            on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+          end\n+          return\n+        end\n+        ctx.client:request('workspace/executeCommand', hint_labels[idx].label.command, function(...)\n+          local default_handler = ctx.client.handlers['workspace/executeCommand']\n+            or vim.lsp.handlers['workspace/executeCommand']\n+          if default_handler then\n+            default_handler(...)\n+          end\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end, ctx.bufnr)\n+      end\n+    )\n+\n+    return 1\n+  end,\n+}\n+\n+--- @alias vim.lsp.inlay_hint.action.name\n+---| 'textEdits' -- insert texts into the buffer\n+---| 'command' -- See 'workspace/executeCommand'\n+---| 'location' -- Jump to the location (usually the definition of the identifier or type)\n+---| 'hover' -- show a hover window of the symbols shown in the inlay hint\n+---| 'tooltip' -- show a hover-like window, containing available tooltips, commands and locations\n+\n+--- @alias vim.lsp.inlay_hint.action\n+---| vim.lsp.inlay_hint.action.name\n+---| vim.lsp.inlay_hint.action.handler\n+\n+--- @class vim.lsp.inlay_hint.action.context\n+--- @inlinedoc\n+--- @field bufnr integer\n+--- @field client vim.lsp.Client\n+\n+--- @class vim.lsp.inlay_hint.action.on_finish.context\n+--- @inlinedoc\n+--- @field client? vim.lsp.Client The LSP client used to trigger the action if the action was successfully triggered.\n+--- If the action opened or jumped to a new buffer, this will be the buffer number.\n+--- Otherwise it'll be the original buffer.\n+--- @field bufnr integer\n+\n+--- This should be called __exactly__ once in the action handler.\n+--- @alias vim.lsp.inlay_hint.action.on_finish.callback fun(ctx: vim.lsp.inlay_hint.action.on_finish.context)\n+\n+--- @alias vim.lsp.inlay_hint.action.handler fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context, on_finish: vim.lsp.inlay_hint.action.on_finish.callback?):integer\n+\n+--- @class vim.lsp.inlay_hint.action.Opts\n+--- @inlinedoc\n+--- Inlay hints (returned by `vim.lsp.inlay_hint.get()`) to take actions on.\n+--- When not specified:\n+---   - in |Normal-mode|, it uses hints on either side of the cursor.\n+---   - in |Visual-mode|, it uses hints inside the selected range.\n+--- @field hints? vim.lsp.inlay_hint.get.ret[]\n+\n+--- Apply some actions provided by inlay hints in the selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\n+---   { 'n', 'v' },\n+---   'gI',\n+---   function()\n+---     vim.lsp.inlay_hint.action('textEdits')\n+---   end,\n+---   { desc = 'Apply inlay hint textEdits' }\n+--- )\n+--- ```\n+---\n+--- @param action vim.lsp.inlay_hint.action\n+--- Possible actions:\n+--- - `\"textEdits\"`: insert `textEdits` that comes with the inlay hints.\n+--- - `\"location\"`: jump to one of the locations associated with the inlay hints.\n+--- - `\"command\"`: execute one of the `lsp.Command`s that comes with the inlay hint.\n+--- - `\"hover\"`: if there are some locations associated with the inlay hint, show the hover\n+---   information of the identifiers at those locations.\n+--- - `\"tooltip\"`: show a hover-like window that contains the `tooltip`, available `command`s and\n+---   `location`s that comes with the inlay hint.\n+--- - a custom handler with 3 parameters:\n+---   - `hints`: `lsp.InlayHint[]` a list of inlay hints in the requested range.\n+---   - `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the buffer number on which the action is taken, and the LSP client that provides `hints`.\n+---   - `on_finish`: `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})` see the `callback` parameter of `vim.lsp.inlay_hint.apply_action`.\n+---     When implementing a custom handler, the `on_finish` callback should be called when the handler is returning a non-zero value.\n+---\n+---   This custom handler should also return the number of items in `hints` that contributed to the action. For example, the `location` handler should return `1` on a successful jump because the target location is from 1 inlay hint object, regardless of the number of hints in `hints`.\n+--- @param opts? vim.lsp.inlay_hint.action.Opts\n+--- @param callback? fun(ctx: {bufnr: integer, client?: vim.lsp.Client})\n+--- A callback function that will be triggered exactly once (asynchronously) at the end of the action.\n+--- It accepts a table with the following keys as the parameter:\n+--- - `bufnr`: the buffer number that is focused on. If there's any jump-to-location or pop-up,\n+---   this'll points you to the new buffer.\n+--- - `client?`: the `vim.lsp.Client` used to invoke the action. `nil` when the action failed\n+---   to be invoked.\n+function M.action(action, opts, callback)\n+  vim.validate('action', action, function(val)\n+    return type(val) == 'function' or type(inlayhint_actions[val]) == 'function'\n+  end, false)\n+  vim.validate('opts', opts, 'table', true)\n+  vim.validate('callback', callback, 'function', true)\n+\n+  local action_handler = action\n+  if type(action) == 'string' then\n+    action_handler = inlayhint_actions[action]\n+    --- @cast action_handler -vim.lsp.inlay_hint.action.name\n+  end\n+\n+  opts = opts or {}\n+\n+  local bufnr = api.nvim_get_current_buf()\n+\n+  local on_finish_cb_called = false\n+  if callback then\n+    local original_callback = callback\n+    -- decorate the `on_finish` callback to make sure it only called once.\n+    ---@type vim.lsp.inlay_hint.action.on_finish.callback\n+    callback = function(...)\n+      assert(not on_finish_cb_called, 'The callback should only be called once.')\n+      on_finish_cb_called = true\n+      return original_callback(...)\n+    end\n+  end\n+\n+  local hints = opts.hints\n+  if hints == nil then\n+    local range = action_helpers.make_range()\n+    hints = M.get({\n+      range = {\n+        -- in `M.on_inlayhint`,\n+        -- the inlay hints are stored by byte indices, not lsp positions (utf-*),\n+        -- so we can't use `vim.range.to_lsp`\n+        start = { line = range.start.row, character = range.start.col },\n+        ['end'] = { line = range.end_.row, character = range.end_.col },\n+      },\n+      bufnr = bufnr,\n+    })\n+  end\n+  --- group inlay hints by clients.\n+  ---@type table<integer, lsp.InlayHint[]>\n+  local hints_by_clients = vim.defaulttable(function(_)\n+    return {}\n+  end)\n+\n+  vim.iter(hints):each(\n+    ---@param item vim.lsp.inlay_hint.get.ret\n+    function(item)\n+      table.insert(hints_by_clients[item.client_id], item.inlay_hint)\n+    end\n+  )\n+\n+  ---@type vim.lsp.Client[]\n+  local clients = vim\n+    .iter(vim.tbl_keys(hints_by_clients))\n+    :map(function(cli_id)\n+      return vim.lsp.get_client_by_id(cli_id)\n+    end)\n+    :totable()\n+\n+  --- iterate through `clients` and requests for inlay hints.\n+  --- If a client provides no inlay hint (`nil` or `{}`) for the given range, or the provided hints don't contain\n+  --- the attributes needed for the the action, proceed to the next client. Otherwise, the action is",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619854297",
            "id": 2619854297,
            "line": 1056,
            "node_id": "PRRC_kwDOAPphoM6cJ83Z",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 1056,
            "original_position": 629,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 629,
            "pull_request_review_id": 3578768971,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619854297/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T15:43:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619854297",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619883444"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619883444"
                }
            },
            "author_association": "NONE",
            "body": "english is not my first language, but I think this needs to be like this:\r\n```suggestion\r\n  --- Append `new_label` to `labels` if there are no duplicates.\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T15:27:00Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619883444",
            "id": 2619883444,
            "line": 559,
            "node_id": "PRRC_kwDOAPphoM6cKD-0",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 559,
            "original_position": 132,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 132,
            "pull_request_review_id": 3578768971,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619883444/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T15:43:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619883444",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619899677"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619899677"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n          'vim.lsp.inlay_hint.action(\"hover\") only supports showing hover for a single inlay hint.',\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T15:30:19Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619899677",
            "id": 2619899677,
            "line": 723,
            "node_id": "PRRC_kwDOAPphoM6cKH8d",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 723,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 296,
            "pull_request_review_id": 3578768971,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619899677/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:05:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619899677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619947841"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619947841"
                }
            },
            "author_association": "NONE",
            "body": "I think this is supposed to be a table\r\n```suggestion\r\n    ---@type lsp.InlayHint[]\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T15:45:07Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619947841",
            "id": 2619947841,
            "line": 626,
            "node_id": "PRRC_kwDOAPphoM6cKTtB",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 626,
            "original_position": 199,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 199,
            "pull_request_review_id": 3578907445,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619947841/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T15:45:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619947841",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2619997185"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619997185"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n    --- Go through the labels to build the content of the hover\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T16:02:12Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location' })\n+    if hint_labels == nil then\n+      return 0\n+    end\n+\n+    ---@type string[]\n+    local lines = {}\n+\n+    --- Go though the labels to build the content of the hover",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2619997185",
            "id": 2619997185,
            "line": 737,
            "node_id": "PRRC_kwDOAPphoM6cKfwB",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 737,
            "original_position": 310,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 310,
            "pull_request_review_id": 3578979848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619997185/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2619997185",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2620003587"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620003587"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n---   - `on_finish`: `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})` see the `callback` parameter of `vim.lsp.inlay_hint.action`.\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T16:04:33Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location' })\n+    if hint_labels == nil then\n+      return 0\n+    end\n+\n+    ---@type string[]\n+    local lines = {}\n+\n+    --- Go though the labels to build the content of the hover\n+    ---@param idx integer?\n+    ---@param item vim.lsp.inlay_hint.action.hint_label?\n+    local function get_hover(idx, item)\n+      if idx == nil or item == nil then\n+        -- all locations have been processed\n+        -- open the hover window\n+        if #lines == 0 then\n+          lines = { 'Empty' }\n+        end\n+        local float_buf, _ = util.open_floating_preview(lines, 'markdown')\n+        if on_finish then\n+          on_finish({ client = ctx.client, bufnr = float_buf })\n+        end\n+        return\n+      end\n+\n+      -- `get_hint_labels` makes sure `item.label` has location attribute\n+      local label_loc = assert(item.label.location)\n+      ---@type lsp.HoverParams\n+      local hover_param = {\n+        textDocument = { uri = label_loc.uri },\n+        position = label_loc.range.start,\n+      }\n+      ctx.client:request(\n+        'textDocument/hover',\n+        hover_param,\n+        ---@param result lsp.Hover?\n+        function(_, result, _, _)\n+          if result then\n+            local md_lines = util.convert_input_to_markdown_lines(result.contents)\n+            if #md_lines > 0 then\n+              if #lines > 0 then\n+                -- blank line between label parts\n+                lines[#lines + 1] = ''\n+              end\n+              lines[#lines + 1] = string.format('# `%s`', item.label.value)\n+              vim.list_extend(lines, md_lines)\n+            end\n+          end\n+          get_hover(next(hint_labels, idx))\n+        end,\n+        ctx.bufnr\n+      )\n+    end\n+\n+    get_hover(next(hint_labels))\n+    return 1\n+  end,\n+\n+  tooltip = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location', 'command' })\n+\n+    -- the level 1 heading is the full hint object\n+    local lines = { string.format('# `%s`', action_helpers.get_label_text(hint, false)), '' }\n+\n+    if hint.tooltip then\n+      util.convert_input_to_markdown_lines(hint.tooltip, lines)\n+    end\n+\n+    if hint_labels then\n+      vim.iter(hint_labels):each(\n+        --- @param hint_label vim.lsp.inlay_hint.action.hint_label\n+        function(hint_label)\n+          local label = hint_label.label\n+          lines[#lines + 1] = ''\n+          -- each of the level 2 headings is the text of a label part\n+          lines[#lines + 1] = string.format('## `%s`', label.value)\n+          lines[#lines + 1] = ''\n+          if label.tooltip then\n+            -- borrowed from `vim.lsp.buf.hover()`\n+            util.convert_input_to_markdown_lines(label.tooltip, lines)\n+          end\n+          if label.location then\n+            -- include the location in this label part\n+            lines[#lines + 1] = string.format(\n+              '_Location_: `%s`:%d',\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+          if label.command then\n+            -- include the command associated to this label part\n+            local command_line = string.format('_Command_: %s', label.command.title)\n+            if label.command.tooltip then\n+              command_line = command_line .. string.format(' (%s)', label.command.tooltip)\n+            end\n+            lines[#lines + 1] = command_line\n+          end\n+        end\n+      )\n+    end\n+\n+    if #lines == 2 then\n+      -- no tooltip/command/location has been found. Skip this hint.\n+      return 0\n+    end\n+\n+    ---@type integer, integer\n+    local buf, _ = util.open_floating_preview(lines, 'markdown')\n+\n+    if on_finish then\n+      on_finish({ bufnr = buf, client = ctx.client })\n+    end\n+    return 1\n+  end,\n+\n+  command = function(hints, ctx, on_finish)\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"command\") only supports showing commands for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    if #hints == 0 then\n+      return 0\n+    end\n+    local hint_labels = action_helpers.get_hint_labels(assert(hints[1]), { 'command' })\n+    if hint_labels == nil or #hint_labels == 0 then\n+      -- no commands in this hint\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param item vim.lsp.inlay_hint.action.hint_label\n+          function(item)\n+            local label = item.label\n+            local entry_line = string.format('%s: %s', label.value, assert(label.command).title)\n+            if label.tooltip then\n+              entry_line = entry_line .. string.format(' (%s)', label.tooltip)\n+            end\n+            return entry_line\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Command to execute' },\n+      function(_, idx)\n+        if idx == nil then\n+          -- `vim.ui.select` was cancelled\n+          if on_finish then\n+            on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+          end\n+          return\n+        end\n+        ctx.client:request('workspace/executeCommand', hint_labels[idx].label.command, function(...)\n+          local default_handler = ctx.client.handlers['workspace/executeCommand']\n+            or vim.lsp.handlers['workspace/executeCommand']\n+          if default_handler then\n+            default_handler(...)\n+          end\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end, ctx.bufnr)\n+      end\n+    )\n+\n+    return 1\n+  end,\n+}\n+\n+--- @alias vim.lsp.inlay_hint.action.name\n+---| 'textEdits' -- insert texts into the buffer\n+---| 'command' -- See 'workspace/executeCommand'\n+---| 'location' -- Jump to the location (usually the definition of the identifier or type)\n+---| 'hover' -- show a hover window of the symbols shown in the inlay hint\n+---| 'tooltip' -- show a hover-like window, containing available tooltips, commands and locations\n+\n+--- @alias vim.lsp.inlay_hint.action\n+---| vim.lsp.inlay_hint.action.name\n+---| vim.lsp.inlay_hint.action.handler\n+\n+--- @class vim.lsp.inlay_hint.action.context\n+--- @inlinedoc\n+--- @field bufnr integer\n+--- @field client vim.lsp.Client\n+\n+--- @class vim.lsp.inlay_hint.action.on_finish.context\n+--- @inlinedoc\n+--- @field client? vim.lsp.Client The LSP client used to trigger the action if the action was successfully triggered.\n+--- If the action opened or jumped to a new buffer, this will be the buffer number.\n+--- Otherwise it'll be the original buffer.\n+--- @field bufnr integer\n+\n+--- This should be called __exactly__ once in the action handler.\n+--- @alias vim.lsp.inlay_hint.action.on_finish.callback fun(ctx: vim.lsp.inlay_hint.action.on_finish.context)\n+\n+--- @alias vim.lsp.inlay_hint.action.handler fun(hints: lsp.InlayHint[], ctx: vim.lsp.inlay_hint.action.context, on_finish: vim.lsp.inlay_hint.action.on_finish.callback?):integer\n+\n+--- @class vim.lsp.inlay_hint.action.Opts\n+--- @inlinedoc\n+--- Inlay hints (returned by `vim.lsp.inlay_hint.get()`) to take actions on.\n+--- When not specified:\n+---   - in |Normal-mode|, it uses hints on either side of the cursor.\n+---   - in |Visual-mode|, it uses hints inside the selected range.\n+--- @field hints? vim.lsp.inlay_hint.get.ret[]\n+\n+--- Apply some actions provided by inlay hints in the selected range.\n+---\n+--- Example usage:\n+--- ```lua\n+--- vim.keymap.set(\n+---   { 'n', 'v' },\n+---   'gI',\n+---   function()\n+---     vim.lsp.inlay_hint.action('textEdits')\n+---   end,\n+---   { desc = 'Apply inlay hint textEdits' }\n+--- )\n+--- ```\n+---\n+--- @param action vim.lsp.inlay_hint.action\n+--- Possible actions:\n+--- - `\"textEdits\"`: insert `textEdits` that comes with the inlay hints.\n+--- - `\"location\"`: jump to one of the locations associated with the inlay hints.\n+--- - `\"command\"`: execute one of the `lsp.Command`s that comes with the inlay hint.\n+--- - `\"hover\"`: if there are some locations associated with the inlay hint, show the hover\n+---   information of the identifiers at those locations.\n+--- - `\"tooltip\"`: show a hover-like window that contains the `tooltip`, available `command`s and\n+---   `location`s that comes with the inlay hint.\n+--- - a custom handler with 3 parameters:\n+---   - `hints`: `lsp.InlayHint[]` a list of inlay hints in the requested range.\n+---   - `ctx`: `{bufnr: integer, client: vim.lsp.Client}` the buffer number on which the action is taken, and the LSP client that provides `hints`.\n+---   - `on_finish`: `fun(_ctx: {bufnr: integer, client?: vim.lsp.Client})` see the `callback` parameter of `vim.lsp.inlay_hint.apply_action`.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2620003587",
            "id": 2620003587,
            "line": 978,
            "node_id": "PRRC_kwDOAPphoM6cKhUD",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 978,
            "original_position": 551,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 551,
            "pull_request_review_id": 3578979848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620003587/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620003587",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2620004133"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004133"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n          'vim.lsp.inlay_hint.action(\"command\") only supports showing commands for a single inlay hint.',\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T16:04:46Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location' })\n+    if hint_labels == nil then\n+      return 0\n+    end\n+\n+    ---@type string[]\n+    local lines = {}\n+\n+    --- Go though the labels to build the content of the hover\n+    ---@param idx integer?\n+    ---@param item vim.lsp.inlay_hint.action.hint_label?\n+    local function get_hover(idx, item)\n+      if idx == nil or item == nil then\n+        -- all locations have been processed\n+        -- open the hover window\n+        if #lines == 0 then\n+          lines = { 'Empty' }\n+        end\n+        local float_buf, _ = util.open_floating_preview(lines, 'markdown')\n+        if on_finish then\n+          on_finish({ client = ctx.client, bufnr = float_buf })\n+        end\n+        return\n+      end\n+\n+      -- `get_hint_labels` makes sure `item.label` has location attribute\n+      local label_loc = assert(item.label.location)\n+      ---@type lsp.HoverParams\n+      local hover_param = {\n+        textDocument = { uri = label_loc.uri },\n+        position = label_loc.range.start,\n+      }\n+      ctx.client:request(\n+        'textDocument/hover',\n+        hover_param,\n+        ---@param result lsp.Hover?\n+        function(_, result, _, _)\n+          if result then\n+            local md_lines = util.convert_input_to_markdown_lines(result.contents)\n+            if #md_lines > 0 then\n+              if #lines > 0 then\n+                -- blank line between label parts\n+                lines[#lines + 1] = ''\n+              end\n+              lines[#lines + 1] = string.format('# `%s`', item.label.value)\n+              vim.list_extend(lines, md_lines)\n+            end\n+          end\n+          get_hover(next(hint_labels, idx))\n+        end,\n+        ctx.bufnr\n+      )\n+    end\n+\n+    get_hover(next(hint_labels))\n+    return 1\n+  end,\n+\n+  tooltip = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location', 'command' })\n+\n+    -- the level 1 heading is the full hint object\n+    local lines = { string.format('# `%s`', action_helpers.get_label_text(hint, false)), '' }\n+\n+    if hint.tooltip then\n+      util.convert_input_to_markdown_lines(hint.tooltip, lines)\n+    end\n+\n+    if hint_labels then\n+      vim.iter(hint_labels):each(\n+        --- @param hint_label vim.lsp.inlay_hint.action.hint_label\n+        function(hint_label)\n+          local label = hint_label.label\n+          lines[#lines + 1] = ''\n+          -- each of the level 2 headings is the text of a label part\n+          lines[#lines + 1] = string.format('## `%s`', label.value)\n+          lines[#lines + 1] = ''\n+          if label.tooltip then\n+            -- borrowed from `vim.lsp.buf.hover()`\n+            util.convert_input_to_markdown_lines(label.tooltip, lines)\n+          end\n+          if label.location then\n+            -- include the location in this label part\n+            lines[#lines + 1] = string.format(\n+              '_Location_: `%s`:%d',\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+          if label.command then\n+            -- include the command associated to this label part\n+            local command_line = string.format('_Command_: %s', label.command.title)\n+            if label.command.tooltip then\n+              command_line = command_line .. string.format(' (%s)', label.command.tooltip)\n+            end\n+            lines[#lines + 1] = command_line\n+          end\n+        end\n+      )\n+    end\n+\n+    if #lines == 2 then\n+      -- no tooltip/command/location has been found. Skip this hint.\n+      return 0\n+    end\n+\n+    ---@type integer, integer\n+    local buf, _ = util.open_floating_preview(lines, 'markdown')\n+\n+    if on_finish then\n+      on_finish({ bufnr = buf, client = ctx.client })\n+    end\n+    return 1\n+  end,\n+\n+  command = function(hints, ctx, on_finish)\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"command\") only supports showing commands for a single inlay hint.',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2620004133",
            "id": 2620004133,
            "line": 861,
            "node_id": "PRRC_kwDOAPphoM6cKhcl",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 861,
            "original_position": 434,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 434,
            "pull_request_review_id": 3578979848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004133/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004133",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2620004497"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004497"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n          'vim.lsp.inlay_hint.action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T16:04:57Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.\n+--- @param hint lsp.InlayHint\n+--- @param needed_fields (\"location\"|\"command\"|\"tooltip\")[]?\n+--- @return vim.lsp.inlay_hint.action.hint_label[]?\n+action_helpers.get_hint_labels = function(hint, needed_fields)\n+  vim.validate('needed_fields', needed_fields, function(val)\n+    return vim.islist(val)\n+      and vim.iter(needed_fields):any(function(field)\n+        return vim.list_contains({ 'location', 'command', 'tooltip' }, field)\n+      end)\n+  end, false)\n+  --- @type vim.lsp.inlay_hint.action.hint_label[]\n+  local hint_labels = {}\n+\n+  if type(hint.label) == 'table' and #hint.label > 0 then\n+    vim.iter(hint.label):each(\n+      --- @param label lsp.InlayHintLabelPart\n+      function(label)\n+        if\n+          vim.iter(needed_fields):any(function(field_name)\n+            return label[field_name] ~= nil\n+          end)\n+        then\n+          action_helpers.add_new_label(hint_labels, { hint = hint, label = label }, needed_fields)\n+        end\n+      end\n+    )\n+  end\n+\n+  if #hint_labels > 0 then\n+    return hint_labels\n+  end\n+end\n+\n+--- The built-in action handlers.\n+--- @type table<vim.lsp.inlay_hint.action.name, vim.lsp.inlay_hint.action.handler>\n+local inlayhint_actions = {\n+  textEdits = function(hints, ctx, on_finish)\n+    ---@type lsp.InlayHint\n+    local valid_hints = vim\n+      .iter(hints)\n+      :filter(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          -- only keep those that have text edits.\n+          return hint ~= nil and hint.textEdits ~= nil and not vim.tbl_isempty(hint.textEdits)\n+        end\n+      )\n+      :totable()\n+    --- @type lsp.TextEdit[]\n+    local text_edits = vim\n+      .iter(valid_hints)\n+      :map(\n+        --- @param hint lsp.InlayHint\n+        function(hint)\n+          return hint.textEdits\n+        end\n+      )\n+      :flatten(1)\n+      :totable()\n+    if #text_edits > 0 then\n+      vim.schedule(function()\n+        util.apply_text_edits(text_edits, ctx.bufnr, ctx.client.offset_encoding)\n+        if on_finish then\n+          on_finish({ bufnr = ctx.bufnr, client = ctx.client })\n+        end\n+      end)\n+    end\n+    return #valid_hints\n+  end,\n+  location = function(hints, ctx, on_finish)\n+    local count = 0\n+\n+    --- @type vim.lsp.inlay_hint.action.hint_label[]\n+    local hint_labels = {}\n+\n+    vim.iter(hints):each(\n+      --- @param item lsp.InlayHint\n+      function(item)\n+        if type(item.label) == 'table' and #item.label > 0 then\n+          local labels_from_this = action_helpers.get_hint_labels(item, { 'location' })\n+          if labels_from_this then\n+            count = count + 1\n+            vim.list_extend(hint_labels, labels_from_this)\n+          end\n+        end\n+      end\n+    )\n+\n+    if vim.tbl_isempty(hint_labels) then\n+      return 0\n+    end\n+\n+    action_helpers.do_or_select(\n+      vim\n+        .iter(hint_labels)\n+        :map(\n+          --- @param loc vim.lsp.inlay_hint.action.hint_label\n+          function(loc)\n+            local label = loc.label\n+            return string.format(\n+              '%s\\t%s:%d',\n+              label.value,\n+              action_helpers.cleanup_path(vim.uri_to_fname(label.location.uri), ctx.client.root_dir),\n+              label.location.range.start.line\n+            )\n+          end\n+        )\n+        :totable(),\n+      { prompt = 'Location to jump to' },\n+      function(_, idx)\n+        if idx then\n+          util.show_document(\n+            hint_labels[idx].label.location,\n+            ctx.client.offset_encoding,\n+            { reuse_win = true, focus = true }\n+          )\n+\n+          if on_finish then\n+            on_finish({ bufnr = api.nvim_get_current_buf(), client = ctx.client })\n+          end\n+        end\n+      end\n+    )\n+\n+    return count\n+  end,\n+\n+  hover = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',\n+          vim.log.levels.WARN\n+        )\n+      end)\n+    end\n+    local hint = assert(hints[1])\n+    local hint_labels = action_helpers.get_hint_labels(hint, { 'location' })\n+    if hint_labels == nil then\n+      return 0\n+    end\n+\n+    ---@type string[]\n+    local lines = {}\n+\n+    --- Go though the labels to build the content of the hover\n+    ---@param idx integer?\n+    ---@param item vim.lsp.inlay_hint.action.hint_label?\n+    local function get_hover(idx, item)\n+      if idx == nil or item == nil then\n+        -- all locations have been processed\n+        -- open the hover window\n+        if #lines == 0 then\n+          lines = { 'Empty' }\n+        end\n+        local float_buf, _ = util.open_floating_preview(lines, 'markdown')\n+        if on_finish then\n+          on_finish({ client = ctx.client, bufnr = float_buf })\n+        end\n+        return\n+      end\n+\n+      -- `get_hint_labels` makes sure `item.label` has location attribute\n+      local label_loc = assert(item.label.location)\n+      ---@type lsp.HoverParams\n+      local hover_param = {\n+        textDocument = { uri = label_loc.uri },\n+        position = label_loc.range.start,\n+      }\n+      ctx.client:request(\n+        'textDocument/hover',\n+        hover_param,\n+        ---@param result lsp.Hover?\n+        function(_, result, _, _)\n+          if result then\n+            local md_lines = util.convert_input_to_markdown_lines(result.contents)\n+            if #md_lines > 0 then\n+              if #lines > 0 then\n+                -- blank line between label parts\n+                lines[#lines + 1] = ''\n+              end\n+              lines[#lines + 1] = string.format('# `%s`', item.label.value)\n+              vim.list_extend(lines, md_lines)\n+            end\n+          end\n+          get_hover(next(hint_labels, idx))\n+        end,\n+        ctx.bufnr\n+      )\n+    end\n+\n+    get_hover(next(hint_labels))\n+    return 1\n+  end,\n+\n+  tooltip = function(hints, ctx, on_finish)\n+    if #hints == 0 then\n+      return 0\n+    end\n+    if #hints ~= 1 then\n+      vim.schedule(function()\n+        vim.notify(\n+          'vim.lsp.inlay_hint.apply_action(\"tooltip\") only supports showing tooltips for a single inlay hint.',",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2620004497",
            "id": 2620004497,
            "line": 794,
            "node_id": "PRRC_kwDOAPphoM6cKhiR",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 794,
            "original_position": 367,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 367,
            "pull_request_review_id": 3578979848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004497/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620004497",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/36219#discussion_r2620071158"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/36219"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620071158"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n---Return a non-empty list of hint labels , or `nil` if not found.\r\n```",
            "commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "created_at": "2025-12-15T16:27:59Z",
            "diff_hunk": "@@ -435,4 +436,685 @@ function M.enable(enable, filter)\n   end\n end\n \n+--- @class (private) vim.lsp.inlay_hint.action.LocationItem\n+--- @field hint_name string\n+--- @field hint_position lsp.Position\n+--- @field label_name string\n+--- @field location lsp.Location\n+\n+--- @class (private) vim.lsp.inlay_hint.action.hint_label\n+--- @field hint lsp.InlayHint\n+--- @field label lsp.InlayHintLabelPart\n+\n+local action_helpers = {\n+  --- turn an inlay hint object into the visible text, merging any label parts.\n+  --- paddings can be optionally included.\n+  --- @param hint lsp.InlayHint\n+  --- @param with_padding boolean?\n+  --- @return string\n+  get_label_text = function(hint, with_padding)\n+    --- @type string?\n+    local label\n+    if type(hint.label) == 'string' then\n+      label = tostring(hint.label)\n+    elseif vim.islist(hint.label) then\n+      ---@type string\n+      label = vim\n+        .iter(hint.label)\n+        :map(\n+          --- @param part lsp.InlayHintLabelPart\n+          function(part)\n+            return part.value\n+          end\n+        )\n+        :join('')\n+    end\n+\n+    assert(label ~= nil, 'Failed to extract the label value from the inlay hint')\n+\n+    if with_padding then\n+      if hint.paddingLeft then\n+        label = ' ' .. label\n+      end\n+      if hint.paddingRight then\n+        label = label .. ' '\n+      end\n+    end\n+\n+    return label\n+  end,\n+\n+  --- a wrapper of `vim.ui.select` that skips the menu when there's only one item.\n+  --- @generic T\n+  --- @param items T[] Arbitrary items\n+  --- @param opts vim.ui.select.Opts Additional options\n+  --- @param on_choice fun(item: T|nil, idx: integer|nil)\n+  do_or_select = function(items, opts, on_choice)\n+    if #items == 0 then\n+      return error('Empty items!')\n+    end\n+    if #items == 1 then\n+      return on_choice(items[1], 1)\n+    end\n+    return vim.ui.select(items, opts, on_choice)\n+  end,\n+\n+  --- @param path string\n+  --- @param base string?\n+  --- @return string\n+  cleanup_path = function(path, base)\n+    ---@type string?\n+    local result = nil\n+    if base then\n+      -- relative to `base`\n+      result = vim.fs.relpath(base, path)\n+    end\n+    if result == nil then\n+      result = fn.fnamemodify(path, ':p:~')\n+    end\n+    return result\n+  end,\n+\n+  --- build the range from normal or visual mode based on cursor position.\n+  --- @return vim.Range\n+  make_range = function()\n+    local bufnr = api.nvim_get_current_buf()\n+    local winid = fn.bufwinid(bufnr)\n+    local mode = fn.mode()\n+\n+    -- mark position, (1, 0) indexed, end-exclusive\n+    --- @type {start: vim.Pos, end: vim.Pos}\n+    local range = {}\n+\n+    if mode == 'n' then\n+      local cursor = api.nvim_win_get_cursor(winid)\n+      range.start = vim.pos.cursor(cursor)\n+      range['end'] = vim.pos.cursor(cursor)\n+      range['end'].col = range['end'].col + 1\n+    else\n+      local start_pos = fn.getpos('v')\n+      local end_pos = fn.getpos('.')\n+      if\n+        start_pos[2] > end_pos[2] or (start_pos[2] == end_pos[2] and start_pos[3] > end_pos[3])\n+      then\n+        --- @type [integer, integer, integer, integer]\n+        start_pos, end_pos = end_pos, start_pos\n+      end\n+      range = {\n+        start = vim.pos.cursor({ start_pos[2], start_pos[3] - 1 }),\n+        ['end'] = vim.pos.cursor({ end_pos[2], end_pos[3] }),\n+      }\n+\n+      if mode == 'V' or mode == 'Vs' then\n+        range.start.col = 0\n+        range['end'].row = range['end'].row + 1\n+        range['end'].col = 0\n+      end\n+    end\n+    range.start.buf = bufnr\n+    range['end'].buf = bufnr\n+    return vim.range(range.start, range['end'])\n+  end,\n+\n+  --- Append `new_label` to `labels` if there's no duplicates.\n+  ---@param labels vim.lsp.inlay_hint.action.hint_label[]\n+  ---@param new_label vim.lsp.inlay_hint.action.hint_label\n+  ---@param by_attribute ('location'|'command'|'tooltip')[]|nil When provided, only check for these attributes (and `value`) for equality\n+  add_new_label = function(labels, new_label, by_attribute)\n+    if\n+      vim.iter(labels):any(\n+        ---@param existing_label vim.lsp.inlay_hint.action.hint_label\n+        function(existing_label)\n+          -- check for duplications with existing hint_labels\n+          if by_attribute then\n+            -- check for concerned attributes\n+            return vim.iter(by_attribute):all(function(attr)\n+              return existing_label.label.value == new_label.label.value\n+                and vim.deep_equal(existing_label.label[attr], new_label.label[attr])\n+            end)\n+          else\n+            -- check the entire label\n+            return vim.deep_equal(existing_label.label, new_label.label)\n+          end\n+        end\n+      )\n+    then\n+      return\n+    end\n+    table.insert(labels, new_label)\n+  end,\n+}\n+\n+---Return a non-empty list of lsp locations, or `nil` if not found.",
            "html_url": "https://github.com/neovim/neovim/pull/36219#discussion_r2620071158",
            "id": 2620071158,
            "line": 588,
            "node_id": "PRRC_kwDOAPphoM6cKxz2",
            "original_commit_id": "6353a3fed03d4861e3e75e56a19c75f940472da2",
            "original_line": 588,
            "original_position": 161,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/inlay_hint.lua",
            "position": 161,
            "pull_request_review_id": 3578979848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620071158/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-12-15T16:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2620071158",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "BTW: this PR doesn't set up any default keymaps because not a lot of LSP servers implement `textEdits` in the inlay hint responses. Defining a default keymap for this would be useless for those who don't use a compatible LSP server and might be polluting the \"namespace of keymaps\".",
            "created_at": "2025-10-17T11:07:42Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3415027714",
            "id": 3415027714,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7LjTAC",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3415027714/reactions"
            },
            "updated_at": "2025-10-17T11:07:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3415027714",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> We should also handle cases where we need to resolve inlay hints\r\n\r\nthis'll take a bit longer because there'd need to be parallel async requests to resolve (each resolve only handles one inlay hint). I'll try.",
            "created_at": "2025-10-17T15:41:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3416097438",
            "id": 3416097438,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7LnYKe",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3416097438/reactions"
            },
            "updated_at": "2025-10-17T15:41:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3416097438",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> BTW: this PR doesn't set up any default keymaps because not a lot of LSP servers implement `textEdits` in the inlay hint responses. Defining a default keymap for this would be useless for those who don't use a compatible LSP server and might be polluting the \"namespace of keymaps\".\r\n\r\nWe also don't enable inlay hints by default.",
            "created_at": "2025-10-18T03:22:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3417756312",
            "id": 3417756312,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7LttKY",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3417756312/reactions"
            },
            "updated_at": "2025-10-18T03:22:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3417756312",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@Davidyz sorry to do this. I really appreciate the thought and effort put into this PR and I hope you'll stick with us in coming up with a great implementation of this feature, but I do feel the need to take a step back and re-assess the problem that we're trying to solve here.\r\n\r\nThis PR advertises closing https://github.com/neovim/neovim/issues/36181, where I asked why [`vim.lsp.inlay_hint.get()`](https://neovim.io/doc/user/lsp.html#vim.lsp.inlay_hint.get()) isn't enough to accomplish that functionality. [Your response was that it was incompatible with a particular plugin](https://github.com/neovim/neovim/issues/36181#issuecomment-3404616670), which IMO (happy to let others disagree with me here) isn't a strong enough reason to change the LSP API provided by core. Instead of adding different API entrypoints we should try to make the existing functions more ergonomic for plugins to hook into (or better document how to modify these methods from a plugin in a legal way).\r\n\r\nWhile reviewing this PR I realize that in the future we will also want to be able to apply commands provided by [inlay hint label parts](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.18/specification/#inlayHintLabelPart). I don't want us to have to have to cook up code similar to the one proposed here to have that functionality when [`vim.lsp.inlay_hint.get()`](https://neovim.io/doc/user/lsp.html#vim.lsp.inlay_hint.get()) allows that and more. If it doesn't does that today then let's make it more powerful instead of starting from scratch with a different approach :) ",
            "created_at": "2025-10-19T01:11:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3419114076",
            "id": 3419114076,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7Ly4pc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3419114076/reactions"
            },
            "updated_at": "2025-10-19T01:11:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3419114076",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> [Your response was that it was incompatible with a particular plugin](https://github.com/neovim/neovim/issues/36181#issuecomment-3404616670), which IMO (happy to let others disagree with me here) isn't a strong enough reason to change the LSP API provided by core.\r\n\r\nPerhaps I didn't make it clear enough. It's not really about that particular plugin, but rather the fact that overwriting handlers will break the `apply_text_edits` functionality, and the users would have to write the broken functionalities from scratch if they want them back (for example, in my original plugin implementation, I had to refactor everything from `vim.lsp.inlay_hint.get` to `client:request` so that my plugin can continue to function). _I guess this stem from the fact that a inlay hint response object carries fields for completely different purposes (UI, text edits, commands/label\r\nparts, etc.), and since they're used differently, it makes some sense to dispatch them to different handling mechanism?_\r\n\r\nAnyways, if you're intending to closing this PR in favor of a new one that adhere to the nvim API design better, feel free to do so. If that's the case, I'd probably just keep maintaining my implementation in https://github.com/Davidyz/inlayhint-filler.nvim.",
            "created_at": "2025-10-19T02:19:40Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3419148138",
            "id": 3419148138,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7LzA9q",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3419148138/reactions"
            },
            "updated_at": "2025-10-19T02:19:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3419148138",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "After some more in-depth research in the LSP specs, I'd like to propose an updated design to this PR that attempts to also provide APIs for labelparts and tooltips (alongside the existing textedits):\r\n\r\nA new `vim.lsp.inlay_hint.actions` submodule, which exposes the following 3 public API:\r\n- `vim.lsp.inlay_hint.actions.text_edits()`: apply textedits from the hint, if available (this is what I've already implemented in this PR).\r\n- `vim.lsp.inlay_hint.actions.tool_tips(callback)` where callback is a function that accepts a list of tooltips as a parameter. Users can use this to open a float win (similar to hover) that shows the tool tip. The parameter contains all tooltips collected from the hint, including the one from the inlayhint object and the ones in the label (labelparts).\r\n- `vim.lsp.inlay_hint.actions.command()`: opens a `vim.ui.select` window, listing the commands from the labelparts so that the users can choose a command to execute.\r\n\r\nMy current `apply_text_edits` function would be refactored into a `apply_action` function (can be a `local` or `---@private` function, this is TBD) that accepts a callback function `fun(hints: lsp.InlayHint[])`. The 3 public API would just need to contain the callback that implements their corresponding features. \r\n\r\nAbout whether we should reuse the hints cached in `bufstate`, I hold my view that we shouldn't, because:\r\n1. \"inlayhints being stored in `bufstate`\" cannot be guaranteed (plugins or user configs can break this).\r\n2. The current default handlers that update `bufstate` don't do `inlayHint/resolve`. Even if the hints are correctly stored in `bufstate`, they may not be up-to-date and require resolving anyway.\r\n\r\nBtw, I don't use a language server that provides tooltips or label parts. If the above design is approved, I might need some guidance on testing the commands and tooltips on a real language server.\r\n\r\n\r\n> Update: Alternatively, we can have one single public API: `vim.lsp.inlay_hint.apply_action(action)`, where action is one of `textEdits`, `tooltips` and `commands`. The implementations would just be `local` functions used as callback in the `client:request`",
            "created_at": "2025-10-27T10:02:56Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3450449965",
            "id": 3450449965,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7NqbAt",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3450449965/reactions"
            },
            "updated_at": "2025-10-28T06:28:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3450449965",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@MariaSolOs I just refactored the implementation that exposes one public interface (`vim.lsp.inlay_hint.apply_action`). At the moment, it only supports `textEdits`, but I can start working on handlers for the other attributes (tooltip, command and location) if this design is ok. They'll reuse the same range-filtering and `inlayHint/resolve` logic, and I'd only need to add new callbacks to the `inlayhint_actions` table.",
            "created_at": "2025-10-28T10:05:25Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3455596109",
            "id": 3455596109,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7N-DZN",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3455596109/reactions"
            },
            "updated_at": "2025-10-28T10:05:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3455596109",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm continuing the development of this feature in my plugin: https://github.com/Davidyz/inlayhint-filler.nvim/pull/10\r\n\r\nSuggestions/help (mostly on LSPs that have nice implementations of inlay hint) are welcomed!",
            "created_at": "2025-11-25T11:37:41Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3575217867",
            "id": 3575217867,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7VGX7L",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3575217867/reactions"
            },
            "updated_at": "2025-11-25T11:37:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3575217867",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "needs a rebase\r\n\r\n> one single public API: `vim.lsp.inlay_hint.apply_action(action)`\r\n\r\nSeems fine if it's part of LSP. @MariaSolOs does this look like what you were expecting?",
            "created_at": "2025-11-26T04:55:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3579116271",
            "id": 3579116271,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7VVPrv",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3579116271/reactions"
            },
            "updated_at": "2025-11-26T04:56:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3579116271",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> needs a rebase\n\nSorry I forgot to convert this back to a draft. I'm currently working on the action handlers (jump to location, execute commands, etc.) in a feature branch of my plugin. I'll come back and clean up this PR (the docstring and `vim.pos`) after I finish with the handlers.",
            "created_at": "2025-11-26T05:36:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3579273971",
            "id": 3579273971,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7VV2Lz",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3579273971/reactions"
            },
            "updated_at": "2025-11-26T05:36:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3579273971",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@MariaSolOs @ribru17 I've refactored this PR to adapt the new design that provides API for interacting `textEdits`, `location`, `command` (untested) and `tooltip`. I haven't written the unit tests and docs and the code requires some further cleanup like Justin mentioned, but it'd be nice if you could take a look at the overall design (the public API, UI/UX, etc.). I've updated the PR description to include a minimal setup that can be used to try it out.",
            "created_at": "2025-11-27T13:31:17Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3585882803",
            "id": 3585882803,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7VvDqz",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3585882803/reactions"
            },
            "updated_at": "2025-11-27T13:31:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3585882803",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "btw since `vim.lsp.inlay_hint.apply_action` is async, should I take #31206 into account? This'll probably make it easier to write the tests too, because I can just pass the buffer number of the tooltip hover (or the jumped location) in the callback argument.\r\n\r\nUpdate: I did it because it makes writing tests a lot easier.",
            "created_at": "2025-11-29T03:54:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3590962409",
            "id": 3590962409,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7WCbzp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3590962409/reactions"
            },
            "updated_at": "2025-12-02T13:57:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3590962409",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Need decisions:\r\n1. Whether `tooltip` and `command` should support fetching from multiple inlay hints (currently they're limited to the first one if there are multiple of them)? Personally, I think it'll be easier to build the `tooltip` buffer if they're limited to one hint only. As for `command`, I still haven't been able to find an LSP that provides it, so to me it's a WIP anyway, and I'm ok with limiting it to one hint only atm.\r\n2. naming: `apply_action` or `action` (waiting for @justinmk)? Personally, I'm ok with either `action` or `apply_action`.",
            "created_at": "2025-12-02T14:07:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3602249218",
            "id": 3602249218,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7WtfYC",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3602249218/reactions"
            },
            "updated_at": "2025-12-02T14:07:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3602249218",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Added `hover` action, which sends `textDocument/hover` to the locations in the label parts and open a float window containing the hover info of the identifiers in the inlay hint:\r\n<img width=\"2624\" height=\"1581\" alt=\"image\" src=\"https://github.com/user-attachments/assets/d7745ed6-c8fc-4193-95ac-22b3cbae8521\" />",
            "created_at": "2025-12-03T04:39:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3605061412",
            "id": 3605061412,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7W4N8k",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3605061412/reactions"
            },
            "updated_at": "2025-12-03T04:39:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3605061412",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@MariaSolOs Hi! Just wondering if this PR is likely to be reviewed before the 0.12 release. Not trying to push or urge anything, I understand that theres a lot to review, and this is a large PR. Im only asking because it helps me decide the future of [my plugin](https://github.com/Davidyz/inlayhint-filler.nvim). Thanks!",
            "created_at": "2025-12-09T09:23:43Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3631201088",
            "id": 3631201088,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7Yb7tA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3631201088/reactions"
            },
            "updated_at": "2025-12-09T09:23:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3631201088",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Hi,\r\nI just stumbled upon this PR when trying to implement this feature myself.\r\n\r\nJust wanted to let you know that, as an outsider, this looks great (or at least good enough to steal for my config, until this gets merged :smile: )",
            "created_at": "2025-12-15T15:12:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3656182555",
            "id": 3656182555,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7Z7Osb",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3656182555/reactions"
            },
            "updated_at": "2025-12-15T15:12:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3656182555",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "Also, a small nit, I think the convention in neovim (or at least in this file) is to start all of the comments with capital letters, which you are not doing in a lot of them",
            "created_at": "2025-12-15T15:49:59Z",
            "html_url": "https://github.com/neovim/neovim/pull/36219#issuecomment-3656361914",
            "id": 3656361914,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
            "node_id": "IC_kwDOAPphoM7Z76e6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3656361914/reactions"
            },
            "updated_at": "2025-12-15T15:49:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3656361914",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/48057913?v=4",
                "events_url": "https://api.github.com/users/oriori1703/events{/privacy}",
                "followers_url": "https://api.github.com/users/oriori1703/followers",
                "following_url": "https://api.github.com/users/oriori1703/following{/other_user}",
                "gists_url": "https://api.github.com/users/oriori1703/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oriori1703",
                "id": 48057913,
                "login": "oriori1703",
                "node_id": "MDQ6VXNlcjQ4MDU3OTEz",
                "organizations_url": "https://api.github.com/users/oriori1703/orgs",
                "received_events_url": "https://api.github.com/users/oriori1703/received_events",
                "repos_url": "https://api.github.com/users/oriori1703/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oriori1703/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oriori1703/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oriori1703",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/36219/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/36219/commits",
    "created_at": "2025-10-17T02:23:51Z",
    "diff_url": "https://github.com/neovim/neovim/pull/36219.diff",
    "draft": false,
    "head": {
        "label": "Davidyz:feat/inlayhint_textedits",
        "ref": "feat/inlayhint_textedits",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/Davidyz/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/Davidyz/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/Davidyz/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/Davidyz/neovim/branches{/branch}",
            "clone_url": "https://github.com/Davidyz/neovim.git",
            "collaborators_url": "https://api.github.com/repos/Davidyz/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/Davidyz/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/Davidyz/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/Davidyz/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/Davidyz/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/Davidyz/neovim/contributors",
            "created_at": "2025-08-30T03:15:24Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/Davidyz/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/Davidyz/neovim/downloads",
            "events_url": "https://api.github.com/repos/Davidyz/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/Davidyz/neovim/forks",
            "full_name": "Davidyz/neovim",
            "git_commits_url": "https://api.github.com/repos/Davidyz/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/Davidyz/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/Davidyz/neovim/git/tags{/sha}",
            "git_url": "git://github.com/Davidyz/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/Davidyz/neovim/hooks",
            "html_url": "https://github.com/Davidyz/neovim",
            "id": 1047259080,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/Davidyz/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/Davidyz/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/Davidyz/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/Davidyz/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/Davidyz/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/Davidyz/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/Davidyz/neovim/merges",
            "milestones_url": "https://api.github.com/repos/Davidyz/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOPmvnyA",
            "notifications_url": "https://api.github.com/repos/Davidyz/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
                "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
                "followers_url": "https://api.github.com/users/Davidyz/followers",
                "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
                "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Davidyz",
                "id": 30951234,
                "login": "Davidyz",
                "node_id": "MDQ6VXNlcjMwOTUxMjM0",
                "organizations_url": "https://api.github.com/users/Davidyz/orgs",
                "received_events_url": "https://api.github.com/users/Davidyz/received_events",
                "repos_url": "https://api.github.com/users/Davidyz/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Davidyz",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/Davidyz/neovim/pulls{/number}",
            "pushed_at": "2025-12-15T09:36:10Z",
            "releases_url": "https://api.github.com/repos/Davidyz/neovim/releases{/id}",
            "size": 343527,
            "ssh_url": "git@github.com:Davidyz/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/Davidyz/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/Davidyz/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/Davidyz/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/Davidyz/neovim/subscription",
            "svn_url": "https://github.com/Davidyz/neovim",
            "tags_url": "https://api.github.com/repos/Davidyz/neovim/tags",
            "teams_url": "https://api.github.com/repos/Davidyz/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/Davidyz/neovim/git/trees{/sha}",
            "updated_at": "2025-10-12T13:00:25Z",
            "url": "https://api.github.com/repos/Davidyz/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "6353a3fed03d4861e3e75e56a19c75f940472da2",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
            "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
            "followers_url": "https://api.github.com/users/Davidyz/followers",
            "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
            "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/Davidyz",
            "id": 30951234,
            "login": "Davidyz",
            "node_id": "MDQ6VXNlcjMwOTUxMjM0",
            "organizations_url": "https://api.github.com/users/Davidyz/orgs",
            "received_events_url": "https://api.github.com/users/Davidyz/received_events",
            "repos_url": "https://api.github.com/users/Davidyz/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/Davidyz",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/36219",
    "id": 2922712450,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/36219",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": false,
    "merge_commit_sha": "586144a9f64bece8b68ccaaeeae66c2991de581b",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6uNQ2C",
    "number": 36219,
    "patch_url": "https://github.com/neovim/neovim/pull/36219.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
            "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
            "followers_url": "https://api.github.com/users/ribru17/followers",
            "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
            "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ribru17",
            "id": 55766287,
            "login": "ribru17",
            "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
            "organizations_url": "https://api.github.com/users/ribru17/orgs",
            "received_events_url": "https://api.github.com/users/ribru17/received_events",
            "repos_url": "https://api.github.com/users/ribru17/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ribru17",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
            "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
            "followers_url": "https://api.github.com/users/justinmk/followers",
            "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
            "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/justinmk",
            "id": 1359421,
            "login": "justinmk",
            "node_id": "MDQ6VXNlcjEzNTk0MjE=",
            "organizations_url": "https://api.github.com/users/justinmk/orgs",
            "received_events_url": "https://api.github.com/users/justinmk/received_events",
            "repos_url": "https://api.github.com/users/justinmk/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/justinmk",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/36219/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/6353a3fed03d4861e3e75e56a19c75f940472da2",
    "title": "feat(lsp): add `vim.lsp.inlay_hint.apply_action()`",
    "updated_at": "2025-12-15T16:34:02Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/36219",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/30951234?v=4",
        "events_url": "https://api.github.com/users/Davidyz/events{/privacy}",
        "followers_url": "https://api.github.com/users/Davidyz/followers",
        "following_url": "https://api.github.com/users/Davidyz/following{/other_user}",
        "gists_url": "https://api.github.com/users/Davidyz/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/Davidyz",
        "id": 30951234,
        "login": "Davidyz",
        "node_id": "MDQ6VXNlcjMwOTUxMjM0",
        "organizations_url": "https://api.github.com/users/Davidyz/orgs",
        "received_events_url": "https://api.github.com/users/Davidyz/received_events",
        "repos_url": "https://api.github.com/users/Davidyz/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/Davidyz/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/Davidyz/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/Davidyz",
        "user_view_type": "public"
    }
}