{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34223/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34223/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/34223"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34223"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34223/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/1b6b4655143e810d97d7e3a33545bd1ce24e210f"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6134,
            "forks_count": 6134,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1965,
            "open_issues_count": 1965,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-06-17T02:49:56Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 328511,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 90375,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-06-17T02:36:18Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 90375,
            "watchers_count": 90375,
            "web_commit_signoff_required": false
        },
        "sha": "dc05598d0201d156e8ac435f156751e7f6b224ae",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "# Problem\r\n\r\nCurrently if a user wants to download any plugins they need to hunt down for a third-party plugin, witch can be daunting.\r\n\r\n# Solution\r\n\r\nProvide a minimal (419LOC) package manager that offers a simple API to download plugins via remote and load them using the default `:h packages` feature.\r\n\r\n\r\n# Other information\r\n\r\nThis plugin is hard fork of [paq.nvim](https://github.com/savq/paq-nvim) and I've been using it for some months now and it is pretty stable, even though I have a very simple use case.\r\n\r\nEvery package is downloaded in in the `opt` directory and packadded by default when you register a plugin with `register()`. A plugin can be disable from been packadded by adding a `opt` key locally to the package spec or globally via `config`.\r\n\r\n\r\nThis is a slightly modified version of what I have in [my repo](https://github.com/saccarosium/pack.nvim)\r\n\r\nThe documentation should be ready to go and easly hookable into your existing pipeline since I've used the same script to generate it on my repo.\r\n\r\n<details><summary>Usage</summary>\r\n<p>\r\n\r\n```lua\r\nvim.pack.register({\r\n  \"tpope/fugitive\",\r\n  { dracula/vim, as = \"dracula\" },\r\n})\r\n```\r\n\r\n- `PackInstall` to install all new plugins\r\n- `PackUpdate` to update all plugins\r\n- `PackClean` to remove unused plugins\r\n- `PackSync` to do all the above\r\n\r\n</p>\r\n</details> \r\n\r\n<details><summary>API</summary>\r\n<p>\r\n\r\n- `pack.register`: register plugins to manage\r\n- `pack.query`: query managed plugins\r\n- `PackDone<Action>`: autocmds triggered by actions\r\n\r\n</p>\r\n</details> ",
    "closed_at": "2025-06-12T11:18:07Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113564487"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113564487"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "What is pack.nvim? And why is there `start` directory here?",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T09:22:25Z",
            "diff_hunk": "@@ -0,0 +1,635 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+  local stat = assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = assert(uv.fs_read(file, stat.size, 0), err_msg:format('read'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+  return data\n+end\n+\n+--- @return vim._pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' and name ~= 'pack.nvim' then\n+      local dir = vim.fs.joinpath(Path.packs, name)\n+      local pkg = Packages[name]\n+      if not pkg or pkg.dir ~= dir then\n+        table.insert(unlisted, { name = name, dir = dir })\n+      end\n+    end\n+  end\n+  return unlisted\n+end\n+\n+--- @param dir string\n+--- @return string\n+local function get_git_hash(dir)\n+  local first_line = function(path)\n+    local data = file_read(path)\n+    return vim.split(data, '\\n')[1]\n+  end\n+  local head_ref = first_line(vim.fs.joinpath(dir, '.git', 'HEAD'))\n+  return head_ref and first_line(vim.fs.joinpath(dir, '.git', head_ref:sub(6, -1)))\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param prev_hash string\n+--- @param cur_hash string\n+local function log_update_changes(pkg, prev_hash, cur_hash)\n+  vim.system(\n+    { 'git', 'log', '--pretty=format:* %s', ('%s..%s'):format(prev_hash, cur_hash) },\n+    { cwd = pkg.dir, text = true },\n+    function(obj)\n+      if obj.code ~= 0 then\n+        local msg = ('\\nFailed to execute git log into %q (code %d):\\n%s\\n'):format(\n+          pkg.dir,\n+          obj.code,\n+          obj.stderr\n+        )\n+        file_write(Path.log, 'a+', msg)\n+        return\n+      end\n+      local output = ('\\n%s updated:\\n%s\\n'):format(pkg.name, obj.stdout)\n+      file_write(Path.log, 'a+', output)\n+    end\n+  )\n+end\n+\n+--- @param name string\n+--- @param msg_op Messages\n+--- @param result string\n+--- @param n integer?\n+--- @param total integer?\n+local function report(name, msg_op, result, n, total)\n+  local count = n and (' [%d/%d]'):format(n, total) or ''\n+  vim.notify(\n+    ('Pack:%s %s %s'):format(count, msg_op[result], name),\n+    result == 'err' and vim.log.levels.ERROR or vim.log.levels.INFO\n+  )\n+end\n+\n+--- Object to track result of operations (installs, updates, etc.)\n+--- @param total integer\n+--- @param callback function\n+--- @return function\n+local function new_counter(total, callback)\n+  local c = { ok = 0, err = 0, nop = 0 }\n+  return vim.schedule_wrap(function(name, msg_op, result)\n+    if c.ok + c.err + c.nop < total then\n+      c[result] = c[result] + 1\n+      if result ~= 'nop' then\n+        report(name, msg_op, result, c.ok + c.nop, total)\n+      end\n+    end\n+\n+    if c.ok + c.err + c.nop == total then\n+      callback(c.ok, c.err, c.nop)\n+    end\n+  end)\n+end\n+\n+local function lock_write()\n+  -- remove run key since can have a function in it, and\n+  -- json.encode doesn't support functions\n+  local pkgs = vim.deepcopy(Packages)\n+  for p, _ in pairs(pkgs) do\n+    pkgs[p].build = nil\n+  end\n+  local ok, result = pcall(vim.json.encode, pkgs)\n+  if not ok then\n+    error(result)\n+  end\n+  -- Ignore if fail\n+  pcall(file_write, Path.lock, 'w', result)\n+  Lock = Packages\n+end\n+\n+local function lock_load()\n+  local exists, data = pcall(file_read, Path.lock)\n+  if exists then\n+    local ok, result = pcall(vim.json.decode, data)\n+    if ok then\n+      Lock = not vim.tbl_isempty(result) and result or Packages\n+      -- Repopulate 'build' key so 'vim.deep_equal' works\n+      for name, pkg in\n+        pairs(result --[[@as table<string, vim._pack.PackageSpec>]])\n+      do\n+        pkg.build = Packages[name] and Packages[name].build or nil\n+      end\n+    end\n+  else\n+    lock_write()\n+    Lock = Packages\n+  end\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function clone(pkg, counter)\n+  local args = vim.list_extend({ 'git', 'clone', pkg.url }, Config.clone_args)\n+  if pkg.branch then\n+    vim.list_extend(args, { '-b', pkg.branch })\n+  end\n+  table.insert(args, pkg.dir)\n+  vim.system(args, {}, function(obj)\n+    local ok = obj.code == 0\n+    if ok then\n+      pkg.status = M.status.CLONED\n+      if pkg.build then\n+        table.insert(BuildQueue, pkg)\n+      end\n+    end\n+    counter(pkg.name, Messages.install, ok and 'ok' or 'err')\n+  end)\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function pull(pkg, counter)\n+  local prev_hash = Lock[pkg.name] and Lock[pkg.name].hash or pkg.hash\n+  vim.system(vim.list_extend({ 'git', 'pull' }, Config.pull_args), { cwd = pkg.dir }, function(obj)\n+    if obj.code ~= 0 then\n+      counter(pkg.name, Messages.update, 'err')\n+      local errmsg = ('\\nFailed to update %s:\\n%s\\n'):format(pkg.name, obj.stderr)\n+      file_write(Path.log, 'a+', errmsg)\n+      return\n+    end\n+    local cur_hash = get_git_hash(pkg.dir)\n+    -- It can happen that the user has deleted manually a directory.\n+    -- Thus the pkg.hash is left blank and we need to update it.\n+    if cur_hash == prev_hash or prev_hash == '' then\n+      pkg.hash = cur_hash\n+      counter(pkg.name, Messages.update, 'nop')\n+      return\n+    end\n+    log_update_changes(pkg, prev_hash or '', cur_hash)\n+    pkg.status, pkg.hash = M.status.UPDATED, cur_hash\n+    counter(pkg.name, Messages.update, 'ok')\n+    if pkg.build then\n+      table.insert(BuildQueue, pkg)\n+    end\n+  end)\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function clone_or_pull(pkg, counter)\n+  if Filter.to_update(pkg) then\n+    pull(pkg, counter)\n+  elseif Filter.to_install(pkg) then\n+    clone(pkg, counter)\n+  end\n+end\n+\n+local function process_build_queue()\n+  local failed = {}\n+\n+  local after = function(pkg, ok)\n+    report(pkg.name, Messages.build, ok)\n+    if not ok then\n+      table.insert(failed, pkg)\n+    end\n+  end\n+\n+  for _, pkg in ipairs(BuildQueue) do\n+    local t = type(pkg.build)\n+    if t == 'function' then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' and vim.startswith(pkg.build, ':') then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(vim.cmd, pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' then\n+      local args = vim.split(pkg.build, '%s', { trimempty = true })\n+      vim.system(\n+        args,\n+        { cwd = pkg.dir },\n+        vim.schedule_wrap(function(obj)\n+          after(pkg, obj.code == 0)\n+        end)\n+      )\n+    end\n+  end\n+\n+  BuildQueue = failed\n+end\n+\n+--- @param pkg vim._pack.Package\n+local function reclone(pkg)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  if ok then\n+    clone(pkg, function() end)\n+  end\n+end\n+\n+--- @param conflict pack.Conflict\n+local function resolve(conflict)\n+  reclone(conflict.curr)\n+end\n+\n+--- @param pkg string|vim._pack.PackageSpec\n+--- @return vim._pack.Package\n+local function register(pkg)\n+  if type(pkg) == 'string' then\n+    pkg = { pkg }\n+  end\n+\n+  local url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\n+    or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\n+\n+  local name = pkg.as or url:gsub('%.git$', ''):match('/([%w-_.]+)$') -- Infer name from `url`\n+  if not name then\n+    error('Failed to parse ' .. vim.inspect(pkg))\n+  end\n+\n+  local dir = vim.fs.joinpath(Path.packs, name)\n+  local ok, hash = pcall(get_git_hash, dir)\n+  hash = ok and hash or ''\n+\n+  return {\n+    branch = pkg.branch,\n+    build = pkg.build,\n+    dir = dir,\n+    hash = hash,\n+    name = name,\n+    opt = pkg.opt,\n+    pin = pkg.pin,\n+    status = uv.fs_stat(dir) and M.status.INSTALLED or M.status.TO_INSTALL,\n+    url = url,\n+  }\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function remove(pkg, counter)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  counter(pkg.name, Messages.remove, ok and 'ok' or 'err')\n+  if not ok then\n+    return\n+  end\n+  pkg.status = M.status.REMOVED\n+  Packages[pkg.name] = pkg\n+end\n+\n+--- @nodoc\n+--- @class pack.Conflict\n+--- @field prev vim._pack.Package\n+--- @field curr vim._pack.Package\n+---\n+--- @return pack.Conflict[]\n+local function calculate_conflicts()\n+  local conflicts = {}\n+  for name, lock in pairs(Lock) do\n+    local pkg = Packages[name]\n+    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= lock.url) then\n+      table.insert(conflicts, { prev = lock, curr = pkg })\n+    end\n+  end\n+  return conflicts\n+end\n+\n+--- @nodoc\n+--- @alias Operation\n+--- | '\"install\"'\n+--- | '\"update\"'\n+--- | '\"remove\"'\n+--- | '\"sync\"'\n+---\n+--- Boilerplate around operations (autocmds, counter initialization, etc.)\n+--- @param op Operation\n+--- @param fn function\n+--- @param pkgs vim._pack.Package[]\n+local function exe_op(op, fn, pkgs)\n+  if vim.tbl_isempty(pkgs) then\n+    vim.notify('Pack: Nothing to ' .. op)\n+\n+    vim.api.nvim_exec_autocmds('User', {\n+      pattern = 'PackDone' .. op:gsub('^%l', string.upper),\n+    })\n+    return\n+  end\n+\n+  local function after(ok, err, nop)\n+    local summary = 'Pack: %s complete. %d ok; %d errors;' .. (nop > 0 and ' %d no-ops' or '')\n+    vim.notify(string.format(summary, op, ok, err, nop))\n+    vim.cmd('silent! helptags ALL')\n+\n+    if #BuildQueue ~= 0 then\n+      process_build_queue()\n+    end\n+\n+    vim.api.nvim_exec_autocmds('User', { pattern = 'PackDone' .. op:gsub('^%l', string.upper) })\n+\n+    -- This makes the logfile reload if there were changes while the job was running\n+    vim.cmd('silent! checktime ' .. vim.fn.fnameescape(Path.log))\n+\n+    lock_write()\n+  end\n+\n+  local counter = new_counter(#pkgs, after)\n+\n+  for _, pkg in ipairs(pkgs) do\n+    fn(pkg, counter)\n+  end\n+end\n+\n+---@param opts vim._pack.Opts? When omitted or `nil`, retrieve the current\n+---       configuration. Otherwise, a configuration table (see |pack.Opts|).\n+---@return vim._pack.Opts? : Current pack config if {opts} is omitted.\n+function M.config(opts)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  if not opts then\n+    return vim.deepcopy(Config, true)\n+  end\n+\n+  vim.iter(opts):each(function(k, v)\n+    Config[k] = v\n+  end)\n+end\n+\n+--- Register one or more plugins to be installed (see [pack.PackageSpec]())\n+---\n+--- Example:\n+---\n+--- ```lua\n+--- -- pack will update by itself\n+--- pack.register({\n+---   \"neovim/nvim-lspconfig\",\n+---   { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate' },\n+---   -- don't load this plugin when registering. The user needs to call `packadd`.\n+---   { 'tpope/vim-fugitive', load = false },\n+--- })\n+--- ```\n+---\n+--- @param pkgs vim._pack.PackageSpec[]\n+function M.register(pkgs)\n+  vim.validate('pkgs', pkgs, { 'table' }, true)\n+\n+  -- Register plugins and load them\n+  local errors = {}\n+  Packages = vim\n+    .iter(pkgs)\n+    :map(function(spec)\n+      local ok, pkg = pcall(register, spec)\n+      if not ok then\n+        table.insert(errors, pkg)\n+      else\n+        return pkg\n+      end\n+    end)\n+    :fold(\n+      {},\n+      --- @param acc table<string, vim._pack.Package>\n+      --- @param pkg vim._pack.Package\n+      function(acc, pkg)\n+        acc[pkg.name] = pkg\n+        if not pkg.opt then\n+          pcall(vim.cmd.packadd, pkg.name)\n+          -- Remove opt from the schema\n+          ---@diagnostic disable-next-line: inject-field, no-unknown\n+          pkg.opt = nil\n+        end\n+        return acc\n+      end\n+    )\n+\n+  -- Resolve conflict between user configuration and lockfile\n+  vim.iter(calculate_conflicts()):each(resolve)\n+\n+  vim.iter(errors):each(function(error)\n+    file_write(Path.log, 'a+', '\\n' .. error)\n+  end)\n+\n+  if #errors > 0 then\n+    vim.notify(\n+      ('Pack: %d packages failed to be parsed. Check :PackLogOpen to learn more'):format(#errors),\n+      vim.log.levels.ERROR\n+    )\n+  end\n+end\n+\n+--- Installs not already installed registered plugins\n+---\n+--- Can also be invoked with `PackInstall`. [PackInstall]()\n+function M.install()\n+  exe_op('install', clone, vim.tbl_filter(Filter.to_install, Packages))\n+end\n+\n+--- Updates all registered plugins\n+---\n+--- Can also be invoked with `PackUpdate`. [PackUpdate]()\n+function M.update()\n+  local pkgs = vim.tbl_filter(Filter.to_update, Packages)\n+  -- Add pack.nvim to pkgs to update\n+  local path = vim.fs.joinpath(vim.fs.dirname(Path.packs), 'start', 'pack.nvim')\n+  table.insert(pkgs, { name = 'pack.nvim', dir = path, hash = get_git_hash(path) })",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113564487",
            "id": 2113564487,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59-m9H",
            "original_commit_id": "66471ea3dab3f165914c10fdb496a4e58617f0ef",
            "original_line": 539,
            "original_position": 539,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2877652920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113564487/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T10:00:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113564487",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113629648"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113629648"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Was a hack to make the package manager to auto update but if this is in core it isn't necessary",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T10:05:00Z",
            "diff_hunk": "@@ -0,0 +1,635 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+  local stat = assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = assert(uv.fs_read(file, stat.size, 0), err_msg:format('read'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+  return data\n+end\n+\n+--- @return vim._pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' and name ~= 'pack.nvim' then\n+      local dir = vim.fs.joinpath(Path.packs, name)\n+      local pkg = Packages[name]\n+      if not pkg or pkg.dir ~= dir then\n+        table.insert(unlisted, { name = name, dir = dir })\n+      end\n+    end\n+  end\n+  return unlisted\n+end\n+\n+--- @param dir string\n+--- @return string\n+local function get_git_hash(dir)\n+  local first_line = function(path)\n+    local data = file_read(path)\n+    return vim.split(data, '\\n')[1]\n+  end\n+  local head_ref = first_line(vim.fs.joinpath(dir, '.git', 'HEAD'))\n+  return head_ref and first_line(vim.fs.joinpath(dir, '.git', head_ref:sub(6, -1)))\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param prev_hash string\n+--- @param cur_hash string\n+local function log_update_changes(pkg, prev_hash, cur_hash)\n+  vim.system(\n+    { 'git', 'log', '--pretty=format:* %s', ('%s..%s'):format(prev_hash, cur_hash) },\n+    { cwd = pkg.dir, text = true },\n+    function(obj)\n+      if obj.code ~= 0 then\n+        local msg = ('\\nFailed to execute git log into %q (code %d):\\n%s\\n'):format(\n+          pkg.dir,\n+          obj.code,\n+          obj.stderr\n+        )\n+        file_write(Path.log, 'a+', msg)\n+        return\n+      end\n+      local output = ('\\n%s updated:\\n%s\\n'):format(pkg.name, obj.stdout)\n+      file_write(Path.log, 'a+', output)\n+    end\n+  )\n+end\n+\n+--- @param name string\n+--- @param msg_op Messages\n+--- @param result string\n+--- @param n integer?\n+--- @param total integer?\n+local function report(name, msg_op, result, n, total)\n+  local count = n and (' [%d/%d]'):format(n, total) or ''\n+  vim.notify(\n+    ('Pack:%s %s %s'):format(count, msg_op[result], name),\n+    result == 'err' and vim.log.levels.ERROR or vim.log.levels.INFO\n+  )\n+end\n+\n+--- Object to track result of operations (installs, updates, etc.)\n+--- @param total integer\n+--- @param callback function\n+--- @return function\n+local function new_counter(total, callback)\n+  local c = { ok = 0, err = 0, nop = 0 }\n+  return vim.schedule_wrap(function(name, msg_op, result)\n+    if c.ok + c.err + c.nop < total then\n+      c[result] = c[result] + 1\n+      if result ~= 'nop' then\n+        report(name, msg_op, result, c.ok + c.nop, total)\n+      end\n+    end\n+\n+    if c.ok + c.err + c.nop == total then\n+      callback(c.ok, c.err, c.nop)\n+    end\n+  end)\n+end\n+\n+local function lock_write()\n+  -- remove run key since can have a function in it, and\n+  -- json.encode doesn't support functions\n+  local pkgs = vim.deepcopy(Packages)\n+  for p, _ in pairs(pkgs) do\n+    pkgs[p].build = nil\n+  end\n+  local ok, result = pcall(vim.json.encode, pkgs)\n+  if not ok then\n+    error(result)\n+  end\n+  -- Ignore if fail\n+  pcall(file_write, Path.lock, 'w', result)\n+  Lock = Packages\n+end\n+\n+local function lock_load()\n+  local exists, data = pcall(file_read, Path.lock)\n+  if exists then\n+    local ok, result = pcall(vim.json.decode, data)\n+    if ok then\n+      Lock = not vim.tbl_isempty(result) and result or Packages\n+      -- Repopulate 'build' key so 'vim.deep_equal' works\n+      for name, pkg in\n+        pairs(result --[[@as table<string, vim._pack.PackageSpec>]])\n+      do\n+        pkg.build = Packages[name] and Packages[name].build or nil\n+      end\n+    end\n+  else\n+    lock_write()\n+    Lock = Packages\n+  end\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function clone(pkg, counter)\n+  local args = vim.list_extend({ 'git', 'clone', pkg.url }, Config.clone_args)\n+  if pkg.branch then\n+    vim.list_extend(args, { '-b', pkg.branch })\n+  end\n+  table.insert(args, pkg.dir)\n+  vim.system(args, {}, function(obj)\n+    local ok = obj.code == 0\n+    if ok then\n+      pkg.status = M.status.CLONED\n+      if pkg.build then\n+        table.insert(BuildQueue, pkg)\n+      end\n+    end\n+    counter(pkg.name, Messages.install, ok and 'ok' or 'err')\n+  end)\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function pull(pkg, counter)\n+  local prev_hash = Lock[pkg.name] and Lock[pkg.name].hash or pkg.hash\n+  vim.system(vim.list_extend({ 'git', 'pull' }, Config.pull_args), { cwd = pkg.dir }, function(obj)\n+    if obj.code ~= 0 then\n+      counter(pkg.name, Messages.update, 'err')\n+      local errmsg = ('\\nFailed to update %s:\\n%s\\n'):format(pkg.name, obj.stderr)\n+      file_write(Path.log, 'a+', errmsg)\n+      return\n+    end\n+    local cur_hash = get_git_hash(pkg.dir)\n+    -- It can happen that the user has deleted manually a directory.\n+    -- Thus the pkg.hash is left blank and we need to update it.\n+    if cur_hash == prev_hash or prev_hash == '' then\n+      pkg.hash = cur_hash\n+      counter(pkg.name, Messages.update, 'nop')\n+      return\n+    end\n+    log_update_changes(pkg, prev_hash or '', cur_hash)\n+    pkg.status, pkg.hash = M.status.UPDATED, cur_hash\n+    counter(pkg.name, Messages.update, 'ok')\n+    if pkg.build then\n+      table.insert(BuildQueue, pkg)\n+    end\n+  end)\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function clone_or_pull(pkg, counter)\n+  if Filter.to_update(pkg) then\n+    pull(pkg, counter)\n+  elseif Filter.to_install(pkg) then\n+    clone(pkg, counter)\n+  end\n+end\n+\n+local function process_build_queue()\n+  local failed = {}\n+\n+  local after = function(pkg, ok)\n+    report(pkg.name, Messages.build, ok)\n+    if not ok then\n+      table.insert(failed, pkg)\n+    end\n+  end\n+\n+  for _, pkg in ipairs(BuildQueue) do\n+    local t = type(pkg.build)\n+    if t == 'function' then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' and vim.startswith(pkg.build, ':') then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(vim.cmd, pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' then\n+      local args = vim.split(pkg.build, '%s', { trimempty = true })\n+      vim.system(\n+        args,\n+        { cwd = pkg.dir },\n+        vim.schedule_wrap(function(obj)\n+          after(pkg, obj.code == 0)\n+        end)\n+      )\n+    end\n+  end\n+\n+  BuildQueue = failed\n+end\n+\n+--- @param pkg vim._pack.Package\n+local function reclone(pkg)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  if ok then\n+    clone(pkg, function() end)\n+  end\n+end\n+\n+--- @param conflict pack.Conflict\n+local function resolve(conflict)\n+  reclone(conflict.curr)\n+end\n+\n+--- @param pkg string|vim._pack.PackageSpec\n+--- @return vim._pack.Package\n+local function register(pkg)\n+  if type(pkg) == 'string' then\n+    pkg = { pkg }\n+  end\n+\n+  local url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\n+    or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\n+\n+  local name = pkg.as or url:gsub('%.git$', ''):match('/([%w-_.]+)$') -- Infer name from `url`\n+  if not name then\n+    error('Failed to parse ' .. vim.inspect(pkg))\n+  end\n+\n+  local dir = vim.fs.joinpath(Path.packs, name)\n+  local ok, hash = pcall(get_git_hash, dir)\n+  hash = ok and hash or ''\n+\n+  return {\n+    branch = pkg.branch,\n+    build = pkg.build,\n+    dir = dir,\n+    hash = hash,\n+    name = name,\n+    opt = pkg.opt,\n+    pin = pkg.pin,\n+    status = uv.fs_stat(dir) and M.status.INSTALLED or M.status.TO_INSTALL,\n+    url = url,\n+  }\n+end\n+\n+--- @param pkg vim._pack.Package\n+--- @param counter function\n+local function remove(pkg, counter)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  counter(pkg.name, Messages.remove, ok and 'ok' or 'err')\n+  if not ok then\n+    return\n+  end\n+  pkg.status = M.status.REMOVED\n+  Packages[pkg.name] = pkg\n+end\n+\n+--- @nodoc\n+--- @class pack.Conflict\n+--- @field prev vim._pack.Package\n+--- @field curr vim._pack.Package\n+---\n+--- @return pack.Conflict[]\n+local function calculate_conflicts()\n+  local conflicts = {}\n+  for name, lock in pairs(Lock) do\n+    local pkg = Packages[name]\n+    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= lock.url) then\n+      table.insert(conflicts, { prev = lock, curr = pkg })\n+    end\n+  end\n+  return conflicts\n+end\n+\n+--- @nodoc\n+--- @alias Operation\n+--- | '\"install\"'\n+--- | '\"update\"'\n+--- | '\"remove\"'\n+--- | '\"sync\"'\n+---\n+--- Boilerplate around operations (autocmds, counter initialization, etc.)\n+--- @param op Operation\n+--- @param fn function\n+--- @param pkgs vim._pack.Package[]\n+local function exe_op(op, fn, pkgs)\n+  if vim.tbl_isempty(pkgs) then\n+    vim.notify('Pack: Nothing to ' .. op)\n+\n+    vim.api.nvim_exec_autocmds('User', {\n+      pattern = 'PackDone' .. op:gsub('^%l', string.upper),\n+    })\n+    return\n+  end\n+\n+  local function after(ok, err, nop)\n+    local summary = 'Pack: %s complete. %d ok; %d errors;' .. (nop > 0 and ' %d no-ops' or '')\n+    vim.notify(string.format(summary, op, ok, err, nop))\n+    vim.cmd('silent! helptags ALL')\n+\n+    if #BuildQueue ~= 0 then\n+      process_build_queue()\n+    end\n+\n+    vim.api.nvim_exec_autocmds('User', { pattern = 'PackDone' .. op:gsub('^%l', string.upper) })\n+\n+    -- This makes the logfile reload if there were changes while the job was running\n+    vim.cmd('silent! checktime ' .. vim.fn.fnameescape(Path.log))\n+\n+    lock_write()\n+  end\n+\n+  local counter = new_counter(#pkgs, after)\n+\n+  for _, pkg in ipairs(pkgs) do\n+    fn(pkg, counter)\n+  end\n+end\n+\n+---@param opts vim._pack.Opts? When omitted or `nil`, retrieve the current\n+---       configuration. Otherwise, a configuration table (see |pack.Opts|).\n+---@return vim._pack.Opts? : Current pack config if {opts} is omitted.\n+function M.config(opts)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  if not opts then\n+    return vim.deepcopy(Config, true)\n+  end\n+\n+  vim.iter(opts):each(function(k, v)\n+    Config[k] = v\n+  end)\n+end\n+\n+--- Register one or more plugins to be installed (see [pack.PackageSpec]())\n+---\n+--- Example:\n+---\n+--- ```lua\n+--- -- pack will update by itself\n+--- pack.register({\n+---   \"neovim/nvim-lspconfig\",\n+---   { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate' },\n+---   -- don't load this plugin when registering. The user needs to call `packadd`.\n+---   { 'tpope/vim-fugitive', load = false },\n+--- })\n+--- ```\n+---\n+--- @param pkgs vim._pack.PackageSpec[]\n+function M.register(pkgs)\n+  vim.validate('pkgs', pkgs, { 'table' }, true)\n+\n+  -- Register plugins and load them\n+  local errors = {}\n+  Packages = vim\n+    .iter(pkgs)\n+    :map(function(spec)\n+      local ok, pkg = pcall(register, spec)\n+      if not ok then\n+        table.insert(errors, pkg)\n+      else\n+        return pkg\n+      end\n+    end)\n+    :fold(\n+      {},\n+      --- @param acc table<string, vim._pack.Package>\n+      --- @param pkg vim._pack.Package\n+      function(acc, pkg)\n+        acc[pkg.name] = pkg\n+        if not pkg.opt then\n+          pcall(vim.cmd.packadd, pkg.name)\n+          -- Remove opt from the schema\n+          ---@diagnostic disable-next-line: inject-field, no-unknown\n+          pkg.opt = nil\n+        end\n+        return acc\n+      end\n+    )\n+\n+  -- Resolve conflict between user configuration and lockfile\n+  vim.iter(calculate_conflicts()):each(resolve)\n+\n+  vim.iter(errors):each(function(error)\n+    file_write(Path.log, 'a+', '\\n' .. error)\n+  end)\n+\n+  if #errors > 0 then\n+    vim.notify(\n+      ('Pack: %d packages failed to be parsed. Check :PackLogOpen to learn more'):format(#errors),\n+      vim.log.levels.ERROR\n+    )\n+  end\n+end\n+\n+--- Installs not already installed registered plugins\n+---\n+--- Can also be invoked with `PackInstall`. [PackInstall]()\n+function M.install()\n+  exe_op('install', clone, vim.tbl_filter(Filter.to_install, Packages))\n+end\n+\n+--- Updates all registered plugins\n+---\n+--- Can also be invoked with `PackUpdate`. [PackUpdate]()\n+function M.update()\n+  local pkgs = vim.tbl_filter(Filter.to_update, Packages)\n+  -- Add pack.nvim to pkgs to update\n+  local path = vim.fs.joinpath(vim.fs.dirname(Path.packs), 'start', 'pack.nvim')\n+  table.insert(pkgs, { name = 'pack.nvim', dir = path, hash = get_git_hash(path) })",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113629648",
            "id": 2113629648,
            "in_reply_to_id": 2113564487,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59-23Q",
            "original_commit_id": "66471ea3dab3f165914c10fdb496a4e58617f0ef",
            "original_line": 539,
            "original_position": 539,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2877753165,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113629648/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T10:05:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113629648",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113732312"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113732312"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  assert(uv.fs_write(file, data) == #data, err_msg:format('write'))\r\n```\r\n\r\nUnlikely (especially when writing to disk), but `fs_write` is allowed to succeed with a partial write.\r\n\r\nLooping until everything's written or using something higher-level like the `:h lua-lib-io` stuff or a `uv_pipe_t` (though non-blocking) may be more robust, but this is probably fine.\r\n\r\n(Also a nit, but this stuff leaves the `fd` open on error)",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T11:10:41Z",
            "diff_hunk": "@@ -0,0 +1,631 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113732312",
            "id": 2113732312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_P7Y",
            "original_commit_id": "247384d99d2ca5dd7b10e84214ad752dd9058282",
            "original_line": 105,
            "original_position": 105,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2877917704,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113732312/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T11:24:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113732312",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113733181"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113733181"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  local data = uv.fs_read(file, stat.size, 0)\r\n  assert(data and #data == stat.size, err_msg:format('read'))\r\n```\r\n\r\nSimilar for `fs_read`.",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T11:11:17Z",
            "diff_hunk": "@@ -0,0 +1,631 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+  local stat = assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = assert(uv.fs_read(file, stat.size, 0), err_msg:format('read'))",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113733181",
            "id": 2113733181,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_QI9",
            "original_commit_id": "247384d99d2ca5dd7b10e84214ad752dd9058282",
            "original_line": 115,
            "original_position": 115,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2877917704,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113733181/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T11:16:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113733181",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113791579"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113791579"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    if type == 'directory' then\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T11:51:19Z",
            "diff_hunk": "@@ -0,0 +1,631 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+  local stat = assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = assert(uv.fs_read(file, stat.size, 0), err_msg:format('read'))\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+  return data\n+end\n+\n+--- @return vim._pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' and name ~= 'pack.nvim' then",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113791579",
            "id": 2113791579,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_eZb",
            "original_commit_id": "247384d99d2ca5dd7b10e84214ad752dd9058282",
            "original_line": 144,
            "original_position": 124,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878025090,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113791579/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T11:51:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113791579",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113824554"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113824554"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I should have addressed it with latest push",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T12:15:07Z",
            "diff_hunk": "@@ -0,0 +1,631 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+  assert(uv.fs_write(file, data), err_msg:format('write'))",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113824554",
            "id": 2113824554,
            "in_reply_to_id": 2113732312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_mcq",
            "original_commit_id": "247384d99d2ca5dd7b10e84214ad752dd9058282",
            "original_line": 105,
            "original_position": 105,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878075213,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113824554/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T12:15:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113824554",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113856508"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113856508"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  local written = uv.fs_write(file, data)\r\n  if written ~= #data then\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T12:36:35Z",
            "diff_hunk": "@@ -0,0 +1,651 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  local byte = uv.fs_write(file, data) == #data\n+  if not byte == #data then",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113856508",
            "id": 2113856508,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_uP8",
            "original_commit_id": "64bdb00ce219e48baa91db705885708b67798b40",
            "original_line": 107,
            "original_position": 107,
            "original_start_line": 106,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878127430,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113856508/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-29T12:42:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113856508",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113860483"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113860483"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  local data = uv.fs_read(file, stat.size, 0)\r\n  safe_assert(data and #data == stat.size, err_msg:format('read'))\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T12:39:05Z",
            "diff_hunk": "@@ -0,0 +1,651 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  local byte = uv.fs_write(file, data) == #data\n+  if not byte == #data then\n+    assert(uv.fs_close(file), err_msg:format('close'))\n+    error(err_msg:format('write'))\n+  end\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+\n+  ---@generic T\n+  ---@param cond? T\n+  ---@param message? any\n+  ---@return T\n+  ---@return any ...\n+  local safe_assert = function(cond, message)\n+    if not cond then\n+      assert(uv.fs_close(file), err_msg:format('close'))\n+    end\n+    return assert(cond, message)\n+  end\n+\n+  local stat = safe_assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = safe_assert(uv.fs_read(file, stat.size, 0), err_msg:format('read'))",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113860483",
            "id": 2113860483,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_vOD",
            "original_commit_id": "64bdb00ce219e48baa91db705885708b67798b40",
            "original_line": 134,
            "original_position": 134,
            "original_start_line": null,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878127430,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113860483/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T12:42:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113860483",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113861850"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113861850"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  if uv.fs_write(file, data) ~= #data then\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T12:39:59Z",
            "diff_hunk": "@@ -0,0 +1,651 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  local byte = uv.fs_write(file, data) == #data\n+  if not byte == #data then",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113861850",
            "id": 2113861850,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_vja",
            "original_commit_id": "64bdb00ce219e48baa91db705885708b67798b40",
            "original_line": 107,
            "original_position": 107,
            "original_start_line": 106,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878137725,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113861850/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-29T12:40:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113861850",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2113866778"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113866778"
                }
            },
            "author_association": "MEMBER",
            "body": "glepnir beat me to it :smile: ",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T12:43:07Z",
            "diff_hunk": "@@ -0,0 +1,651 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim._pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim._pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim._pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim._pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim._pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim._pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim._pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim._pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  local byte = uv.fs_write(file, data) == #data\n+  if not byte == #data then",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2113866778",
            "id": 2113866778,
            "in_reply_to_id": 2113856508,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM59_wwa",
            "original_commit_id": "64bdb00ce219e48baa91db705885708b67798b40",
            "original_line": 107,
            "original_position": 107,
            "original_start_line": 106,
            "path": "runtime/lua/vim/_pack.lua",
            "position": null,
            "pull_request_review_id": 2878145387,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113866778/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-05-29T12:43:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2113866778",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2114119134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114119134"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n    Deletes all plugins installed but not registered in the pack\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T14:41:23Z",
            "diff_hunk": "@@ -2513,6 +2513,104 @@ vim.loader.reset({path})                                  *vim.loader.reset()*\n       • {path}  (`string?`) path to reset\n \n \n+==============================================================================\n+Lua module: vim.pack                                                *vim.pack*\n+\n+*vim.pack.Opts*\n+\n+    Fields: ~\n+      • {url_format}  (`string`, default: `https://github.com/%s.git`) Format\n+                      string used to transform the package name into a git\n+                      url.\n+      • {clone_args}  (`string[]`, default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+                      Flags passed to `git clone` during installation of a\n+                      plugin (see `:Man git-clone(1)` for more)\n+      • {pull_args}   (`string[]`, default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+                      Flags passed to `git pull` during update of a plugin\n+                      (see `:Man git-pull(1)` for more)\n+\n+*vim.pack.Package*\n+\n+    Fields: ~\n+      • {name}    (`string`)\n+      • {dir}     (`string`)\n+      • {status}  (`vim.pack.Status`)\n+      • {hash}    (`string`)\n+      • {url}     (`string`)\n+      • {pin}     (`boolean?`)\n+      • {branch}  (`string?`)\n+      • {build}   (`string?|function?`)\n+\n+*vim.pack.PackageSpec*\n+\n+    Fields: ~\n+      • {[1]}     (`string`)\n+      • {build}   (`string?`)\n+      • {branch}  (`string?`)\n+      • {pin}     (`boolean?`)\n+      • {opt}     (`boolean?`)\n+      • {as}      (`string?`)\n+\n+\n+vim.pack.clean()                                            *vim.pack.clean()*\n+    Deletes all not plugins installed but not registered in the pack",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2114119134",
            "id": 2114119134,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-AuXe",
            "original_commit_id": "ebd2e91d1db7768a9f5b26ef0d7a9a1d2508668e",
            "original_line": 2556,
            "original_position": 44,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2878550362,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114119134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T14:41:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114119134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7074?v=4",
                "events_url": "https://api.github.com/users/wincent/events{/privacy}",
                "followers_url": "https://api.github.com/users/wincent/followers",
                "following_url": "https://api.github.com/users/wincent/following{/other_user}",
                "gists_url": "https://api.github.com/users/wincent/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wincent",
                "id": 7074,
                "login": "wincent",
                "node_id": "MDQ6VXNlcjcwNzQ=",
                "organizations_url": "https://api.github.com/users/wincent/orgs",
                "received_events_url": "https://api.github.com/users/wincent/received_events",
                "repos_url": "https://api.github.com/users/wincent/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wincent/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wincent/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wincent",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2114491848"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114491848"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= pkg.url) then\r\n```\r\n\r\nWhile its other comments were nonsense, the review bot that invaded us was right about this at least.",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T18:08:45Z",
            "diff_hunk": "@@ -0,0 +1,653 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim.pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim.pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim.pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim.pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim.pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim.pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim.pack.Package[]\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim.pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  if uv.fs_write(file, data) ~= #data then\n+    assert(uv.fs_close(file), err_msg:format('close'))\n+    error(err_msg:format('write'))\n+  end\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+\n+  ---@generic T\n+  ---@param cond? T\n+  ---@param message? any\n+  ---@return T\n+  ---@return any ...\n+  local safe_assert = function(cond, message)\n+    if not cond then\n+      assert(uv.fs_close(file), err_msg:format('close'))\n+    end\n+    return assert(cond, message)\n+  end\n+\n+  local stat = safe_assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = uv.fs_read(file, stat.size, 0)\n+  safe_assert(data and #data == stat.size, err_msg:format('read'))\n+  --- @cast data string\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+\n+  return data\n+end\n+\n+--- @return vim.pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' then\n+      local dir = vim.fs.joinpath(Path.packs, name)\n+      local pkg = Packages[name]\n+      if not pkg or pkg.dir ~= dir then\n+        table.insert(unlisted, { name = name, dir = dir })\n+      end\n+    end\n+  end\n+  return unlisted\n+end\n+\n+--- @param dir string\n+--- @return string\n+local function get_git_hash(dir)\n+  local first_line = function(path)\n+    local data = file_read(path)\n+    return vim.split(data, '\\n')[1]\n+  end\n+  local head_ref = first_line(vim.fs.joinpath(dir, '.git', 'HEAD'))\n+  return head_ref and first_line(vim.fs.joinpath(dir, '.git', head_ref:sub(6, -1)))\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param prev_hash string\n+--- @param cur_hash string\n+local function log_update_changes(pkg, prev_hash, cur_hash)\n+  vim.system(\n+    { 'git', 'log', '--pretty=format:* %s', ('%s..%s'):format(prev_hash, cur_hash) },\n+    { cwd = pkg.dir, text = true },\n+    function(obj)\n+      if obj.code ~= 0 then\n+        local msg = ('\\nFailed to execute git log into %q (code %d):\\n%s\\n'):format(\n+          pkg.dir,\n+          obj.code,\n+          obj.stderr\n+        )\n+        file_write(Path.log, 'a+', msg)\n+        return\n+      end\n+      local output = ('\\n%s updated:\\n%s\\n'):format(pkg.name, obj.stdout)\n+      file_write(Path.log, 'a+', output)\n+    end\n+  )\n+end\n+\n+--- @param name string\n+--- @param msg_op Messages\n+--- @param result string\n+--- @param n integer?\n+--- @param total integer?\n+local function report(name, msg_op, result, n, total)\n+  local count = n and (' [%d/%d]'):format(n, total) or ''\n+  vim.notify(\n+    ('Pack:%s %s %s'):format(count, msg_op[result], name),\n+    result == 'err' and vim.log.levels.ERROR or vim.log.levels.INFO\n+  )\n+end\n+\n+--- Object to track result of operations (installs, updates, etc.)\n+--- @param total integer\n+--- @param callback function\n+--- @return function\n+local function new_counter(total, callback)\n+  local c = { ok = 0, err = 0, nop = 0 }\n+  return vim.schedule_wrap(function(name, msg_op, result)\n+    if c.ok + c.err + c.nop < total then\n+      c[result] = c[result] + 1\n+      if result ~= 'nop' then\n+        report(name, msg_op, result, c.ok + c.nop, total)\n+      end\n+    end\n+\n+    if c.ok + c.err + c.nop == total then\n+      callback(c.ok, c.err, c.nop)\n+    end\n+  end)\n+end\n+\n+local function lock_write()\n+  -- remove run key since can have a function in it, and\n+  -- json.encode doesn't support functions\n+  local pkgs = vim.deepcopy(Packages)\n+  for p, _ in pairs(pkgs) do\n+    pkgs[p].build = nil\n+  end\n+  local ok, result = pcall(vim.json.encode, pkgs)\n+  if not ok then\n+    error(result)\n+  end\n+  -- Ignore if fail\n+  pcall(file_write, Path.lock, 'w', result)\n+  Lock = Packages\n+end\n+\n+local function lock_load()\n+  local exists, data = pcall(file_read, Path.lock)\n+  if exists then\n+    local ok, result = pcall(vim.json.decode, data)\n+    if ok then\n+      Lock = not vim.tbl_isempty(result) and result or Packages\n+      -- Repopulate 'build' key so 'vim.deep_equal' works\n+      for name, pkg in\n+        pairs(result --[[@as table<string, vim.pack.PackageSpec>]])\n+      do\n+        pkg.build = Packages[name] and Packages[name].build or nil\n+      end\n+    end\n+  else\n+    lock_write()\n+    Lock = Packages\n+  end\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone(pkg, counter)\n+  local args = vim.list_extend({ 'git', 'clone', pkg.url }, Config.clone_args)\n+  if pkg.branch then\n+    vim.list_extend(args, { '-b', pkg.branch })\n+  end\n+  table.insert(args, pkg.dir)\n+  vim.system(args, {}, function(obj)\n+    local ok = obj.code == 0\n+    if ok then\n+      pkg.status = M.status.CLONED\n+      if pkg.build then\n+        table.insert(BuildQueue, pkg)\n+      end\n+    end\n+    counter(pkg.name, Messages.install, ok and 'ok' or 'err')\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function pull(pkg, counter)\n+  local prev_hash = Lock[pkg.name] and Lock[pkg.name].hash or pkg.hash\n+  vim.system(vim.list_extend({ 'git', 'pull' }, Config.pull_args), { cwd = pkg.dir }, function(obj)\n+    if obj.code ~= 0 then\n+      counter(pkg.name, Messages.update, 'err')\n+      local errmsg = ('\\nFailed to update %s:\\n%s\\n'):format(pkg.name, obj.stderr)\n+      file_write(Path.log, 'a+', errmsg)\n+      return\n+    end\n+    local cur_hash = get_git_hash(pkg.dir)\n+    -- It can happen that the user has deleted manually a directory.\n+    -- Thus the pkg.hash is left blank and we need to update it.\n+    if cur_hash == prev_hash or prev_hash == '' then\n+      pkg.hash = cur_hash\n+      counter(pkg.name, Messages.update, 'nop')\n+      return\n+    end\n+    log_update_changes(pkg, prev_hash or '', cur_hash)\n+    pkg.status, pkg.hash = M.status.UPDATED, cur_hash\n+    counter(pkg.name, Messages.update, 'ok')\n+    if pkg.build then\n+      table.insert(BuildQueue, pkg)\n+    end\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone_or_pull(pkg, counter)\n+  if Filter.to_update(pkg) then\n+    pull(pkg, counter)\n+  elseif Filter.to_install(pkg) then\n+    clone(pkg, counter)\n+  end\n+end\n+\n+local function process_build_queue()\n+  local failed = {}\n+\n+  local after = function(pkg, ok)\n+    report(pkg.name, Messages.build, ok)\n+    if not ok then\n+      table.insert(failed, pkg)\n+    end\n+  end\n+\n+  for _, pkg in ipairs(BuildQueue) do\n+    local t = type(pkg.build)\n+    if t == 'function' then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' and vim.startswith(pkg.build, ':') then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(vim.cmd, pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' then\n+      local args = vim.split(pkg.build, '%s', { trimempty = true })\n+      vim.system(\n+        args,\n+        { cwd = pkg.dir },\n+        vim.schedule_wrap(function(obj)\n+          after(pkg, obj.code == 0)\n+        end)\n+      )\n+    end\n+  end\n+\n+  BuildQueue = failed\n+end\n+\n+--- @param pkg vim.pack.Package\n+local function reclone(pkg)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  if ok then\n+    clone(pkg, function() end)\n+  end\n+end\n+\n+--- @param conflict pack.Conflict\n+local function resolve(conflict)\n+  reclone(conflict.curr)\n+end\n+\n+--- @param pkg string|vim.pack.PackageSpec\n+--- @return vim.pack.Package\n+local function register(pkg)\n+  if type(pkg) == 'string' then\n+    pkg = { pkg }\n+  end\n+\n+  local url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\n+    or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\n+\n+  local name = pkg.as or url:gsub('%.git$', ''):match('/([%w-_.]+)$') -- Infer name from `url`\n+  if not name then\n+    error('Failed to parse ' .. vim.inspect(pkg))\n+  end\n+\n+  local dir = vim.fs.joinpath(Path.packs, name)\n+  local ok, hash = pcall(get_git_hash, dir)\n+  hash = ok and hash or ''\n+\n+  return {\n+    branch = pkg.branch,\n+    build = pkg.build,\n+    dir = dir,\n+    hash = hash,\n+    name = name,\n+    opt = pkg.opt,\n+    pin = pkg.pin,\n+    status = uv.fs_stat(dir) and M.status.INSTALLED or M.status.TO_INSTALL,\n+    url = url,\n+  }\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function remove(pkg, counter)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  counter(pkg.name, Messages.remove, ok and 'ok' or 'err')\n+  if not ok then\n+    return\n+  end\n+  pkg.status = M.status.REMOVED\n+  Packages[pkg.name] = pkg\n+end\n+\n+--- @nodoc\n+--- @class pack.Conflict\n+--- @field prev vim.pack.Package\n+--- @field curr vim.pack.Package\n+---\n+--- @return pack.Conflict[]\n+local function calculate_conflicts()\n+  local conflicts = {}\n+  for name, lock in pairs(Lock) do\n+    local pkg = Packages[name]\n+    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= lock.url) then",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2114491848",
            "id": 2114491848,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-CJXI",
            "original_commit_id": "ebd2e91d1db7768a9f5b26ef0d7a9a1d2508668e",
            "original_line": 419,
            "original_position": 419,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2879180385,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 2,
                "laugh": 0,
                "rocket": 2,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114491848/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T18:12:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114491848",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2114492526"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114492526"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- @type table<string, vim.pack.Package>\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T18:09:15Z",
            "diff_hunk": "@@ -0,0 +1,653 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim.pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim.pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim.pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim.pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim.pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim.pack.Package[]\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type vim.pack.Package[]",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2114492526",
            "id": 2114492526,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-CJhu",
            "original_commit_id": "ebd2e91d1db7768a9f5b26ef0d7a9a1d2508668e",
            "original_line": 42,
            "original_position": 42,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2879180385,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114492526/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T18:12:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114492526",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2114495133"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114495133"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- @type table<string, vim.pack.Package>\r\n```",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-05-29T18:10:54Z",
            "diff_hunk": "@@ -0,0 +1,653 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim.pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim.pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim.pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim.pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim.pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type vim.pack.Package[]",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2114495133",
            "id": 2114495133,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5-CKKd",
            "original_commit_id": "ebd2e91d1db7768a9f5b26ef0d7a9a1d2508668e",
            "original_line": 38,
            "original_position": 38,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2879180385,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114495133/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-05-29T18:12:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2114495133",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2141776729"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141776729"
                }
            },
            "author_association": "NONE",
            "body": "```suggestion\r\n---   { 'tpope/vim-fugitive', opt = true },\r\n```\r\n\r\nIf this comment is correct that `opt = false` means the user needs to call `packadd`, this is backwards and needs to change. `opt` is short for optional, and is the name of the `pack/*/opt` dir on the packpath searched by `packadd`, so a value of `opt = true` (NOT `false`) should go along with being in that folder, and requiring `packadd` to load (which would mean it is being _optionally_ loaded). This is a convention followed by other nvim package managers with an `opt` key as well. See [my longer comment here](https://github.com/neovim/neovim/pull/34223#issuecomment-2965125904)\r\n\r\nIf the comment is the thing that is incorrect (which to be honest I hope to be the case) then I found an incorrect comment and you can ignore the rest of my communication on this matter. But I think the comment is correct unfortunately.",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-06-12T05:57:17Z",
            "diff_hunk": "@@ -0,0 +1,653 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim.pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim.pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim.pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim.pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim.pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type table<string, vim.pack.Package>\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type table<string, vim.pack.Package>\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim.pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  if uv.fs_write(file, data) ~= #data then\n+    assert(uv.fs_close(file), err_msg:format('close'))\n+    error(err_msg:format('write'))\n+  end\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+\n+  ---@generic T\n+  ---@param cond? T\n+  ---@param message? any\n+  ---@return T\n+  ---@return any ...\n+  local safe_assert = function(cond, message)\n+    if not cond then\n+      assert(uv.fs_close(file), err_msg:format('close'))\n+    end\n+    return assert(cond, message)\n+  end\n+\n+  local stat = safe_assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = uv.fs_read(file, stat.size, 0)\n+  safe_assert(data and #data == stat.size, err_msg:format('read'))\n+  --- @cast data string\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+\n+  return data\n+end\n+\n+--- @return vim.pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' then\n+      local dir = vim.fs.joinpath(Path.packs, name)\n+      local pkg = Packages[name]\n+      if not pkg or pkg.dir ~= dir then\n+        table.insert(unlisted, { name = name, dir = dir })\n+      end\n+    end\n+  end\n+  return unlisted\n+end\n+\n+--- @param dir string\n+--- @return string\n+local function get_git_hash(dir)\n+  local first_line = function(path)\n+    local data = file_read(path)\n+    return vim.split(data, '\\n')[1]\n+  end\n+  local head_ref = first_line(vim.fs.joinpath(dir, '.git', 'HEAD'))\n+  return head_ref and first_line(vim.fs.joinpath(dir, '.git', head_ref:sub(6, -1)))\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param prev_hash string\n+--- @param cur_hash string\n+local function log_update_changes(pkg, prev_hash, cur_hash)\n+  vim.system(\n+    { 'git', 'log', '--pretty=format:* %s', ('%s..%s'):format(prev_hash, cur_hash) },\n+    { cwd = pkg.dir, text = true },\n+    function(obj)\n+      if obj.code ~= 0 then\n+        local msg = ('\\nFailed to execute git log into %q (code %d):\\n%s\\n'):format(\n+          pkg.dir,\n+          obj.code,\n+          obj.stderr\n+        )\n+        file_write(Path.log, 'a+', msg)\n+        return\n+      end\n+      local output = ('\\n%s updated:\\n%s\\n'):format(pkg.name, obj.stdout)\n+      file_write(Path.log, 'a+', output)\n+    end\n+  )\n+end\n+\n+--- @param name string\n+--- @param msg_op Messages\n+--- @param result string\n+--- @param n integer?\n+--- @param total integer?\n+local function report(name, msg_op, result, n, total)\n+  local count = n and (' [%d/%d]'):format(n, total) or ''\n+  vim.notify(\n+    ('Pack:%s %s %s'):format(count, msg_op[result], name),\n+    result == 'err' and vim.log.levels.ERROR or vim.log.levels.INFO\n+  )\n+end\n+\n+--- Object to track result of operations (installs, updates, etc.)\n+--- @param total integer\n+--- @param callback function\n+--- @return function\n+local function new_counter(total, callback)\n+  local c = { ok = 0, err = 0, nop = 0 }\n+  return vim.schedule_wrap(function(name, msg_op, result)\n+    if c.ok + c.err + c.nop < total then\n+      c[result] = c[result] + 1\n+      if result ~= 'nop' then\n+        report(name, msg_op, result, c.ok + c.nop, total)\n+      end\n+    end\n+\n+    if c.ok + c.err + c.nop == total then\n+      callback(c.ok, c.err, c.nop)\n+    end\n+  end)\n+end\n+\n+local function lock_write()\n+  -- remove run key since can have a function in it, and\n+  -- json.encode doesn't support functions\n+  local pkgs = vim.deepcopy(Packages)\n+  for p, _ in pairs(pkgs) do\n+    pkgs[p].build = nil\n+  end\n+  local ok, result = pcall(vim.json.encode, pkgs)\n+  if not ok then\n+    error(result)\n+  end\n+  -- Ignore if fail\n+  pcall(file_write, Path.lock, 'w', result)\n+  Lock = Packages\n+end\n+\n+local function lock_load()\n+  local exists, data = pcall(file_read, Path.lock)\n+  if exists then\n+    local ok, result = pcall(vim.json.decode, data)\n+    if ok then\n+      Lock = not vim.tbl_isempty(result) and result or Packages\n+      -- Repopulate 'build' key so 'vim.deep_equal' works\n+      for name, pkg in\n+        pairs(result --[[@as table<string, vim.pack.PackageSpec>]])\n+      do\n+        pkg.build = Packages[name] and Packages[name].build or nil\n+      end\n+    end\n+  else\n+    lock_write()\n+    Lock = Packages\n+  end\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone(pkg, counter)\n+  local args = vim.list_extend({ 'git', 'clone', pkg.url }, Config.clone_args)\n+  if pkg.branch then\n+    vim.list_extend(args, { '-b', pkg.branch })\n+  end\n+  table.insert(args, pkg.dir)\n+  vim.system(args, {}, function(obj)\n+    local ok = obj.code == 0\n+    if ok then\n+      pkg.status = M.status.CLONED\n+      if pkg.build then\n+        table.insert(BuildQueue, pkg)\n+      end\n+    end\n+    counter(pkg.name, Messages.install, ok and 'ok' or 'err')\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function pull(pkg, counter)\n+  local prev_hash = Lock[pkg.name] and Lock[pkg.name].hash or pkg.hash\n+  vim.system(vim.list_extend({ 'git', 'pull' }, Config.pull_args), { cwd = pkg.dir }, function(obj)\n+    if obj.code ~= 0 then\n+      counter(pkg.name, Messages.update, 'err')\n+      local errmsg = ('\\nFailed to update %s:\\n%s\\n'):format(pkg.name, obj.stderr)\n+      file_write(Path.log, 'a+', errmsg)\n+      return\n+    end\n+    local cur_hash = get_git_hash(pkg.dir)\n+    -- It can happen that the user has deleted manually a directory.\n+    -- Thus the pkg.hash is left blank and we need to update it.\n+    if cur_hash == prev_hash or prev_hash == '' then\n+      pkg.hash = cur_hash\n+      counter(pkg.name, Messages.update, 'nop')\n+      return\n+    end\n+    log_update_changes(pkg, prev_hash or '', cur_hash)\n+    pkg.status, pkg.hash = M.status.UPDATED, cur_hash\n+    counter(pkg.name, Messages.update, 'ok')\n+    if pkg.build then\n+      table.insert(BuildQueue, pkg)\n+    end\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone_or_pull(pkg, counter)\n+  if Filter.to_update(pkg) then\n+    pull(pkg, counter)\n+  elseif Filter.to_install(pkg) then\n+    clone(pkg, counter)\n+  end\n+end\n+\n+local function process_build_queue()\n+  local failed = {}\n+\n+  local after = function(pkg, ok)\n+    report(pkg.name, Messages.build, ok)\n+    if not ok then\n+      table.insert(failed, pkg)\n+    end\n+  end\n+\n+  for _, pkg in ipairs(BuildQueue) do\n+    local t = type(pkg.build)\n+    if t == 'function' then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' and vim.startswith(pkg.build, ':') then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(vim.cmd, pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' then\n+      local args = vim.split(pkg.build, '%s', { trimempty = true })\n+      vim.system(\n+        args,\n+        { cwd = pkg.dir },\n+        vim.schedule_wrap(function(obj)\n+          after(pkg, obj.code == 0)\n+        end)\n+      )\n+    end\n+  end\n+\n+  BuildQueue = failed\n+end\n+\n+--- @param pkg vim.pack.Package\n+local function reclone(pkg)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  if ok then\n+    clone(pkg, function() end)\n+  end\n+end\n+\n+--- @param conflict pack.Conflict\n+local function resolve(conflict)\n+  reclone(conflict.curr)\n+end\n+\n+--- @param pkg string|vim.pack.PackageSpec\n+--- @return vim.pack.Package\n+local function register(pkg)\n+  if type(pkg) == 'string' then\n+    pkg = { pkg }\n+  end\n+\n+  local url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\n+    or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\n+\n+  local name = pkg.as or url:gsub('%.git$', ''):match('/([%w-_.]+)$') -- Infer name from `url`\n+  if not name then\n+    error('Failed to parse ' .. vim.inspect(pkg))\n+  end\n+\n+  local dir = vim.fs.joinpath(Path.packs, name)\n+  local ok, hash = pcall(get_git_hash, dir)\n+  hash = ok and hash or ''\n+\n+  return {\n+    branch = pkg.branch,\n+    build = pkg.build,\n+    dir = dir,\n+    hash = hash,\n+    name = name,\n+    opt = pkg.opt,\n+    pin = pkg.pin,\n+    status = uv.fs_stat(dir) and M.status.INSTALLED or M.status.TO_INSTALL,\n+    url = url,\n+  }\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function remove(pkg, counter)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  counter(pkg.name, Messages.remove, ok and 'ok' or 'err')\n+  if not ok then\n+    return\n+  end\n+  pkg.status = M.status.REMOVED\n+  Packages[pkg.name] = pkg\n+end\n+\n+--- @nodoc\n+--- @class pack.Conflict\n+--- @field prev vim.pack.Package\n+--- @field curr vim.pack.Package\n+---\n+--- @return pack.Conflict[]\n+local function calculate_conflicts()\n+  local conflicts = {}\n+  for name, lock in pairs(Lock) do\n+    local pkg = Packages[name]\n+    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= pkg.url) then\n+      table.insert(conflicts, { prev = lock, curr = pkg })\n+    end\n+  end\n+  return conflicts\n+end\n+\n+--- @nodoc\n+--- @alias Operation\n+--- | '\"install\"'\n+--- | '\"update\"'\n+--- | '\"remove\"'\n+--- | '\"sync\"'\n+---\n+--- Boilerplate around operations (autocmds, counter initialization, etc.)\n+--- @param op Operation\n+--- @param fn function\n+--- @param pkgs vim.pack.Package[]\n+local function exe_op(op, fn, pkgs)\n+  if vim.tbl_isempty(pkgs) then\n+    vim.notify('Pack: Nothing to ' .. op)\n+\n+    vim.api.nvim_exec_autocmds('User', {\n+      pattern = 'PackDone' .. op:gsub('^%l', string.upper),\n+    })\n+    return\n+  end\n+\n+  local function after(ok, err, nop)\n+    local summary = 'Pack: %s complete. %d ok; %d errors;' .. (nop > 0 and ' %d no-ops' or '')\n+    vim.notify(string.format(summary, op, ok, err, nop))\n+    vim.cmd('silent! helptags ALL')\n+\n+    if #BuildQueue ~= 0 then\n+      process_build_queue()\n+    end\n+\n+    vim.api.nvim_exec_autocmds('User', { pattern = 'PackDone' .. op:gsub('^%l', string.upper) })\n+\n+    -- This makes the logfile reload if there were changes while the job was running\n+    vim.cmd('silent! checktime ' .. vim.fn.fnameescape(Path.log))\n+\n+    lock_write()\n+  end\n+\n+  local counter = new_counter(#pkgs, after)\n+\n+  for _, pkg in ipairs(pkgs) do\n+    fn(pkg, counter)\n+  end\n+end\n+\n+---@param opts vim.pack.Opts? When omitted or `nil`, retrieve the current\n+---       configuration. Otherwise, a configuration table (see |vim.pack.Opts|).\n+---@return vim.pack.Opts? : Current pack config if {opts} is omitted.\n+function M.config(opts)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  if not opts then\n+    return vim.deepcopy(Config, true)\n+  end\n+\n+  vim.iter(opts):each(function(k, v)\n+    Config[k] = v\n+  end)\n+end\n+\n+--- Register one or more plugins to be installed (see [pack.PackageSpec]())\n+---\n+--- Example:\n+---\n+--- ```lua\n+--- -- pack will update by itself\n+--- pack.register({\n+---   \"neovim/nvim-lspconfig\",\n+---   { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate' },\n+---   -- don't load this plugin when registering. The user needs to call `packadd`.\n+---   { 'tpope/vim-fugitive', opt = false },",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2141776729",
            "id": 2141776729,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_qOtZ",
            "original_commit_id": "43532a5ddaddd9dae4e7834e22c1a5bcd84e8578",
            "original_line": 496,
            "original_position": 496,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2919634990,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141776729/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T06:12:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141776729",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34223#discussion_r2141822273"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34223"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141822273"
                }
            },
            "author_association": "NONE",
            "body": "Edit... Actually, it seems the comment might be incorrect and thus the generated docs are also incorrect.\r\n\r\nCode says this. Looks like it loads at startup if `opt = false` to me! And if `opt = true` it does not and requires user to call `packadd`. So that is good!\r\n\r\nAlthough it does it via `packadd` at startup rather than just downloading to the `pack/*/start` directory which I am not the biggest fan of. Sorta ok though still, it will have the same behavior as long as it is called during execution of `init.lua` or I think also `plugin/*` files. Results in a longer rtp, and possibly less reliable for `after` directories if called outside of `init.lua`, but probably fine.\r\n\r\n```lua\r\n      function(acc, pkg)\r\n        acc[pkg.name] = pkg\r\n        if not pkg.opt then\r\n          pcall(vim.cmd.packadd, pkg.name)\r\n          -- Remove opt from the schema\r\n          ---@diagnostic disable-next-line: inject-field, no-unknown\r\n          pkg.opt = nil\r\n        end\r\n        return acc\r\n      end\r\n```\r\n\r\nI'm not sure I 100% understand why you set `pkg.opt = nil` either? I'm assuming that is required by some later processing step? Edit: Ah. The lockfile. `opt` is removed before writing to lockfile, which has the dir (derived from as), hash, url and some other stuff but does not need opt.",
            "commit_id": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
            "created_at": "2025-06-12T06:32:42Z",
            "diff_hunk": "@@ -0,0 +1,653 @@\n+local uv = vim.uv\n+\n+local M = {}\n+\n+--- @class vim.pack.PackageSpec\n+--- @field [1] string\n+--- @field build string?\n+--- @field branch string?\n+--- @field pin boolean?\n+--- @field opt boolean?\n+--- @field as string?\n+\n+--- @class vim.pack.Package\n+--- @field name string\n+--- @field dir string\n+--- @field status vim.pack.Status\n+--- @field hash string\n+--- @field url string\n+--- @field pin boolean?\n+--- @field branch string?\n+--- @field build string? | function?\n+\n+--- @nodoc\n+--- @enum vim.pack.Status\n+M.status = {\n+  INSTALLED = 0,\n+  CLONED = 1,\n+  UPDATED = 2,\n+  REMOVED = 3,\n+  TO_INSTALL = 4,\n+}\n+\n+--- List of packages to build\n+--- @type vim.pack.Package[]\n+local BuildQueue = {}\n+\n+--- Table of pgks loaded from the lockfile\n+--- @type table<string, vim.pack.Package>\n+local Lock = {}\n+\n+--- Table of pkgs loaded from the user configuration\n+--- @type table<string, vim.pack.Package>\n+local Packages = {}\n+\n+--- @type table<string, string>\n+local Path = {\n+  lock = vim.fs.joinpath(vim.fn.stdpath('state'), 'pack-lock.json'),\n+  log = vim.fs.joinpath(vim.fn.stdpath('log'), 'pack.log'),\n+  packs = vim.fs.joinpath(vim.fn.stdpath('data'), 'site', 'pack', 'packs', 'opt'),\n+}\n+\n+--- @class vim.pack.Opts\n+---\n+--- Format string used to transform the package name into a git url.\n+--- (default: `https://github.com/%s.git`)\n+--- @field url_format string\n+---\n+--- Flags passed to `git clone` during installation of a plugin (see `:Man git-clone(1)` for more)\n+--- (default: `{ \"--depth=1\", \"--recurse-submodules\", \"--shallow-submodules\", \"--no-single-branch\" }`)\n+--- @field clone_args string[]\n+---\n+--- Flags passed to `git pull` during update of a plugin (see `:Man git-pull(1)` for more)\n+--- (default: `{ \"--tags\", \"--force\", \"--recurse-submodules\", \"--update-shallow\" }`)\n+--- @field pull_args string[]\n+local Config = {\n+  -- Using '--tags --force' means conflicting tags will be synced with remote\n+  clone_args = { '--depth=1', '--recurse-submodules', '--shallow-submodules', '--no-single-branch' },\n+  pull_args = { '--tags', '--force', '--recurse-submodules', '--update-shallow' },\n+  url_format = 'https://github.com/%s.git',\n+}\n+\n+--- @enum Messages\n+local Messages = {\n+  install = { ok = 'Installed', err = 'Failed to install' },\n+  update = { ok = 'Updated', err = 'Failed to update', nop = '(up-to-date)' },\n+  remove = { ok = 'Removed', err = 'Failed to remove' },\n+  build = { ok = 'Built', err = 'Failed to build' },\n+}\n+\n+--- @enum Filter\n+local Filter = {\n+  installed = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL\n+  end,\n+  not_removed = function(p)\n+    return p.status ~= M.status.REMOVED\n+  end,\n+  removed = function(p)\n+    return p.status == M.status.REMOVED\n+  end,\n+  to_install = function(p)\n+    return p.status == M.status.TO_INSTALL\n+  end,\n+  to_update = function(p)\n+    return p.status ~= M.status.REMOVED and p.status ~= M.status.TO_INSTALL and not p.pin\n+  end,\n+}\n+\n+--- @param path string\n+--- @param flags string|integer\n+--- @param data string\n+local function file_write(path, flags, data)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, flags, 0x1A4), err_msg:format('open'))\n+\n+  if uv.fs_write(file, data) ~= #data then\n+    assert(uv.fs_close(file), err_msg:format('close'))\n+    error(err_msg:format('write'))\n+  end\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+end\n+\n+--- @param path string\n+--- @return string\n+local function file_read(path)\n+  local err_msg = \"Failed to %s '\" .. path .. \"'\"\n+  local file = assert(uv.fs_open(path, 'r', 0x1A4), err_msg:format('open'))\n+\n+  ---@generic T\n+  ---@param cond? T\n+  ---@param message? any\n+  ---@return T\n+  ---@return any ...\n+  local safe_assert = function(cond, message)\n+    if not cond then\n+      assert(uv.fs_close(file), err_msg:format('close'))\n+    end\n+    return assert(cond, message)\n+  end\n+\n+  local stat = safe_assert(uv.fs_stat(path), err_msg:format('get stats for'))\n+  local data = uv.fs_read(file, stat.size, 0)\n+  safe_assert(data and #data == stat.size, err_msg:format('read'))\n+  --- @cast data string\n+\n+  assert(uv.fs_close(file), err_msg:format('close'))\n+\n+  return data\n+end\n+\n+--- @return vim.pack.Package[]\n+local function find_unlisted()\n+  local unlisted = {}\n+  for name, type in vim.fs.dir(Path.packs) do\n+    if type == 'directory' then\n+      local dir = vim.fs.joinpath(Path.packs, name)\n+      local pkg = Packages[name]\n+      if not pkg or pkg.dir ~= dir then\n+        table.insert(unlisted, { name = name, dir = dir })\n+      end\n+    end\n+  end\n+  return unlisted\n+end\n+\n+--- @param dir string\n+--- @return string\n+local function get_git_hash(dir)\n+  local first_line = function(path)\n+    local data = file_read(path)\n+    return vim.split(data, '\\n')[1]\n+  end\n+  local head_ref = first_line(vim.fs.joinpath(dir, '.git', 'HEAD'))\n+  return head_ref and first_line(vim.fs.joinpath(dir, '.git', head_ref:sub(6, -1)))\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param prev_hash string\n+--- @param cur_hash string\n+local function log_update_changes(pkg, prev_hash, cur_hash)\n+  vim.system(\n+    { 'git', 'log', '--pretty=format:* %s', ('%s..%s'):format(prev_hash, cur_hash) },\n+    { cwd = pkg.dir, text = true },\n+    function(obj)\n+      if obj.code ~= 0 then\n+        local msg = ('\\nFailed to execute git log into %q (code %d):\\n%s\\n'):format(\n+          pkg.dir,\n+          obj.code,\n+          obj.stderr\n+        )\n+        file_write(Path.log, 'a+', msg)\n+        return\n+      end\n+      local output = ('\\n%s updated:\\n%s\\n'):format(pkg.name, obj.stdout)\n+      file_write(Path.log, 'a+', output)\n+    end\n+  )\n+end\n+\n+--- @param name string\n+--- @param msg_op Messages\n+--- @param result string\n+--- @param n integer?\n+--- @param total integer?\n+local function report(name, msg_op, result, n, total)\n+  local count = n and (' [%d/%d]'):format(n, total) or ''\n+  vim.notify(\n+    ('Pack:%s %s %s'):format(count, msg_op[result], name),\n+    result == 'err' and vim.log.levels.ERROR or vim.log.levels.INFO\n+  )\n+end\n+\n+--- Object to track result of operations (installs, updates, etc.)\n+--- @param total integer\n+--- @param callback function\n+--- @return function\n+local function new_counter(total, callback)\n+  local c = { ok = 0, err = 0, nop = 0 }\n+  return vim.schedule_wrap(function(name, msg_op, result)\n+    if c.ok + c.err + c.nop < total then\n+      c[result] = c[result] + 1\n+      if result ~= 'nop' then\n+        report(name, msg_op, result, c.ok + c.nop, total)\n+      end\n+    end\n+\n+    if c.ok + c.err + c.nop == total then\n+      callback(c.ok, c.err, c.nop)\n+    end\n+  end)\n+end\n+\n+local function lock_write()\n+  -- remove run key since can have a function in it, and\n+  -- json.encode doesn't support functions\n+  local pkgs = vim.deepcopy(Packages)\n+  for p, _ in pairs(pkgs) do\n+    pkgs[p].build = nil\n+  end\n+  local ok, result = pcall(vim.json.encode, pkgs)\n+  if not ok then\n+    error(result)\n+  end\n+  -- Ignore if fail\n+  pcall(file_write, Path.lock, 'w', result)\n+  Lock = Packages\n+end\n+\n+local function lock_load()\n+  local exists, data = pcall(file_read, Path.lock)\n+  if exists then\n+    local ok, result = pcall(vim.json.decode, data)\n+    if ok then\n+      Lock = not vim.tbl_isempty(result) and result or Packages\n+      -- Repopulate 'build' key so 'vim.deep_equal' works\n+      for name, pkg in\n+        pairs(result --[[@as table<string, vim.pack.PackageSpec>]])\n+      do\n+        pkg.build = Packages[name] and Packages[name].build or nil\n+      end\n+    end\n+  else\n+    lock_write()\n+    Lock = Packages\n+  end\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone(pkg, counter)\n+  local args = vim.list_extend({ 'git', 'clone', pkg.url }, Config.clone_args)\n+  if pkg.branch then\n+    vim.list_extend(args, { '-b', pkg.branch })\n+  end\n+  table.insert(args, pkg.dir)\n+  vim.system(args, {}, function(obj)\n+    local ok = obj.code == 0\n+    if ok then\n+      pkg.status = M.status.CLONED\n+      if pkg.build then\n+        table.insert(BuildQueue, pkg)\n+      end\n+    end\n+    counter(pkg.name, Messages.install, ok and 'ok' or 'err')\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function pull(pkg, counter)\n+  local prev_hash = Lock[pkg.name] and Lock[pkg.name].hash or pkg.hash\n+  vim.system(vim.list_extend({ 'git', 'pull' }, Config.pull_args), { cwd = pkg.dir }, function(obj)\n+    if obj.code ~= 0 then\n+      counter(pkg.name, Messages.update, 'err')\n+      local errmsg = ('\\nFailed to update %s:\\n%s\\n'):format(pkg.name, obj.stderr)\n+      file_write(Path.log, 'a+', errmsg)\n+      return\n+    end\n+    local cur_hash = get_git_hash(pkg.dir)\n+    -- It can happen that the user has deleted manually a directory.\n+    -- Thus the pkg.hash is left blank and we need to update it.\n+    if cur_hash == prev_hash or prev_hash == '' then\n+      pkg.hash = cur_hash\n+      counter(pkg.name, Messages.update, 'nop')\n+      return\n+    end\n+    log_update_changes(pkg, prev_hash or '', cur_hash)\n+    pkg.status, pkg.hash = M.status.UPDATED, cur_hash\n+    counter(pkg.name, Messages.update, 'ok')\n+    if pkg.build then\n+      table.insert(BuildQueue, pkg)\n+    end\n+  end)\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function clone_or_pull(pkg, counter)\n+  if Filter.to_update(pkg) then\n+    pull(pkg, counter)\n+  elseif Filter.to_install(pkg) then\n+    clone(pkg, counter)\n+  end\n+end\n+\n+local function process_build_queue()\n+  local failed = {}\n+\n+  local after = function(pkg, ok)\n+    report(pkg.name, Messages.build, ok)\n+    if not ok then\n+      table.insert(failed, pkg)\n+    end\n+  end\n+\n+  for _, pkg in ipairs(BuildQueue) do\n+    local t = type(pkg.build)\n+    if t == 'function' then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' and vim.startswith(pkg.build, ':') then\n+      ---@diagnostic disable-next-line: param-type-mismatch\n+      local ok = pcall(vim.cmd, pkg.build)\n+      after(pkg, ok)\n+    elseif t == 'string' then\n+      local args = vim.split(pkg.build, '%s', { trimempty = true })\n+      vim.system(\n+        args,\n+        { cwd = pkg.dir },\n+        vim.schedule_wrap(function(obj)\n+          after(pkg, obj.code == 0)\n+        end)\n+      )\n+    end\n+  end\n+\n+  BuildQueue = failed\n+end\n+\n+--- @param pkg vim.pack.Package\n+local function reclone(pkg)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  if ok then\n+    clone(pkg, function() end)\n+  end\n+end\n+\n+--- @param conflict pack.Conflict\n+local function resolve(conflict)\n+  reclone(conflict.curr)\n+end\n+\n+--- @param pkg string|vim.pack.PackageSpec\n+--- @return vim.pack.Package\n+local function register(pkg)\n+  if type(pkg) == 'string' then\n+    pkg = { pkg }\n+  end\n+\n+  local url = (pkg[1]:match('^https?://') and pkg[1]) -- [1] is a URL\n+    or string.format(Config.url_format, pkg[1]) -- [1] is a repository name\n+\n+  local name = pkg.as or url:gsub('%.git$', ''):match('/([%w-_.]+)$') -- Infer name from `url`\n+  if not name then\n+    error('Failed to parse ' .. vim.inspect(pkg))\n+  end\n+\n+  local dir = vim.fs.joinpath(Path.packs, name)\n+  local ok, hash = pcall(get_git_hash, dir)\n+  hash = ok and hash or ''\n+\n+  return {\n+    branch = pkg.branch,\n+    build = pkg.build,\n+    dir = dir,\n+    hash = hash,\n+    name = name,\n+    opt = pkg.opt,\n+    pin = pkg.pin,\n+    status = uv.fs_stat(dir) and M.status.INSTALLED or M.status.TO_INSTALL,\n+    url = url,\n+  }\n+end\n+\n+--- @param pkg vim.pack.Package\n+--- @param counter function\n+local function remove(pkg, counter)\n+  local ok = pcall(vim.fs.rm, pkg.dir, { recursive = true })\n+  counter(pkg.name, Messages.remove, ok and 'ok' or 'err')\n+  if not ok then\n+    return\n+  end\n+  pkg.status = M.status.REMOVED\n+  Packages[pkg.name] = pkg\n+end\n+\n+--- @nodoc\n+--- @class pack.Conflict\n+--- @field prev vim.pack.Package\n+--- @field curr vim.pack.Package\n+---\n+--- @return pack.Conflict[]\n+local function calculate_conflicts()\n+  local conflicts = {}\n+  for name, lock in pairs(Lock) do\n+    local pkg = Packages[name]\n+    if pkg and Filter.not_removed(lock) and (lock.branch ~= pkg.branch or lock.url ~= pkg.url) then\n+      table.insert(conflicts, { prev = lock, curr = pkg })\n+    end\n+  end\n+  return conflicts\n+end\n+\n+--- @nodoc\n+--- @alias Operation\n+--- | '\"install\"'\n+--- | '\"update\"'\n+--- | '\"remove\"'\n+--- | '\"sync\"'\n+---\n+--- Boilerplate around operations (autocmds, counter initialization, etc.)\n+--- @param op Operation\n+--- @param fn function\n+--- @param pkgs vim.pack.Package[]\n+local function exe_op(op, fn, pkgs)\n+  if vim.tbl_isempty(pkgs) then\n+    vim.notify('Pack: Nothing to ' .. op)\n+\n+    vim.api.nvim_exec_autocmds('User', {\n+      pattern = 'PackDone' .. op:gsub('^%l', string.upper),\n+    })\n+    return\n+  end\n+\n+  local function after(ok, err, nop)\n+    local summary = 'Pack: %s complete. %d ok; %d errors;' .. (nop > 0 and ' %d no-ops' or '')\n+    vim.notify(string.format(summary, op, ok, err, nop))\n+    vim.cmd('silent! helptags ALL')\n+\n+    if #BuildQueue ~= 0 then\n+      process_build_queue()\n+    end\n+\n+    vim.api.nvim_exec_autocmds('User', { pattern = 'PackDone' .. op:gsub('^%l', string.upper) })\n+\n+    -- This makes the logfile reload if there were changes while the job was running\n+    vim.cmd('silent! checktime ' .. vim.fn.fnameescape(Path.log))\n+\n+    lock_write()\n+  end\n+\n+  local counter = new_counter(#pkgs, after)\n+\n+  for _, pkg in ipairs(pkgs) do\n+    fn(pkg, counter)\n+  end\n+end\n+\n+---@param opts vim.pack.Opts? When omitted or `nil`, retrieve the current\n+---       configuration. Otherwise, a configuration table (see |vim.pack.Opts|).\n+---@return vim.pack.Opts? : Current pack config if {opts} is omitted.\n+function M.config(opts)\n+  vim.validate('opts', opts, 'table', true)\n+\n+  if not opts then\n+    return vim.deepcopy(Config, true)\n+  end\n+\n+  vim.iter(opts):each(function(k, v)\n+    Config[k] = v\n+  end)\n+end\n+\n+--- Register one or more plugins to be installed (see [pack.PackageSpec]())\n+---\n+--- Example:\n+---\n+--- ```lua\n+--- -- pack will update by itself\n+--- pack.register({\n+---   \"neovim/nvim-lspconfig\",\n+---   { 'nvim-treesitter/nvim-treesitter', build = ':TSUpdate' },\n+---   -- don't load this plugin when registering. The user needs to call `packadd`.\n+---   { 'tpope/vim-fugitive', opt = false },",
            "html_url": "https://github.com/neovim/neovim/pull/34223#discussion_r2141822273",
            "id": 2141822273,
            "in_reply_to_id": 2141776729,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_qZ1B",
            "original_commit_id": "43532a5ddaddd9dae4e7834e22c1a5bcd84e8578",
            "original_line": 496,
            "original_position": 496,
            "original_start_line": null,
            "path": "runtime/lua/vim/pack.lua",
            "position": null,
            "pull_request_review_id": 2919703791,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141822273/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-12T06:51:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2141822273",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Have you seen https://github.com/neovim/neovim/pull/34009?",
            "created_at": "2025-05-29T08:30:22Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918700257",
            "id": 2918700257,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t99Th",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918700257/reactions"
            },
            "updated_at": "2025-05-29T08:30:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918700257",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "No actually I didn't see that. But looking at it I much prefer my approach to this since is much simpler IMO.\r\n\r\nBut if you guys prefer the other PR I can close this no problem.",
            "created_at": "2025-05-29T08:37:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918716897",
            "id": 2918716897,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t-BXh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918716897/reactions"
            },
            "updated_at": "2025-05-29T08:37:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918716897",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> No actually I didn't see that. But looking at it I much prefer my approach to this since is much simpler IMO.\r\n\r\nThe #34009 is definitely designed to be more interactive and capable, but it is still relatively straightforward and minimal. And if taking LOC into account, the core features of the initial PR is not much bigger (496 LOC), although it has grown a bit (557 now) and will grow if/after lockfile and packspec support.",
            "created_at": "2025-05-29T08:49:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918744042",
            "id": 2918744042,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t-H_q",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918744042/reactions"
            },
            "updated_at": "2025-05-29T08:49:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918744042",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> is definitely designed to be more interactive and capable\r\n\r\nNot really, is over complicated for no real reason. Also I can see my version been more hackable and straight forward.\r\n\r\nBut I think this comes down to personal preferences so we should let other decide for themself at this point. Obw I'll say that my version is better and you'll say the opposite. Comes down to what people find more simple to use ",
            "created_at": "2025-05-29T08:57:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918763843",
            "id": 2918763843,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t-M1D",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 5,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 7,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918763843/reactions"
            },
            "updated_at": "2025-05-29T08:57:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918763843",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Not really, is over complicated for no real reason.\r\n\r\n*That* is definitely not the case. Not sure which parts you think are over complicated, but every functionality serves its purpose and is proven to be useful.",
            "created_at": "2025-05-29T09:04:30Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918780257",
            "id": 2918780257,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t-Q1h",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918780257/reactions"
            },
            "updated_at": "2025-05-29T09:04:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918780257",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> That is definitely not the case. \r\n\r\nPlease provide me a list of feature and use case that your implementation does that mine doesn't?\r\n\r\n> Not sure which parts you think are over complicated, but every functionality serves its purpose and is proven to be useful.\r\n\r\nOk, looking at your implementation (some thing I could be wrong and let me know).\r\n\r\n### Point 1\r\n\r\nYour implementation spread state of installed plugins all over the place since it supports arbitrary change of state via `vim.pack.del` and `vim.pack.add` this can really confuse people and makes it unreasonably complicated to track the state. If you add that plugins can be lazy loaded you add a lot of complexity.\r\n\r\nTo be more specific lets say a user has the following config:\r\n\r\n```lua\r\nvim.pack.add({\r\n  \"someplugin/plugin\",\r\n  \"someotherplugin/plugin\",\r\n})\r\n```\r\n\r\n1. They reboot and this two plugins are installed and then wants to install another one this time while nvim is running.\r\n2. They install a 3rd plugin that will be available only for this session. They reboot again and the plugin is not loaded and maybe they forgot to clean it. \r\n3. Now they have a plugin that doesn't get loaded and it there taking dust.\r\n\r\nWhy this is important?\r\n1. The state of the `pack` directory is not clear.\r\n2. You created a UX where I NEED to remember to clean my plugin that maybe I forgot they even exist\r\n3. If you start adding lazy loaded packages how can you ever track every single one of them if you want to extend this in any meaningful way?\r\n4. You're are making really difficult to have clear points in witch the state is mutated\r\n\r\nIn my implementation you have only one source of truth whatever is register with the `register()` function. That is the only place where the state is mutated. Then from there since the plugins knows every installed package it can automatically for you remove, update and install plugins.\r\n\r\n```lua\r\nvim.pack.register(\r\n  \"someplugin/plugin\",\r\n  \"someotherplugin/plugin\",\r\n})\r\n```\r\n\r\nA `PackSync` and you are sure that your `pack` directory synced with your config.\r\n\r\n### Point 2\r\n\r\nYour implementation is stiff and cannot be easily extended by other plugins because you are doing to many stuff such as the confirmation buffer and autoinstall on boot.\r\n\r\nMy implementation can be hacked by the user to do whatever yours is doing and more personalised to them.\r\n\r\nLet's see some examples:\r\n\r\n**What if I don't want that `vim.pack.add` to automatically packadd my plugin?**\r\n\r\nIn yours: I need to call `vim.pack.add` where you want to be loaded witch spread state and `vim.pack.get` will give you different result before and after `vim.pack.add` run. Good luck tracking state if you want to build a plugin to extend this by for example have a lazy.nvim like experience.\r\n\r\nIn mine: You can simply switch a `opt` flag globally or locally and then you can simply use `packadd` to do it yourself witch can be useful if you want to redefine the loading completely and make it lazy for example.\r\n\r\n**What if I don't like that you automatically download a package at startup?**\r\n\r\nIn yours: I cannot change this or I need to delete the autocmd (witch I need to know that exists)\r\n\r\nIn mine: You can simply do:\r\n```lua\r\nautocmd(\"VimEnter\", {\r\n  once = true,\r\n  callback = function()\r\n    local pkgs = vim.pack.query(\"to_install\")\r\n    if not vim.tbl_isempty(pkgs) then\r\n      vim.pack.install()\r\n    end\r\n  end,\r\n})\r\n```\r\n\r\nMoreover I can do it when I want in whatever event I want if I want it.\r\n\r\n### Point 3\r\n\r\nMy implementation already has lockfile support and I can make pure and reproducible really easy.",
            "created_at": "2025-05-29T10:04:17Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2918918676",
            "id": 2918918676,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6t-yoU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 7,
                "-1": 4,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 11,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918918676/reactions"
            },
            "updated_at": "2025-05-29T10:07:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2918918676",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> > That is definitely not the case.\r\n> \r\n> Please provide me a list of feature and use case that your implementation does that mine doesn't?\r\n\r\nYou made a claim about the PR being \"... over complicated for no real reason\". I didn't claim to know the exact difference with this PR.\r\n\r\nOne of the main design decisions of #34223 are:\r\n\r\n- Have a single entry point function (`vim.pack.add()`) to essentially \"ensure these plugins are available\". It acts as \"smarter `:packadd`\": add to the 'init.lua' (in one or many places) and write the code after it safely assuming that all the plugins are installed. This allows for a less nested, essentially \"top-down\" config involving plugins.\r\n\r\n- Have user see and confirm update changes before applying them. This makes it more likely to be aware of breaking changes and newly added features. It is currently implemented as a separate confirmation buffer (somewhat similar to `:checkhealth`). It also takes advantage of the built-in LSP capabilities which reuses already known concepts/mappings and available LSP-enhancing plugins.\r\n\r\n- Simplify plugin specification as much as possible in favor of other approaches. See \"Design decisions notes\" of #34009. This lifts the burden from the user about figuring out the intricacies of different spec fields.\r\n\r\n---\r\n\r\n> * They reboot and this two plugins are installed and then wants to install another one this time while nvim is running.\r\n> * They install a 3rd plugin that will be available only for this session. They reboot again and the plugin is not loaded and maybe they forgot to clean it.\r\n> * Now they have a plugin that doesn't get loaded and it there taking dust.\r\n\r\n\"They install a 3rd plugin ...\" step should be by adding a `vim.pack.add()` entry if they want this to be persistent. Executing interactively in the command line will have effect only in the current session, yes. This is a similar logic to almost any existing configuration approach: setting options, using any command, etc.\r\n\r\n> * The state of the `pack` directory is not clear.\r\n\r\nIt is a directory with plugins. Any of them can be added now, later, or not at all. Their state on disk is the same as it was during latest interaction with it (i.e. after install or update).\r\n\r\n> * You created a UX where I NEED to remember to clean my plugin that maybe I forgot they even exist\r\n\r\nAll plugins are available in `vim.pack.get()` and will be (all) shown by default in confirmation buffer after the lockfile support.\r\n\r\n> * If you start adding lazy loaded packages how can you ever track every single one of them if you want to extend this in any meaningful way?\r\n> * You're are making really difficult to have clear points in witch the state is mutated\r\n\r\nI don't understand neither question or point. All available plugins are subdirectories in the fixed 'pack/core/opt'. All added plugins are both present in the 'runtimepath' and inside local session tracking list (to also track their spec).\r\n\r\n---\r\n\r\n> **What if I don't want that `vim.pack.add` to automatically packadd my plugin?**\r\n> \r\n> In yours: I need to call `vim.pack.add` where you want to be loaded witch spread state and `vim.pack.get` will give you different result before and after `vim.pack.add` run. Good luck tracking state if you want to build a plugin to extend this by for example have a lazy.nvim like experience.\r\n> \r\n> In mine: You can simply switch a `opt` flag globally or locally and then you can simply use `packadd` to do it yourself witch can be useful if you want to redefine the loading completely and make it lazy for example.\r\n\r\nThe logic is that instead of \"simply use `packadd`\" it is \"simply use `vim.pack.add()`\".\r\n\r\nThe `vim.pack.get()` will still show all available plugins: some of them will shown as added, some - don't. Yes, not yet added plugins will have default `version` (instead of what user might have set it to last) but that will change after lockfile support.\r\n\r\n> What if I don't like that you automatically download a package at startup?\r\n\r\nEither remove/comment the `vim.pack.add()` call or do not confirm plugin installation (currently this throws an error, but can be changed to not error depending on the usefullness).\r\n\r\n---\r\n\r\n> My implementation already has lockfile support and I can make pure and reproducible really easy.\r\n\r\nYou forgot to mention that it also doesn't contain user commands. Actually adding either of them is not a big deal (as this PR has proven), it is that their format and intended workflow need further discussion.\r\n\r\n---\r\n\r\nAnd @saccarosium, please, tone down the language a bit. This is never intended to be a \"mine is the best, yours is trash\" kind of discussion.",
            "created_at": "2025-05-29T12:31:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919254513",
            "id": 2919254513,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uAEnx",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 8,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 9,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919254513/reactions"
            },
            "updated_at": "2025-05-29T12:50:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919254513",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> This is never intended to be a \"mine is the best, yours is trash\" kind of discussion.\r\n\r\nNot to be pedantic but claiming \"is _definitely_ designed to be more interactive and capable\" is not really that neutral... \"Definitely\" in comparison to what?\r\n\r\nI'm not attacking YOU or anything. I simply stating what I think of the matter I don't think I'm been to aggressive (if I'm sorry it's not my intention) \r\n\r\n> I don't understand neither question or point. All available plugins are subdirectories in the fixed 'pack/core/opt'. All added plugins are both present in the 'runtimepath' and inside local session tracking list (to also track their spec).\r\n\r\n```lua\r\nautocmd(\"FileType\", {\r\n  pattern = \"someft\",\r\n  callback = function()\r\n    vim.pack.add(\"someplugin\")\r\n  end,\r\n})\r\n```\r\n\r\nIn this case the plugin will be discovered by your implementation only when callback is executed. Before you added this plugin the state and lockfile that are generated before the adding of the plugin are incomplete.\r\n\r\nAlso in this scenario I'll open some file with that filetype and I'll get prompted to install the plugin? Rather annoying.\r\n\r\n> The logic is that instead of \"simply use packadd\" it is \"simply use vim.pack.add()\".\r\n\r\nYou are not getting the point. If I want to create a plugin on top of your implementation I want to be able to control when a plugin gets loaded without all the side effects of your function. Also using my approach you prevent the problem described above because the package manager knows about every package that it needs to manage from the start.\r\n\r\n> All plugins are available in vim.pack.get() and will be (all) shown by default in confirmation buffer after the lockfile support.\r\n  \r\nIs bad UX because at that point it doesn't provide a lot of value doesn't it? If I want to extend this and implement handlers for different situations\r\n\r\n> Simplify plugin specification as much as possible in favor of other approaches. See \"Design decisions notes\" of https://github.com/neovim/neovim/pull/34009. This lifts the burden from the user about figuring out the intricacies of different spec fields.\r\n\r\nIn this the spec is pretty simple and doesn't really preclude the possibility of using other means (such as `pkg.json`). But I think is worth thinking about when we have something tangible to use. Currently you are adding friction for no reason.",
            "created_at": "2025-05-29T13:37:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919428058",
            "id": 2919428058,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uAu_a",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919428058/reactions"
            },
            "updated_at": "2025-05-29T13:37:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919428058",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> ```lua\r\n> autocmd(\"FileType\", {\r\n>   pattern = \"someft\",\r\n>   callback = function()\r\n>     vim.pack.add(\"someplugin\")\r\n>   end,\r\n> })\r\n> ```\r\n>\r\n> In this case the plugin will be discovered by your implementation only when callback is executed. Before you added this plugin the state and lockfile that are generated before the adding of the plugin are incomplete.\r\n\r\nIt will be `:packadd`ed at this point, yes. If it is present on disk - at the state it is currently on disk. If it is not present on disk - it is installed at the specified `version`.\r\n\r\nThere is nothing to \"discover\": all subdirectories of 'pack/core/opt/' directory are available plugins . They are never automatically removed, only after an explicit `vim.pack.del()`. Their target `version` will be stored in the (probably private) lockfile (used in `vim.pack.update()` and `vim.pack.get()`) and will be updated after every install or `vim.pack.update()`.\r\n\r\nAs there is no lockfile support yet, making assumptions about how it works is premature.\r\n\r\n> Also in this scenario I'll open some file with that filetype and I'll get prompted to install the plugin? Rather annoying.\r\n\r\nOnly the first time to actually install a plugin if it is absent on disk. And this seems reasonable to me: no need to install a plugin until it is actually needed.\r\n\r\n> You are not getting the point. If I want to create a plugin on top of your implementation I want to be able to control when a plugin gets loaded without all the side effects of your function.\r\n\r\nThe single (not plural) \"side effect\" is making sure a plugin is available. Other than that it is the same as `:packadd` and can be used to control \"when a plugin is loaded\".\r\n\r\n> > All plugins are available in vim.pack.get() and will be (all) shown by default in confirmation buffer after the lockfile support.\r\n> \r\n> Is bad UX because at that point it doesn't provide a lot of value doesn't it? If I want to extend this and implement handlers for different situations\r\n\r\nThis doesn't make much sense. What \"handlers for different situations\" and how is it related to `vim.pack.get()`? The latter directly returns an information about all available plugins: some with `true` flag if the plugin was added to current session, some with `false` if not (yet) added.",
            "created_at": "2025-05-29T14:05:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919520132",
            "id": 2919520132,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uBFeE",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919520132/reactions"
            },
            "updated_at": "2025-05-29T14:05:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919520132",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "We have different opinion and taste, that's fine. At this point I would like to wait what implementation people like more and let them decide from that.",
            "created_at": "2025-05-29T14:10:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919533937",
            "id": 2919533937,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uBI1x",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919533937/reactions"
            },
            "updated_at": "2025-05-29T14:10:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919533937",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > No actually I didn't see that. But looking at it I much prefer my approach to this since is much simpler IMO.\r\n> \r\n> The #34009 is definitely designed to be more interactive and capable, but it is still relatively straightforward and minimal.\r\n\r\nAnd this interactiveness might be too much for some, especially if there is no way to opt out. I have looked at mini.deps a while ago (when there were some issues with pckr.nvim, before Lewis fixed them) and decided against migration due to that interactiveness (it's great to have a choice).\r\n\r\nPerhaps first step could be some 'naked', extensible,`vim.pack` implementation, without user interfaces other than API? Then either some interface can be added later or plugins can provide them as they seem fit (but I am not entirely sure what the project goal here is).\r\n\r\n(Great work both of you!)",
            "created_at": "2025-05-29T15:52:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919840755",
            "id": 2919840755,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uCTvz",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 6,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919840755/reactions"
            },
            "updated_at": "2025-05-29T15:52:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919840755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/69750637?v=4",
                "events_url": "https://api.github.com/users/gegoune/events{/privacy}",
                "followers_url": "https://api.github.com/users/gegoune/followers",
                "following_url": "https://api.github.com/users/gegoune/following{/other_user}",
                "gists_url": "https://api.github.com/users/gegoune/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gegoune",
                "id": 69750637,
                "login": "gegoune",
                "node_id": "MDQ6VXNlcjY5NzUwNjM3",
                "organizations_url": "https://api.github.com/users/gegoune/orgs",
                "received_events_url": "https://api.github.com/users/gegoune/received_events",
                "repos_url": "https://api.github.com/users/gegoune/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gegoune/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gegoune/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gegoune",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> And this interactiveness might be too much for some, especially if there is no way to opt out. I have looked at mini.deps a while ago (when there were some issues with pckr.nvim, before Lewis fixed them) and decided against migration due to that interactiveness (it's great to have a choice).\r\n\r\nIs it a general \"if there is no way to opt out\" (which I mostly agree) or are there concrete examples? With #34009 (and 'mini.deps' for first two points) this comes down to:\r\n- Emphasis on showing progress with LSP progress / `vim.notify()`. No way to opt out, can be added, but I don't think how this can be a bad thing.\r\n- Review and confirm updates. This can opted out by forcing updates: `vim.pack.update(nil, { force = true })` and future `:PackUpdate!` (`:Pack! update`). This way all changes will be applied without confirm.\r\n- Confirm installation. Initially PR didn't have it and I personally think a call to `vim.pack.add()` is enough of confirmation, but I can see the arguments for having to confirm also. No way to opt out (so that install is without confirm), can be added.\r\n\r\nEverything else is designed for a more straightforward scripting: put `vim.pack.add()` in 'init.lua' and it \"just works\". Same as with any other part of config (options, autocommands, etc.). If don't want some plugin temporarily - comment it out. If don't want at all - `vim.pack.del()`.",
            "created_at": "2025-05-29T16:53:32Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2919998933",
            "id": 2919998933,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uC6XV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919998933/reactions"
            },
            "updated_at": "2025-05-29T16:53:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2919998933",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "But I can really see how it can really annoy some people as a opt out feature rather than a opt in.",
            "created_at": "2025-05-29T16:59:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2920012131",
            "id": 2920012131,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uC9lj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2920012131/reactions"
            },
            "updated_at": "2025-05-29T16:59:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2920012131",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@echasnovski why you so mean? IMO this PR just another implementation of built-in package manager for Neovim, this is a kind of competition. Neovim is an open-source project, people have the right to contribute their code and users are free choose they prefer, this project isn't yours alone to control.\r\nYour PR hasn't even been merged yet, and you're already promoting it someone else's PR while claiming yours is better. Maybe yours is better, but i prefer this PR because it's simpler and easier to understand, compared to your flashy implementation, so why not just let users decide?",
            "created_at": "2025-05-30T05:02:25Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2921237984",
            "id": 2921237984,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uHo3g",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921237984/reactions"
            },
            "updated_at": "2025-05-30T07:06:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921237984",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/201720307?v=4",
                "events_url": "https://api.github.com/users/RicardoKovd/events{/privacy}",
                "followers_url": "https://api.github.com/users/RicardoKovd/followers",
                "following_url": "https://api.github.com/users/RicardoKovd/following{/other_user}",
                "gists_url": "https://api.github.com/users/RicardoKovd/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/RicardoKovd",
                "id": 201720307,
                "login": "RicardoKovd",
                "node_id": "U_kgDODAYB8w",
                "organizations_url": "https://api.github.com/users/RicardoKovd/orgs",
                "received_events_url": "https://api.github.com/users/RicardoKovd/received_events",
                "repos_url": "https://api.github.com/users/RicardoKovd/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/RicardoKovd/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/RicardoKovd/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/RicardoKovd",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Why are you so mean?\n\n@RicardoKovd I think the question is better to ask yourself. Do you realize that you are personal attacking?\n\n> this project isn't yours alone to control.\n\nWhen have anyone here said that this PR should be closed?\n\n> Your PR hasn't even been merged yet, and you're already promoting it someone else's PR while claiming yours is better.\n\nThey are just discussing between different implementations. At least they all give their arguments, what arguments have you given in your comment, other than personal attacking?",
            "created_at": "2025-05-30T05:34:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2921280129",
            "id": 2921280129,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uHzKB",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921280129/reactions"
            },
            "updated_at": "2025-05-30T07:06:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921280129",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/111893501?v=4",
                "events_url": "https://api.github.com/users/brianhuster/events{/privacy}",
                "followers_url": "https://api.github.com/users/brianhuster/followers",
                "following_url": "https://api.github.com/users/brianhuster/following{/other_user}",
                "gists_url": "https://api.github.com/users/brianhuster/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/brianhuster",
                "id": 111893501,
                "login": "brianhuster",
                "node_id": "U_kgDOBqtb_Q",
                "organizations_url": "https://api.github.com/users/brianhuster/orgs",
                "received_events_url": "https://api.github.com/users/brianhuster/received_events",
                "repos_url": "https://api.github.com/users/brianhuster/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/brianhuster/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/brianhuster/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/brianhuster",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> @echasnovski why you so mean?\r\n> ... \r\n> Your PR hasn't even been merged yet, and you're already promoting it someone else's PR while claiming yours is better.\r\n\r\nThere was *no* claim from me that either PR is \"better\". The original \"more interactive and capable\" is not equal to \"better\" (as the first can be described with examples and the second is a personal opinion). Everything after that was strictly an answer to some claim about alleged flaws in #34009 (especially an unwarranted \"over complicated for no real reason\").\r\n\r\nAnd if some other funcionality were merged, there would be no discussions.\r\n\r\n\r\n",
            "created_at": "2025-05-30T06:02:37Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2921319739",
            "id": 2921319739,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6uH807",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921319739/reactions"
            },
            "updated_at": "2025-05-30T07:06:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2921319739",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "```\r\n---   -- don't load this plugin when registering. The user needs to call `packadd`.\r\n---   { 'tpope/vim-fugitive', opt = false },\r\n```\r\n\r\nThis is confusing. To the point where this is not a nitpick but a serious concern.\r\n\r\nUsually, when `opt = true`, like in [`paq.nvim`](https://github.com/savq/paq-nvim) (and every single nix wrapper for neovim), it means that you DO need to call `packadd`, akin to putting it in the `pack/*/opt` directory on the packpath, and if `opt = false` (or `nil`) then it installs to a `pack/*/start` directory on the packpath rather than calling packadd itself manually but hidden from the user.\r\n\r\nThis is the opposite. Is this comment correct? It appears as though you install ALL plugins into `pack/*/opt`, and then manually call packadd at startup for all plugins with `opt = true`? Why not install `opt = false` startup plugins to `pack/*/start` and `opt = true` to `pack/*/opt`? And why is it named backwards? (Mostly why is it named backwards)\r\n\r\nThere may be a reason why you might want to add them all to `pack/*/opt` instead of installing them into `pack/*/{start, opt}` (although I cannot think of one at the moment) but I cannot see a single reason why `opt = true` does not mean `optionally loaded via packadd` and instead means the opposite?\r\n\r\n`opt = false` should mean \"loaded at startup\" and `opt = true` should mean \"optionally loaded via packadd`.\r\n\r\nWith my main concern stated, I will also say, [lze](https://github.com/BirdeeHub/lze) and [lz.n](https://github.com/nvim-neorocks/lz.n) are going to be so good when we have a builtin plugin manager! I am excited!\r\n\r\n---\r\n\r\nI also have 1 more concern which is that some people download their plugins through other means that do not require runtime path existence checks (such as nix where everything is provisioned to the proper directories before nvim ever starts).\r\n\r\nIf the builtin plugin manager is not used or is disabled, it should be careful not to check for existence of plugins on the packpath for performance reasons. But I would assume that you aren't checking for unregistered plugins so I would assume that this was done correctly. So this second concern is likely a nonissue. I'm mostly just concerned about if opt is backwards or not.",
            "created_at": "2025-06-12T05:06:06Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965125904",
            "id": 2965125904,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wvDsQ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965125904/reactions"
            },
            "updated_at": "2025-06-12T06:21:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965125904",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Usually, when opt = true, like in [paq.nvim](https://github.com/savq/paq-nvim) (and every single nix wrapper for neovim), it means that you DO need to call packadd, akin to putting it in the pack/*/opt directory on the packpath, and if opt = false (or nil) then it installs to a pack/*/start directory on the packpath rather than calling packadd itself manually but hidden from the user.\r\n\r\nWhen I've introduced the change that key was called `load` so when you wanted to not load the plugin you would specify `load = false`. After some discussion <https://github.com/saccarosium/pack.nvim/issues/8> justin thought that having less jargon split was a good thing and i simply rename it. But you are right, it may be more appropriate to switch the logic around. \r\n\r\n> This is the opposite. Is this comment correct? It appears as though you install ALL plugins into pack/*/opt, and then manually call packadd at startup for all plugins with opt = true? Why not install opt = false startup plugins to pack/*/start and opt = true to pack/*/opt?\r\n\r\nThere are issues with the `start` directory. I don't remember them all on the top of my head but there are some issues that makes really painfull to work with the `start` directory. This is why this and #34009 uses the opt directory and then packadd manually.\r\n\r\n> I also have 1 more concern which is that some people download their plugins through other means that do not require runtime path existence checks (such as nix where everything is provisioned to the proper directories before nvim ever starts).\r\n\r\nThis plugin is only concerned by the plugins in `pack/packs/opt/*` so as long as nix doesn't install plugins in that directory you are good.",
            "created_at": "2025-06-12T06:39:43Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965309780",
            "id": 2965309780,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wvwlU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965309780/reactions"
            },
            "updated_at": "2025-06-12T06:39:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965309780",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "I am on your side that the other one was doing a bit too much tbh, simple is good. But ultimately, as long as they allow me to use packadd to load a plugin that is downloaded as optional, I am not too worried.\r\n\r\nI do agree that being prompted to download all your rust plugins only once you open a rust file for example would be a bad thing.\r\n\r\nA plugin manager should download all the plugins in my config when I open it for the first time, not when the plugin is first loaded. Downloading and loading are different things. I want my lockfile to be populated, and my plugins there. I don't want to lose wifi only to discover I don't have the things I need to work offline installed yet, for example. This might even be multiplied by plugins themselves using the plugin manager to download dependencies that you don't know haven't been installed yet. I think yours handles this correctly.\r\n\r\nI think some people may want luarocks support? Would there be a way to have a plugin that extends this new package manager and works within this same API with this implementation? It doesn't need to be built into it, but it should allow for enough extend-ability to allow such a thing IMO? Not sure if this matters though, because you can still use rocks.nvim or whatever to install rocks. But would be cool.\r\n\r\nIf this implementation allows for that Im definitely on board, it is very similar to paq.nvim which I like. And paq.nvim was specifically called out in the proposal as a good model.\r\n\r\n(and to be clear, I wasn't worried about nix compat, just about not checking the packpath for unregistered plugins, which it seems you do avoid)",
            "created_at": "2025-06-12T07:41:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965490232",
            "id": 2965490232,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wwco4",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965490232/reactions"
            },
            "updated_at": "2025-06-12T08:23:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965490232",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "After evaluating a bit more the other implementation I would say that I still prefer my approach and I would like to improve it by:\r\n- Making the lockfile more useful and reproducible with the possibility of rolling back the configuration after an update\r\n- Supporting `vim.version` for the branch\r\n- Incorporating `vim.ui.progress` when it will come out\r\n\r\nBut I would like to know if the maintainers prefer to go with my implementation or @echasnovski's one. There were other occasions where I did a bunch of work and it wasn't reviewed or accepted with little or no feedback so I would like to know if the effort I want to put in to this has some value to the core maintainers.\r\n\r\nObviously I'm aware that the maintainers are volunteers and they need to allocate their time and energy wisely but so do I, so I would like a straight answer.\r\n\r\nThe current design differences between the two implementation are (at least as far as I can see @echasnovski add your thoughts if I miss something)\r\n\r\nMine:\r\n- the focus is a single source of truth for all your plugins and you operate on them in bulk.\r\n- it is only configuration driven if you want to alter the state you need to change the configuration\r\n- it has no dedicated UI by default (can be implemented by plugins e.g. mason like ui for plugins or a update buffer as the other configuration)\r\n- it is more manual by default (the user needs to opt-in to automations by making them self).\r\n- it'll still be smaller that Echasnovski's because it simply does less stuff\r\n\r\nEchasnovski's:\r\n- the focus is for a smarter `packadd` that checks if the plugin is on the disk. While it has bulk functionality it also allows the user to modify the session by allowing arbitrary installation of plugins during runtime (session plugins if I recall)\r\n- it has a stronger opinion of UIs by having a dedicated buffer for reviewing changes before updating\r\n- it has some more automation by default (it ask the user at startup if he want's to install packages)\r\n- even thought it is not currently added, by the plans, I can see offering more options to customise the behaviour for example: thread count, more flashed out remote management \r\n\r\ncc: @justinmk @lewis6991 @clason ",
            "created_at": "2025-06-12T07:51:42Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965524177",
            "id": 2965524177,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wwk7R",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965524177/reactions"
            },
            "updated_at": "2025-06-12T07:51:42Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965524177",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> the focus is a single source of truth for all your plugins and you operate on them in bulk.\n\nThis is the biggest part of the design I disagree with. Just like `:packadd` the user should be able to call this whenever they want. This is effectively how a user can implement lazy loading on top without specific core support.\n\nI'm also not a fan of the shape of `vim.pack.Opts` and `vim.pack.Package`. I don't think we should be exposing hooks to insert random git arguments.\n\nI don't know if I'll have enough bandwidth to review this fully. I've already put in quite a lot of time reviewing (and contributing to @echasnovski ), and am fairly happy with its current state.\n\nAnd to add, line count has little influence in my decision of which to go for. Most complex tasks follow the 80/20 rule anyway, so the line count can quickly balloon as it matures. What matters most is the best interface, and most robust implementation that doesn't expose too many edge cases and gracefully handles most/all error conditions.",
            "created_at": "2025-06-12T08:22:13Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965615503",
            "id": 2965615503,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6ww7OP",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965615503/reactions"
            },
            "updated_at": "2025-06-12T08:22:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965615503",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Mine:\r\n> \r\n> * the focus is a single source of truth for all your plugins and you operate on them in bulk.\r\n> \r\n> * it is only configuration driven if you want to alter the state you need to change the configuration\r\n\r\nBoth of these are mostly true for #34009 also.\r\n\r\nThe \"single source of truth\" is currently present plugins in the dedicated 'pack/core/opt' directory. Those represent all the plugins currently used (loaded or not). If users want, forcing potentially lazy-loaded plugins be always present but not loaded is also possible: `vim.pack.add(..., { bang = true })` executes `:packadd!` (which only adds plugin's path to `rtp`, but not loads any code after startup).\r\n\r\nThe design focus is also on having `vim.pack.add()` call(s) in the config. While it is possible to install and load a plugin only for current session interactively, it is not the main use case. As far as I can tell, this PR also allows to install a plugin for only current session: `:lua register()` followed by `:lua install()`. I think the only difference is that this plugin will be automatically deleted from disk in the next session, while #34009 would not touch it and leave to the user to decided later whether they want it to be removed.\r\n\r\nSome other differences are:\r\n- This PR only allows to checkout to branch and freeze it. #34009 is designed to allow checking out to tags, commits, and specific version ranges (like check out to semver-like tag that is only for version `1.*.*`).\r\n- The #34009 main focus on action hooks is by writing autocommands and future packspec support. This PR has separate `build` in plugin spec.\r\n- Not currently implemented in #34009, but are planned (so probably can be added in this approach also, but not sure how involved you planned to be here):\r\n    - Tests: both end-to-end and for some edge cases.\r\n    - [Packspec](https://github.com/neovim/packspec) support.",
            "created_at": "2025-06-12T08:23:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965618964",
            "id": 2965618964,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6ww8EU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965618964/reactions"
            },
            "updated_at": "2025-06-12T08:23:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965618964",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "@echasnovski Is it possible with your implementation to download a plugin WITHOUT calling packadd on it? Im having issues figuring it out. It seems to me like I can only choose between `packadd` and `packadd!`. I want to just download the thing. I don't want my downloading of stuff complected in with how I load it or I get randomly blindsided by stuff that I haven't downloaded.\r\n\r\nIf I can easily download all my plugins up front without calling packadd on them, I am happy.\r\n\r\nI suppose I also don't want plugins themselves downloading things upon first load either, they should do that when I install them (for the same reason, and also auditablility).",
            "created_at": "2025-06-12T08:32:21Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965647344",
            "id": 2965647344,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxC_w",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965647344/reactions"
            },
            "updated_at": "2025-06-12T09:21:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965647344",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "In the end, this is an executive decision I don't want to get in the way of, but since I was tagged, here's my personal opinion: This PR is much closer to what I originally had in mind for a native package manager (paq.nvim vs. vim-plug, focus on low-level infrastructure for other plugin managers to build on top of), but I also have a vested interest in having a `vim.async` module in core. As I myself would not use either in my own config (very happy with my current setup), my only skin in this game is to never have to see a minimal reproducing config that starts with bootstrapping `lazy.nvim` again -- which I believe both approaches will make possible. ",
            "created_at": "2025-06-12T08:37:35Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965662762",
            "id": 2965662762,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxGwq",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965662762/reactions"
            },
            "updated_at": "2025-06-12T08:37:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965662762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I don't want my downloading of stuff complected in with how I load it ...\r\n\r\n`:packadd!` doesn't *load* plugin: i.e. it doesn't execute plugin's `plugin/` directory. All it does is including that directory in 'runtimepath' which, for example, allows its 'lua/' code to be used some time later (a.k.a. lazy loaded). To later force the 'plugin/' scripts to execute, call `vim.cmd.packadd()` directly.\r\n\r\nSo the setup can look something like this:\r\n\r\n```lua\r\n-- `:packadd` immediately\r\nvim.pack.add({ 'https://github.com/user/plugin' })\r\nrequire('plugin').setup()\r\n\r\n-- Only ensure present on disk while manually load later\r\nvim.pack.add({ 'https://github.com/user/lazy-plugin' }, { bang = true })\r\nvim.cmd('au FileType lang lua require(\"lazy-plugin\").setup()')\r\n```",
            "created_at": "2025-06-12T08:51:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965705057",
            "id": 2965705057,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxRFh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 1,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965705057/reactions"
            },
            "updated_at": "2025-06-12T08:51:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965705057",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "calling `packadd!` is meaningfully different than not calling `packadd!`\r\n\r\nIt would allow you to call require on the plugin without any of the plugins `plugin/*` scripts being loaded ever, which may lead to unintended effects, and confusion.\r\n\r\nAnd it would interfere with anything designed to load if something could not be found via require as well, such as in lze if you use the on_require handler, the config in your spec would not trigger and the plugin and ftplugin scripts would not be ran, as it was already present when it tried to require it.\r\n\r\nAs your implementation does not create ways to lazily load plugins more easily than using packadd itself, only downloading the things when you do it, [lze](https://github.com/BirdeeHub/lze) and [lz.n](https://github.com/nvim-neorocks/lz.n) will be very relevant to how people manage lazy loading going forwards, as they solve the \"multiple triggers, 1 plugin\" problem, and not being able to have full control over whether the plugin is available or not is bad for both of these solutions, and probably others.\r\n\r\nNow, of course, in both lze and lz.n you can change the load function used. You could change the load function to be a call to vim.pack.add() with the info. But then this requires more boilerplate.\r\n\r\nBoth can be extended to handle this, its not ultimately the biggest issue for either plugin, but it still has the issue of things not being downloaded until they are loaded, which I have made my stance clear on.\r\n\r\nBasically, 1 extra option should be added to allow it to not call `packadd` or `packadd!` if you dont want that. Because it is a lot easier and faster to never add something than it is to add it then remove it.\r\n\r\nAnd Im a little worried about plugins themselves making use of the package manager and the possible lazily created and downloaded node modules situation that would create",
            "created_at": "2025-06-12T09:02:46Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965742750",
            "id": 2965742750,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxaSe",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965742750/reactions"
            },
            "updated_at": "2025-06-12T09:46:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965742750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@BirdeeHub let's keep this sort of discussion on hold until the high-level decisions are made. And plugins themselves are not meant to call the plugin manager directly; dependencies are planned to be handled via spec files (which will come later).",
            "created_at": "2025-06-12T09:21:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965813750",
            "id": 2965813750,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxrn2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965813750/reactions"
            },
            "updated_at": "2025-06-12T09:21:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965813750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "I suppose that comment should probably have been on the other PR.\r\n\r\nBut we are discussing both implementations here right now, seemed reasonable.\r\n\r\nRegardless, I feel that how plugins are loaded and how plugins are downloaded are different things, and I figured I would make my opinion known before everything was implemented and merged.",
            "created_at": "2025-06-12T09:22:58Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2965821547",
            "id": 2965821547,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wxthr",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965821547/reactions"
            },
            "updated_at": "2025-06-12T09:27:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2965821547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/85372418?v=4",
                "events_url": "https://api.github.com/users/BirdeeHub/events{/privacy}",
                "followers_url": "https://api.github.com/users/BirdeeHub/followers",
                "following_url": "https://api.github.com/users/BirdeeHub/following{/other_user}",
                "gists_url": "https://api.github.com/users/BirdeeHub/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/BirdeeHub",
                "id": 85372418,
                "login": "BirdeeHub",
                "node_id": "MDQ6VXNlcjg1MzcyNDE4",
                "organizations_url": "https://api.github.com/users/BirdeeHub/orgs",
                "received_events_url": "https://api.github.com/users/BirdeeHub/received_events",
                "repos_url": "https://api.github.com/users/BirdeeHub/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/BirdeeHub/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/BirdeeHub/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/BirdeeHub",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Ok, after responding to some comments and thought about it a bit I think I will close this and focus on giving feedback on #34009 to prevent splits in effort.\r\n\r\nThanks to everybody that gave their opinion and feedback.",
            "created_at": "2025-06-12T11:18:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2966223253",
            "id": 2966223253,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6wzPmV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 4,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966223253/reactions"
            },
            "updated_at": "2025-06-12T11:18:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966223253",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Yeah, sorry about the unfortunate collision. ",
            "created_at": "2025-06-12T12:31:05Z",
            "html_url": "https://github.com/neovim/neovim/pull/34223#issuecomment-2966519670",
            "id": 2966519670,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
            "node_id": "IC_kwDOAPphoM6w0X92",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966519670/reactions"
            },
            "updated_at": "2025-06-12T12:31:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2966519670",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/34223/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/34223/commits",
    "created_at": "2025-05-29T08:27:49Z",
    "diff_url": "https://github.com/neovim/neovim/pull/34223.diff",
    "draft": false,
    "head": {
        "label": "saccarosium:vim.pack",
        "ref": "vim.pack",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/saccarosium/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/saccarosium/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/saccarosium/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/saccarosium/neovim/branches{/branch}",
            "clone_url": "https://github.com/saccarosium/neovim.git",
            "collaborators_url": "https://api.github.com/repos/saccarosium/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/saccarosium/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/saccarosium/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/saccarosium/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/saccarosium/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/saccarosium/neovim/contributors",
            "created_at": "2025-05-23T15:52:26Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/saccarosium/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/saccarosium/neovim/downloads",
            "events_url": "https://api.github.com/repos/saccarosium/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/saccarosium/neovim/forks",
            "full_name": "saccarosium/neovim",
            "git_commits_url": "https://api.github.com/repos/saccarosium/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/saccarosium/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/saccarosium/neovim/git/tags{/sha}",
            "git_url": "git://github.com/saccarosium/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/saccarosium/neovim/hooks",
            "html_url": "https://github.com/saccarosium/neovim",
            "id": 989132437,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/saccarosium/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/saccarosium/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/saccarosium/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/saccarosium/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/saccarosium/neovim/labels{/name}",
            "language": null,
            "languages_url": "https://api.github.com/repos/saccarosium/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/saccarosium/neovim/merges",
            "milestones_url": "https://api.github.com/repos/saccarosium/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOOvT2lQ",
            "notifications_url": "https://api.github.com/repos/saccarosium/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
                "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
                "followers_url": "https://api.github.com/users/saccarosium/followers",
                "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
                "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/saccarosium",
                "id": 96259932,
                "login": "saccarosium",
                "node_id": "U_kgDOBbzPXA",
                "organizations_url": "https://api.github.com/users/saccarosium/orgs",
                "received_events_url": "https://api.github.com/users/saccarosium/received_events",
                "repos_url": "https://api.github.com/users/saccarosium/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/saccarosium",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/saccarosium/neovim/pulls{/number}",
            "pushed_at": "2025-06-12T11:18:14Z",
            "releases_url": "https://api.github.com/repos/saccarosium/neovim/releases{/id}",
            "size": 314616,
            "ssh_url": "git@github.com:saccarosium/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/saccarosium/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/saccarosium/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/saccarosium/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/saccarosium/neovim/subscription",
            "svn_url": "https://github.com/saccarosium/neovim",
            "tags_url": "https://api.github.com/repos/saccarosium/neovim/tags",
            "teams_url": "https://api.github.com/repos/saccarosium/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/saccarosium/neovim/git/trees{/sha}",
            "updated_at": "2025-05-23T15:52:26Z",
            "url": "https://api.github.com/repos/saccarosium/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "1b6b4655143e810d97d7e3a33545bd1ce24e210f",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
            "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
            "followers_url": "https://api.github.com/users/saccarosium/followers",
            "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
            "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/saccarosium",
            "id": 96259932,
            "login": "saccarosium",
            "node_id": "U_kgDOBbzPXA",
            "organizations_url": "https://api.github.com/users/saccarosium/orgs",
            "received_events_url": "https://api.github.com/users/saccarosium/received_events",
            "repos_url": "https://api.github.com/users/saccarosium/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/saccarosium",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/34223",
    "id": 2551523426,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34223",
    "labels": [],
    "locked": false,
    "merge_commit_sha": null,
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6YFShi",
    "number": 34223,
    "patch_url": "https://github.com/neovim/neovim/pull/34223.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/34223/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/1b6b4655143e810d97d7e3a33545bd1ce24e210f",
    "title": "feat(vim.pack): minimal package manager",
    "updated_at": "2025-06-12T12:31:06Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/34223",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/96259932?v=4",
        "events_url": "https://api.github.com/users/saccarosium/events{/privacy}",
        "followers_url": "https://api.github.com/users/saccarosium/followers",
        "following_url": "https://api.github.com/users/saccarosium/following{/other_user}",
        "gists_url": "https://api.github.com/users/saccarosium/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/saccarosium",
        "id": 96259932,
        "login": "saccarosium",
        "node_id": "U_kgDOBbzPXA",
        "organizations_url": "https://api.github.com/users/saccarosium/orgs",
        "received_events_url": "https://api.github.com/users/saccarosium/received_events",
        "repos_url": "https://api.github.com/users/saccarosium/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/saccarosium/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/saccarosium/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/saccarosium",
        "user_view_type": "public"
    }
}