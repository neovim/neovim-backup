{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30841/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30841/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/30841"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30841"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30841/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/18924b17331d55329c344dc76a70bd23b1c30ddf"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6262,
            "forks_count": 6262,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1971,
            "open_issues_count": 1971,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-08-19T00:45:15Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 338530,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 92074,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-08-19T01:56:33Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 92074,
            "watchers_count": 92074,
            "web_commit_signoff_required": false
        },
        "sha": "052126b77ad83b1f26da46dad8c42efacffe7568",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "## Problems\r\n`vim.lsp.buf.document_highlight` was implemented quite a long time ago. Its API style differs from our latest APIs, such as `vim.lsp.inlay_hint`. I believe it's time to give it an overhaul.\r\n\r\n## Solution\r\n* Reimplement `textDocument/documentHighlight` as a standalone module, offering an API similar to `vim.lsp.document_highlight.enable()`.\r\n* Additionally, `vim.lsp.document_highlight.jump()` for jumping between highlights.\r\n\r\n[document_highlight.webm](https://github.com/user-attachments/assets/67755d5b-5084-4171-96e3-9fa2bc9dce5e)\r\n\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804542407"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804542407"
                }
            },
            "author_association": "MEMBER",
            "body": "It is better to avoid CursorMoved",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T10:46:36Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804542407",
            "id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rjyHH",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2374849028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804542407/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:23:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804542407",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804543190"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804543190"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\r\n```",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T10:47:08Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    refresh(bufnr)\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if\n+      not (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      return\n+    end\n+    refresh(bufnr)\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string?\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    local client_hilights = bufstate.client_hilights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+      -- When deleting characters at the end of a line,\n+      -- the extmark range might still remain as it was before the deletion.\n+      local max_col = #api.nvim_buf_get_lines(bufnr, row, row + 1, false)[1]\n+\n+      for _, row_highlights in pairs(client_hilights) do\n+        local highlights = row_highlights[row] or {}\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = math.min(highlight.range['end'].character, max_col)\n+          vim.api.nvim_buf_set_extmark(bufnr, namespace, row, col, {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804543190",
            "id": 1804543190,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rjyTW",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 166,
            "original_position": 166,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2374849028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804543190/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T10:47:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804543190",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804679948"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804679948"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Because `textDocument/documentHighlight` needs to get the cursor's position in the document (it is used for fuzzy matching the references of the symbol under the cursor), I don't know know to avoid it. Since LSP requests are sent asynchronously, and we are not handling its return value here, I think it shouldn't cause too much of a performance issue, but I intended to implement debouncing here. If there is a better way, please let me know.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T12:18:30Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804679948",
            "id": 1804679948,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rkTsM",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375060313,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804679948/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T12:18:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804679948",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804692852"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804692852"
                }
            },
            "author_association": "MEMBER",
            "body": "there send the current cursor position to the server. What happens when you move quickly like holding jk is that the refresh function keeps sending requests. no processing here.\r\n\r\nUse a timer here and store the last request. When it is triggered again and still within the timeout, you need to cancel the previous request and start a new timer. When the callback function is called, you also need to determine whether the cursor position is the same as the previous cursor position. This is no different from CursorHold. Users can adjust it according to updatetime",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T12:28:02Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804692852",
            "id": 1804692852,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rkW10",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375082138,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804692852/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T12:28:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804692852",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804747274"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804747274"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> there send the current cursor position to the server. What happens when you move quickly like holding jk is that the refresh function keeps sending requests. no processing here.\r\n\r\nAs mentioned earlier, this is exactly my plan (I haven't optimized the performance yet; it's currently just a rough implementation, but I intend to do so, just like the todo list above).\r\n\r\nI'm not sure if `CursorHold` is a good idea, It shouldn't be used for this purpose because we do want to trigger it after the cursor is moved. The default `updatetime` is too long for debouncing, and it's a global option that shouldn't be changed for one specific purpose.\r\n\r\nLater when this PR is ready to merge, I will request a review.\r\n\r\nEdit: checked similar plugins including `vim-illuminate` and `mini.cursorword`, they are all using `CursorMoved`.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T13:02:25Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804747274",
            "id": 1804747274,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rkkIK",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375177182,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804747274/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:05:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804747274",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804778871"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804778871"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes CursorHold is not a good idea here either. CursorMoved is also sensitive. At least you need to handle some of the behaviors I said.\r\n\r\nI'm not sure if we need this. Plugins need a certain amount of space. not all in core.  see what other member opinion :)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T13:21:26Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804778871",
            "id": 1804778871,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rkr13",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375230529,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804778871/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:22:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804778871",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804813316"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804813316"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't use a plugin for this. I have this in my config:\r\n\r\n```lua\r\n\r\nlocal function debounce(ms, fn)\r\n  local timer = assert(vim.uv.new_timer())\r\n  return function(...)\r\n    local argc, argv = select('#', ...), { ... }\r\n    timer:start(ms, 0, function()\r\n      timer:stop()\r\n      vim.schedule(function()\r\n        fn(unpack(argv, 1, argc))\r\n      end)\r\n    end)\r\n  end\r\nend\r\n\r\ndo -- textDocument/documentHighlight\r\n  local method = 'textDocument/documentHighlight'\r\n\r\n  api.nvim_create_autocmd({ 'FocusGained', 'WinEnter', 'BufEnter', 'CursorMoved', 'CursorHold', 'CursorHoldI' }, {\r\n    callback = debounce(200, function(args)\r\n      lsp.buf.clear_references()\r\n      local bufnr = args.buf --- @type integer\r\n      for _, client in ipairs(lsp.get_clients({ bufnr = bufnr })) do\r\n        if client.supports_method(method, { bufnr = bufnr }) then\r\n          local params = lsp.util.make_position_params()\r\n          client.request(method, params, nil, bufnr)\r\n        end\r\n      end\r\n    end)\r\n  })\r\n\r\n  api.nvim_create_autocmd({ 'FocusLost', 'WinLeave', 'BufLeave' }, {\r\n    callback = lsp.buf.clear_references\r\n  })\r\nend\r\n```\r\n\r\nIt's not perfect, but works well enough.\r\n\r\n[ref](https://github.com/lewis6991/dotfiles/blob/main/config/nvim/lua/lewis6991/lsp.lua)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T13:41:55Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804813316",
            "id": 1804813316,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rk0QE",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375288454,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804813316/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:42:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804813316",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804822490"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804822490"
                }
            },
            "author_association": "MEMBER",
            "body": "Tangential, but it would make sense to refactor this debounce function (which already exists somewhere in the changetracking module) and expose it. This is exactly the sort of short but non-trivial snippet that having in our stdlib would be a significant QoL improvement for the ecosystem. Fits well with `vim.schedule`, too.\r\n\r\n(Same with `memoize` and async, *ceterum censeo*.)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T13:47:15Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804822490",
            "id": 1804822490,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rk2fa",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375303738,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804822490/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:48:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804822490",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804827583"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804827583"
                }
            },
            "author_association": "MEMBER",
            "body": "Further off-topic: it would be nice to have a separate doc section for these \"functional\" libs (`defer_fn`, `schedule`, `wait`, etc.) for better discoverability.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T13:50:03Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804827583",
            "id": 1804827583,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rk3u_",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375311962,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804827583/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T13:50:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804827583",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804931842"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804931842"
                }
            },
            "author_association": "MEMBER",
            "body": "> : it would be nice to have a separate doc section for these \"functional\" libs (`defer_fn`, `schedule`, `wait`, etc.)\r\n\r\ndefer_fn, schedule, schedule_wrap, should never have been separate functions.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T14:48:30Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804931842",
            "id": 1804931842,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rlRMC",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375486260,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804931842/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T14:48:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804931842",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1804955922"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804955922"
                }
            },
            "author_association": "MEMBER",
            "body": "I think `schedule` and `schedule_wrap` work well as separate functions as they are both used plenty and they have different return types (`nil` vs `function`). It's similar to how Lua has `coroutine.wrap` vs `coroutine.create` which return `function` and `thread` respectively.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T15:03:01Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1804955922",
            "id": 1804955922,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rlXES",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375526272,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804955922/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T15:03:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804955922",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805134416"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805134416"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "In this case, I believe the closest-to-perfect solution would require resolving https://github.com/neovim/neovim/issues/27509. Other methods seem more like workarounds.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T17:12:01Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805134416",
            "id": 1805134416,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rmCpQ",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2375817829,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805134416/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T17:12:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805134416",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805320942"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805320942"
                }
            },
            "author_association": "MEMBER",
            "body": "this will have the side effect that requests triggered by other plugins or custom user functions would also trigger a new refresh - I'm not sure if that's desired?\r\n\r\nWhy is this additional LspNotify autocmd necessary?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T19:38:08Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805320942",
            "id": 1805320942,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rmwLu",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 250,
            "original_position": 195,
            "original_start_line": 181,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376119000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805320942/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-17T19:44:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805320942",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805322141"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805322141"
                }
            },
            "author_association": "MEMBER",
            "body": "The old implementation used a map for this which seems more straightforward. Any reason to change this?\r\n\r\n",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T19:38:31Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805322141",
            "id": 1805322141,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rmwed",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 214,
            "original_position": 208,
            "original_start_line": 199,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376119000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805322141/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-17T19:44:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805322141",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805325068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805325068"
                }
            },
            "author_association": "MEMBER",
            "body": "Params would need to be created per client with `client.offset_encoding` ",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-17T19:41:18Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805325068",
            "id": 1805325068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rmxMM",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 140,
            "original_position": 140,
            "original_start_line": 139,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376119000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805325068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-17T19:44:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805325068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805689225"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805689225"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "`CursorMoved` is only triggered in normal and visual modes, and will not occur in insert mode. I don't have a definitive answer here, but I think we need to choose one from `LspNotify` and `CursorMovedI`, or disable all highlights in insert mode.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T01:20:01Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805689225",
            "id": 1805689225,
            "in_reply_to_id": 1805320942,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5roKGJ",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 250,
            "original_position": 195,
            "original_start_line": 181,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376713726,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805689225/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T01:20:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805689225",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805691480"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691480"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "For `DocumentHighlight`, the standard specifies that `kind` is optional. This approach may be more straightforward than a map, as it better represents a fallback. If there are performance differences I will change this.\r\n\r\nhttps://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#documentHighlightKind",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T01:24:35Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805691480",
            "id": 1805691480,
            "in_reply_to_id": 1805322141,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5roKpY",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 214,
            "original_position": 208,
            "original_start_line": 199,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376717518,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691480/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T01:52:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691480",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805691913"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691913"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Thank you for your reminder. I haven't completed the work related to offset_encoding yet, but it's on my todo list. I will look into this.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T01:25:25Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805691913",
            "id": 1805691913,
            "in_reply_to_id": 1805325068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5roKwJ",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 140,
            "original_position": 140,
            "original_start_line": 139,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376718254,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691913/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T01:52:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805691913",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1805716128"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805716128"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "(Mark as resolved because the debounce logic has been added.)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T01:58:43Z",
            "diff_hunk": "@@ -0,0 +1,189 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+-- Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+--\n+-- Whether document highlights are enabled for this buffer,\n+-- `nil` indicates following the global state.\n+---@field enabled? boolean\n+--\n+-- Each client attached to this buffer must exists.\n+--\n+-- Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+-- Each buffer attached by at least one LSP server must exists,\n+-- otherwise it should not exists or be cleaned up.\n+--\n+-- Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    local bufstate = bufstates[bufnr] or {}\n+    local client_hilights = bufstate.client_hilights or {}\n+\n+    if not client_hilights[client.id] then\n+      client_hilights[client.id] = {}\n+    end\n+\n+    bufstate.client_hilights = client_hilights\n+    bufstates[bufnr] = bufstate\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.bufnr\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+-- |lsp-handler| for the method `textDocument/documentHighlight`\n+-- Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+api.nvim_create_autocmd('CursorMoved', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1805716128",
            "id": 1805716128,
            "in_reply_to_id": 1804542407,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5roQqg",
            "original_commit_id": "105be026703bb1e75e0c0fa871a9c996f3645e87",
            "original_line": 221,
            "original_position": 107,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2376762028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805716128/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T01:58:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1805716128",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806064900"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806064900"
                }
            },
            "author_association": "MEMBER",
            "body": "As `base` is a constant I would inline it and remove all the `string.format`'s.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:04:36Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806064900",
            "id": 1806064900,
            "in_reply_to_id": 1805322141,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpl0E",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 214,
            "original_position": 208,
            "original_start_line": 199,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377333652,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806064900/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T08:04:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806064900",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806102594"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806102594"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I initially planned to change this number because `LspReference` is ambiguous. However, I couldn't think of a better name, as `LspDocumentHighlight` is too long and unnecessary. I can change this.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:30:00Z",
            "diff_hunk": "@@ -0,0 +1,323 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or {}\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  local client_id = assert(ctx.client_id)\n+  local client_hilights = bufstate.client_hilights\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+  client_hilights[client_id] = row_highlights\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local params = util.make_position_params()\n+  vim.lsp.buf_request(bufnr, ms.textDocument_documentHighlight, params)\n+end\n+\n+local function debunce(f)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      100,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+local debounced_refresh = debunce(refresh)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806102594",
            "id": 1806102594,
            "in_reply_to_id": 1805322141,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpvBC",
            "original_commit_id": "db40ee7506eb2cfa011d4f04e3d6c87492f7d22c",
            "original_line": 214,
            "original_position": 208,
            "original_start_line": 199,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377397298,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806102594/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T08:30:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806102594",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806107955"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806107955"
                }
            },
            "author_association": "MEMBER",
            "body": "These can't be removed. They need to be deprecated first.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:33:56Z",
            "diff_hunk": "@@ -1679,60 +1678,6 @@ function M.open_floating_preview(contents, syntax, opts)\n   return floating_bufnr, floating_winnr\n end\n \n-do --[[ References ]]\n-  local reference_ns = api.nvim_create_namespace('vim_lsp_references')\n-\n-  --- Removes document highlights from a buffer.\n-  ---\n-  ---@param bufnr integer? Buffer id\n-  function M.buf_clear_references(bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806107955",
            "id": 1806107955,
            "line": 1793,
            "node_id": "PRRC_kwDOAPphoM5rpwUz",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 1793,
            "original_position": 18,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/util.lua",
            "position": 6,
            "pull_request_review_id": 2377405856,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806107955/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T08:33:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806107955",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806111044"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806111044"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think these should be created at `require` time. These should either be placed somewhere in `plugin`, or setup via some other function. Perhaps `lsp.start()`?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:36:17Z",
            "diff_hunk": "@@ -0,0 +1,350 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806111044",
            "id": 1806111044,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpxFE",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 55,
            "original_position": 55,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377410869,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806111044/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T08:36:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806111044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806114506"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806114506"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    if bufstate.enabled == nil then\r\n      return globalstate.enabled\r\n    else\r\n      return bufstate.enabled\r\n    end\r\n```",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:38:56Z",
            "diff_hunk": "@@ -0,0 +1,350 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_hilights = bufstate.client_hilights\n+  client_hilights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+    client.request(ms.textDocument_documentHighlight, params)\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_hilights = bufstate.client_hilights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_hilights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            hl_group = kind_to_hl_group(highlight.kind),\n+            ephemeral = false,\n+            end_row = end_row,\n+            end_col = end_col,\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return false\n+    end\n+\n+    if bufstates[bufnr].enabled == nil then\n+      return globalstate.enabled\n+    else\n+      return bufstates[bufnr].enabled\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806114506",
            "id": 1806114506,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpx7K",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 310,
            "original_position": 309,
            "original_start_line": 305,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377417090,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806114506/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-18T08:38:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806114506",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806115348"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806115348"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  end\r\n```\r\n\r\nDon't nest after a early return.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:39:37Z",
            "diff_hunk": "@@ -0,0 +1,350 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_hilights = bufstate.client_hilights\n+  client_hilights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+    client.request(ms.textDocument_documentHighlight, params)\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_hilights = bufstate.client_hilights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_hilights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            hl_group = kind_to_hl_group(highlight.kind),\n+            ephemeral = false,\n+            end_row = end_row,\n+            end_col = end_col,\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  else",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806115348",
            "id": 1806115348,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpyIU",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 298,
            "original_position": 298,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377418515,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806115348/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T08:39:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806115348",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806116877"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806116877"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  vim.validate('enable', enable, 'boolean', true)\r\n  vim.validate('filter', filter, 'table', true)\r\n```\r\n\r\nEasier to read and faster.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T08:40:41Z",
            "diff_hunk": "@@ -0,0 +1,350 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_hilights = bufstate.client_hilights or {}\n+    client_hilights[client_id] = {}\n+    bufstate.client_hilights = client_hilights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_hilights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_hilights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      local highlights = row_highlights[row] or {}\n+      highlights[#highlights + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_hilights = bufstate.client_hilights\n+  client_hilights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+local function refresh(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+    client.request(ms.textDocument_documentHighlight, params)\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_to_hl_group(kind)\n+  local base = 'LspReference'\n+  if kind == 2 then\n+    return string.format('%sRead', base)\n+  elseif kind == 3 then\n+    return string.format('%sWrite', base)\n+  else -- kind == 1 also the default\n+    return string.format('%sText', base)\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_hilights = bufstate.client_hilights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_hilights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            hl_group = kind_to_hl_group(highlight.kind),\n+            ephemeral = false,\n+            end_row = end_row,\n+            end_col = end_col,\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return false\n+    end\n+\n+    if bufstates[bufnr].enabled == nil then\n+      return globalstate.enabled\n+    else\n+      return bufstates[bufnr].enabled\n+    end\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate({ enable = { enable, 'boolean', true }, filter = { filter, 'table', true } })",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806116877",
            "id": 1806116877,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rpygN",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 323,
            "original_position": 323,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377421240,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806116877/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T08:42:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806116877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1806191249"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806191249"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Makes sense, but this part is likely temporary. I will add a dedicated PR for managing bufstate after a while(for this module and `inaly_hint.lua`), and the logic is based on this part, so these autocmds will be removed from this module regardless. `inlay_hint.lua` has a similar logic, so maybe in follow-up PRs for both of them? or is there any vulnerability here? ",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-18T09:31:44Z",
            "diff_hunk": "@@ -0,0 +1,350 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_hilights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or {}\n+      local client_hilights = bufstate.client_hilights or {}\n+\n+      if not client_hilights[client.id] then\n+        client_hilights[client.id] = {}\n+      end\n+\n+      bufstate.client_hilights = client_hilights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1806191249",
            "id": 1806191249,
            "in_reply_to_id": 1806111044,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rqEqR",
            "original_commit_id": "bb7d2375c8e6e8cbc54685d84627643b6bf7226c",
            "original_line": 55,
            "original_position": 55,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2377554080,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806191249/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-18T09:36:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1806191249",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807700618"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807700618"
                }
            },
            "author_association": "MEMBER",
            "body": "Please dont' use `goto`, it's extension from luajit not PUC lua 5.1",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T07:10:53Z",
            "diff_hunk": "@@ -0,0 +1,486 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end\n+    refresh(bufnr)\n+  end\n+end\n+\n+---@class vim.lsp.document_highlight.JumpOpts\n+---@inlinedoc\n+---\n+---The number of highlights to move by, starting from {pos}. A positive\n+---integer moves forward by {count} highlights, while a negative integer moves\n+---backward by {count} highlights.\n+---@field count integer\n+---\n+---Cursor position as a `(row, col)` tuple. See |nvim_win_get_cursor()|.\n+---Used to find the nearest highlight.\n+---Default is the current cursor position.\n+---@field pos? [integer,integer]\n+---\n+---Window ID\n+---(default: `0`)\n+---@field winid? integer\n+---\n+---Refresh documents highlights immediately before jumping.\n+---@field refresh? boolean\n+\n+---Move to a document highlight\n+---@param opts vim.lsp.document_highlight.JumpOpts\n+function M.jump(opts)\n+  vim.validate('opts', opts, 'table')\n+  vim.validate('count', opts.count, 'number')\n+\n+  local count = opts.count\n+\n+  local winid = opts.winid or api.nvim_get_current_win()\n+  local pos = opts.pos or api.nvim_win_get_cursor(winid)\n+  ---@cast pos [integer, integer]\n+  pos = { pos[1] - 1, pos[2] }\n+\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  if opts.refresh then\n+    refresh(bufnr, { sync = true })\n+  end\n+\n+  -- Jump forward\n+  while count > 0 do\n+    for _, row_highlights in pairs(bufstate.client_highlights) do\n+      for row = pos[1], #api.nvim_buf_get_lines(bufnr, 0, -1, true) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for i = 1, #highlights do\n+          local highlight = highlights[i]\n+\n+          if row == pos[1] then\n+            if highlight.range['start'].character > pos[2] then\n+              pos = { highlight.range['start'].line, highlight.range['start'].character }\n+              goto continue",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807700618",
            "id": 1807700618,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv1KK",
            "original_commit_id": "d6804d09bbe260b34bbaf2044bae8f8077d40f9f",
            "original_line": 439,
            "original_position": 439,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380189641,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807700618/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-20T07:11:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807700618",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728138"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728138"
                }
            },
            "author_association": "MEMBER",
            "body": "just call vim.validate once, `enable` and `filter` can be in a table ",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:27:35Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728138",
            "id": 1807728138,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv74K",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 346,
            "original_position": 357,
            "original_start_line": 356,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380247294,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728138/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:35:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728138",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728270"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728270"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    bufstate.enabled = enable ~= globalstate.enabled and enable or nil\r\n```",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:28:13Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728270",
            "id": 1807728270,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv76O",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 368,
            "original_position": 379,
            "original_start_line": 375,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380247294,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728270/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:30:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728270",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728464"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728464"
                }
            },
            "author_association": "MEMBER",
            "body": "also there just call once.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:29:21Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end\n+    refresh(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param pos [integer, integer]\n+---@param client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+---@return [integer, integer]\n+local function jump_next(bufnr, pos, client_highlights)\n+  for _, row_highlights in pairs(client_highlights) do\n+    for row = pos[1], #api.nvim_buf_get_lines(bufnr, 0, -1, true) do\n+      local highlights = row_highlights[row] or {}\n+\n+      for i = 1, #highlights do\n+        local highlight = highlights[i]\n+\n+        if row == pos[1] then\n+          if highlight.range['start'].character > pos[2] then\n+            return { highlight.range['start'].line, highlight.range['start'].character }\n+          end\n+        else\n+          return { highlight.range['start'].line, highlight.range['start'].character }\n+        end\n+      end\n+    end\n+  end\n+\n+  return pos\n+end\n+\n+---@param bufnr integer\n+---@param pos [integer, integer]\n+---@param client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+---@return [integer, integer]\n+---@diagnostic disable-next-line: unused-local\n+local function jump_prev(bufnr, pos, client_highlights)\n+  assert(bufnr) -- reserved but not used\n+\n+  -- Same logic as jump forward but in reverse\n+  for _, row_highlights in pairs(client_highlights) do\n+    for row = pos[1], 0, -1 do\n+      local highlights = row_highlights[row] or {}\n+\n+      for i = #highlights, 1, -1 do\n+        local highlight = highlights[i]\n+\n+        if row == pos[1] then\n+          if highlight.range['end'].character < pos[2] then\n+            return { highlight.range['start'].line, highlight.range['start'].character }\n+          end\n+        else\n+          return { highlight.range['start'].line, highlight.range['start'].character }\n+        end\n+      end\n+    end\n+  end\n+\n+  return pos\n+end\n+\n+---@class vim.lsp.document_highlight.JumpOpts\n+---@inlinedoc\n+---\n+---The number of highlights to move by, starting from {pos}. A positive\n+---integer moves forward by {count} highlights, while a negative integer moves\n+---backward by {count} highlights.\n+---@field count integer\n+---\n+---Cursor position as a `(row, col)` tuple. See |nvim_win_get_cursor()|.\n+---Used to find the nearest highlight.\n+---Default is the current cursor position.\n+---@field pos? [integer,integer]\n+---\n+---Window ID\n+---(default: `0`)\n+---@field winid? integer\n+---\n+---Refresh documents highlights immediately before jumping.\n+---@field refresh? boolean\n+\n+---Move to a document highlight\n+---@param opts vim.lsp.document_highlight.JumpOpts\n+function M.jump(opts)\n+  vim.validate('opts', opts, 'table')\n+  vim.validate('count', opts.count, 'number')",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807728464",
            "id": 1807728464,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv79Q",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 328,
            "original_position": 464,
            "original_start_line": 463,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380247294,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728464/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:35:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807728464",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807729309"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729309"
                }
            },
            "author_association": "MEMBER",
            "body": "No, this would revert a recent PR from @lewis6991. This was deliberate. See #30855.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:32:53Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807729309",
            "id": 1807729309,
            "in_reply_to_id": 1807728138,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv8Kd",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 346,
            "original_position": 357,
            "original_start_line": 356,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380248682,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729309/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:32:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729309",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807729643"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729643"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, it was suggested by lewis [there](https://github.com/neovim/neovim/pull/30841#discussion_r1806116877)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:35:01Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807729643",
            "id": 1807729643,
            "in_reply_to_id": 1807728138,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv8Pr",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 346,
            "original_position": 357,
            "original_start_line": 356,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380248999,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729643/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:35:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807729643",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807730112"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730112"
                }
            },
            "author_association": "MEMBER",
            "body": "np i just see the code without see more context.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:38:08Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807730112",
            "id": 1807730112,
            "in_reply_to_id": 1807728138,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv8XA",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 346,
            "original_position": 357,
            "original_start_line": 356,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380250532,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730112/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:38:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730112",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807730115"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730115"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is not correct. `and ... or` is not equivalent to the regular ternary operation. In `condition and expr1 or expr2`, if the value of `expr1` can be `nil` or `false`, regardless of the result of `condition`, the obtained value will always be `expr2`. This is what I deliberately want to avoid.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:38:10Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807730115",
            "id": 1807730115,
            "in_reply_to_id": 1807728270,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv8XD",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 368,
            "original_position": 379,
            "original_start_line": 375,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380250537,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730115/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:38:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807730115",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r1807731350"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807731350"
                }
            },
            "author_association": "MEMBER",
            "body": "aha I remember encountering a similar nil trap but I forgot about it. it should be avoided. enable always has a boolean available i think, we have `vim.F.if_nil`",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2024-10-20T08:44:23Z",
            "diff_hunk": "@@ -0,0 +1,502 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+local namespace = api.nvim_create_namespace('vim_lsp_document_highlight')\n+local augroup = api.nvim_create_augroup('vim_lsp_document_highlight', {})\n+\n+local globalstate = {\n+  enabled = false,\n+}\n+\n+---Buffer-local state for document highlights\n+---@class (private) vim.lsp.document_highlight.BufState\n+---\n+---Whether document highlights are enabled for this buffer,\n+---`nil` indicates following the global state.\n+---@field enabled? boolean\n+---\n+---Each data change generates a unique version,\n+---not garanteed, numbers may be reused over time.\n+---@field version integer\n+---\n+---Latest `version` with data applied.\n+---@field applied? integer\n+---\n+---Each client attached to this buffer must exists.\n+---\n+---Index in the form of client_id -> (row -> highlights)\n+---@field client_highlights table<integer, table<integer, lsp.DocumentHighlight[]?>?>\n+\n+---Each buffer attached by at least one supported LSP server must exists,\n+---otherwise it should not exists or be cleaned up.\n+---\n+---Index in the form of bufnr -> bufstate\n+---@type table<integer, vim.lsp.document_highlight.BufState?>\n+local bufstates = {}\n+for _, client in ipairs(vim.lsp.get_clients()) do\n+  for _, bufnr in ipairs(vim.lsp.get_buffers_by_client_id(client.id)) do\n+    if client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr }) then\n+      local bufstate = bufstates[bufnr] or { version = 0 }\n+      local client_highlights = bufstate.client_highlights or {}\n+\n+      if not client_highlights[client.id] then\n+        client_highlights[client.id] = {}\n+      end\n+\n+      bufstate.client_highlights = client_highlights\n+      bufstates[bufnr] = bufstate\n+    end\n+  end\n+end\n+api.nvim_create_autocmd('LspAttach', {\n+  group = augroup,\n+  callback = function(args)\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    if\n+      not assert(vim.lsp.get_client_by_id(client_id)).supports_method(\n+        ms.textDocument_documentHighlight\n+      )\n+    then\n+      return\n+    end\n+\n+    ---@type integer\n+    local bufnr = args.buf\n+    local bufstate = bufstates[bufnr] or { version = 0 }\n+    bufstates[bufnr] = bufstate\n+\n+    local client_highlights = bufstate.client_highlights or {}\n+    client_highlights[client_id] = {}\n+    bufstate.client_highlights = client_highlights\n+\n+    api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function()\n+        bufstates[bufnr] = nil\n+      end,\n+    })\n+  end,\n+})\n+api.nvim_create_autocmd('LspDetach', {\n+  group = augroup,\n+  callback = function(args)\n+    -- bufnr may not exists if the buffer is already unloaded\n+    ---@type integer?\n+    local bufnr = args.bufnr\n+    if not bufnr then\n+      return\n+    end\n+    local bufstate = assert(bufstates[bufnr])\n+\n+    ---@type integer\n+    local client_id = args.data.client_id\n+    bufstate.client_highlights[client_id] = nil\n+    if vim.tbl_isempty(bufstate.client_highlights) then\n+      bufstates[bufnr] = nil\n+    end\n+  end,\n+})\n+\n+---|lsp-handler| for the method `textDocument/documentHighlight`\n+---Store hints for a specific buffer and client\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function M.on_document_highlight(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local client_id = assert(ctx.client_id)\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+\n+  ---@type table<integer, lsp.DocumentHighlight[]?>\n+  local row_highlights = {}\n+  for _, highlight in pairs(result or {}) do\n+    highlight.range['start'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['start'], client.offset_encoding)\n+    highlight.range['end'].character =\n+      util._get_line_byte_from_position(bufnr, highlight.range['end'], client.offset_encoding)\n+\n+    for row = highlight.range['start'].line, highlight.range['end'].line do\n+      -- `highlights` is sorted by `highlight.range['start'].character`\n+      local highlights = row_highlights[row] or {}\n+      ---@type integer\n+      local pos = 0\n+      for i = #highlights, 1, -1 do\n+        if highlight.range['start'].character > highlights[i].range['start'].character then\n+          pos = i\n+          break\n+        end\n+      end\n+      highlights[pos + 1] = highlight\n+      row_highlights[row] = highlights\n+    end\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  local client_highlights = bufstate.client_highlights\n+  client_highlights[client_id] = row_highlights\n+  bufstate.version = (bufstate.version + 1) % 8\n+\n+  api.nvim__redraw({ buf = bufnr, valid = true })\n+end\n+\n+---@param bufnr integer\n+---@param opts? {client_id?: integer, sync?: boolean}\n+local function refresh(bufnr, opts)\n+  local bufstate = assert(bufstates[bufnr])\n+  local enabled = bufstate.enabled\n+  if enabled == nil then\n+    enabled = globalstate.enabled\n+  end\n+\n+  if not enabled then\n+    api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+    api.nvim__redraw({ buf = bufnr, valid = true })\n+    return\n+  end\n+\n+  opts = opts or {}\n+\n+  ---@type vim.lsp.Client[]\n+  local clients\n+  if opts.client_id then\n+    clients = { assert(vim.lsp.get_client_by_id(opts.client_id)) }\n+  else\n+    clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_documentHighlight })\n+  end\n+\n+  for _, client in ipairs(clients) do\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    if opts.sync then\n+      local response = client.request_sync(ms.textDocument_documentHighlight, params, nil, bufnr)\n+      if response == nil then\n+        return\n+      end\n+\n+      M.on_document_highlight(\n+        response.err,\n+        response.result,\n+        { bufnr = bufnr, client_id = client.id, method = ms.textDocument_documentHighlight }\n+      )\n+    else\n+      client.request(ms.textDocument_documentHighlight, params, nil, bufnr)\n+    end\n+  end\n+end\n+\n+---@param f function\n+---@param timeout integer\n+local function debunce(f, timeout)\n+  ---@type uv.uv_timer_t?\n+  local timer = nil\n+  return function(...)\n+    local args = { ... }\n+    if timer then\n+      vim.uv.timer_stop(timer)\n+      timer:close()\n+      timer = nil\n+    end\n+    timer = assert(vim.uv.new_timer())\n+    vim.uv.timer_start(\n+      timer,\n+      timeout,\n+      0,\n+      vim.schedule_wrap(function()\n+        timer:close()\n+        timer = nil\n+        f(unpack(args))\n+      end)\n+    )\n+  end\n+end\n+\n+-- The interval for reporting keyboard events is usually 30ms,\n+-- 100ms is a reasonable value to debounce the cursor movement.\n+local debounced_refresh = debunce(refresh, 100)\n+\n+api.nvim_create_autocmd('CursorMoved', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on cursor movement',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    if bufstates[bufnr] then\n+      debounced_refresh(bufnr)\n+    end\n+  end,\n+})\n+api.nvim_create_autocmd('LspNotify', {\n+  group = augroup,\n+  desc = 'Refresh document highlights on document change or open',\n+  callback = function(args)\n+    ---@type integer\n+    local bufnr = args.buf\n+    local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+    if\n+      bufstates[bufnr]\n+      and client.supports_method(ms.textDocument_documentHighlight, { bufnr = bufnr })\n+      and (\n+        args.data.method == ms.textDocument_didChange\n+        or args.data.method == ms.textDocument_didOpen\n+      )\n+    then\n+      refresh(bufnr, { client_id = client.id })\n+    end\n+  end,\n+})\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function hl_group_from_kind(kind)\n+  if kind == 2 then\n+    return 'LspReferenceRead'\n+  elseif kind == 3 then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if bufstate.version == bufstate.applied then\n+      return\n+    end\n+\n+    local enabled = bufstate.enabled\n+    if enabled == nil then\n+      enabled = globalstate.enabled\n+    end\n+\n+    if not enabled then\n+      return\n+    end\n+\n+    local client_highlights = bufstate.client_highlights\n+\n+    for row = toprow, botrow do\n+      api.nvim_buf_clear_namespace(bufnr, namespace, row, row + 1)\n+\n+      for _, row_highlights in pairs(client_highlights) do\n+        local highlights = row_highlights[row] or {}\n+\n+        for _, highlight in pairs(highlights) do\n+          local col = highlight.range['start'].character\n+          local end_row = highlight.range['end'].line\n+          local end_col = highlight.range['end'].character\n+\n+          api.nvim_buf_set_extmark(bufnr, namespace, row, col, {\n+            end_row = end_row,\n+            end_col = end_col,\n+            ephemeral = false,\n+            hl_group = hl_group_from_kind(highlight.kind),\n+          })\n+        end\n+      end\n+    end\n+\n+    bufstate.applied = bufstate.version\n+  end,\n+})\n+\n+---Optional filters |kwargs|, or `nil` for all.\n+---@class vim.lsp.document_highlight.enable.Filter\n+---@inlinedoc\n+---\n+---Buffer number, or 0 for current buffer, or nil for all.\n+---@field bufnr? integer\n+\n+---Query whether document highlight is enabled in the {filter}ed scope\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+---@return boolean\n+function M.is_enabled(filter)\n+  vim.validate({ filter = { filter, 'table', true } })\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    return globalstate.enabled\n+  end\n+\n+  bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return false\n+  end\n+\n+  if bufstate.enabled == nil then\n+    return globalstate.enabled\n+  else\n+    return bufstate.enabled\n+  end\n+end\n+\n+---Enables or disables document highlights for the {filter}ed scope.\n+---\n+---To \"toggle\", pass the inverse of `is_enabled()`:\n+---\n+---```lua\n+---vim.lsp.document_highlight.enable(not vim.lsp.document_highlight.is_enabled())\n+---```\n+---@param enable? boolean\n+---@param filter? vim.lsp.document_highlight.enable.Filter\n+function M.enable(enable, filter)\n+  vim.validate('enable', enable, 'boolean', true)\n+  vim.validate('filter', filter, 'table', true)\n+  enable = enable == nil or enable\n+  filter = filter or {}\n+\n+  local bufnr = filter.bufnr\n+  if bufnr == nil then\n+    globalstate.enabled = enable\n+    for b, bufstate in pairs(bufstates) do\n+      bufstate.enabled = nil\n+      refresh(b)\n+    end\n+  else\n+    bufnr = bufnr == 0 and api.nvim_get_current_buf() or bufnr\n+    local bufstate = bufstates[bufnr]\n+    if not bufstate then\n+      return\n+    end\n+\n+    if enable == globalstate.enabled then\n+      bufstate.enabled = nil\n+    else\n+      bufstate.enabled = enable\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r1807731350",
            "id": 1807731350,
            "in_reply_to_id": 1807728270,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rv8qW",
            "original_commit_id": "ab8040a320cedc77bb31f6adcba054b24629e746",
            "original_line": 368,
            "original_position": 379,
            "original_start_line": 375,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": null,
            "pull_request_review_id": 2380252075,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807731350/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-10-20T08:45:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1807731350",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
                "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
                "followers_url": "https://api.github.com/users/glepnir/followers",
                "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
                "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/glepnir",
                "id": 41671631,
                "login": "glepnir",
                "node_id": "MDQ6VXNlcjQxNjcxNjMx",
                "organizations_url": "https://api.github.com/users/glepnir/orgs",
                "received_events_url": "https://api.github.com/users/glepnir/received_events",
                "repos_url": "https://api.github.com/users/glepnir/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/glepnir",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189852983"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189852983"
                }
            },
            "author_association": "MEMBER",
            "body": "what does `jump({})` with no options do? ",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T11:59:30Z",
            "diff_hunk": "@@ -1941,6 +1924,23 @@ on_publish_diagnostics({_}, {params}, {ctx})\n        {ctx}     (`lsp.HandlerContext`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.document_highlight                *lsp-document_highlight*\n+\n+jump({opts})                               *vim.lsp.document_highlight.jump()*",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189852983",
            "id": 2189852983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ChoE3",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 1983,
            "original_position": 38,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2993509347,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189852983/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T11:59:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189852983",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189855183"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189855183"
                }
            },
            "author_association": "MEMBER",
            "body": "should this mention `false` ?\n```suggestion\n  vim.deprecate('vim.lsp.buf.clear_references()', 'vim.lsp.document_highlight.enable(false)', '0.12')\n```",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T12:00:48Z",
            "diff_hunk": "@@ -1059,13 +1059,14 @@ end\n ---         |hl-LspReferenceText|\n ---         |hl-LspReferenceRead|\n ---         |hl-LspReferenceWrite|\n+--- @deprecated\n function M.document_highlight()\n-  lsp.buf_request(0, ms.textDocument_documentHighlight, client_positional_params())\n+  vim.deprecate('vim.lsp.buf.document_highlight()', 'vim.lsp.document_highlight.enable()', '0.12')\n end\n \n---- Removes document highlights from current buffer.\n+--- @deprecated\n function M.clear_references()\n-  util.buf_clear_references()\n+  vim.deprecate('vim.lsp.buf.clear_references()', 'vim.lsp.document_highlight.enable()', '0.12')",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189855183",
            "id": 2189855183,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ChonP",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 1069,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/buf.lua",
            "position": null,
            "pull_request_review_id": 2993512788,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189855183/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T12:00:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189855183",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189858675"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189858675"
                }
            },
            "author_association": "MEMBER",
            "body": "how does one \"show a list of doc highlights\" without this?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T12:02:54Z",
            "diff_hunk": "@@ -1735,18 +1735,22 @@ do --[[ References ]]\n \n   --- Removes document highlights from a buffer.\n   ---\n+  ---@deprecated\n   ---@param bufnr integer? Buffer id\n   function M.buf_clear_references(bufnr)\n+    vim.deprecate('vim.lsp.util.buf_clear_references()', 'nil', '0.12')\n     api.nvim_buf_clear_namespace(bufnr or 0, reference_ns, 0, -1)\n   end\n \n   --- Shows a list of document highlights for a certain buffer.\n   ---\n+  ---@deprecated\n   ---@param bufnr integer Buffer id\n   ---@param references lsp.DocumentHighlight[] objects to highlight\n   ---@param position_encoding 'utf-8'|'utf-16'|'utf-32'\n   ---@see https://microsoft.github.io/language-server-protocol/specification/#textDocumentContentChangeEvent\n   function M.buf_highlight_references(bufnr, references, position_encoding)\n+    vim.deprecate('vim.lsp.util.buf_highlight_references()', 'nil', '0.12')",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189858675",
            "id": 2189858675,
            "line": 1807,
            "node_id": "PRRC_kwDOAPphoM6Chpdz",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 1807,
            "original_position": 19,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/util.lua",
            "position": 19,
            "pull_request_review_id": 2993518522,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189858675/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T12:02:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189858675",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189861612"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189861612"
                }
            },
            "author_association": "MEMBER",
            "body": "expect dedents the screen, so this could be indented more nicely :)",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T12:04:30Z",
            "diff_hunk": "@@ -0,0 +1,183 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local t_lsp = require('test.functional.plugin.lsp.testutil')\n+local Screen = require('test.functional.ui.screen')\n+\n+local dedent = t.dedent\n+local eq = t.eq\n+\n+local api = n.api\n+local exec_lua = n.exec_lua\n+local insert = n.insert\n+\n+local clear_notrace = t_lsp.clear_notrace\n+local create_server_definition = t_lsp.create_server_definition\n+\n+describe('vim.lsp.document_highlight', function()\n+  local text = dedent([[\n+global = _G\n+\n+local variable = global\n+\n+if variable == global then\n+\n+end\n+]])\n+\n+  local grid_without_highlights = [[\n+  global = _G                                          |\n+                                                       |\n+  local variable = global                              |\n+                                                       |\n+  if variable == global then                           |\n+                                                       |\n+  end                                                  |\n+  ^                                                     |\n+  {2:~                                                    }|*5\n+                                                       |\n+]]\n+\n+  local grid_with_highlights = [[\n+  {1:global} = _G                                          |\n+                                                       |\n+  local variable = {1:global}                              |\n+                                                       |\n+  if variable == {1:global} then                           |\n+                                                       |\n+  end                                                  |\n+  ^                                                     |\n+  {2:~                                                    }|*5\n+                                                       |\n+]]\n+\n+  --- @type test.functional.ui.screen\n+  local screen\n+\n+  --- @type integer\n+  local client_id\n+\n+  --- @type integer\n+  local bufnr\n+\n+  before_each(function()\n+    clear_notrace()\n+    exec_lua(create_server_definition)\n+\n+    screen = Screen.new()\n+    screen:set_default_attr_ids({\n+      [1] = { foreground = Screen.colors.Grey0, background = Screen.colors.LightGrey },\n+      [2] = { bold = true, foreground = Screen.colors.Blue1 },\n+    })\n+\n+    bufnr = n.api.nvim_get_current_buf()\n+    client_id = exec_lua(function()\n+      _G.server = _G._create_server({\n+        capabilities = {\n+          documentHighlightProvider = true,\n+        },\n+        handlers = {\n+          ['textDocument/documentHighlight'] = function(_, _, callback)\n+            callback(nil, {\n+              {\n+                kind = 3,\n+                range = {\n+                  ['end'] = {\n+                    character = 6,\n+                    line = 0,\n+                  },\n+                  start = {\n+                    character = 0,\n+                    line = 0,\n+                  },\n+                },\n+              },\n+              {\n+                kind = 2,\n+                range = {\n+                  ['end'] = {\n+                    character = 23,\n+                    line = 2,\n+                  },\n+                  start = {\n+                    character = 17,\n+                    line = 2,\n+                  },\n+                },\n+              },\n+              {\n+                kind = 2,\n+                range = {\n+                  ['end'] = {\n+                    character = 21,\n+                    line = 4,\n+                  },\n+                  start = {\n+                    character = 15,\n+                    line = 4,\n+                  },\n+                },\n+              },\n+            })\n+          end,\n+        },\n+      })\n+\n+      return vim.lsp.start({ name = 'dummy', cmd = _G.server.cmd })\n+    end)\n+\n+    insert(text)\n+\n+    screen:expect({ grid = grid_with_highlights })\n+  end)\n+\n+  after_each(function()\n+    api.nvim_exec_autocmds('VimLeavePre', { modeline = false })\n+  end)\n+\n+  it('clears document highlights when sole client detaches', function()\n+    exec_lua(function()\n+      vim.lsp.stop_client(client_id)\n+    end)\n+\n+    screen:expect({ grid = grid_without_highlights })\n+  end)\n+\n+  describe('jump()', function()\n+    it('jumpts to the last highlight', function()\n+      exec_lua(function()\n+        vim.lsp.document_highlight.jump({ count = 999 })\n+      end)\n+      screen:expect([[\n+  {1:global} = _G                                          |",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189861612",
            "id": 2189861612,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ChqLs",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 151,
            "original_position": 151,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/document_highlight_spec.lua",
            "position": null,
            "pull_request_review_id": 2993523240,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189861612/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T12:04:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189861612",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189862203"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189862203"
                }
            },
            "author_association": "MEMBER",
            "body": "using dedent() so can indent this ?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T12:04:53Z",
            "diff_hunk": "@@ -0,0 +1,183 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local t_lsp = require('test.functional.plugin.lsp.testutil')\n+local Screen = require('test.functional.ui.screen')\n+\n+local dedent = t.dedent\n+local eq = t.eq\n+\n+local api = n.api\n+local exec_lua = n.exec_lua\n+local insert = n.insert\n+\n+local clear_notrace = t_lsp.clear_notrace\n+local create_server_definition = t_lsp.create_server_definition\n+\n+describe('vim.lsp.document_highlight', function()\n+  local text = dedent([[\n+global = _G",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189862203",
            "id": 2189862203,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6ChqU7",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 18,
            "original_position": 18,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/document_highlight_spec.lua",
            "position": null,
            "pull_request_review_id": 2993524205,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189862203/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T12:04:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189862203",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2189864887"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189864887"
                }
            },
            "author_association": "MEMBER",
            "body": "does the new enable() need some parts of this doc ?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-07T12:06:25Z",
            "diff_hunk": "@@ -1059,13 +1059,14 @@ end\n ---         |hl-LspReferenceText|\n ---         |hl-LspReferenceRead|\n ---         |hl-LspReferenceWrite|",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2189864887",
            "id": 2189864887,
            "line": 1076,
            "node_id": "PRRC_kwDOAPphoM6Chq-3",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 1076,
            "original_position": 3,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/buf.lua",
            "position": 3,
            "pull_request_review_id": 2993528915,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189864887/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-07T12:06:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2189864887",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2215311988"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2215311988"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This function just adds the document highlights where they need to be, and doesn't really \"show a list\". I could add a function similar to `vim.diagnostic.setqflist()`, just `like vim.lsp.document_highglight.jump()` is to `vim.diagnostic.jump()`. But I doubt this would be of much use, since `vim.lsp.buf.references()` does almost the same (though not identical) thing.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-18T07:59:13Z",
            "diff_hunk": "@@ -1735,18 +1735,22 @@ do --[[ References ]]\n \n   --- Removes document highlights from a buffer.\n   ---\n+  ---@deprecated\n   ---@param bufnr integer? Buffer id\n   function M.buf_clear_references(bufnr)\n+    vim.deprecate('vim.lsp.util.buf_clear_references()', 'nil', '0.12')\n     api.nvim_buf_clear_namespace(bufnr or 0, reference_ns, 0, -1)\n   end\n \n   --- Shows a list of document highlights for a certain buffer.\n   ---\n+  ---@deprecated\n   ---@param bufnr integer Buffer id\n   ---@param references lsp.DocumentHighlight[] objects to highlight\n   ---@param position_encoding 'utf-8'|'utf-16'|'utf-32'\n   ---@see https://microsoft.github.io/language-server-protocol/specification/#textDocumentContentChangeEvent\n   function M.buf_highlight_references(bufnr, references, position_encoding)\n+    vim.deprecate('vim.lsp.util.buf_highlight_references()', 'nil', '0.12')",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2215311988",
            "id": 2215311988,
            "in_reply_to_id": 2189858675,
            "line": 1807,
            "node_id": "PRRC_kwDOAPphoM6ECvp0",
            "original_commit_id": "600b3dcc4dca8ed878fab025dfcce6b647c73878",
            "original_line": 1807,
            "original_position": 19,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/util.lua",
            "position": 19,
            "pull_request_review_id": 3032444853,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2215311988/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-18T07:59:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2215311988",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2224207418"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224207418"
                }
            },
            "author_association": "MEMBER",
            "body": "generally want to avoid setting up global handlers on module-load. should this be in enable() somewhere ?",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-23T02:56:37Z",
            "diff_hunk": "@@ -0,0 +1,430 @@\n+local bit = require('bit')\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local protocol = require('vim.lsp.protocol')\n+local ms = require('vim.lsp.protocol').Methods\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+\n+local Capability = require('vim.lsp._capability')\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.document_highlight.Highlight\n+---@field kind lsp.DocumentHighlightKind\n+---@field range Range4\n+\n+---@class (private) vim.lsp.document_highlight.ClientState\n+---@field namespace integer\n+---@field highlights vim.lsp.document_highlight.Highlight[]\n+---@field version integer\n+\n+---@class (private) vim.lsp.document_highlight.State : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.document_highlight.State?>\n+---@field client_state table<integer, vim.lsp.document_highlight.ClientState?>\n+---@field timer uv.uv_timer_t\n+---@field version integer\n+local State = { name = 'document_highlight', active = {} }\n+State.__index = State\n+setmetatable(State, Capability)\n+\n+--- Do a binary search of the highlights in the half-open range [lo, hi).\n+---\n+--- Return the index i in range such that\n+--- highlights[j].range.end < (row, col) for all j < i, and\n+--- highlights[j].range.end >= (row, col) for all j >= i,\n+--- or return hi if no such index is found.\n+---@param highlights vim.lsp.document_highlight.Highlight\n+---@param row integer\n+---@param col integer\n+---@param lo integer\n+---@param hi integer\n+local function lower_bound(highlights, row, col, lo, hi)\n+  while lo < hi do\n+    local mid = bit.rshift(lo + hi, 1) -- Equivalent to floor((lo + hi) / 2).\n+    if Range.cmp_pos.lt(highlights[mid].range[3], highlights[mid].range[4], row, col) then\n+      lo = mid + 1\n+    else\n+      hi = mid\n+    end\n+  end\n+  return lo\n+end\n+\n+--- Do a binary search of the highlights in the half-open range [lo, hi).\n+---\n+--- Return the index i in range such that\n+--- highlights[j].range.start <= (row, col) for all j < i, and\n+--- highlights[j].range.start > (row, col) for all j >= i,\n+--- or return hi if no such index is found.\n+---@param highlights vim.lsp.document_highlight.Highlight\n+---@param row integer\n+---@param col integer\n+---@param lo integer\n+---@param hi integer\n+local function upper_bound(highlights, row, col, lo, hi)\n+  while lo < hi do\n+    local mid = bit.rshift(lo + hi, 1) -- Equivalent to floor((lo + hi) / 2).\n+    if Range.cmp_pos.lt(row, col, highlights[mid].range[1], highlights[mid].range[2]) then\n+      hi = mid\n+    else\n+      lo = mid + 1\n+    end\n+  end\n+  return lo\n+end\n+\n+--- Return 0-based cursor position\n+---\n+---@param winid? integer\n+local function cursor_pos(winid)\n+  local line, col = unpack(api.nvim_win_get_cursor(winid or api.nvim_get_current_win()))\n+  return line - 1, col\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.document_highlight.State\n+function State:new(bufnr)\n+  self = Capability.new(self, bufnr)\n+  self.version = 0\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function()\n+      local state = State.active[bufnr]\n+      if not state then\n+        return true\n+      end\n+      if M.is_enabled({ bufnr = bufnr }) then\n+        state:update()\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = self.augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      if M.is_enabled({ bufnr = bufnr }) then\n+        self:on_cursor_moved()\n+      end\n+    end,\n+  })\n+\n+  return self\n+end\n+\n+---@package\n+---@param client_id integer\n+function State:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    self.client_state[client_id] = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.document_highlight:' .. client_id),\n+      highlights = {},\n+      version = 0,\n+    }\n+  end\n+end\n+\n+---@package\n+---@param client_id integer\n+function State:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    self.client_state[client_id] = nil\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    api.nvim__redraw({ buf = self.bufnr, valid = true, flush = false })\n+  end\n+end\n+\n+---@package\n+function State:on_cursor_moved()\n+  local row, col = cursor_pos(api.nvim_get_current_win())\n+  --- Clear and re-request document highlights\n+  --- only when the cursor moves outside the current highlight range.\n+  --- This avoids the illusion of lag and reduces unnecessary resource usage.\n+  local update = false\n+  for _, state in pairs(self.client_state) do\n+    local highlights = state.highlights\n+    local i = lower_bound(state.highlights, row, col, 1, #highlights)\n+    local range = highlights[i] and highlights[i].range\n+\n+    if not range or not Range.contains(range, { row, col, row, col }) then\n+      api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+      update = true\n+    end\n+  end\n+  if update then\n+    self:update()\n+  end\n+end\n+\n+---@package\n+function State:reset()\n+  self.version = 0\n+  for _, state in pairs(self.client_state) do\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    state.highlights = {}\n+    state.version = 0\n+  end\n+end\n+\n+---@package\n+function State:update()\n+  self.version = bit.band(self.version + 1, 0xffffffff)\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+    -- In most environments,\n+    -- holding down a key triggers repeated input every 3040ms,\n+    -- so a debounce value of 50ms is sufficient.\n+  end, 50)\n+end\n+\n+---@private\n+function State:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n+    end\n+  end\n+end\n+\n+---Store highlights for a specific buffer and client\n+---@package\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function State:handler(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n+  end\n+\n+  local client = assert(vim.lsp.get_client_by_id(ctx.client_id))\n+  ---@type vim.lsp.document_highlight.Highlight[]\n+  local highlights = {}\n+  for _, raw in ipairs(result or {}) do\n+    highlights[#highlights + 1] = {\n+      kind = raw.kind,\n+      range = {\n+        raw.range['start'].line,\n+        util._get_line_byte_from_position(self.bufnr, raw.range['start'], client.offset_encoding),\n+        raw.range['end'].line,\n+        util._get_line_byte_from_position(self.bufnr, raw.range['end'], client.offset_encoding),\n+      },\n+    }\n+  end\n+  table.sort(highlights, function(a, b)\n+    return Range.cmp_pos.lt(a.range[3], a.range[4], b.range[1], b.range[2])\n+  end)\n+\n+  state.highlights = highlights\n+  state.version = self.version\n+\n+  api.nvim__redraw({ buf = self.bufnr, valid = true })\n+end\n+\n+---@package\n+---@param client_id? integer\n+function State:request(client_id)\n+  local method = ms.textDocument_documentHighlight\n+\n+  for id in pairs(client_id and { client_id } or self.client_state) do\n+    local client = assert(vim.lsp.get_client_by_id(id))\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    util._cancel_requests({\n+      bufnr = self.bufnr,\n+      clients = { client },\n+      method = method,\n+      type = 'pending',\n+    })\n+\n+    client:request(method, params, function(...)\n+      self:handler(...)\n+    end, self.bufnr)\n+  end\n+end\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_hl(kind)\n+  if kind == protocol.DocumentHighlightKind.Read then\n+    return 'LspReferenceRead'\n+  elseif kind == protocol.DocumentHighlightKind.Write then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function State:on_win(toprow, botrow)\n+  for _, state in pairs(self.client_state) do\n+    -- Buffer changes may invalidate the original highlight ranges,\n+    -- never set outdated highlights as extmarks.\n+    if state.version == self.version then\n+      api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+\n+      -- Only set extmarks for visible lines\n+      local highlights = state.highlights\n+      local first = lower_bound(highlights, toprow, 0, 1, #highlights + 1)\n+      local last = upper_bound(highlights, botrow, math.huge, first, #highlights + 1) - 1\n+\n+      for i = first, last do\n+        local row, col, end_row, end_col = Range.unpack4(highlights[i].range)\n+\n+        api.nvim_buf_set_extmark(self.bufnr, state.namespace, row, col, {\n+          end_row = end_row,\n+          end_col = end_col,\n+          hl_group = kind_hl(highlights[i].kind),\n+          -- Although we want to avoid\n+          -- showing outdated document highlights when the cursor moves,\n+          -- updating highlights after a document change\n+          -- requires waiting for the server's response.\n+          -- This delay can cause flickering, so we don't use ephemeral extmarks here.\n+          ephemeral = false,\n+        })\n+      end\n+    end\n+  end\n+end\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.document_highlight')\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2224207418",
            "id": 2224207418,
            "line": 262,
            "node_id": "PRRC_kwDOAPphoM6EkrY6",
            "original_commit_id": "6b6d8e01647ee6a32a120e981b99b721fe8af67c",
            "original_line": 262,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": 262,
            "pull_request_review_id": 3045405993,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224207418/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-23T02:56:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224207418",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2224682875"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224682875"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think the effect is the same, because `set_decoration_provider` can only be set globally, which means that as long as `enable()` is called, it will also be set globally and there is no way to remove it, which is the same as setting it when loading the module.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-23T07:36:13Z",
            "diff_hunk": "@@ -0,0 +1,430 @@\n+local bit = require('bit')\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local protocol = require('vim.lsp.protocol')\n+local ms = require('vim.lsp.protocol').Methods\n+local Range = require('vim.treesitter._range')\n+local api = vim.api\n+\n+local Capability = require('vim.lsp._capability')\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.document_highlight.Highlight\n+---@field kind lsp.DocumentHighlightKind\n+---@field range Range4\n+\n+---@class (private) vim.lsp.document_highlight.ClientState\n+---@field namespace integer\n+---@field highlights vim.lsp.document_highlight.Highlight[]\n+---@field version integer\n+\n+---@class (private) vim.lsp.document_highlight.State : vim.lsp.Capability\n+---@field active table<integer, vim.lsp.document_highlight.State?>\n+---@field client_state table<integer, vim.lsp.document_highlight.ClientState?>\n+---@field timer uv.uv_timer_t\n+---@field version integer\n+local State = { name = 'document_highlight', active = {} }\n+State.__index = State\n+setmetatable(State, Capability)\n+\n+--- Do a binary search of the highlights in the half-open range [lo, hi).\n+---\n+--- Return the index i in range such that\n+--- highlights[j].range.end < (row, col) for all j < i, and\n+--- highlights[j].range.end >= (row, col) for all j >= i,\n+--- or return hi if no such index is found.\n+---@param highlights vim.lsp.document_highlight.Highlight\n+---@param row integer\n+---@param col integer\n+---@param lo integer\n+---@param hi integer\n+local function lower_bound(highlights, row, col, lo, hi)\n+  while lo < hi do\n+    local mid = bit.rshift(lo + hi, 1) -- Equivalent to floor((lo + hi) / 2).\n+    if Range.cmp_pos.lt(highlights[mid].range[3], highlights[mid].range[4], row, col) then\n+      lo = mid + 1\n+    else\n+      hi = mid\n+    end\n+  end\n+  return lo\n+end\n+\n+--- Do a binary search of the highlights in the half-open range [lo, hi).\n+---\n+--- Return the index i in range such that\n+--- highlights[j].range.start <= (row, col) for all j < i, and\n+--- highlights[j].range.start > (row, col) for all j >= i,\n+--- or return hi if no such index is found.\n+---@param highlights vim.lsp.document_highlight.Highlight\n+---@param row integer\n+---@param col integer\n+---@param lo integer\n+---@param hi integer\n+local function upper_bound(highlights, row, col, lo, hi)\n+  while lo < hi do\n+    local mid = bit.rshift(lo + hi, 1) -- Equivalent to floor((lo + hi) / 2).\n+    if Range.cmp_pos.lt(row, col, highlights[mid].range[1], highlights[mid].range[2]) then\n+      hi = mid\n+    else\n+      lo = mid + 1\n+    end\n+  end\n+  return lo\n+end\n+\n+--- Return 0-based cursor position\n+---\n+---@param winid? integer\n+local function cursor_pos(winid)\n+  local line, col = unpack(api.nvim_win_get_cursor(winid or api.nvim_get_current_win()))\n+  return line - 1, col\n+end\n+\n+---@package\n+---@param bufnr integer\n+---@return vim.lsp.document_highlight.State\n+function State:new(bufnr)\n+  self = Capability.new(self, bufnr)\n+  self.version = 0\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_lines = function()\n+      local state = State.active[bufnr]\n+      if not state then\n+        return true\n+      end\n+      if M.is_enabled({ bufnr = bufnr }) then\n+        state:update()\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('CursorMoved', {\n+    group = self.augroup,\n+    buffer = bufnr,\n+    callback = function()\n+      if M.is_enabled({ bufnr = bufnr }) then\n+        self:on_cursor_moved()\n+      end\n+    end,\n+  })\n+\n+  return self\n+end\n+\n+---@package\n+---@param client_id integer\n+function State:on_attach(client_id)\n+  local state = self.client_state[client_id]\n+  if not state then\n+    self.client_state[client_id] = {\n+      namespace = api.nvim_create_namespace('nvim.lsp.document_highlight:' .. client_id),\n+      highlights = {},\n+      version = 0,\n+    }\n+  end\n+end\n+\n+---@package\n+---@param client_id integer\n+function State:on_detach(client_id)\n+  local state = self.client_state[client_id]\n+  if state then\n+    self.client_state[client_id] = nil\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    api.nvim__redraw({ buf = self.bufnr, valid = true, flush = false })\n+  end\n+end\n+\n+---@package\n+function State:on_cursor_moved()\n+  local row, col = cursor_pos(api.nvim_get_current_win())\n+  --- Clear and re-request document highlights\n+  --- only when the cursor moves outside the current highlight range.\n+  --- This avoids the illusion of lag and reduces unnecessary resource usage.\n+  local update = false\n+  for _, state in pairs(self.client_state) do\n+    local highlights = state.highlights\n+    local i = lower_bound(state.highlights, row, col, 1, #highlights)\n+    local range = highlights[i] and highlights[i].range\n+\n+    if not range or not Range.contains(range, { row, col, row, col }) then\n+      api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+      update = true\n+    end\n+  end\n+  if update then\n+    self:update()\n+  end\n+end\n+\n+---@package\n+function State:reset()\n+  self.version = 0\n+  for _, state in pairs(self.client_state) do\n+    api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+    state.highlights = {}\n+    state.version = 0\n+  end\n+end\n+\n+---@package\n+function State:update()\n+  self.version = bit.band(self.version + 1, 0xffffffff)\n+  self:reset_timer()\n+  self.timer = vim.defer_fn(function()\n+    self:request()\n+    -- In most environments,\n+    -- holding down a key triggers repeated input every 3040ms,\n+    -- so a debounce value of 50ms is sufficient.\n+  end, 50)\n+end\n+\n+---@private\n+function State:reset_timer()\n+  local timer = self.timer\n+  if timer then\n+    self.timer = nil\n+    if not timer:is_closing() then\n+      timer:stop()\n+      timer:close()\n+    end\n+  end\n+end\n+\n+---Store highlights for a specific buffer and client\n+---@package\n+---@param result? lsp.DocumentHighlight[]\n+---@param ctx lsp.HandlerContext\n+function State:handler(err, result, ctx)\n+  if err then\n+    log.error('document highlight', err)\n+  end\n+\n+  local state = self.client_state[ctx.client_id]\n+  if not state then\n+    return\n+  end\n+\n+  local client = assert(vim.lsp.get_client_by_id(ctx.client_id))\n+  ---@type vim.lsp.document_highlight.Highlight[]\n+  local highlights = {}\n+  for _, raw in ipairs(result or {}) do\n+    highlights[#highlights + 1] = {\n+      kind = raw.kind,\n+      range = {\n+        raw.range['start'].line,\n+        util._get_line_byte_from_position(self.bufnr, raw.range['start'], client.offset_encoding),\n+        raw.range['end'].line,\n+        util._get_line_byte_from_position(self.bufnr, raw.range['end'], client.offset_encoding),\n+      },\n+    }\n+  end\n+  table.sort(highlights, function(a, b)\n+    return Range.cmp_pos.lt(a.range[3], a.range[4], b.range[1], b.range[2])\n+  end)\n+\n+  state.highlights = highlights\n+  state.version = self.version\n+\n+  api.nvim__redraw({ buf = self.bufnr, valid = true })\n+end\n+\n+---@package\n+---@param client_id? integer\n+function State:request(client_id)\n+  local method = ms.textDocument_documentHighlight\n+\n+  for id in pairs(client_id and { client_id } or self.client_state) do\n+    local client = assert(vim.lsp.get_client_by_id(id))\n+    local params = util.make_position_params(0, client.offset_encoding)\n+\n+    util._cancel_requests({\n+      bufnr = self.bufnr,\n+      clients = { client },\n+      method = method,\n+      type = 'pending',\n+    })\n+\n+    client:request(method, params, function(...)\n+      self:handler(...)\n+    end, self.bufnr)\n+  end\n+end\n+\n+---@param kind lsp.DocumentHighlightKind\n+---@return string\n+local function kind_hl(kind)\n+  if kind == protocol.DocumentHighlightKind.Read then\n+    return 'LspReferenceRead'\n+  elseif kind == protocol.DocumentHighlightKind.Write then\n+    return 'LspReferenceWrite'\n+  else -- kind == 1 also the default\n+    return 'LspReferenceText'\n+  end\n+end\n+\n+---@package\n+---@param toprow integer\n+---@param botrow integer\n+function State:on_win(toprow, botrow)\n+  for _, state in pairs(self.client_state) do\n+    -- Buffer changes may invalidate the original highlight ranges,\n+    -- never set outdated highlights as extmarks.\n+    if state.version == self.version then\n+      api.nvim_buf_clear_namespace(self.bufnr, state.namespace, 0, -1)\n+\n+      -- Only set extmarks for visible lines\n+      local highlights = state.highlights\n+      local first = lower_bound(highlights, toprow, 0, 1, #highlights + 1)\n+      local last = upper_bound(highlights, botrow, math.huge, first, #highlights + 1) - 1\n+\n+      for i = first, last do\n+        local row, col, end_row, end_col = Range.unpack4(highlights[i].range)\n+\n+        api.nvim_buf_set_extmark(self.bufnr, state.namespace, row, col, {\n+          end_row = end_row,\n+          end_col = end_col,\n+          hl_group = kind_hl(highlights[i].kind),\n+          -- Although we want to avoid\n+          -- showing outdated document highlights when the cursor moves,\n+          -- updating highlights after a document change\n+          -- requires waiting for the server's response.\n+          -- This delay can cause flickering, so we don't use ephemeral extmarks here.\n+          ephemeral = false,\n+        })\n+      end\n+    end\n+  end\n+end\n+\n+local namespace = api.nvim_create_namespace('nvim.lsp.document_highlight')\n+api.nvim_set_decoration_provider(namespace, {\n+  on_win = function(_, _, bufnr, toprow, botrow)",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2224682875",
            "id": 2224682875,
            "in_reply_to_id": 2224207418,
            "line": 262,
            "node_id": "PRRC_kwDOAPphoM6Emfd7",
            "original_commit_id": "6b6d8e01647ee6a32a120e981b99b721fe8af67c",
            "original_line": 262,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/document_highlight.lua",
            "position": 262,
            "pull_request_review_id": 3046061098,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224682875/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-23T07:36:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2224682875",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2241341928"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241341928"
                }
            },
            "author_association": "MEMBER",
            "body": "is it enabled by default? if so should mention it here.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-30T01:29:41Z",
            "diff_hunk": "@@ -216,6 +216,9 @@ LSP\n   https://microsoft.github.io/language-server-protocol/specification/#textDocument_linkedEditingRange\n  Support for related documents in pull diagnostics:\n   https://microsoft.github.io/language-server-protocol/specifications/specification-current/#relatedFullDocumentDiagnosticReport\n+ Re-implemented support for `textDocument/documentHighlight",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2241341928",
            "id": 2241341928,
            "line": 231,
            "node_id": "PRRC_kwDOAPphoM6FmCno",
            "original_commit_id": "513def74f1a180be6b36f8aab60ad14b01251316",
            "original_line": 231,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": 4,
            "pull_request_review_id": 3069653971,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241341928/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-30T01:29:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241341928",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30841#discussion_r2241342323"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30841"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241342323"
                }
            },
            "author_association": "MEMBER",
            "body": "add a `@brief` to the lua module to give a small overview of this feature.",
            "commit_id": "18924b17331d55329c344dc76a70bd23b1c30ddf",
            "created_at": "2025-07-30T01:30:07Z",
            "diff_hunk": "@@ -1940,6 +1924,50 @@ on_publish_diagnostics({_}, {params}, {ctx})\n        {ctx}     (`lsp.HandlerContext`)\n \n \n+==============================================================================\n+Lua module: vim.lsp.document_highlight                *lsp-document_highlight*\n+",
            "html_url": "https://github.com/neovim/neovim/pull/30841#discussion_r2241342323",
            "id": 2241342323,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM6FmCtz",
            "original_commit_id": "513def74f1a180be6b36f8aab60ad14b01251316",
            "original_line": 1825,
            "original_position": 47,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 3069654399,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241342323/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-30T01:30:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2241342323",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "> but like `vim.lsp.inlay_hint`, this API needs to manage an independent `bufstate`. We can explore solutions such as [Lua: store metatables on vim.b/vim.w/vim.t/vim.v scopes#12544](https://github.com/neovim/neovim/issues/12544) or refactor LSP `bufstate` management into a standalone module (since the lifecycle of these variables is tied to events like `LspAttach` and `LspDetach`)\r\n\r\nIf there is a common pattern amongst these lsp modules then yes they should use a single common lsp-internal-only module that implements this. Several of these lsp modules have implemented their own long-lived \"lifecycle\" maps, and that is not something that should be reinvented in each.",
            "created_at": "2024-10-17T10:42:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2419180757",
            "id": 2419180757,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QMcTV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2419180757/reactions"
            },
            "updated_at": "2024-10-17T10:42:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2419180757",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Feels to me that the decision when to show the highlights is something users might want to control. This has somehow different semantics than something like semantic tokens given that it's position dependant\r\n\r\nThere is indeed a certain issue with flexibility, and this is the key to the problem, but I have long-term goals regarding this. I have previously noticed that a considerable number of people want to customize the display of inlay hints, as evidenced by the strong reactions and numerous approvals in https://github.com/neovim/neovim/issues/28261, but we did not find a solution.\r\n\r\nIn LSP, the three methods have similarities, besides the `textDocument/documentHighlight` that is being attempted to change here, they also include `textDocument/inlayHint` and `textDocument/codeLens`. If they are all implemented by the decoration provider. then we have enough reason to provide a unified interface, something like `on_decorate`, for all three methods. This is one of my long-term goals.\r\n\r\nAlthough many people want to define the way highlights are displayed, I don't believe there are as many people who want to manage `bufstate`, which is the management of how this data to be displayed is updated, this is just cumbersome work. This part is handled by our traditional `lsp-handler`, which is easy for users to modify, that's good, but modifying them doesn't make sense for the three LSP methods I mentioned earlier, so users either have to use built-in features that cannot be customized or completely take over the implementation of these requests, which is why I believe there is a necessity for `on_decorate`.\r\n\r\nAs for the management of bufstate, I also have some ideas. Similar to what @justinmk mentioned earlier, I plan to refactor an internal-only `vim.lsp._state` module to manage the lifecycle of bufstate required for `textDocument/documentHighlight`, `textDocument/inlayHint`, and `textDocument/codeLens`. This will greatly allow us to reuse code while improving flexibility.",
            "created_at": "2024-10-18T01:49:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2421066482",
            "id": 2421066482,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QTory",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421066482/reactions"
            },
            "updated_at": "2024-10-18T01:49:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421066482",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have completed the minimum target functionality, please feel free to review or test this PR. I have not written a standalone test module for nvim yet, so adding tests will take some time.",
            "created_at": "2024-10-18T09:34:46Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2421973932",
            "id": 2421973932,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QXGOs",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421973932/reactions"
            },
            "updated_at": "2024-10-18T09:34:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421973932",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I have previously noticed that a considerable number of people want to customize the display of inlay hints, as evidenced by the strong reactions and numerous approvals in #28261, but we did not find a solution.\r\n\r\nIt also wasn't a goal to find one that makes customization easier than what's already possible.\r\n\r\nIf we wanted to find a way to customize the highlighting of all inlay_hints, document_highlights and code_lens then I'm not sure if this should depend on all of them having a decoration provider implementation. As that's also a bit implementation specific and I'm not sure if that aspect should leak to users.\r\n\r\nI also question a bit if that should be a goal, given that there aren't that many options on how to display them within the constraints from the specification.\r\n\r\n>  If they are all implemented by the decoration provider. then we have enough reason to provide a unified interface, something like on_decorate, for all three methods. This is one of my long-term goals.\r\n\r\nCan you give a bit of a peek how this would look like - and also how a supposed `lsp._state` would look like?\r\n\r\nBoth codelens and inlay-hints have the resolve request addition, that's one of the reasons they need dedicated state management and why a decoration provider makes sense to me as it allows to restrict resolving items to the active view-port which helps performance. Document highlights don't have that requirement and that made the implementation so far a lot simpler. The autocmds and highlights were sufficient.\r\n\r\n\r\nDon't get me wrong, I'm not opposed to changing stuff around to enable new functionality or make the setup easier. But so far this seems to me a bit solution oriented and I'm missing why we'd incur churn for users when in the end some might even loose functionality they currently make use of and the implementation is more complex than before.\r\n",
            "created_at": "2024-10-18T09:36:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2421977938",
            "id": 2421977938,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QXHNS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421977938/reactions"
            },
            "updated_at": "2024-10-18T09:40:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2421977938",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> As for the management of bufstate, I also have some ideas. Similar to what @justinmk mentioned earlier, I plan to refactor an internal-only `vim.lsp._state` module to manage the lifecycle of bufstate\r\n\r\nWouldn't it make sense to start with that (separate PR)? There are at least 2 lsp modules that could be refactored to use this. That is a more targeted change, that is also useful for future lsp work.",
            "created_at": "2024-10-18T10:23:07Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422108262",
            "id": 2422108262,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QXnBm",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422108262/reactions"
            },
            "updated_at": "2024-10-18T10:23:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422108262",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Both codelens and inlay-hints have the resolve request addition, that's one of the reasons they need dedicated state management and why a decoration provider makes sense to me as it allows to restrict resolving items to the active view-port which helps performance. Document highlights don't have that requirement and that made the implementation so far a lot simpler. The autocmds and highlights were sufficient.\r\n\r\nSo I think our disagreement lies in whether to manage the state of document highlights? I have two reasons for supporting this.\r\n\r\nFunctionally, it allows us to provide some more advanced features, such as jumping to the previous highlighted location or jumping to the next highlighted location, which was in the previous to-do list, but I think it might be an independent PR, so I deleted it. Explaining why this feature is useful and why it needs to be implemented could take quite a long time; I can explain it in another PR. It is important to note that this is not functionally overlapping with `vim.lsp.buf.references`, as it provides fuzzy matching, and if the state is saved, its implementation would be quite simple.\r\n\r\nFor complexity, the complexity of the current implementation comes from the management of bufstate. If it is not managed by it, all implementations will become very simple. In fact, I have already implemented my ideas and logic for managing them in this PR.\r\n\r\n> and also how a supposed `lsp._state` would look like?\r\n\r\n> Wouldn't it make sense to start with that (separate PR)? \r\n\r\nOK, I will freeze this PR now and start with this.",
            "created_at": "2024-10-18T11:13:45Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422225732",
            "id": 2422225732,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QYDtE",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422225732/reactions"
            },
            "updated_at": "2024-10-18T11:13:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422225732",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> So I think our disagreement lies in whether to manage the state of document highlights? \r\n\r\nMostly. autocmds are implicit state of enabled/disabled and the decoration provider doesn't bring any benefits over setting the highlights in the callback given that highlights tend to be few. \r\n\r\n> Functionally, it allows us to provide some more advanced features, such as jumping to the previous highlighted location or jumping to the next highlighted location, which was in the previous to-do list, but I think it might be an independent PR, so I deleted it\r\n\r\nThis doesn't need state management either but can be done by firing new requests. I did that in nvim-overfly:\r\n\r\nhttps://github.com/mfussenegger/nvim-overfly/blob/48df0c67ff59d0550ff306579e8aa4e9193b665f/lua/overfly.lua#L5-L60\r\n\r\nIf you'd base it on the state you'd have the disadvantage that it has higher latency if the highlighting refresh is debounced. E.g. if you move a cursor you'd have to wait the 200ms or whatever to get the correct state for the current variable under the cursor.",
            "created_at": "2024-10-18T11:19:29Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422235794",
            "id": 2422235794,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QYGKS",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422235794/reactions"
            },
            "updated_at": "2024-10-18T11:31:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422235794",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> such as jumping to the previous highlighted location or jumping to the next highlighted location\r\n\r\nThat is indeed a compelling use case (but of course not at _any_ cost). In general, it's better to work \"inside out\", starting with the low-level functionality (but providing a roadmap either in the PR description or in a tracking issue) and moving to the user-facing features rather than doing \"vertical slices\".",
            "created_at": "2024-10-18T11:20:35Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422237781",
            "id": 2422237781,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QYGpV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422237781/reactions"
            },
            "updated_at": "2024-10-18T11:20:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422237781",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> This doesn't need state management either but can be done by firing new requests. I did that in nvim-overfly:\r\n\r\nThis is also an example of why I think should be implemented by storing. If it is sync, it will block; if it is async, the cursor may be unexpectedly moved after the user moves. Using state to implement both cases can avoid this, and most importantly, it ensures what you see is what you get.\r\n\r\n> but of course not at any cost\r\n\r\nAnd this is the key, costless except for the state, while state management has other more important reasons to be implemented.\r\n\r\n> starting with the low-level functionality (but providing a roadmap either in the PR description or in a tracking issue) and moving to the user-facing features rather than doing \"vertical slices\".\r\n\r\nMake sense.\r\n",
            "created_at": "2024-10-18T11:34:41Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422262883",
            "id": 2422262883,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QYMxj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422262883/reactions"
            },
            "updated_at": "2024-10-18T11:34:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422262883",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> If it is sync, it will block; if it is async, the cursor may be unexpectedly moved after the user moves\r\n\r\nAt least with luals, pylsp and eclipse.jdt.ls the move happens pretty much instant in my experience with overfly. No blocking noticable.\r\nI also often use it before the highlight based on a CursorHold kicks in, but if you wanted to ensure that what you see is what you get: the state would also already be there in the form of extmarks. (`:Inspect` shows the document highlights) - One could also use them to jump to the next extmark with a given namespace/highlight group. That could even be generalized if desired.\r\nThat said, to me jumping based on a deferred highlight state would be a Verschlimmbesserung and I'd stick with the overfly implementation as it doesn't have the debounce latency.\r\n\r\nTo summarize my points:\r\n\r\n- The state already exists as aucmds or extmarks and we'd be duplicating it - that is required to some degree for inlay hints and code-lens due to the resolve logic, but not for document highlights.\r\n\r\n- If the main problem is that it's too much effort to enable document highlight we could either:\r\n    - consider enabling it by default (disable: via changing capabilities or clearing a augroup)\r\n    - have a .enable()/.is_enabled based on autocmd/augroups without additional state\r\n\r\n- If the main motivation is the jump/move:\r\n    - Could be based on extmarks\r\n    - Could be based on dedicated request\r\n    - Or something that aligns with future vim.jump plans (e.g. `vim.jump(vim.lsp.doc_hl.get({ direction = 1 })[1])`)\r\n\r\n\r\nAnd to address the mentioned problems:\r\n\r\n> Its API style differs from our latest APIs, such as vim.lsp.inlay_hint\r\n\r\nIt still matches the other `lsp.buf.` functions and there are no plans to move every function into a dedicated module.\r\nThat said, if we do end up with a .enable/.is_enabled it may be warranted to change the API surface, but that doesn't require changing the implementation approach.\r\n\r\n> It's just a simple function, requiring users to create their own autocmds or bind keymaps. It's not ready-to-use out of the box. Perhaps this is why I rarely see people using it\r\n\r\nIt's not clear if that is a discoverability problem or if people regard installing a plugin as easier than setting up two autocmds. See above for potential solutions.\r\n\r\n> Its current implementation does not offer greater extensibility;\r\n\r\nIs this in regards to move/jump or are there other concrete cases you have in mind?\r\n\r\n\r\n> It relies on functions in vim.lsp.util, adding complexity, which we are now striving to avoid\r\n\r\nFair point, but the .util functions could simply be inlined without changing the overall approach.\r\nThere's no reason `buf.clear_references()` needs to forward to `util.buf_clear_references()` instead of doing the work directly.\r\n\r\n> It doesn't leverage the advantages of our more advanced APIs, such as nvim_set_decoration_provider.\r\n\r\nNot leveraging a more advanced API is not a problem by itself. Only if there are shortcomings that would be solved by switching to a different API. Are there any?\r\n",
            "created_at": "2024-10-18T13:53:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422534183",
            "id": 2422534183,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QZPAn",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422534183/reactions"
            },
            "updated_at": "2024-10-18T14:17:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422534183",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I must admit that it is still too early to discuss features like `vim.lsp.document_highlight.jump`. My starting point is that providing this feature is simple, but right now I have no way to confirm this because the preliminary work planned has not been completed. Once these goals are achieved, I will try to answer the questions raised by @mfussenegger.\r\n\r\nMy current planned roadmap:\r\n\r\n- [ ] `vim.lsp._state`, which is confirmed to be necessary, will provide it in a PR that refactors `inlay_hint.lua`.\r\n- [ ] Add `enable` and `is_enabled` for `vim.lsp.codelens`. Based on previous discussions, I think we agreed that `enable` and `is_enable` is an acceptable interface and codelens is suitable for utilizing `nvim_set_decoration_provider`, right? This will be a separate PR.\r\n- [ ] Complete this PR. May implement `jump` here to check whether it's worth.\r\n- [ ] Implement `textDocument/foldingRange`, provide something like `vim.lsp.foldexpr`. Surprise! I also have plans to implement new features, and this feature's implementation should based on `vim.lsp._state`.\r\n- [ ] Explore `vim.lsp.config`. One major feature that `textDocument/foldingRange` can bring is automatic folding of imports. We definitely need an interface to configure it if the feature was implemented, this can be done in a separate module, but I think if we have a lot of `enable` and `is_enable`, a unified interface should be valuable.\r\n\r\nI believe the goals to be implemented mentioned above won't be too complex, while also adhering to the code standards here. I hope nvim can maintain high extensibility while also being more out of the box, which is why I am not creating a standalone plugin or just implementing it casually in my dotfiles. Of course, this is all contingent on the agreement of you maintainers.",
            "created_at": "2024-10-18T16:32:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2422844517",
            "id": 2422844517,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6Qaaxl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422844517/reactions"
            },
            "updated_at": "2024-10-18T16:32:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2422844517",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> It's not clear if that is a discoverability problem or if people regard installing a plugin as easier than setting up two autocmds.\r\n\r\nAs a regular user, I'm fine with setting up the autocmds. However, I still prefer using a plugin. IMO, the current (from master) suggested setup has two main limitations:\r\n1. Since it uses the `CursorHold` event, if the cursor moves too fast, multiple regions may be highlighted (which has been addressed in this discussion)\r\n2. Since the other autocmd uses the `CursorMoved` event, references are often cleared unnecessarily (i.e., when moving within the same word)",
            "created_at": "2024-10-19T15:23:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2423963158",
            "id": 2423963158,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6Qer4W",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2423963158/reactions"
            },
            "updated_at": "2024-10-19T15:23:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2423963158",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/84649544?v=4",
                "events_url": "https://api.github.com/users/igorlfs/events{/privacy}",
                "followers_url": "https://api.github.com/users/igorlfs/followers",
                "following_url": "https://api.github.com/users/igorlfs/following{/other_user}",
                "gists_url": "https://api.github.com/users/igorlfs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/igorlfs",
                "id": 84649544,
                "login": "igorlfs",
                "node_id": "MDQ6VXNlcjg0NjQ5NTQ0",
                "organizations_url": "https://api.github.com/users/igorlfs/orgs",
                "received_events_url": "https://api.github.com/users/igorlfs/received_events",
                "repos_url": "https://api.github.com/users/igorlfs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/igorlfs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/igorlfs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/igorlfs",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@igorlfs This is not our point of divergence. I believe we have reached a consensus that it is necessary to provide an `enable()` interface to enable directly, and our current discussion focuses on the implementation method.\r\n\r\nI force-pushed with `vim.lsp.document_highlight.jump` implemented.\r\n\r\n> That said, to me jumping based on a deferred highlight state would be a Verschlimmbesserung and I'd stick with the overfly implementation as it doesn't have the debounce latency.\r\n\r\nThis potential issue has been resolved in there (it's not complicated). I implemented it because I currently need this feature, and I am still trying to implement `vim.lsp._state`.\r\n\r\n\r\n",
            "created_at": "2024-10-20T06:54:06Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-2424666902",
            "id": 2424666902,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6QhXsW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2424666902/reactions"
            },
            "updated_at": "2024-10-20T06:57:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2424666902",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I'm currently working on this PR again because #34639 will resolve #31453, which blocked this PR.\r\n\r\nInterestingly, when I created this PR, I had just started contributing to Neovim and was not very familiar with the code elsewhere. Now that I have picked up this PR again, I find that its internal logic has many similarities with `vim.lsp.semantic_tokens`, even though I had not read it when I created this PR.\r\n\r\nI am now a bit more confident in advancing the LSP data cache module.",
            "created_at": "2025-06-25T09:45:17Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3004130568",
            "id": 3004130568,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM6zD2UI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 4,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3004130568/reactions"
            },
            "updated_at": "2025-06-25T10:01:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3004130568",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have rechecked most of the logic in this PR, and it is now significantly different from the earliest version (nearly a year ago). I believe it is ready to be merged/reviewed.",
            "created_at": "2025-07-18T08:38:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3088530467",
            "id": 3088530467,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM64Fzwj",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3088530467/reactions"
            },
            "updated_at": "2025-07-18T08:38:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3088530467",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> What's a bit of a bummer is that this is taking away the possibility for users to define there own trigger for the document highlight.\r\n\r\nExposing a trigger API isnt hardits basically done. We can just expose `State:update()`. The current auto trigger already calls it; our autocmd is simply more finegrained than what most users would write themselves. Debounce still works if users call `State:update()` themselves.\r\n\r\nTheres friction between customizable and works out of the box. For LSP features I favor the latter because the protocol seems not very extensible and not fully controlled by the open source community. The friction isnt com form effort, Im happy to implement it, but is it seem that we dont want a swarm of APIs, so we have to choice between something customizable (`vim.lsp.buf.document_highlight()`) and something out of the box (`vim.lsp.document_highlight.enable()`). Correct me if Im wrong.\r\n\r\nI think most users call `vim.lsp.buf.document_highlight()` to repeat the same logic for the same purpose, rather than to truly customize it. If theres any common usage that isnt covered yet, its probably pause/resume. I can add that API as well, it wouldnt make things significantly more complex.\r\n\r\n> Also - does the window decoration code have a performance advantage for the document highlights? There are usually not too many highlight references and the logic of `buf_highlight_references` was rather simple, compared to what we have now. (40 lines vs. 430)\r\n\r\nThe core logic is about 200 lines, mainly because we need to store results instead of discarding them right after setting them. This isnt just for the decoration provider; it is also for supporting `jump()`. And on top of that, its straightforward to add other features like the update() and resume() I mentioned above. Im no expert on extmarks, but according to my understanding of the docs, decoration provider should improve some performance, or at least not make it worse.\r\n\r\nRegarding performance, you probably know Im working on the LSP data caching modulethats also why I picked up this PR. Its not only because the two areas overlap, but because Im interested in implementing `partialResultParams`. I plan to explore `partialResultParams` on top of `vim.lsp.Capability`, and since document highlight supports `partialResultParams`, it feels like a good place to start. This should also bring some performance gains. That said, whats a bit frustrating is that Im still struggling with the details of how to implement such a module, so I havent been able to start on it yet.",
            "created_at": "2025-07-23T14:07:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3108822093",
            "id": 3108822093,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM65TNxN",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3108822093/reactions"
            },
            "updated_at": "2025-07-23T14:07:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3108822093",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Theres friction between customizable and works out of the box. For LSP features I favor the latter\r\n\r\nYes, most LSP features just won't be used if they don't work automatically. Though we also want to provide the \"framework\" part of `vim.lsp` where possible.\r\n\r\nThis is a feature that I never tried, so it's cool to have it working by default.\r\n\r\nHowever, I am surprised to see so much new code in this PR, if it's replacing an existing feature. If features were added, the PR description (and news.txt) would benefit from mentioning that. Is there code that can/will be eliminated too?",
            "created_at": "2025-07-24T01:55:35Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3111692553",
            "id": 3111692553,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM65eKkJ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3111692553/reactions"
            },
            "updated_at": "2025-07-24T01:56:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3111692553",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I re-checked this PR, and I feel that there is not much code that can be eliminated without cost.\r\n\r\nSome code could be eliminated, or reused with refactoring, mainly:\r\n1. Two binary searches for `Range` and `Pos`. This part of the code can be shared with other modules, but we currently lack such modules (https://github.com/neovim/neovim/issues/25509)\r\n2. The debounce logic is to prevent too many requests from being sent too frequently. I hope to solve this problem while solving the LSP data module.\r\n3. `enable()`, mainly because of the docstring. I am currently planning to extract a common function in https://github.com/neovim/neovim/pull/35018 to avoid us repeating documents with almost the same meaning.\r\n\r\nExcluding the above three parts, even if the documentation comments and docstrings are kept like any other module, this is only about 200 lines of code. But I don't think such a sacrifice is effective, because the logic here is already quite simple, but it is not reflected in the number of lines of code.\r\n\r\nI have an update to news.txt, and mentioned that this module is re-implemented, because it can be seen by the tag `lsp-document_highlight` in news.txt, so I didn't write a separate entry for completely new features like `jump()`, I just updated the description of this PR. For new features, I do want to add a `pause()` to keep the highlight content unchanged, which is not very complicated and does not add too much code, but out of caution in providing APIs, I think it should be discussed separately.",
            "created_at": "2025-07-26T09:58:04Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3121579369",
            "id": 3121579369,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM66D4Vp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3121579369/reactions"
            },
            "updated_at": "2025-07-26T09:58:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3121579369",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Two binary searches for `Range` and `Pos`. This part of the code can be shared with other modules, but we currently lack such modules ([Lua: Position / Range abstraction (vim.pos.Pos)#25509](https://github.com/neovim/neovim/issues/25509))\r\n\r\nCan you move those utils to something like `vim._pos` ? Even if they deal with lsp-specific positions, we want to start accumulating position-related code in one place.\r\n\r\n> The debounce logic is to prevent too many requests from being sent too frequently. I hope to solve this problem while solving the LSP data module.\r\n\r\nI thought we had a common throttle or debounce util somewhere, but don't see it. Would be nice to add that to `vim._util` if you can, but if it slows you down too much we can leave it as a TODO.\r\n\r\n> `enable()`, mainly because of the docstring. I am currently planning to extract a common function in [refactor(lsp): centralized enable/is_enabled strategy#35018](https://github.com/neovim/neovim/pull/35018) to avoid us repeating documents with almost the same meaning.\r\n\r\nnice!",
            "created_at": "2025-07-30T01:34:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3134588486",
            "id": 3134588486,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM661gZG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3134588486/reactions"
            },
            "updated_at": "2025-07-30T01:34:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3134588486",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Regarding performance, you probably know Im working on the LSP data caching modulethats also why I picked up this PR. Its not only because the two areas overlap, but because Im interested in implementing partialResultParams. I plan to explore partialResultParams on top of vim.lsp.Capability, and since document highlight supports partialResultParams, it feels like a good place to start. This should also bring some performance gains. That said, whats a bit frustrating is that Im still struggling with the details of how to implement such a module, so I havent been able to start on it yet.\r\n\r\nThis still doesn't explain to me why we need the decoration provider. My understanding is that the decoration provider is useful to limit highlighting to the active region. That seems useful if you'd otherwise highlight a lot more - e.g. like in the semantic token case where it is the entire file.\r\n\r\nIn the case of document highlights you typically have < 10. Maybe with rare extreme cases going up to 100 or so.\r\nLooking up the state if you could make a few vim.hl.range calls doesn't seem like the right trade-off. That's at least my intuition, that's why I was asking for numbers. If we add lots of logic to replace much simpler logic, there should be a good rationale.",
            "created_at": "2025-07-30T13:12:38Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3136300668",
            "id": 3136300668,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM668CZ8",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3136300668/reactions"
            },
            "updated_at": "2025-07-30T13:12:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3136300668",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I don't know if the added complexity of the decoration provider refers to using the api itself, or if you think we can reduce other logic by not using it. The callback of the decoration provider itself is about 30 lines, so simply replacing it with set_extmark or hl.range wouldn't be very effective, and it is not costly for a theoretical performance improvement, though not critical in practice, as you said. My preference for this API mainly lies in its separation of display logic and data updates, which makes the overall logic feel clearer to me. This is just my superficial understanding, I'm not insisting on using it, but I just want to make sure how I should modify the code.",
            "created_at": "2025-07-30T14:23:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/30841#issuecomment-3136594021",
            "id": 3136594021,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
            "node_id": "IC_kwDOAPphoM669KBl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3136594021/reactions"
            },
            "updated_at": "2025-07-30T14:23:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3136594021",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/30841/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/30841/commits",
    "created_at": "2024-10-17T10:22:31Z",
    "diff_url": "https://github.com/neovim/neovim/pull/30841.diff",
    "draft": false,
    "head": {
        "label": "ofseed:reimplement-document-highlight",
        "ref": "reimplement-document-highlight",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/ofseed/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/ofseed/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/ofseed/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/ofseed/neovim/branches{/branch}",
            "clone_url": "https://github.com/ofseed/neovim.git",
            "collaborators_url": "https://api.github.com/repos/ofseed/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/ofseed/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/ofseed/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/ofseed/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/ofseed/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/ofseed/neovim/contributors",
            "created_at": "2021-11-30T18:13:03Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/ofseed/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/ofseed/neovim/downloads",
            "events_url": "https://api.github.com/repos/ofseed/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/ofseed/neovim/forks",
            "full_name": "ofseed/neovim",
            "git_commits_url": "https://api.github.com/repos/ofseed/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/ofseed/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/ofseed/neovim/git/tags{/sha}",
            "git_url": "git://github.com/ofseed/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/ofseed/neovim/hooks",
            "html_url": "https://github.com/ofseed/neovim",
            "id": 433537354,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/ofseed/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/ofseed/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/ofseed/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/ofseed/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/ofseed/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/ofseed/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/ofseed/neovim/merges",
            "milestones_url": "https://api.github.com/repos/ofseed/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGddBSg",
            "notifications_url": "https://api.github.com/repos/ofseed/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/ofseed/neovim/pulls{/number}",
            "pushed_at": "2025-08-18T15:46:14Z",
            "releases_url": "https://api.github.com/repos/ofseed/neovim/releases{/id}",
            "size": 329291,
            "ssh_url": "git@github.com:ofseed/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/ofseed/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/ofseed/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/ofseed/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/ofseed/neovim/subscription",
            "svn_url": "https://github.com/ofseed/neovim",
            "tags_url": "https://api.github.com/repos/ofseed/neovim/tags",
            "teams_url": "https://api.github.com/repos/ofseed/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/ofseed/neovim/git/trees{/sha}",
            "updated_at": "2025-08-18T12:19:37Z",
            "url": "https://api.github.com/repos/ofseed/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "18924b17331d55329c344dc76a70bd23b1c30ddf",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
            "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
            "followers_url": "https://api.github.com/users/ofseed/followers",
            "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
            "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ofseed",
            "id": 61115159,
            "login": "ofseed",
            "node_id": "MDQ6VXNlcjYxMTE1MTU5",
            "organizations_url": "https://api.github.com/users/ofseed/orgs",
            "received_events_url": "https://api.github.com/users/ofseed/received_events",
            "repos_url": "https://api.github.com/users/ofseed/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ofseed",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/30841",
    "id": 2129822810,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30841",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        },
        {
            "color": "F3A62E",
            "default": false,
            "description": "community: Google Summer of Code project",
            "id": 834483397,
            "name": "gsoc",
            "node_id": "MDU6TGFiZWw4MzQ0ODMzOTc=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/gsoc"
        },
        {
            "color": "F9D0C4",
            "default": false,
            "description": "",
            "id": 3968935075,
            "name": "breaking-change",
            "node_id": "LA_kwDOAPphoM7skSSj",
            "url": "https://api.github.com/repos/neovim/neovim/labels/breaking-change"
        }
    ],
    "locked": false,
    "merge_commit_sha": null,
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5-8oRa",
    "number": 30841,
    "patch_url": "https://github.com/neovim/neovim/pull/30841.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
            "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
            "followers_url": "https://api.github.com/users/ribru17/followers",
            "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
            "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ribru17",
            "id": 55766287,
            "login": "ribru17",
            "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
            "organizations_url": "https://api.github.com/users/ribru17/orgs",
            "received_events_url": "https://api.github.com/users/ribru17/received_events",
            "repos_url": "https://api.github.com/users/ribru17/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ribru17",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/30841/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/18924b17331d55329c344dc76a70bd23b1c30ddf",
    "title": "feat(lsp)!: reimplement LSP document highlight with the new API style",
    "updated_at": "2025-08-18T13:52:06Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/30841",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
        "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
        "followers_url": "https://api.github.com/users/ofseed/followers",
        "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
        "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/ofseed",
        "id": 61115159,
        "login": "ofseed",
        "node_id": "MDQ6VXNlcjYxMTE1MTU5",
        "organizations_url": "https://api.github.com/users/ofseed/orgs",
        "received_events_url": "https://api.github.com/users/ofseed/received_events",
        "repos_url": "https://api.github.com/users/ofseed/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/ofseed",
        "user_view_type": "public"
    }
}