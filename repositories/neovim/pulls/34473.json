{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34473/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/34473"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34473"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/b36a944d8aa0314240a8e0b8603169ab01987940"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6262,
            "forks_count": 6262,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1971,
            "open_issues_count": 1971,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-08-19T00:45:15Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 338530,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 92074,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-08-19T01:56:33Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 92074,
            "watchers_count": 92074,
            "web_commit_signoff_required": false
        },
        "sha": "029b7a149fa77cefe45e8df5524ef41ed4ee78eb",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Not quite finished, but raising this now to gather some feedback.\r\n\r\nFeel free to post comments here but please also consider raising issues on https://github.com/lewis6991/async.nvim which is where this is being developed.\r\n\r\n---\r\n\r\nThis is modelled mostly after [pythons asyncio](https://docs.python.org/3/library/asyncio.html) since that aligned closest to the existing implementations that I looked at.\r\n\r\n### Basic usage\r\n\r\n#### Create a task\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n  async.sleep(1000)\r\n  return 'done'\r\nend\r\n\r\n-- synchronous wait\r\nlocal result = task:wait()\r\nprint(result)\r\n\r\n-- synchronous wait with a timeout\r\nlocal result = task:wait(100)\r\nprint(result)\r\n\r\n-- asynchronous wait\r\ntask:wait(function(err, result)\r\n  print(result)\r\nend\r\n```\r\n\r\n#### Awaiting\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n  async.sleep(1000)\r\n  return 'done'\r\nend\r\n\r\n--- @async\r\nlocal function foo()\r\n  return 'world'\r\nend\r\n\r\nasync.run(function()\r\n  -- await a task\r\n  print(async.await(task)) -- prints 'done'\r\n\r\n  -- await a callback function\r\n  --- @param on_result fun(result: string)\r\n  local result = async.await(function(on_result)\r\n    vim.system({'echo', 'hello'}, nil, function(obj)\r\n      on_result(obj.stdout)\r\n    end)\r\n  end)\r\n\r\n  print(result) -- prints 'hello'\r\n\r\n  -- await an async function? No need, just call it!\r\n  print(foo()) -- prints 'world'\r\nend)\r\n```\r\n\r\n#### Cancellation and resource cleanup\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n    async.await(function(on_done)\r\n        local timer = vim.uv.new_timer()\r\n        timer:start(100, 0, on_done)\r\n\r\n        -- timer also implements a close method, so return it here\r\n        -- so async.run() can close it\r\n        return timer\r\n    end)\r\nend)\r\n\r\ntask:close() -- calls timer:close()\r\n```\r\n\r\n#### Iteration/Joining\r\n\r\n```lua\r\nasync.run(function()\r\n  local task1 = async.run(...)\r\n  local task2 = async.run(...)\r\n\r\n  -- Iterates tasks as they complete, not necessarily in order.\r\n  for i, err, result in async.iter({task1, task2}) do\r\n      print(i, err, result)\r\n  end\r\n\r\n  -- Or just wait for all tasks\r\n  local results = async.join({task1, task2})\r\n\r\n  -- Or just wait for one task\r\n  local i, err, result = async.joinany({task1, task2})\r\nend)\r\n```\r\n\r\n### Credit\r\n\r\nI took lots of ideas and implementations from both https://github.com/nvim-neotest/nvim-nio and https://github.com/gregorias/coop.nvim .\r\n\r\n---\r\n\r\nResolves #19624\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144804637"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637"
                }
            },
            "author_association": "MEMBER",
            "body": "async.lua is typechecked with emmylua due to is much stronger support for generics",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:06:51Z",
            "diff_hunk": "@@ -8,6 +8,7 @@\n       \"${3rd}/busted/library\"\n     ],\n     \"ignoreDir\": [\n+      \"/lua/vim/async.lua\",",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144804637",
            "id": 2144804637,
            "line": 11,
            "node_id": "PRRC_kwDOAPphoM5_1x8d",
            "original_commit_id": "ea86ec595defc7b69e2648f8f2b25a9a959f7d63",
            "original_line": 11,
            "original_position": 4,
            "original_start_line": null,
            "path": ".luarc.json",
            "position": 4,
            "pull_request_review_id": 2924365445,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:06:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144866780"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- This module implements an asynchronous programming library for Neovim,\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:22:19Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144866780",
            "id": 2144866780,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2BHc",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144868103"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n---    - Created by `vim.async.run()`.\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:22:38Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144868103",
            "id": 2144868103,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2BcH",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144875812"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812"
                }
            },
            "author_association": "MEMBER",
            "body": "Not necessarily in scope for this PR, but would it make sense to provide `vim.async.system` as a convenience object? I suspect that many consumers will want such a wrapper.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:24:37Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144875812",
            "id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2DUk",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144877762"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- These functions can be executed directly using `async.run()` which runs the\r\n```\r\n\r\nFun! ðŸ˜„ ",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:25:09Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system\n+---   local system = vim.async.wrap(3, function(cmd, opts, cb)\n+---     local obj = vim.system(cmd, opts, cb)\n+---     obj.close = function(_, callback)\n+---       if not obj:is_closing() then\n+---         obj:wait(0)\n+---         callback()\n+---       end\n+---     end\n+---     return obj\n+---   end)\n+---\n+---   local sleep = vim.async.wrap(2, function(duration, callback)\n+---     local timer = assert(vim.uv.new_timer())\n+---     timer:start(duration, 0, callback)\n+---     return timer -- timer has a close method\n+---   end\n+---\n+---   -- Create an async-context using run\n+---   vim.async.run(function())\n+---     local obj_ls = system({'ls'})\n+---     sleep(200)\n+---     local obj_cat = system({'cat file'})\n+---   end)\n+--- ```\n+---\n+--- ### async-function\n+---\n+--- Async functions are functions that must run in an [async-context] because\n+--- they contain at least one call that interacts with the event loop.\n+---\n+--- These functions can be executed directly using `async.run()` which funs the",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144877762",
            "id": 2144877762,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2DzC",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 64,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144981108"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108"
                }
            },
            "author_association": "MEMBER",
            "body": "could that be a flag on `vim.system` ? want to avoid teaching people to reach for similar things in different places. ",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:22:51Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144981108",
            "id": 2144981108,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2dB0",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924622714,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:22:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144988808"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808"
                }
            },
            "author_association": "MEMBER",
            "body": "No, that would be recursive. I also think that the \"for async, look in `vim.async`\" is better for discoverability -- this also avoids spreading out the `async` module over unrelated modules.\r\n\r\n(But the comment was mainly motivated by removing boilerplate and less by the naming.)",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:26:52Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144988808",
            "id": 2144988808,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2e6I",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924634265,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:28:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145028882"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882"
                }
            },
            "author_association": "MEMBER",
            "body": "Users can currently just do:\r\n\r\n```lua\r\nlocal obj = vim.async.await(3, vim.system, cmd, opts)\r\n```\r\n\r\nand/or\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nlocal async_system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nI think it's important that the signature of `vim.system()` stays the same and that It can continue to work properly without `vim.async`.\r\n\r\nIf we do want a convenience wrapper like:\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nvim.async.system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nThen do we also want `vim.async.uv.*` for `vim.uv.*` just like https://github.com/nvim-neotest/nvim-nio/blob/master/lua/nio/uv.lua",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:51:15Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145028882",
            "id": 2145028882,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2osS",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924699803,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:53:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145046508"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508"
                }
            },
            "author_association": "MEMBER",
            "body": "If it's just a one-liner, then we don't need to provide a wrapper and it's enough to give the example in the docs. (The current example made it look much more complicated, but that seems to have been my misreading.)",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:01:30Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145046508",
            "id": 2145046508,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2s_s",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924729849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:01:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145050781"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this example is an AI hallucination ðŸ™ˆ . Lines 44-49 are bogus",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:04:11Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145050781",
            "id": 2145050781,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2uCd",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924736930,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:04:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145052428"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428"
                }
            },
            "author_association": "MEMBER",
            "body": "Picking up from my previous comment, maybe we can simplify this example to make it less daunting?\r\n\r\n(If that example teaches something useful, we can give it as a second example, but then I'd suggest adding a bit more documentation to it to explain what each part does.)\r\n\r\nRight now, a naive reader may believe that the first comment applies to the _whole_ snippet rather than just the first line.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:05:12Z",
            "diff_hunk": "@@ -0,0 +1,648 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This modules implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create be `vim.async.run()`.\n+   â€¢ Can be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145052428",
            "id": 2145052428,
            "line": 40,
            "node_id": "PRRC_kwDOAPphoM5_2ucM",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 40,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-async.txt",
            "position": 40,
            "pull_request_review_id": 2924739742,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:05:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2146810462"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      vim.async.run(function()\r\n        local obj_ls = system({'ls'})\r\n        sleep(200)\r\n        local obj_cat = system({'cat', 'file'})\r\n      end)\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-14T10:18:21Z",
            "diff_hunk": "@@ -0,0 +1,640 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      local sleep = vim.async.wrap(2, function(duration, callback)\n+        local timer = assert(vim.uv.new_timer())\n+        timer:start(duration, 0, callback)\n+        return timer -- timer has a close method\n+      end\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        sleep(200)\n+        local obj_cat = system({'cat file'})\n+      end)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2146810462",
            "id": 2146810462,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_9bpe",
            "original_commit_id": "ff32e61bd1a394c269a10e898f0aa297c7e249ce",
            "original_line": 50,
            "original_position": 56,
            "original_start_line": 52,
            "path": "runtime/doc/lua-async.txt",
            "position": null,
            "pull_request_review_id": 2928164091,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-14T10:18:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2150435208"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      vim.async.run(function()\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-16T16:43:02Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2150435208",
            "id": 2150435208,
            "line": 46,
            "node_id": "PRRC_kwDOAPphoM6ALQmI",
            "original_commit_id": "03d3a74be245818dc733be67e226e39a83f54195",
            "original_line": 46,
            "original_position": 46,
            "original_start_line": null,
            "path": "runtime/doc/lua-async.txt",
            "position": 46,
            "pull_request_review_id": 2932821351,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-16T16:43:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2195507321"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321"
                }
            },
            "author_association": "MEMBER",
            "body": "[This post](https://gregorias.github.io/posts/using-coroutines-in-neovim-lua/) mentions that plenary [can't nest two \"coroutine functions\"](https://github.com/nvim-lua/plenary.nvim/issues/395). Is that what this test covers / does this PR address that ?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-09T16:56:19Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local exec_lua = n.exec_lua\n+\n+-- TODO: test error message has correct stack trace when:\n+-- task finishes with no continuation\n+-- task finishes with synchronous wait\n+-- nil in results\n+\n+--- @param s string\n+--- @param f fun()\n+local function it_exec(s, f)\n+  it(s, function()\n+    exec_lua(f)\n+  end)\n+end\n+\n+describe('async', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua('package.path = ...', package.path)\n+\n+    exec_lua(function()\n+      _G.Async = require('vim.async')\n+      _G.await = Async.await\n+      _G.run = Async.run\n+      _G.wrap = Async.wrap\n+\n+      function _G.check_timer(weak)\n+        assert(weak.timer and weak.timer:is_closing(), 'Timer is not closing')\n+        collectgarbage('collect')\n+        assert(not next(weak), 'Resources not collected')\n+      end\n+\n+      function _G.check_task_err(task, pat)\n+        local ok, err = pcall(task.wait, task, 10)\n+        assert(not ok and err:match(pat), task:traceback(err))\n+      end\n+\n+      function _G.eq(expected, actual)\n+        assert(\n+          vim.deep_equal(expected, actual),\n+          ('%s does not equal %s'):format(vim.inspect(actual), vim.inspect(expected))\n+        )\n+      end\n+    end)\n+  end)\n+\n+  it_exec('can await a uv callback function', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local done = false\n+\n+    --- @param path string\n+    --- @param options uv.spawn.options\n+    --- @param on_exit fun(code: integer, signal: integer)\n+    --- @return uv.uv_process_t handle\n+    local function spawn(path, options, on_exit)\n+      local obj = vim.uv.spawn(path, options, on_exit)\n+      table.insert(weak, obj)\n+      return obj\n+    end\n+\n+    run(function()\n+      local code1 = await(3, spawn, 'echo', { args = { 'foo' } })\n+      assert(code1 == 0)\n+\n+      local code2 = await(3, spawn, 'echo', { args = { 'bar' } })\n+      assert(code2 == 0)\n+\n+      done = true\n+    end):wait(1000)\n+\n+    assert(done)\n+\n+    collectgarbage('collect')\n+    assert(not next(weak), 'Resources not collected')\n+  end)\n+\n+  it_exec('callback function can be closed', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(_callback)\n+        -- Never call callback\n+        local timer = vim.uv.new_timer()\n+        weak.timer = timer\n+        return timer --[[@as async.Closable]]\n+      end)\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be double closed', function()\n+    --- @type { timer: uv.uv_timer_t? }\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(callback)\n+        -- Never call callback\n+        local timer = assert(vim.uv.new_timer())\n+        weak.timer = timer\n+\n+        -- prematurely close the timer\n+        timer:close(callback)\n+        return timer --[[@as async.Closable]]\n+      end)\n+\n+      return 'FINISH'\n+    end)\n+\n+    check_task_err(task, 'handle .* is already closing')\n+    check_timer(weak)\n+  end)\n+\n+  -- Same as test above but uses async and wrap\n+  it_exec('callback function can be closed (2)', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local wfn = wrap(1, function(_callback)\n+      -- Never call callback\n+      local timer = vim.uv.new_timer()\n+      weak.timer = timer\n+      return timer --[[@as async.Closable]]\n+    end)\n+\n+    local task = run(function()\n+      wfn()\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be closed (nested)', function()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2195507321",
            "id": 2195507321,
            "line": 137,
            "node_id": "PRRC_kwDOAPphoM6C3Mh5",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 137,
            "original_position": 141,
            "original_start_line": null,
            "path": "test/functional/lua/async_spec.lua",
            "position": 137,
            "pull_request_review_id": 3002310375,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-09T16:56:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2195520184"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't know, you'd have to be more specific, I don't really understand the point. You certainly would have to be careful about how you use coroutines in an async context. This library explicitly prevents calling `coroutine.yield` in an async context.\n\nThe post does have:\n\n> async uses a complicated machinery that is hard to understand. Itâ€™s unnecessary, because native coroutines work just fine.\n\nWhich I fundamentally disagree with. It's like saying C is too complicated, ASM is just fine.\n\nThe code in this issue https://github.com/nvim-lua/plenary.nvim/issues/395 doesn't make any sense. It's running two `async.runs` and then using their result in a callback without waiting for the results. If the code was corrected, then it could work with this library.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-09T17:02:53Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local exec_lua = n.exec_lua\n+\n+-- TODO: test error message has correct stack trace when:\n+-- task finishes with no continuation\n+-- task finishes with synchronous wait\n+-- nil in results\n+\n+--- @param s string\n+--- @param f fun()\n+local function it_exec(s, f)\n+  it(s, function()\n+    exec_lua(f)\n+  end)\n+end\n+\n+describe('async', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua('package.path = ...', package.path)\n+\n+    exec_lua(function()\n+      _G.Async = require('vim.async')\n+      _G.await = Async.await\n+      _G.run = Async.run\n+      _G.wrap = Async.wrap\n+\n+      function _G.check_timer(weak)\n+        assert(weak.timer and weak.timer:is_closing(), 'Timer is not closing')\n+        collectgarbage('collect')\n+        assert(not next(weak), 'Resources not collected')\n+      end\n+\n+      function _G.check_task_err(task, pat)\n+        local ok, err = pcall(task.wait, task, 10)\n+        assert(not ok and err:match(pat), task:traceback(err))\n+      end\n+\n+      function _G.eq(expected, actual)\n+        assert(\n+          vim.deep_equal(expected, actual),\n+          ('%s does not equal %s'):format(vim.inspect(actual), vim.inspect(expected))\n+        )\n+      end\n+    end)\n+  end)\n+\n+  it_exec('can await a uv callback function', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local done = false\n+\n+    --- @param path string\n+    --- @param options uv.spawn.options\n+    --- @param on_exit fun(code: integer, signal: integer)\n+    --- @return uv.uv_process_t handle\n+    local function spawn(path, options, on_exit)\n+      local obj = vim.uv.spawn(path, options, on_exit)\n+      table.insert(weak, obj)\n+      return obj\n+    end\n+\n+    run(function()\n+      local code1 = await(3, spawn, 'echo', { args = { 'foo' } })\n+      assert(code1 == 0)\n+\n+      local code2 = await(3, spawn, 'echo', { args = { 'bar' } })\n+      assert(code2 == 0)\n+\n+      done = true\n+    end):wait(1000)\n+\n+    assert(done)\n+\n+    collectgarbage('collect')\n+    assert(not next(weak), 'Resources not collected')\n+  end)\n+\n+  it_exec('callback function can be closed', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(_callback)\n+        -- Never call callback\n+        local timer = vim.uv.new_timer()\n+        weak.timer = timer\n+        return timer --[[@as async.Closable]]\n+      end)\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be double closed', function()\n+    --- @type { timer: uv.uv_timer_t? }\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(callback)\n+        -- Never call callback\n+        local timer = assert(vim.uv.new_timer())\n+        weak.timer = timer\n+\n+        -- prematurely close the timer\n+        timer:close(callback)\n+        return timer --[[@as async.Closable]]\n+      end)\n+\n+      return 'FINISH'\n+    end)\n+\n+    check_task_err(task, 'handle .* is already closing')\n+    check_timer(weak)\n+  end)\n+\n+  -- Same as test above but uses async and wrap\n+  it_exec('callback function can be closed (2)', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local wfn = wrap(1, function(_callback)\n+      -- Never call callback\n+      local timer = vim.uv.new_timer()\n+      weak.timer = timer\n+      return timer --[[@as async.Closable]]\n+    end)\n+\n+    local task = run(function()\n+      wfn()\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be closed (nested)', function()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2195520184",
            "id": 2195520184,
            "in_reply_to_id": 2195507321,
            "line": 137,
            "node_id": "PRRC_kwDOAPphoM6C3Pq4",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 137,
            "original_position": 141,
            "original_start_line": null,
            "path": "test/functional/lua/async_spec.lua",
            "position": 137,
            "pull_request_review_id": 3002329597,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-09T17:05:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238259339"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339"
                }
            },
            "author_association": "MEMBER",
            "body": "WDYT about these names:\n\n```suggestion\n   â€¢ |vim.async.all()|: Waits for all tasks to complete and collects their\n     results.\n   â€¢ |vim.async.any()|: Waits for the first task to complete and returns\n```\n\nFor reference, C# has `Task.WhenAll`/`Task.WhenAny` which create wrapper tasks that wait for all/any of their children and return the result. That model made a lot of sense to me, and has nice symmetry since the \"join\" is just another task.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T02:50:38Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238259339",
            "id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FaSCL",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3065090805,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T02:50:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238276280"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280"
                }
            },
            "author_association": "MEMBER",
            "body": "I would expect a Task to have these properties too. Do we need both Future and Task, or can we centralize on Task ?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T02:57:26Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238276280",
            "id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6FaWK4",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3065120602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:19:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238285671"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this similar to Go channels? \n\nThis seems like something that could wait until a later phase. Do we need this in the first phase?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T03:01:58Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      â€¢ {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      â€¢ `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      â€¢ `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      â€¢ `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238285671",
            "id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6FaYdn",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3065132542,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T03:01:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238530495"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Personally, I think itâ€™s better to keep the API surface small for the initial release, limiting it to vim.async.{run, all, any, await}. This would make it easier to get merged.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T05:02:06Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      â€¢ {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      â€¢ `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      â€¢ `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      â€¢ `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238530495",
            "id": 2238530495,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6FbUO_",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3065459363,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T05:02:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238948284"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284"
                }
            },
            "author_association": "MEMBER",
            "body": "`event`, `queue`, `future` and `semaphore` were ripped directly from [nvim-nio](https://github.com/nvim-neotest/nvim-nio).\r\n\r\n`event` is used to implement `semaphore` which I already have 3 downstream users waiting for: nvim-treesitter, gitsigns and vim.pack.\r\n\r\nI'm happy to hide `event`, `future` and `queue` from the API (and keep hidden), but I really want to keep semaphore in this PR since it provides a very nice way to control throughput of jobs.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:22:02Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      â€¢ {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      â€¢ `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      â€¢ `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      â€¢ `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238948284",
            "id": 2238948284,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6Fc6O8",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3066172874,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:22:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238958097"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097"
                }
            },
            "author_association": "MEMBER",
            "body": "`vim.async.Task` is implemented with `vim.async.Future`. `Future` is mostly just `Task` without all the coroutine stuff; a results holder which you can register callbacks on.\r\n\r\nCan hide it from the API if you want, though out of everything, I consider the low level control primitives to be low risk. The high risk stuff is `run`, `await`, and the general concurrency model.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:25:20Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238958097",
            "id": 2238958097,
            "in_reply_to_id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6Fc8oR",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3066188977,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:25:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2239001212"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212"
                }
            },
            "author_association": "MEMBER",
            "body": "```c#\r\n Task t = Task.WhenAll(tasks);\r\n```\r\n\r\nThat's cool. Though not sure that translates directly to this domain since we don't need a task container (with an extra corotuine). If an extra task is needed, you can already do:\r\n\r\n```lua\r\nlocal task = async.run(async.join, tasks)\r\n```\r\n\r\nlikewise to create a task directly from a callback function it is currently:\r\n\r\n```lua\r\nlocal task = async.run(async.await, function(cb) ... end)\r\n```\r\n\r\nWhich I really like about this design as you can achieve quite a few things by combining the main functions. Feels quite Lua to me. With that said, I'm not against adding aliases for some of these in the future.\r\n\r\n---\r\n\r\nI do think `any()`/`all()` is a bit too abstract. I did consider making `join()` an overload to `await()` so you could have:\r\n\r\n```lua\r\nawait(task1)\r\nawait({task1, task2, task3})\r\n```\r\n\r\nbut decided against it, since it's a bit too complicated for luals/emmy to understand; better to keep the return type the same across all overloads.\r\n\r\nI'm not a fan of the `join` terminology, name is mostly a placeholder.\r\n\r\nWhat do you think of `awaitall()`/`awaitany()` to signal that these are just other `await` variants?\r\n\r\nYou might be able to convince me of `any()`/`all()`, I'll sleep on it, but right now I do feel these functions need slightly more specific names.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:40:12Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2239001212",
            "id": 2239001212,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FdHJ8",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3066265090,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:40:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240904547"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547"
                }
            },
            "author_association": "MEMBER",
            "body": "> What do you think of `awaitall()`/`awaitany()` to signal that these are just other `await` variants?\r\n\r\nThat's an improvement imo.\r\n\r\n> not sure that translates directly to this domain since we don't need a task container (with an extra corotuine). If an extra task is needed, you can already do: `local task = async.run(async.join, tasks)`\r\n\r\nCould we simplify the interface by always creating a \"potentially unnecessary\" task container? In Phase 2, we could add low-level functions that avoid the extra coroutine, for those that are worried about performance or whatever?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:18:38Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240904547",
            "id": 2240904547,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FkX1j",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069074904,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:18:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240916141"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141"
                }
            },
            "author_association": "MEMBER",
            "body": "> I consider the low level control primitives to be low risk\r\n\r\nWe could start by hiding it, and then expose the low-level things later. But still keep the low-level stuff clearly separated in docs/etc. Will be great for users if there is a clear \"high level path\" that they can follow, and they don't need to look at the low-level stuff unless/until they really care about that.\r\n\r\nThe common case should be easy and clear, and only involves the core concepts (tasks + wait + cancel). The low-level concepts can be put in a separate \"advanced\" docs section.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:22:31Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240916141",
            "id": 2240916141,
            "in_reply_to_id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6Fkaqt",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3069089407,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:23:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240924086"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086"
                }
            },
            "author_association": "MEMBER",
            "body": "Ok that sounds fair. We can always expose more stuff later, but it will help a lot to clearly signal the \"core concepts\" vs the \"low level concepts\".",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:24:48Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   â€¢ |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   â€¢ |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   â€¢ |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   â€¢ Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   â€¢ Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      â€¢ {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      â€¢ {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      â€¢ {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      â€¢ {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      â€¢ {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      â€¢ {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      â€¢ {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      â€¢ {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      â€¢ {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      â€¢ {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      â€¢ {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      â€¢ {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      â€¢ {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      â€¢ {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      â€¢ {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      â€¢ {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      â€¢ {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      â€¢ {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      â€¢ {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      â€¢ {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      â€¢ {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      â€¢ {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      â€¢ {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      â€¢ `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      â€¢ `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      â€¢ `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240924086",
            "id": 2240924086,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6Fkcm2",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3069099365,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:24:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240937703"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703"
                }
            },
            "author_association": "MEMBER",
            "body": "Keep in mind that `join(tasks)` and `run(join, tasks)` behave completely different. The former is a blocking operation and returns the task results, whereas the latter is non-blocking and returns another task. `join(tasks)` doesn't exist as a cheap alternative to `run(join, tasks)`. To make the latter blocking you would need to do `await(run(join, tasks))` which is the same as `join(tasks)` but with an extra coroutine. `await(run(await, run(join(tasks))))` is the same with 2 extra coroutines.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:29:17Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240937703",
            "id": 2240937703,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6Fkf7n",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069116153,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:33:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240960289"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289"
                }
            },
            "author_association": "MEMBER",
            "body": "> To make the latter blocking you would need to do `await(run(join, tasks))` which is the same as `join(tasks)` but with an extra coroutine\r\n\r\nThat's essentially what I'm suggesting :)\r\n",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:36:51Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   â€¢ Functions can run asynchronously using Lua coroutines.\n+   â€¢ Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   â€¢ Create tasks with `vim.async.run()`.\n+   â€¢ Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   â€¢ |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   â€¢ Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   â€¢ |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   â€¢ |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   â€¢ |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   â€¢ |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240960289",
            "id": 2240960289,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6Fklch",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069145346,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:36:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "`vim.task` seems to make sense as a name, because:\r\n\r\n1. the objects are called tasks already in the code samples\r\n2. avoiding \"async\" avoids confusion with \"async/await\" in other platforms\r\n3. we can retire the \"job\" concept and unify on \"tasks\". (child processes are a task subclass)",
            "created_at": "2025-06-12T16:09:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-2967436862",
            "id": 2967436862,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6w334-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967436862/reactions"
            },
            "updated_at": "2025-06-12T16:09:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967436862",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Hi everyone,\r\n\r\nFirst of all, huge thanks to @lewis6991 for pushing this ðŸ™\r\n\r\nWhile experimenting with the design I put together a small prototype [gist](https://gist.github.com/hrsh7th/9751059d72376086b2e4239b21c4ffcd).\r\n(Please donâ€™t see this as an alternative proposal.)\r\n\r\nI donâ€™t intend to open a separate PRâ€”but I thought some of the ideas might be useful as reference.\r\n\r\nIdeas\r\n\r\n* Synchronous yields do not consume stack\r\n    * Synchronous resolution is handled in loops, not recursion\r\n* Cancellation propagation\r\n    * Parent tasks automatically cancel floating children (and vice versa can be enabled)\r\n* `is_finished` / `on_finished` in yielding\r\n    * Helps with cleaning up timers, handles, etc in generic way.\r\n* Closure-based encapsulation\r\n    * Uses closures instead of metatables to support cases like `pcall(task.sync, 1000)`\r\n* Interruptible synchronous operations\r\n    * User can interrupt with `<C-c>`\r\n* Task will be failure if exists floating sub-tasks\r\n    * Makes common mistakes easier to spot\r\n\r\nThe following list is public APIs.\r\n\r\n* vim.task.spawn\r\n* vim.task.yield\r\n* vim.task.in_context\r\n* vim.task.map\r\n* vim.task.any\r\n* vim.task.timeout\r\n* vim.task.schedule\r\n\r\n\r\nFeel free to ignore if this doesnâ€™t helpâ€”just sharing in case any of the ideas spark improvements for the main PR.\r\n\r\nThanks for considering, and really looking forward to this landing!\r\n\r\nEdited: 2025/06/23\r\n\r\nRenamed `vim.async.*` to `vim.task.*`",
            "created_at": "2025-06-19T06:25:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-2986786048",
            "id": 2986786048,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6yBr0A",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 6,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2986786048/reactions"
            },
            "updated_at": "2025-06-23T12:09:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2986786048",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Thanks for this! There's some really good stuff in that gist. I've incorporated a few things in https://github.com/lewis6991/async.nvim/commit/aed11197c171757a811c9459c2bb50ec35f387c5\r\n\r\n> * Synchronous yields do not consume stack\r\n>     * Synchronous resolution is handled in loops, not recursion\r\n\r\nI've added this, thanks.\r\n\r\n> * Closure-based encapsulation\r\n>     * Uses closures instead of metatables to support cases like `pcall(task.sync, 1000)`\r\n\r\nWhile this is convenient for `pcall`, I do not want the Nvim stdlib to use any closure based classes:\r\n\r\n- `foo.bar()` calls a function and has no local state\r\n- `foo:bar()` calls a method and has state.\r\n\r\nIf the `pcall` thing is a problem, then I'm not against adding `task.pwait()`.\r\n\r\n> * Interruptible synchronous operations\r\n>     * User can interrupt with `<C-c>`\r\n\r\n`vim.wait()` should already support this. See #19217\r\n\r\nThe other stuff I'm still reviewing / thinking about. The concept of attaching/detaching tasks to parent tasks is interesting, but need to think about it more.\r\n\r\n",
            "created_at": "2025-06-30T14:13:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3019329712",
            "id": 3019329712,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6z91Cw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3019329712/reactions"
            },
            "updated_at": "2025-06-30T14:13:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3019329712",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Could it be possible to give tasks an `:await()` method? Could be a small ergonomic improvement over `vim.async.await(task)`",
            "created_at": "2025-07-29T03:50:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3130550121",
            "id": 3130550121,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM66mGdp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3130550121/reactions"
            },
            "updated_at": "2025-07-29T03:50:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3130550121",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Could it be possible to give tasks an :await() method? Could be a small ergonomic improvement over vim.async.await(task)\r\n\r\nWe can keep the door open, but right now I'm not so sure. I'd like to avoid creating multiple ways of doing the same thing. I expect most users will alias `local async = vim.async`, and maybe even `local await = vim.async.await` which means a method version has little gain over the existing.\r\n\r\n```lua\r\nawait(task)\r\ntask:await()\r\n```\r\n\r\nAlso, at the moment all task methods can be called in any context; would be nice to maintain that property.\r\n\r\nAlso(2), I think it's good that `await` always leads a statement. This matters more when you have something like:\r\n\r\n```lua\r\n\r\nlocal result = async.await(async.run(function()\r\n   ... -- lots of code\r\nend))\r\n\r\n-- vs\r\n\r\nlocal result = async.run(function()\r\n   ... -- lots of code\r\nend):await()\r\n```\r\n\r\nThe former makes it clearer that the task is being awaited, whereas the latter, the `:await()` call might be off-screen.",
            "created_at": "2025-07-29T08:45:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3131333530",
            "id": 3131333530,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM66pFua",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3131333530/reactions"
            },
            "updated_at": "2025-07-29T08:48:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3131333530",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Iâ€™d like to share some insights from my work on vim.task. Perhaps this is already addressed in this PR, but I believe itâ€™s worth discussing.\r\n\r\nWe need to structure normal-termination, cancellation, and errors:\r\n\r\nFor \"normal-termination\" after opening an fd, the user should be responsible for closing it, as itâ€™s reasonable to expect a function to return an open fd as a result of async processing.\r\nFor \"cancellation\" or \"errors,\" itâ€™s safer for the internal implementation to handle cleanup.\r\n\r\nFor example, consider a process: \"open an fd, open a file, parse its contents.\"\r\n\r\n- If an error occurs while opening the file after opening the fd, the fd must be cleanuped.\r\n- If cancellation occurs during file opening after opening the fd, the fd must be cleanuped.\r\n\r\nIn other words, \"cancellation\" or \"errors\" could be likened to \"exception\" (or \"interruption\"?).\r\n\r\nThis abstraction isnâ€™t fully realized in my vim.task PoC yet.\r\n",
            "created_at": "2025-07-31T02:11:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3138339169",
            "id": 3138339169,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM67D0Fh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3138339169/reactions"
            },
            "updated_at": "2025-08-18T03:42:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3138339169",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> We need to structure normal-termination, cancellation, and errors:\r\n\r\nIsn't that already done here? What is missing from this PR? Please only comment after reviewing this PR. We thoroughly discussed many approaches already in https://github.com/neovim/neovim/issues/19624 .",
            "created_at": "2025-08-18T03:42:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3195003769",
            "id": 3195003769,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6-b-N5",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3195003769/reactions"
            },
            "updated_at": "2025-08-18T03:43:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3195003769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/34473/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/34473/commits",
    "created_at": "2025-06-12T15:48:40Z",
    "diff_url": "https://github.com/neovim/neovim/pull/34473.diff",
    "draft": true,
    "head": {
        "label": "lewis6991:vimasync",
        "ref": "vimasync",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/lewis6991/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/lewis6991/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/lewis6991/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/lewis6991/neovim/branches{/branch}",
            "clone_url": "https://github.com/lewis6991/neovim.git",
            "collaborators_url": "https://api.github.com/repos/lewis6991/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/lewis6991/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/lewis6991/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/lewis6991/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/lewis6991/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/lewis6991/neovim/contributors",
            "created_at": "2020-11-24T21:47:43Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/lewis6991/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/lewis6991/neovim/downloads",
            "events_url": "https://api.github.com/repos/lewis6991/neovim/events",
            "fork": true,
            "forks": 1,
            "forks_count": 1,
            "forks_url": "https://api.github.com/repos/lewis6991/neovim/forks",
            "full_name": "lewis6991/neovim",
            "git_commits_url": "https://api.github.com/repos/lewis6991/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/lewis6991/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/lewis6991/neovim/git/tags{/sha}",
            "git_url": "git://github.com/lewis6991/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/lewis6991/neovim/hooks",
            "html_url": "https://github.com/lewis6991/neovim",
            "id": 315760150,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/lewis6991/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/lewis6991/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/lewis6991/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/lewis6991/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/lewis6991/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/lewis6991/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/lewis6991/neovim/merges",
            "milestones_url": "https://api.github.com/repos/lewis6991/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzMTU3NjAxNTA=",
            "notifications_url": "https://api.github.com/repos/lewis6991/neovim/notifications{?since,all,participating}",
            "open_issues": 1,
            "open_issues_count": 1,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/lewis6991/neovim/pulls{/number}",
            "pushed_at": "2025-07-29T12:40:26Z",
            "releases_url": "https://api.github.com/repos/lewis6991/neovim/releases{/id}",
            "size": 326409,
            "ssh_url": "git@github.com:lewis6991/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/lewis6991/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/lewis6991/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/lewis6991/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/lewis6991/neovim/subscription",
            "svn_url": "https://github.com/lewis6991/neovim",
            "tags_url": "https://api.github.com/repos/lewis6991/neovim/tags",
            "teams_url": "https://api.github.com/repos/lewis6991/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/lewis6991/neovim/git/trees{/sha}",
            "updated_at": "2025-01-29T11:45:46Z",
            "url": "https://api.github.com/repos/lewis6991/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "b36a944d8aa0314240a8e0b8603169ab01987940",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
            "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
            "followers_url": "https://api.github.com/users/lewis6991/followers",
            "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
            "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/lewis6991",
            "id": 7904185,
            "login": "lewis6991",
            "node_id": "MDQ6VXNlcjc5MDQxODU=",
            "organizations_url": "https://api.github.com/users/lewis6991/orgs",
            "received_events_url": "https://api.github.com/users/lewis6991/received_events",
            "repos_url": "https://api.github.com/users/lewis6991/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/lewis6991",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/34473",
    "id": 2587820746,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "stdlib",
            "id": 573222693,
            "name": "lua",
            "node_id": "MDU6TGFiZWw1NzMyMjI2OTM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lua"
        }
    ],
    "locked": false,
    "merge_commit_sha": "5db8bb981598ba0554da516a319e05d677d4e8cc",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6aPwLK",
    "number": 34473,
    "patch_url": "https://github.com/neovim/neovim/pull/34473.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/34473/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/b36a944d8aa0314240a8e0b8603169ab01987940",
    "title": "feat(lua): add vim.async",
    "updated_at": "2025-08-18T03:43:23Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
        "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
        "followers_url": "https://api.github.com/users/lewis6991/followers",
        "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
        "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/lewis6991",
        "id": 7904185,
        "login": "lewis6991",
        "node_id": "MDQ6VXNlcjc5MDQxODU=",
        "organizations_url": "https://api.github.com/users/lewis6991/orgs",
        "received_events_url": "https://api.github.com/users/lewis6991/received_events",
        "repos_url": "https://api.github.com/users/lewis6991/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/lewis6991",
        "user_view_type": "public"
    }
}