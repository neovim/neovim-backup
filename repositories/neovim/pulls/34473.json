{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34473/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/34473"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/34473"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/b36a944d8aa0314240a8e0b8603169ab01987940"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 6262,
            "forks_count": 6262,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1971,
            "open_issues_count": 1971,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2025-08-19T00:45:15Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 338530,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 92074,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2025-08-19T01:56:33Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 92074,
            "watchers_count": 92074,
            "web_commit_signoff_required": false
        },
        "sha": "029b7a149fa77cefe45e8df5524ef41ed4ee78eb",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Not quite finished, but raising this now to gather some feedback.\r\n\r\nFeel free to post comments here but please also consider raising issues on https://github.com/lewis6991/async.nvim which is where this is being developed.\r\n\r\n---\r\n\r\nThis is modelled mostly after [pythons asyncio](https://docs.python.org/3/library/asyncio.html) since that aligned closest to the existing implementations that I looked at.\r\n\r\n### Basic usage\r\n\r\n#### Create a task\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n  async.sleep(1000)\r\n  return 'done'\r\nend\r\n\r\n-- synchronous wait\r\nlocal result = task:wait()\r\nprint(result)\r\n\r\n-- synchronous wait with a timeout\r\nlocal result = task:wait(100)\r\nprint(result)\r\n\r\n-- asynchronous wait\r\ntask:wait(function(err, result)\r\n  print(result)\r\nend\r\n```\r\n\r\n#### Awaiting\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n  async.sleep(1000)\r\n  return 'done'\r\nend\r\n\r\n--- @async\r\nlocal function foo()\r\n  return 'world'\r\nend\r\n\r\nasync.run(function()\r\n  -- await a task\r\n  print(async.await(task)) -- prints 'done'\r\n\r\n  -- await a callback function\r\n  --- @param on_result fun(result: string)\r\n  local result = async.await(function(on_result)\r\n    vim.system({'echo', 'hello'}, nil, function(obj)\r\n      on_result(obj.stdout)\r\n    end)\r\n  end)\r\n\r\n  print(result) -- prints 'hello'\r\n\r\n  -- await an async function? No need, just call it!\r\n  print(foo()) -- prints 'world'\r\nend)\r\n```\r\n\r\n#### Cancellation and resource cleanup\r\n\r\n```lua\r\nlocal task = async.run(function()\r\n    async.await(function(on_done)\r\n        local timer = vim.uv.new_timer()\r\n        timer:start(100, 0, on_done)\r\n\r\n        -- timer also implements a close method, so return it here\r\n        -- so async.run() can close it\r\n        return timer\r\n    end)\r\nend)\r\n\r\ntask:close() -- calls timer:close()\r\n```\r\n\r\n#### Iteration/Joining\r\n\r\n```lua\r\nasync.run(function()\r\n  local task1 = async.run(...)\r\n  local task2 = async.run(...)\r\n\r\n  -- Iterates tasks as they complete, not necessarily in order.\r\n  for i, err, result in async.iter({task1, task2}) do\r\n      print(i, err, result)\r\n  end\r\n\r\n  -- Or just wait for all tasks\r\n  local results = async.join({task1, task2})\r\n\r\n  -- Or just wait for one task\r\n  local i, err, result = async.joinany({task1, task2})\r\nend)\r\n```\r\n\r\n### Credit\r\n\r\nI took lots of ideas and implementations from both https://github.com/nvim-neotest/nvim-nio and https://github.com/gregorias/coop.nvim .\r\n\r\n---\r\n\r\nResolves #19624\r\n",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144804637"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637"
                }
            },
            "author_association": "MEMBER",
            "body": "async.lua is typechecked with emmylua due to is much stronger support for generics",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:06:51Z",
            "diff_hunk": "@@ -8,6 +8,7 @@\n       \"${3rd}/busted/library\"\n     ],\n     \"ignoreDir\": [\n+      \"/lua/vim/async.lua\",",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144804637",
            "id": 2144804637,
            "line": 11,
            "node_id": "PRRC_kwDOAPphoM5_1x8d",
            "original_commit_id": "ea86ec595defc7b69e2648f8f2b25a9a959f7d63",
            "original_line": 11,
            "original_position": 4,
            "original_start_line": null,
            "path": ".luarc.json",
            "position": 4,
            "pull_request_review_id": 2924365445,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:06:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144804637",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144866780"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- This module implements an asynchronous programming library for Neovim,\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:22:19Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144866780",
            "id": 2144866780,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2BHc",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144866780",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144868103"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n---    - Created by `vim.async.run()`.\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:22:38Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144868103",
            "id": 2144868103,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2BcH",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 10,
            "original_position": 10,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144868103",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144875812"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812"
                }
            },
            "author_association": "MEMBER",
            "body": "Not necessarily in scope for this PR, but would it make sense to provide `vim.async.system` as a convenience object? I suspect that many consumers will want such a wrapper.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:24:37Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144875812",
            "id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2DUk",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144875812",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144877762"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- These functions can be executed directly using `async.run()` which runs the\r\n```\r\n\r\nFun! 😄 ",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T11:25:09Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system\n+---   local system = vim.async.wrap(3, function(cmd, opts, cb)\n+---     local obj = vim.system(cmd, opts, cb)\n+---     obj.close = function(_, callback)\n+---       if not obj:is_closing() then\n+---         obj:wait(0)\n+---         callback()\n+---       end\n+---     end\n+---     return obj\n+---   end)\n+---\n+---   local sleep = vim.async.wrap(2, function(duration, callback)\n+---     local timer = assert(vim.uv.new_timer())\n+---     timer:start(duration, 0, callback)\n+---     return timer -- timer has a close method\n+---   end\n+---\n+---   -- Create an async-context using run\n+---   vim.async.run(function())\n+---     local obj_ls = system({'ls'})\n+---     sleep(200)\n+---     local obj_cat = system({'cat file'})\n+---   end)\n+--- ```\n+---\n+--- ### async-function\n+---\n+--- Async functions are functions that must run in an [async-context] because\n+--- they contain at least one call that interacts with the event loop.\n+---\n+--- These functions can be executed directly using `async.run()` which funs the",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144877762",
            "id": 2144877762,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2DzC",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 64,
            "original_position": 72,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924446473,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T11:43:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144877762",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144981108"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108"
                }
            },
            "author_association": "MEMBER",
            "body": "could that be a flag on `vim.system` ? want to avoid teaching people to reach for similar things in different places. ",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:22:51Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144981108",
            "id": 2144981108,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2dB0",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924622714,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:22:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144981108",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2144988808"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808"
                }
            },
            "author_association": "MEMBER",
            "body": "No, that would be recursive. I also think that the \"for async, look in `vim.async`\" is better for discoverability -- this also avoids spreading out the `async` module over unrelated modules.\r\n\r\n(But the comment was mainly motivated by removing boilerplate and less by the naming.)",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:26:52Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2144988808",
            "id": 2144988808,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2e6I",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924634265,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:28:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2144988808",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145028882"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882"
                }
            },
            "author_association": "MEMBER",
            "body": "Users can currently just do:\r\n\r\n```lua\r\nlocal obj = vim.async.await(3, vim.system, cmd, opts)\r\n```\r\n\r\nand/or\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nlocal async_system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nI think it's important that the signature of `vim.system()` stays the same and that It can continue to work properly without `vim.async`.\r\n\r\nIf we do want a convenience wrapper like:\r\n\r\n```lua\r\n--- @type async fun(cmd: string, opts:table): vim.SystemCompleted\r\nvim.async.system = vim.async.wrap(3, vim.system)\r\n```\r\n\r\nThen do we also want `vim.async.uv.*` for `vim.uv.*` just like https://github.com/nvim-neotest/nvim-nio/blob/master/lua/nio/uv.lua",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T12:51:15Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145028882",
            "id": 2145028882,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2osS",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924699803,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T12:53:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145028882",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145046508"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508"
                }
            },
            "author_association": "MEMBER",
            "body": "If it's just a one-liner, then we don't need to provide a wrapper and it's enough to give the example in the docs. (The current example made it look much more complicated, but that seems to have been my misreading.)",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:01:30Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145046508",
            "id": 2145046508,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2s_s",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924729849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:01:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145046508",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145050781"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this example is an AI hallucination 🙈 . Lines 44-49 are bogus",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:04:11Z",
            "diff_hunk": "@@ -0,0 +1,1151 @@\n+--- This modules implements an asynchronous programming library for Neovim,\n+--- enabling developers to write non-blocking, coroutine-based code. Below is a\n+--- summary of its key features and components:\n+---\n+--- 1. Async Contexts:\n+---    - Functions can run asynchronously using Lua coroutines.\n+---    - Async functions are annotated with `@async` and must run within an async context.\n+---\n+--- 2. Task Management:\n+---    - Create be `vim.async.run()`.\n+---    - Can be awaited, canceled, or waited synchronously.\n+---\n+--- 3. Awaiting:\n+---    - [vim.async.await()]: Allows blocking on asynchronous operations, such as\n+---      tasks or callback-based functions.\n+---    - Supports overloads for tasks, and callback functions.\n+---\n+--- 4. Task Wrapping:\n+---    - [vim.async.wrap()]: Converts any callback-based functions into async functions.\n+---\n+--- 5. Concurrency Utilities:\n+---    - [vim.async.iter()]: Iterates over multiple tasks, yielding their results as\n+---      they complete.\n+---    - [vim.async.join()]: Waits for all tasks to complete and collects their\n+---      results.\n+---    - [vim.async.joinany()]: Waits for the first task to complete and returns its\n+---      result.\n+---\n+--- 6. Synchronization Primitives:\n+---    - [vim.async.event()]: Implements an event signaling mechanism for tasks to\n+---      wait and notify.\n+---    - [vim.async.queue()]: A thread-safe FIFO queue for producer-consumer patterns.\n+---    - [vim.async.semaphore()]: Limits concurrent access to shared resources.\n+---\n+--- 7. Error Handling:\n+---    - Errors in async tasks are propagated and can be raised or handled explicitly.\n+---    - Provides methods like [vim.async.Task:traceback()] for debugging.\n+---\n+--- Examples:\n+--- ```lua\n+---   -- Create an async version of vim.system",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145050781",
            "id": 2145050781,
            "in_reply_to_id": 2144875812,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_2uCd",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 41,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/async.lua",
            "position": null,
            "pull_request_review_id": 2924736930,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:04:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145050781",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2145052428"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428"
                }
            },
            "author_association": "MEMBER",
            "body": "Picking up from my previous comment, maybe we can simplify this example to make it less daunting?\r\n\r\n(If that example teaches something useful, we can give it as a second example, but then I'd suggest adding a bit more documentation to it to explain what each part does.)\r\n\r\nRight now, a naive reader may believe that the first comment applies to the _whole_ snippet rather than just the first line.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-13T13:05:12Z",
            "diff_hunk": "@@ -0,0 +1,648 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This modules implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create be `vim.async.run()`.\n+   • Can be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2145052428",
            "id": 2145052428,
            "line": 40,
            "node_id": "PRRC_kwDOAPphoM5_2ucM",
            "original_commit_id": "9c537cb159279abb2d2361f447687499f7f2b7d2",
            "original_line": 40,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-async.txt",
            "position": 40,
            "pull_request_review_id": 2924739742,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-13T13:05:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2145052428",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2146810462"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      vim.async.run(function()\r\n        local obj_ls = system({'ls'})\r\n        sleep(200)\r\n        local obj_cat = system({'cat', 'file'})\r\n      end)\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-14T10:18:21Z",
            "diff_hunk": "@@ -0,0 +1,640 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      local sleep = vim.async.wrap(2, function(duration, callback)\n+        local timer = assert(vim.uv.new_timer())\n+        timer:start(duration, 0, callback)\n+        return timer -- timer has a close method\n+      end\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        sleep(200)\n+        local obj_cat = system({'cat file'})\n+      end)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2146810462",
            "id": 2146810462,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5_9bpe",
            "original_commit_id": "ff32e61bd1a394c269a10e898f0aa297c7e249ce",
            "original_line": 50,
            "original_position": 56,
            "original_start_line": 52,
            "path": "runtime/doc/lua-async.txt",
            "position": null,
            "pull_request_review_id": 2928164091,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-06-14T10:18:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2146810462",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2150435208"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      vim.async.run(function()\r\n```",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-06-16T16:43:02Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2150435208",
            "id": 2150435208,
            "line": 46,
            "node_id": "PRRC_kwDOAPphoM6ALQmI",
            "original_commit_id": "03d3a74be245818dc733be67e226e39a83f54195",
            "original_line": 46,
            "original_position": 46,
            "original_start_line": null,
            "path": "runtime/doc/lua-async.txt",
            "position": 46,
            "pull_request_review_id": 2932821351,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-06-16T16:43:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2150435208",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2195507321"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321"
                }
            },
            "author_association": "MEMBER",
            "body": "[This post](https://gregorias.github.io/posts/using-coroutines-in-neovim-lua/) mentions that plenary [can't nest two \"coroutine functions\"](https://github.com/nvim-lua/plenary.nvim/issues/395). Is that what this test covers / does this PR address that ?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-09T16:56:19Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local exec_lua = n.exec_lua\n+\n+-- TODO: test error message has correct stack trace when:\n+-- task finishes with no continuation\n+-- task finishes with synchronous wait\n+-- nil in results\n+\n+--- @param s string\n+--- @param f fun()\n+local function it_exec(s, f)\n+  it(s, function()\n+    exec_lua(f)\n+  end)\n+end\n+\n+describe('async', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua('package.path = ...', package.path)\n+\n+    exec_lua(function()\n+      _G.Async = require('vim.async')\n+      _G.await = Async.await\n+      _G.run = Async.run\n+      _G.wrap = Async.wrap\n+\n+      function _G.check_timer(weak)\n+        assert(weak.timer and weak.timer:is_closing(), 'Timer is not closing')\n+        collectgarbage('collect')\n+        assert(not next(weak), 'Resources not collected')\n+      end\n+\n+      function _G.check_task_err(task, pat)\n+        local ok, err = pcall(task.wait, task, 10)\n+        assert(not ok and err:match(pat), task:traceback(err))\n+      end\n+\n+      function _G.eq(expected, actual)\n+        assert(\n+          vim.deep_equal(expected, actual),\n+          ('%s does not equal %s'):format(vim.inspect(actual), vim.inspect(expected))\n+        )\n+      end\n+    end)\n+  end)\n+\n+  it_exec('can await a uv callback function', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local done = false\n+\n+    --- @param path string\n+    --- @param options uv.spawn.options\n+    --- @param on_exit fun(code: integer, signal: integer)\n+    --- @return uv.uv_process_t handle\n+    local function spawn(path, options, on_exit)\n+      local obj = vim.uv.spawn(path, options, on_exit)\n+      table.insert(weak, obj)\n+      return obj\n+    end\n+\n+    run(function()\n+      local code1 = await(3, spawn, 'echo', { args = { 'foo' } })\n+      assert(code1 == 0)\n+\n+      local code2 = await(3, spawn, 'echo', { args = { 'bar' } })\n+      assert(code2 == 0)\n+\n+      done = true\n+    end):wait(1000)\n+\n+    assert(done)\n+\n+    collectgarbage('collect')\n+    assert(not next(weak), 'Resources not collected')\n+  end)\n+\n+  it_exec('callback function can be closed', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(_callback)\n+        -- Never call callback\n+        local timer = vim.uv.new_timer()\n+        weak.timer = timer\n+        return timer --[[@as async.Closable]]\n+      end)\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be double closed', function()\n+    --- @type { timer: uv.uv_timer_t? }\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(callback)\n+        -- Never call callback\n+        local timer = assert(vim.uv.new_timer())\n+        weak.timer = timer\n+\n+        -- prematurely close the timer\n+        timer:close(callback)\n+        return timer --[[@as async.Closable]]\n+      end)\n+\n+      return 'FINISH'\n+    end)\n+\n+    check_task_err(task, 'handle .* is already closing')\n+    check_timer(weak)\n+  end)\n+\n+  -- Same as test above but uses async and wrap\n+  it_exec('callback function can be closed (2)', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local wfn = wrap(1, function(_callback)\n+      -- Never call callback\n+      local timer = vim.uv.new_timer()\n+      weak.timer = timer\n+      return timer --[[@as async.Closable]]\n+    end)\n+\n+    local task = run(function()\n+      wfn()\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be closed (nested)', function()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2195507321",
            "id": 2195507321,
            "line": 137,
            "node_id": "PRRC_kwDOAPphoM6C3Mh5",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 137,
            "original_position": 141,
            "original_start_line": null,
            "path": "test/functional/lua/async_spec.lua",
            "position": 137,
            "pull_request_review_id": 3002310375,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-09T16:56:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195507321",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2195520184"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't know, you'd have to be more specific, I don't really understand the point. You certainly would have to be careful about how you use coroutines in an async context. This library explicitly prevents calling `coroutine.yield` in an async context.\n\nThe post does have:\n\n> async uses a complicated machinery that is hard to understand. It’s unnecessary, because native coroutines work just fine.\n\nWhich I fundamentally disagree with. It's like saying C is too complicated, ASM is just fine.\n\nThe code in this issue https://github.com/nvim-lua/plenary.nvim/issues/395 doesn't make any sense. It's running two `async.runs` and then using their result in a callback without waiting for the results. If the code was corrected, then it could work with this library.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-09T17:02:53Z",
            "diff_hunk": "@@ -0,0 +1,412 @@\n+local t = require('test.testutil')\n+local n = require('test.functional.testnvim')()\n+local exec_lua = n.exec_lua\n+\n+-- TODO: test error message has correct stack trace when:\n+-- task finishes with no continuation\n+-- task finishes with synchronous wait\n+-- nil in results\n+\n+--- @param s string\n+--- @param f fun()\n+local function it_exec(s, f)\n+  it(s, function()\n+    exec_lua(f)\n+  end)\n+end\n+\n+describe('async', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua('package.path = ...', package.path)\n+\n+    exec_lua(function()\n+      _G.Async = require('vim.async')\n+      _G.await = Async.await\n+      _G.run = Async.run\n+      _G.wrap = Async.wrap\n+\n+      function _G.check_timer(weak)\n+        assert(weak.timer and weak.timer:is_closing(), 'Timer is not closing')\n+        collectgarbage('collect')\n+        assert(not next(weak), 'Resources not collected')\n+      end\n+\n+      function _G.check_task_err(task, pat)\n+        local ok, err = pcall(task.wait, task, 10)\n+        assert(not ok and err:match(pat), task:traceback(err))\n+      end\n+\n+      function _G.eq(expected, actual)\n+        assert(\n+          vim.deep_equal(expected, actual),\n+          ('%s does not equal %s'):format(vim.inspect(actual), vim.inspect(expected))\n+        )\n+      end\n+    end)\n+  end)\n+\n+  it_exec('can await a uv callback function', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local done = false\n+\n+    --- @param path string\n+    --- @param options uv.spawn.options\n+    --- @param on_exit fun(code: integer, signal: integer)\n+    --- @return uv.uv_process_t handle\n+    local function spawn(path, options, on_exit)\n+      local obj = vim.uv.spawn(path, options, on_exit)\n+      table.insert(weak, obj)\n+      return obj\n+    end\n+\n+    run(function()\n+      local code1 = await(3, spawn, 'echo', { args = { 'foo' } })\n+      assert(code1 == 0)\n+\n+      local code2 = await(3, spawn, 'echo', { args = { 'bar' } })\n+      assert(code2 == 0)\n+\n+      done = true\n+    end):wait(1000)\n+\n+    assert(done)\n+\n+    collectgarbage('collect')\n+    assert(not next(weak), 'Resources not collected')\n+  end)\n+\n+  it_exec('callback function can be closed', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(_callback)\n+        -- Never call callback\n+        local timer = vim.uv.new_timer()\n+        weak.timer = timer\n+        return timer --[[@as async.Closable]]\n+      end)\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be double closed', function()\n+    --- @type { timer: uv.uv_timer_t? }\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local task = run(function()\n+      await(1, function(callback)\n+        -- Never call callback\n+        local timer = assert(vim.uv.new_timer())\n+        weak.timer = timer\n+\n+        -- prematurely close the timer\n+        timer:close(callback)\n+        return timer --[[@as async.Closable]]\n+      end)\n+\n+      return 'FINISH'\n+    end)\n+\n+    check_task_err(task, 'handle .* is already closing')\n+    check_timer(weak)\n+  end)\n+\n+  -- Same as test above but uses async and wrap\n+  it_exec('callback function can be closed (2)', function()\n+    local weak = setmetatable({}, { __mode = 'v' })\n+\n+    local wfn = wrap(1, function(_callback)\n+      -- Never call callback\n+      local timer = vim.uv.new_timer()\n+      weak.timer = timer\n+      return timer --[[@as async.Closable]]\n+    end)\n+\n+    local task = run(function()\n+      wfn()\n+    end)\n+\n+    task:close()\n+\n+    check_task_err(task, 'closed')\n+    check_timer(weak)\n+  end)\n+\n+  it_exec('callback function can be closed (nested)', function()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2195520184",
            "id": 2195520184,
            "in_reply_to_id": 2195507321,
            "line": 137,
            "node_id": "PRRC_kwDOAPphoM6C3Pq4",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 137,
            "original_position": 141,
            "original_start_line": null,
            "path": "test/functional/lua/async_spec.lua",
            "position": 137,
            "pull_request_review_id": 3002329597,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2025-07-09T17:05:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2195520184",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238259339"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339"
                }
            },
            "author_association": "MEMBER",
            "body": "WDYT about these names:\n\n```suggestion\n   • |vim.async.all()|: Waits for all tasks to complete and collects their\n     results.\n   • |vim.async.any()|: Waits for the first task to complete and returns\n```\n\nFor reference, C# has `Task.WhenAll`/`Task.WhenAny` which create wrapper tasks that wait for all/any of their children and return the result. That model made a lot of sense to me, and has nice symmetry since the \"join\" is just another task.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T02:50:38Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238259339",
            "id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FaSCL",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3065090805,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T02:50:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238259339",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238276280"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280"
                }
            },
            "author_association": "MEMBER",
            "body": "I would expect a Task to have these properties too. Do we need both Future and Task, or can we centralize on Task ?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T02:57:26Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238276280",
            "id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6FaWK4",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3065120602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:19:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238276280",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238285671"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this similar to Go channels? \n\nThis seems like something that could wait until a later phase. Do we need this in the first phase?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T03:01:58Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      • `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      • `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      • `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238285671",
            "id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6FaYdn",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3065132542,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T03:01:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238285671",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238530495"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Personally, I think it’s better to keep the API surface small for the initial release, limiting it to vim.async.{run, all, any, await}. This would make it easier to get merged.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T05:02:06Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      • `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      • `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      • `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238530495",
            "id": 2238530495,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6FbUO_",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3065459363,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T05:02:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238530495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238948284"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284"
                }
            },
            "author_association": "MEMBER",
            "body": "`event`, `queue`, `future` and `semaphore` were ripped directly from [nvim-nio](https://github.com/nvim-neotest/nvim-nio).\r\n\r\n`event` is used to implement `semaphore` which I already have 3 downstream users waiting for: nvim-treesitter, gitsigns and vim.pack.\r\n\r\nI'm happy to hide `event`, `future` and `queue` from the API (and keep hidden), but I really want to keep semaphore in this PR since it provides a very nice way to control throughput of jobs.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:22:02Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      • `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      • `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      • `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238948284",
            "id": 2238948284,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6Fc6O8",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3066172874,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:22:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238948284",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2238958097"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097"
                }
            },
            "author_association": "MEMBER",
            "body": "`vim.async.Task` is implemented with `vim.async.Future`. `Future` is mostly just `Task` without all the coroutine stuff; a results holder which you can register callbacks on.\r\n\r\nCan hide it from the API if you want, though out of everything, I consider the low level control primitives to be low risk. The high risk stuff is `run`, `await`, and the general concurrency model.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:25:20Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2238958097",
            "id": 2238958097,
            "in_reply_to_id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6Fc8oR",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3066188977,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:25:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2238958097",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2239001212"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212"
                }
            },
            "author_association": "MEMBER",
            "body": "```c#\r\n Task t = Task.WhenAll(tasks);\r\n```\r\n\r\nThat's cool. Though not sure that translates directly to this domain since we don't need a task container (with an extra corotuine). If an extra task is needed, you can already do:\r\n\r\n```lua\r\nlocal task = async.run(async.join, tasks)\r\n```\r\n\r\nlikewise to create a task directly from a callback function it is currently:\r\n\r\n```lua\r\nlocal task = async.run(async.await, function(cb) ... end)\r\n```\r\n\r\nWhich I really like about this design as you can achieve quite a few things by combining the main functions. Feels quite Lua to me. With that said, I'm not against adding aliases for some of these in the future.\r\n\r\n---\r\n\r\nI do think `any()`/`all()` is a bit too abstract. I did consider making `join()` an overload to `await()` so you could have:\r\n\r\n```lua\r\nawait(task1)\r\nawait({task1, task2, task3})\r\n```\r\n\r\nbut decided against it, since it's a bit too complicated for luals/emmy to understand; better to keep the return type the same across all overloads.\r\n\r\nI'm not a fan of the `join` terminology, name is mostly a placeholder.\r\n\r\nWhat do you think of `awaitall()`/`awaitany()` to signal that these are just other `await` variants?\r\n\r\nYou might be able to convince me of `any()`/`all()`, I'll sleep on it, but right now I do feel these functions need slightly more specific names.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T08:40:12Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2239001212",
            "id": 2239001212,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FdHJ8",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3066265090,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T08:40:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2239001212",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240904547"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547"
                }
            },
            "author_association": "MEMBER",
            "body": "> What do you think of `awaitall()`/`awaitany()` to signal that these are just other `await` variants?\r\n\r\nThat's an improvement imo.\r\n\r\n> not sure that translates directly to this domain since we don't need a task container (with an extra corotuine). If an extra task is needed, you can already do: `local task = async.run(async.join, tasks)`\r\n\r\nCould we simplify the interface by always creating a \"potentially unnecessary\" task container? In Phase 2, we could add low-level functions that avoid the extra coroutine, for those that are worried about performance or whatever?",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:18:38Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240904547",
            "id": 2240904547,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6FkX1j",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069074904,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:18:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240904547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240916141"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141"
                }
            },
            "author_association": "MEMBER",
            "body": "> I consider the low level control primitives to be low risk\r\n\r\nWe could start by hiding it, and then expose the low-level things later. But still keep the low-level stuff clearly separated in docs/etc. Will be great for users if there is a clear \"high level path\" that they can follow, and they don't need to look at the low-level stuff unless/until they really care about that.\r\n\r\nThe common case should be easy and clear, and only involves the core concepts (tasks + wait + cancel). The low-level concepts can be put in a separate \"advanced\" docs section.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:22:31Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240916141",
            "id": 2240916141,
            "in_reply_to_id": 2238276280,
            "line": 169,
            "node_id": "PRRC_kwDOAPphoM6Fkaqt",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 169,
            "original_position": 169,
            "original_start_line": 163,
            "path": "runtime/doc/lua-async.txt",
            "position": 169,
            "pull_request_review_id": 3069089407,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141/reactions"
            },
            "side": "RIGHT",
            "start_line": 163,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:23:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240916141",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240924086"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086"
                }
            },
            "author_association": "MEMBER",
            "body": "Ok that sounds fair. We can always expose more stuff later, but it will help a lot to clearly signal the \"core concepts\" vs the \"low level concepts\".",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:24:48Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns\n+     its result.\n+6. Synchronization Primitives:\n+   • |vim.async.event()|: Implements an event signaling mechanism for tasks to\n+     wait and notify.\n+   • |vim.async.queue()|: A thread-safe FIFO queue for producer-consumer\n+     patterns.\n+   • |vim.async.semaphore()|: Limits concurrent access to shared resources.\n+7. Error Handling:\n+   • Errors in async tasks are propagated and can be raised or handled\n+     explicitly.\n+   • Provides methods like |vim.async.Task:traceback()| for debugging.\n+\n+Examples: >lua\n+\n+      -- Create an async version of vim.system\n+      local system = vim.async.wrap(3, vim.system)\n+\n+      -- Create an async-context using run\n+      vim.async.run(function())\n+        local obj_ls = system({'ls'})\n+        vim.async.sleep(200)\n+        local obj_cat = system({'cat', 'file'})\n+      end)\n+<\n+\n+                                                              *async-function*\n+Async functions are functions that must run in an |async-context| because they\n+contain at least one call that interacts with the event loop.\n+\n+These functions can be executed directly using `async.run()` which runs the\n+function in an async context.\n+\n+Use the `@async` annotation to designate a function as an async function.\n+\n+                                                               *async-context*\n+An async-context is an executation context managed by `vim.async` and is\n+implemented via |lua-coroutine|s. Many of the functions and methods in\n+`vim.async` can only run when within this context.\n+\n+                                                        *async-error-handling*\n+Errors are handled differently depending on whether a function is called in a\n+blocking or non-blocking manner.\n+\n+If a function is waited in a blocking call (via |async.await()| or\n+|async.Task:wait()|), errors are raised immediately.\n+\n+If a function is waited in a non-blocking way (via |async.Task:wait()|),\n+errors are passed as part of the result in the form of `(err?, ...)`, where\n+`err` is the error message and `...` are the results of the function when\n+there is no error.\n+\n+To run a Task without waiting for the result while still raising any errors,\n+use |async.Task:raise_on_error()|.\n+\n+\n+*vim.async.Closable*\n+\n+    Fields: ~\n+      • {close}  (`fun(self, callback?: fun())`)\n+\n+*vim.async.Event*\n+    An event can be used to notify multiple tasks that some event has\n+    happened. An Event object manages an internal flag that can be set to true\n+    with the `set()` method and reset to `false` with the `clear()` method.\n+    The `wait()` method blocks until the flag is set to `true`. The flag is\n+    set to `false` initially.\n+\n+    Fields: ~\n+      • {set}    (`fun(self: vim.async.Event, max_woken: integer?)`) See\n+                 |Event:set()|.\n+      • {wait}   (`fun(self: vim.async.Event)`) See |Event:wait()|.\n+      • {clear}  (`fun(self: vim.async.Event)`) See |Event:clear()|.\n+\n+*vim.async.Queue*\n+\n+    Fields: ~\n+      • {size}        (`fun(self: vim.async.Queue)`) See |Queue:size()|.\n+      • {max_size}    (`fun(self: vim.async.Queue)`) See |Queue:max_size()|.\n+      • {put}         (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put()|.\n+      • {get}         (`fun(self: vim.async.Queue)`) See |Queue:get()|.\n+      • {get_nowait}  (`fun(self: vim.async.Queue)`) See |Queue:get_nowait()|.\n+      • {put_nowait}  (`fun(self: vim.async.Queue, value: any)`) See\n+                      |Queue:put_nowait()|.\n+\n+*vim.async.Semaphore*\n+    A semaphore manages an internal counter which is decremented by each\n+    `acquire()` call and incremented by each `release()` call. The counter can\n+    never go below zero; when `acquire()` finds that it is zero, it blocks,\n+    waiting until some task calls `release()`.\n+\n+    The preferred way to use a Semaphore is with the `with()` method, which\n+    automatically acquires and releases the semaphore around a function call.\n+\n+    Fields: ~\n+      • {with}     (`fun(self: vim.async.Semaphore, fn: async fun(): R...): R...`)\n+                   See |Semaphore:with()|.\n+      • {acquire}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:acquire()|.\n+      • {release}  (`fun(self: vim.async.Semaphore)`) See\n+                   |Semaphore:release()|.\n+\n+*vim.async.Task*\n+    Tasks are used to run coroutines in event loops. If a coroutine needs to\n+    wait on the event loop, the Task suspends the execution of the coroutine\n+    and waits for event loop to restart it.\n+\n+    Use the |vim.async.run()| to create Tasks.\n+\n+    To cancel a running Task use the `close()` method. Calling it will cause\n+    the Task to throw a \"Task is closing or closed\" error into the wrapped\n+    coroutine.\n+\n+    Note a Task can be waited on via more than one waiter.\n+\n+    -- If a -- coroutine is awaiting on a Future object during cancellation,\n+    the Future -- object will be cancelled.\n+\n+    Fields: ~\n+      • {wait}            (`fun(self: vim.async.Task, callback_or_timeout: integer|fun(err?: any, ...: R...)?)`)\n+                          See |Task:wait()|.\n+      • {traceback}       (`fun(self: vim.async.Task, msg: string?): string`)\n+                          See |Task:traceback()|.\n+      • {raise_on_error}  (`fun(self: vim.async.Task): vim.async.Task`) See\n+                          |Task:raise_on_error()|.\n+      • {close}           (`fun(self: vim.async.Task, callback: fun(closed: boolean)?)`)\n+                          See |Task:close()|.\n+      • {status}          (`fun(self: vim.async.Task): 'running'|'suspended'|'normal'|'dead'?`)\n+                          See |Task:status()|.\n+\n+*vim.vim.async.Future*\n+    Future objects are used to bridge low-level callback-based code with\n+    high-level async/await code.\n+\n+    Fields: ~\n+      • {completed}  (`fun(self: vim.vim.async.Future): boolean`) See\n+                     |Future:completed()|.\n+      • {result}     (`fun(self: vim.vim.async.Future): boolean, any`) See\n+                     |Future:result()|.\n+      • {wait}       (`fun(self: vim.vim.async.Future, callback: fun(err?: any, ...: any))`)\n+                     See |Future:wait()|.\n+      • {complete}   (`fun(self: vim.vim.async.Future, err: string?, ...: any)`)\n+                     See |Future:complete()|.\n+\n+\n+await({...})                                               *vim.async.await()*\n+    Asynchronous blocking wait\n+\n+    Example: >lua\n+        local task = vim.async.run(function()\n+           return 1, 'a'\n+        end)\n+\n+        local task_fun = vim.async.async(function(arg)\n+           return 2, 'b', arg\n+        end)\n+\n+        vim.async.run(function()\n+          do -- await a callback function\n+            vim.async.await(1, vim.schedule)\n+          end\n+\n+          do -- await a callback function (if function only has a callback argument)\n+            vim.async.await(vim.schedule)\n+          end\n+\n+          do -- await a task (new async context)\n+            local n, s = vim.async.await(task)\n+            assert(n == 1 and s == 'a')\n+          end\n+\n+        end)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`any`) see overloads\n+\n+    Overloads: ~\n+      • `fun(func: (fun(callback: fun(...:R...)): vim.async.Closable?)): R...`\n+      • `fun(argc: integer, func: (fun(...:T..., callback: fun(...:R...)): vim.async.Closable?), ...:T...): R...`\n+      • `fun(task: vim.async.Task<R>): R...`\n+\n+event()                                                    *vim.async.event()*\n+    Create a new event\n+\n+    An event can signal to multiple listeners to resume execution The event\n+    can be set from a non-async context. >lua\n+         local event = vim.async.event()",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240924086",
            "id": 2240924086,
            "in_reply_to_id": 2238285671,
            "line": 215,
            "node_id": "PRRC_kwDOAPphoM6Fkcm2",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 215,
            "original_position": 215,
            "original_start_line": 213,
            "path": "runtime/doc/lua-async.txt",
            "position": 215,
            "pull_request_review_id": 3069099365,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086/reactions"
            },
            "side": "RIGHT",
            "start_line": 213,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:24:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240924086",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240937703"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703"
                }
            },
            "author_association": "MEMBER",
            "body": "Keep in mind that `join(tasks)` and `run(join, tasks)` behave completely different. The former is a blocking operation and returns the task results, whereas the latter is non-blocking and returns another task. `join(tasks)` doesn't exist as a cheap alternative to `run(join, tasks)`. To make the latter blocking you would need to do `await(run(join, tasks))` which is the same as `join(tasks)` but with an extra coroutine. `await(run(await, run(join(tasks))))` is the same with 2 extra coroutines.",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:29:17Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240937703",
            "id": 2240937703,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6Fkf7n",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069116153,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:33:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240937703",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/34473#discussion_r2240960289"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/34473"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289"
                }
            },
            "author_association": "MEMBER",
            "body": "> To make the latter blocking you would need to do `await(run(join, tasks))` which is the same as `join(tasks)` but with an extra coroutine\r\n\r\nThat's essentially what I'm suggesting :)\r\n",
            "commit_id": "b36a944d8aa0314240a8e0b8603169ab01987940",
            "created_at": "2025-07-29T20:36:51Z",
            "diff_hunk": "@@ -0,0 +1,630 @@\n+\n+==============================================================================\n+Lua module: vim.async                                              *lua-async*\n+\n+This module implements an asynchronous programming library for Neovim,\n+enabling developers to write non-blocking, coroutine-based code. Below is a\n+summary of its key features and components:\n+1. Async Contexts:\n+   • Functions can run asynchronously using Lua coroutines.\n+   • Async functions are annotated with `@async` and must run within an async\n+     context.\n+2. Task Management:\n+   • Create tasks with `vim.async.run()`.\n+   • Tasks be awaited, canceled, or waited synchronously.\n+3. Awaiting:\n+   • |vim.async.await()|: Allows blocking on asynchronous operations, such as\n+     tasks or callback-based functions.\n+   • Supports overloads for tasks, and callback functions.\n+4. Task Wrapping:\n+   • |vim.async.wrap()|: Converts any callback-based functions into async\n+     functions.\n+5. Concurrency Utilities:\n+   • |vim.async.iter()|: Iterates over multiple tasks, yielding their results\n+     as they complete.\n+   • |vim.async.join()|: Waits for all tasks to complete and collects their\n+     results.\n+   • |vim.async.joinany()|: Waits for the first task to complete and returns",
            "html_url": "https://github.com/neovim/neovim/pull/34473#discussion_r2240960289",
            "id": 2240960289,
            "in_reply_to_id": 2238259339,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM6Fklch",
            "original_commit_id": "1db96da6c5ba2ca9495f84f88ce50a94efb35989",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 25,
            "path": "runtime/doc/lua-async.txt",
            "position": 27,
            "pull_request_review_id": 3069145346,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2025-07-29T20:36:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/2240960289",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "`vim.task` seems to make sense as a name, because:\r\n\r\n1. the objects are called tasks already in the code samples\r\n2. avoiding \"async\" avoids confusion with \"async/await\" in other platforms\r\n3. we can retire the \"job\" concept and unify on \"tasks\". (child processes are a task subclass)",
            "created_at": "2025-06-12T16:09:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-2967436862",
            "id": 2967436862,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6w334-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967436862/reactions"
            },
            "updated_at": "2025-06-12T16:09:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2967436862",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Hi everyone,\r\n\r\nFirst of all, huge thanks to @lewis6991 for pushing this 🙏\r\n\r\nWhile experimenting with the design I put together a small prototype [gist](https://gist.github.com/hrsh7th/9751059d72376086b2e4239b21c4ffcd).\r\n(Please don’t see this as an alternative proposal.)\r\n\r\nI don’t intend to open a separate PR—but I thought some of the ideas might be useful as reference.\r\n\r\nIdeas\r\n\r\n* Synchronous yields do not consume stack\r\n    * Synchronous resolution is handled in loops, not recursion\r\n* Cancellation propagation\r\n    * Parent tasks automatically cancel floating children (and vice versa can be enabled)\r\n* `is_finished` / `on_finished` in yielding\r\n    * Helps with cleaning up timers, handles, etc in generic way.\r\n* Closure-based encapsulation\r\n    * Uses closures instead of metatables to support cases like `pcall(task.sync, 1000)`\r\n* Interruptible synchronous operations\r\n    * User can interrupt with `<C-c>`\r\n* Task will be failure if exists floating sub-tasks\r\n    * Makes common mistakes easier to spot\r\n\r\nThe following list is public APIs.\r\n\r\n* vim.task.spawn\r\n* vim.task.yield\r\n* vim.task.in_context\r\n* vim.task.map\r\n* vim.task.any\r\n* vim.task.timeout\r\n* vim.task.schedule\r\n\r\n\r\nFeel free to ignore if this doesn’t help—just sharing in case any of the ideas spark improvements for the main PR.\r\n\r\nThanks for considering, and really looking forward to this landing!\r\n\r\nEdited: 2025/06/23\r\n\r\nRenamed `vim.async.*` to `vim.task.*`",
            "created_at": "2025-06-19T06:25:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-2986786048",
            "id": 2986786048,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6yBr0A",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 6,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2986786048/reactions"
            },
            "updated_at": "2025-06-23T12:09:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2986786048",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Thanks for this! There's some really good stuff in that gist. I've incorporated a few things in https://github.com/lewis6991/async.nvim/commit/aed11197c171757a811c9459c2bb50ec35f387c5\r\n\r\n> * Synchronous yields do not consume stack\r\n>     * Synchronous resolution is handled in loops, not recursion\r\n\r\nI've added this, thanks.\r\n\r\n> * Closure-based encapsulation\r\n>     * Uses closures instead of metatables to support cases like `pcall(task.sync, 1000)`\r\n\r\nWhile this is convenient for `pcall`, I do not want the Nvim stdlib to use any closure based classes:\r\n\r\n- `foo.bar()` calls a function and has no local state\r\n- `foo:bar()` calls a method and has state.\r\n\r\nIf the `pcall` thing is a problem, then I'm not against adding `task.pwait()`.\r\n\r\n> * Interruptible synchronous operations\r\n>     * User can interrupt with `<C-c>`\r\n\r\n`vim.wait()` should already support this. See #19217\r\n\r\nThe other stuff I'm still reviewing / thinking about. The concept of attaching/detaching tasks to parent tasks is interesting, but need to think about it more.\r\n\r\n",
            "created_at": "2025-06-30T14:13:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3019329712",
            "id": 3019329712,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6z91Cw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3019329712/reactions"
            },
            "updated_at": "2025-06-30T14:13:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3019329712",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Could it be possible to give tasks an `:await()` method? Could be a small ergonomic improvement over `vim.async.await(task)`",
            "created_at": "2025-07-29T03:50:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3130550121",
            "id": 3130550121,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM66mGdp",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3130550121/reactions"
            },
            "updated_at": "2025-07-29T03:50:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3130550121",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/55766287?v=4",
                "events_url": "https://api.github.com/users/ribru17/events{/privacy}",
                "followers_url": "https://api.github.com/users/ribru17/followers",
                "following_url": "https://api.github.com/users/ribru17/following{/other_user}",
                "gists_url": "https://api.github.com/users/ribru17/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ribru17",
                "id": 55766287,
                "login": "ribru17",
                "node_id": "MDQ6VXNlcjU1NzY2Mjg3",
                "organizations_url": "https://api.github.com/users/ribru17/orgs",
                "received_events_url": "https://api.github.com/users/ribru17/received_events",
                "repos_url": "https://api.github.com/users/ribru17/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ribru17/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ribru17/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ribru17",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Could it be possible to give tasks an :await() method? Could be a small ergonomic improvement over vim.async.await(task)\r\n\r\nWe can keep the door open, but right now I'm not so sure. I'd like to avoid creating multiple ways of doing the same thing. I expect most users will alias `local async = vim.async`, and maybe even `local await = vim.async.await` which means a method version has little gain over the existing.\r\n\r\n```lua\r\nawait(task)\r\ntask:await()\r\n```\r\n\r\nAlso, at the moment all task methods can be called in any context; would be nice to maintain that property.\r\n\r\nAlso(2), I think it's good that `await` always leads a statement. This matters more when you have something like:\r\n\r\n```lua\r\n\r\nlocal result = async.await(async.run(function()\r\n   ... -- lots of code\r\nend))\r\n\r\n-- vs\r\n\r\nlocal result = async.run(function()\r\n   ... -- lots of code\r\nend):await()\r\n```\r\n\r\nThe former makes it clearer that the task is being awaited, whereas the latter, the `:await()` call might be off-screen.",
            "created_at": "2025-07-29T08:45:12Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3131333530",
            "id": 3131333530,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM66pFua",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3131333530/reactions"
            },
            "updated_at": "2025-07-29T08:48:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3131333530",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I’d like to share some insights from my work on vim.task. Perhaps this is already addressed in this PR, but I believe it’s worth discussing.\r\n\r\nWe need to structure normal-termination, cancellation, and errors:\r\n\r\nFor \"normal-termination\" after opening an fd, the user should be responsible for closing it, as it’s reasonable to expect a function to return an open fd as a result of async processing.\r\nFor \"cancellation\" or \"errors,\" it’s safer for the internal implementation to handle cleanup.\r\n\r\nFor example, consider a process: \"open an fd, open a file, parse its contents.\"\r\n\r\n- If an error occurs while opening the file after opening the fd, the fd must be cleanuped.\r\n- If cancellation occurs during file opening after opening the fd, the fd must be cleanuped.\r\n\r\nIn other words, \"cancellation\" or \"errors\" could be likened to \"exception\" (or \"interruption\"?).\r\n\r\nThis abstraction isn’t fully realized in my vim.task PoC yet.\r\n",
            "created_at": "2025-07-31T02:11:14Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3138339169",
            "id": 3138339169,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM67D0Fh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3138339169/reactions"
            },
            "updated_at": "2025-08-18T03:42:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3138339169",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> We need to structure normal-termination, cancellation, and errors:\r\n\r\nIsn't that already done here? What is missing from this PR? Please only comment after reviewing this PR. We thoroughly discussed many approaches already in https://github.com/neovim/neovim/issues/19624 .",
            "created_at": "2025-08-18T03:42:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/34473#issuecomment-3195003769",
            "id": 3195003769,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
            "node_id": "IC_kwDOAPphoM6-b-N5",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3195003769/reactions"
            },
            "updated_at": "2025-08-18T03:43:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/3195003769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/34473/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/34473/commits",
    "created_at": "2025-06-12T15:48:40Z",
    "diff_url": "https://github.com/neovim/neovim/pull/34473.diff",
    "draft": true,
    "head": {
        "label": "lewis6991:vimasync",
        "ref": "vimasync",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/lewis6991/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/lewis6991/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/lewis6991/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/lewis6991/neovim/branches{/branch}",
            "clone_url": "https://github.com/lewis6991/neovim.git",
            "collaborators_url": "https://api.github.com/repos/lewis6991/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/lewis6991/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/lewis6991/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/lewis6991/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/lewis6991/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/lewis6991/neovim/contributors",
            "created_at": "2020-11-24T21:47:43Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/lewis6991/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/lewis6991/neovim/downloads",
            "events_url": "https://api.github.com/repos/lewis6991/neovim/events",
            "fork": true,
            "forks": 1,
            "forks_count": 1,
            "forks_url": "https://api.github.com/repos/lewis6991/neovim/forks",
            "full_name": "lewis6991/neovim",
            "git_commits_url": "https://api.github.com/repos/lewis6991/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/lewis6991/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/lewis6991/neovim/git/tags{/sha}",
            "git_url": "git://github.com/lewis6991/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/lewis6991/neovim/hooks",
            "html_url": "https://github.com/lewis6991/neovim",
            "id": 315760150,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/lewis6991/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/lewis6991/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/lewis6991/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/lewis6991/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/lewis6991/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/lewis6991/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/lewis6991/neovim/merges",
            "milestones_url": "https://api.github.com/repos/lewis6991/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzMTU3NjAxNTA=",
            "notifications_url": "https://api.github.com/repos/lewis6991/neovim/notifications{?since,all,participating}",
            "open_issues": 1,
            "open_issues_count": 1,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/lewis6991/neovim/pulls{/number}",
            "pushed_at": "2025-07-29T12:40:26Z",
            "releases_url": "https://api.github.com/repos/lewis6991/neovim/releases{/id}",
            "size": 326409,
            "ssh_url": "git@github.com:lewis6991/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/lewis6991/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/lewis6991/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/lewis6991/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/lewis6991/neovim/subscription",
            "svn_url": "https://github.com/lewis6991/neovim",
            "tags_url": "https://api.github.com/repos/lewis6991/neovim/tags",
            "teams_url": "https://api.github.com/repos/lewis6991/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/lewis6991/neovim/git/trees{/sha}",
            "updated_at": "2025-01-29T11:45:46Z",
            "url": "https://api.github.com/repos/lewis6991/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "b36a944d8aa0314240a8e0b8603169ab01987940",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
            "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
            "followers_url": "https://api.github.com/users/lewis6991/followers",
            "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
            "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/lewis6991",
            "id": 7904185,
            "login": "lewis6991",
            "node_id": "MDQ6VXNlcjc5MDQxODU=",
            "organizations_url": "https://api.github.com/users/lewis6991/orgs",
            "received_events_url": "https://api.github.com/users/lewis6991/received_events",
            "repos_url": "https://api.github.com/users/lewis6991/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/lewis6991",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/34473",
    "id": 2587820746,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/34473",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "stdlib",
            "id": 573222693,
            "name": "lua",
            "node_id": "MDU6TGFiZWw1NzMyMjI2OTM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lua"
        }
    ],
    "locked": false,
    "merge_commit_sha": "5db8bb981598ba0554da516a319e05d677d4e8cc",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6aPwLK",
    "number": 34473,
    "patch_url": "https://github.com/neovim/neovim/pull/34473.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/34473/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/b36a944d8aa0314240a8e0b8603169ab01987940",
    "title": "feat(lua): add vim.async",
    "updated_at": "2025-08-18T03:43:23Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/34473",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
        "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
        "followers_url": "https://api.github.com/users/lewis6991/followers",
        "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
        "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/lewis6991",
        "id": 7904185,
        "login": "lewis6991",
        "node_id": "MDQ6VXNlcjc5MDQxODU=",
        "organizations_url": "https://api.github.com/users/lewis6991/orgs",
        "received_events_url": "https://api.github.com/users/lewis6991/received_events",
        "repos_url": "https://api.github.com/users/lewis6991/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/lewis6991",
        "user_view_type": "public"
    }
}