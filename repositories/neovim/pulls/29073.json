{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/29073/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29073/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/29073"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/29073"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29073/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5429,
            "forks_count": 5429,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1739,
            "open_issues_count": 1739,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-06-03T22:07:20Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 272034,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 78772,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-06-03T23:33:38Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 78772,
            "watchers_count": 78772,
            "web_commit_signoff_required": false
        },
        "sha": "7e44ab696a0488ad234b0915a8cf804fd6d79156",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "As requested by @justinmk in https://github.com/nvim-neorocks/nvim-best-practices/issues/5\r\n\r\n- Using https://github.com/nvim-neorocks/nvim-best-practices/issues/5#issuecomment-2131228725 as a guideline\r\n- Reworded a to have a less \"opinionated\" tone (based on feedback in https://github.com/nvim-neorocks/nvim-best-practices/issues/5#issuecomment-2131371976)\r\n\r\nSomething to watch out for: I tend to mix up US and UK style spelling. I've tried to stick to US style, but sometimes UK style slips in :sweat_smile: ",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617902947"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617902947"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Not sure if we want to add this here.\r\nIt hasn't been touched in about 2 years. I still use it and it works fine (as long as I don't use newer features like `(exact)` classes, but I'm either going to fork it or switch to something else.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:19:24Z",
            "diff_hunk": "@@ -0,0 +1,450 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage |LuaCATS| https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t\t       *lua-plugin-type-safety-further-reading*\n+\n+- LuaCATS documentation https://luals.github.io/wiki/annotations/     *LuaCATS*\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| or scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads and from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+local foo = require(\"foo\")\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    local foo = require(\"foo\")\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+if not vim.g.loaded_my_rust_plugin then\n+    -- Initialise\n+end\n+-- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+-- and allows users to prevent plugins from loading\n+-- (in both Lua and Vimscript).\n+vim.g.loaded_my_rust_plugin = true\n+\n+local bufnr = vim.api.nvim_get_current_buf()\n+-- do something specific to this buffer,\n+-- e.g. add a |<Plug>| mapping or create a command\n+vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+    print(\"Hello\")\n+end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+---@param path string The path to the field being validated\n+---@param tbl table The table to validate\n+---@see vim.validate\n+---@return boolean is_valid\n+---@return string|nil error_message\n+local function validate_path(path, tbl)\n+  local ok, err = pcall(vim.validate, tbl)\n+  return ok, err and path .. \".\" .. err\n+end\n+>\n+The function can be called like this:\n+\n+allows you to use the validation:\n+>lua\n+---@param cfg myplugin.Config\n+---@return boolean is_valid\n+---@return string|nil error_message\n+function validate(cfg)\n+    return validate_path(\"vim.g.my_plugin\", {\n+        do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+        strategy = { cfg.strategy, \"string\" },\n+    })\n+end\n+<\n+And invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User cnfiguration\n+- Proper initializaion\n+- Presence of Lua dependencies (e.g. other plugins)\n+- Presence of external dependencies\n+\n+See also |vim.health and |health-dev|.\n+\n+------------------------------------------------------------------------------\n+Minimal config template             *lua-plugin-troubleshooting-minimal-config*\n+\n+It can be useful to provide a template for a minimal configuration, along with \n+a guide on how to use it to reproduce issues.\n+\n+==============================================================================\n+Versioning and releases                        *lua-plugin-versioning-releases*\n+\n+Consider\n+\n+- Using SemVer https://semver.org/ tags and releases to properly communicate\n+  bug fixes, new features, and breaking changes.\n+- Automating versioning and releases in CI.\n+- Publishing to luarocks https://luarocks.org, especially if your plugin\n+  has dependencies or components that need to be built; or if it could be a\n+  dependency for another plugin.\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t       *lua-plugin-versioning-releases-further-reading*\n+\n+- Luarocks <3 Neovim https://github.com/nvim-neorocks/sample-luarocks-plugin\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                 *lua-plugin-versioning-releases-tools*\n+\n+- luarocks-tag-release\n+  https://github.com/marketplace/actions/luarocks-tag-release\n+- release-please-action\n+  https://github.com/marketplace/actions/release-please-action\n+- semantic-release \n+  https://github.com/semantic-release/semantic-release \n+\n+==============================================================================\n+Documentation                                        *lua-plugin-documentation*\n+\n+Provide vimdoc (see |help-writing|), so that users can read your plugin's\n+documentation in Neovim, by entering `:h {plugin}` in |command-mode|.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                       *lua-plugin-documentation-tools*\n+\n+- panvimdoc https://github.com/kdheepak/panvimdoc\n+- lemmy-help https://github.com/numToStr/lemmy-help\n+\n+NOTE: lemmy-help has not been updated recently and is no longer fully\n+      compatible with |LuaCATS|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617902947",
            "id": 1617902947,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gbz1j",
            "original_commit_id": "362800ee2e899b1d7ecfc7c52be56f9f69245fac",
            "original_line": 439,
            "original_position": 444,
            "original_start_line": 441,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083866278,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617902947/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:19:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617902947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617905770"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617905770"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\npotential bugs in your CI before your plugin's users do.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:23:00Z",
            "diff_hunk": "@@ -0,0 +1,452 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage |LuaCATS| https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617905770",
            "id": 1617905770,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb0hq",
            "original_commit_id": "762090b8eda4fb930dfbe4f024080692d1af835f",
            "original_line": 29,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083872421,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617905770/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:23:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617905770",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617907798"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617907798"
                }
            },
            "author_association": "MEMBER",
            "body": "You already linked to this before. This doesn't seem necessary.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:25:22Z",
            "diff_hunk": "@@ -0,0 +1,452 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage |LuaCATS| https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t\t       *lua-plugin-type-safety-further-reading*\n+\n+- LuaCATS documentation https://luals.github.io/wiki/annotations/     *LuaCATS*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617907798",
            "id": 1617907798,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb1BW",
            "original_commit_id": "dcb77c06979aca14dd458b38d776a135b5b5dac5",
            "original_line": 42,
            "original_position": 42,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083875614,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617907798/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:25:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617907798",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617912500"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617912500"
                }
            },
            "author_association": "MEMBER",
            "body": "You need to indent all codeblocks for TS to highlight correctly. Don't ask me why, thems the rules.\r\n\r\n```suggestion\r\n    ---@class FooSubcommand\r\n    ---@field impl fun(args:string[], opts: table)\r\n    ---@field complete? fun(subcmd_arg_lead: string): string[]\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:30:37Z",
            "diff_hunk": "@@ -0,0 +1,447 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617912500",
            "id": 1617912500,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb2K0",
            "original_commit_id": "b213dfb916c50f4ed7c5f0337b58ebfdf549a7b3",
            "original_line": 82,
            "original_position": 82,
            "original_start_line": 80,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083883287,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617912500/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:30:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617912500",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617913278"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913278"
                }
            },
            "author_association": "MEMBER",
            "body": "LMAO absolutely remove this what",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:31:37Z",
            "diff_hunk": "@@ -0,0 +1,450 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage |LuaCATS| https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t\t       *lua-plugin-type-safety-further-reading*\n+\n+- LuaCATS documentation https://luals.github.io/wiki/annotations/     *LuaCATS*\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| or scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads and from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+local foo = require(\"foo\")\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    local foo = require(\"foo\")\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+if not vim.g.loaded_my_rust_plugin then\n+    -- Initialise\n+end\n+-- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+-- and allows users to prevent plugins from loading\n+-- (in both Lua and Vimscript).\n+vim.g.loaded_my_rust_plugin = true\n+\n+local bufnr = vim.api.nvim_get_current_buf()\n+-- do something specific to this buffer,\n+-- e.g. add a |<Plug>| mapping or create a command\n+vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+    print(\"Hello\")\n+end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+---@param path string The path to the field being validated\n+---@param tbl table The table to validate\n+---@see vim.validate\n+---@return boolean is_valid\n+---@return string|nil error_message\n+local function validate_path(path, tbl)\n+  local ok, err = pcall(vim.validate, tbl)\n+  return ok, err and path .. \".\" .. err\n+end\n+>\n+The function can be called like this:\n+\n+allows you to use the validation:\n+>lua\n+---@param cfg myplugin.Config\n+---@return boolean is_valid\n+---@return string|nil error_message\n+function validate(cfg)\n+    return validate_path(\"vim.g.my_plugin\", {\n+        do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+        strategy = { cfg.strategy, \"string\" },\n+    })\n+end\n+<\n+And invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User cnfiguration\n+- Proper initializaion\n+- Presence of Lua dependencies (e.g. other plugins)\n+- Presence of external dependencies\n+\n+See also |vim.health and |health-dev|.\n+\n+------------------------------------------------------------------------------\n+Minimal config template             *lua-plugin-troubleshooting-minimal-config*\n+\n+It can be useful to provide a template for a minimal configuration, along with \n+a guide on how to use it to reproduce issues.\n+\n+==============================================================================\n+Versioning and releases                        *lua-plugin-versioning-releases*\n+\n+Consider\n+\n+- Using SemVer https://semver.org/ tags and releases to properly communicate\n+  bug fixes, new features, and breaking changes.\n+- Automating versioning and releases in CI.\n+- Publishing to luarocks https://luarocks.org, especially if your plugin\n+  has dependencies or components that need to be built; or if it could be a\n+  dependency for another plugin.\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t       *lua-plugin-versioning-releases-further-reading*\n+\n+- Luarocks <3 Neovim https://github.com/nvim-neorocks/sample-luarocks-plugin\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                 *lua-plugin-versioning-releases-tools*\n+\n+- luarocks-tag-release\n+  https://github.com/marketplace/actions/luarocks-tag-release\n+- release-please-action\n+  https://github.com/marketplace/actions/release-please-action\n+- semantic-release \n+  https://github.com/semantic-release/semantic-release \n+\n+==============================================================================\n+Documentation                                        *lua-plugin-documentation*\n+\n+Provide vimdoc (see |help-writing|), so that users can read your plugin's\n+documentation in Neovim, by entering `:h {plugin}` in |command-mode|.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                       *lua-plugin-documentation-tools*\n+\n+- panvimdoc https://github.com/kdheepak/panvimdoc\n+- lemmy-help https://github.com/numToStr/lemmy-help\n+\n+NOTE: lemmy-help has not been updated recently and is no longer fully\n+      compatible with |LuaCATS|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617913278",
            "id": 1617913278,
            "in_reply_to_id": 1617902947,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb2W-",
            "original_commit_id": "362800ee2e899b1d7ecfc7c52be56f9f69245fac",
            "original_line": 439,
            "original_position": 444,
            "original_start_line": 441,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083884465,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913278/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:31:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913278",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617913773"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913773"
                }
            },
            "author_association": "MEMBER",
            "body": "If it's deprecated and not recommended then people don't need to know. Just yeet it.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:32:17Z",
            "diff_hunk": "@@ -0,0 +1,450 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage |LuaCATS| https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t\t       *lua-plugin-type-safety-further-reading*\n+\n+- LuaCATS documentation https://luals.github.io/wiki/annotations/     *LuaCATS*\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| or scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads and from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+local foo = require(\"foo\")\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+vim.api.nvim_create_user_command(\"MyCommand\", function()\n+    local foo = require(\"foo\")\n+    foo.do_something()\n+end, {\n+  -- ...\n+})\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+if not vim.g.loaded_my_rust_plugin then\n+    -- Initialise\n+end\n+-- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+-- and allows users to prevent plugins from loading\n+-- (in both Lua and Vimscript).\n+vim.g.loaded_my_rust_plugin = true\n+\n+local bufnr = vim.api.nvim_get_current_buf()\n+-- do something specific to this buffer,\n+-- e.g. add a |<Plug>| mapping or create a command\n+vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+    print(\"Hello\")\n+end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+---@param path string The path to the field being validated\n+---@param tbl table The table to validate\n+---@see vim.validate\n+---@return boolean is_valid\n+---@return string|nil error_message\n+local function validate_path(path, tbl)\n+  local ok, err = pcall(vim.validate, tbl)\n+  return ok, err and path .. \".\" .. err\n+end\n+>\n+The function can be called like this:\n+\n+allows you to use the validation:\n+>lua\n+---@param cfg myplugin.Config\n+---@return boolean is_valid\n+---@return string|nil error_message\n+function validate(cfg)\n+    return validate_path(\"vim.g.my_plugin\", {\n+        do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+        strategy = { cfg.strategy, \"string\" },\n+    })\n+end\n+<\n+And invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User cnfiguration\n+- Proper initializaion\n+- Presence of Lua dependencies (e.g. other plugins)\n+- Presence of external dependencies\n+\n+See also |vim.health and |health-dev|.\n+\n+------------------------------------------------------------------------------\n+Minimal config template             *lua-plugin-troubleshooting-minimal-config*\n+\n+It can be useful to provide a template for a minimal configuration, along with \n+a guide on how to use it to reproduce issues.\n+\n+==============================================================================\n+Versioning and releases                        *lua-plugin-versioning-releases*\n+\n+Consider\n+\n+- Using SemVer https://semver.org/ tags and releases to properly communicate\n+  bug fixes, new features, and breaking changes.\n+- Automating versioning and releases in CI.\n+- Publishing to luarocks https://luarocks.org, especially if your plugin\n+  has dependencies or components that need to be built; or if it could be a\n+  dependency for another plugin.\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t       *lua-plugin-versioning-releases-further-reading*\n+\n+- Luarocks <3 Neovim https://github.com/nvim-neorocks/sample-luarocks-plugin\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                 *lua-plugin-versioning-releases-tools*\n+\n+- luarocks-tag-release\n+  https://github.com/marketplace/actions/luarocks-tag-release\n+- release-please-action\n+  https://github.com/marketplace/actions/release-please-action\n+- semantic-release \n+  https://github.com/semantic-release/semantic-release \n+\n+==============================================================================\n+Documentation                                        *lua-plugin-documentation*\n+\n+Provide vimdoc (see |help-writing|), so that users can read your plugin's\n+documentation in Neovim, by entering `:h {plugin}` in |command-mode|.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                       *lua-plugin-documentation-tools*\n+\n+- panvimdoc https://github.com/kdheepak/panvimdoc\n+- lemmy-help https://github.com/numToStr/lemmy-help\n+\n+NOTE: lemmy-help has not been updated recently and is no longer fully\n+      compatible with |LuaCATS|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617913773",
            "id": 1617913773,
            "in_reply_to_id": 1617902947,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb2et",
            "original_commit_id": "362800ee2e899b1d7ecfc7c52be56f9f69245fac",
            "original_line": 439,
            "original_position": 444,
            "original_start_line": 441,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083885320,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913773/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:32:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617913773",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617918347"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617918347"
                }
            },
            "author_association": "MEMBER",
            "body": "Annoying sentence. \"Think smart and lots, don't be dumb\"",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:38:17Z",
            "diff_hunk": "@@ -0,0 +1,443 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617918347",
            "id": 1617918347,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb3mL",
            "original_commit_id": "ec200834f5803d0638bd2c3ab2352464079753ac",
            "original_line": 264,
            "original_position": 264,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083892351,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617918347/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:38:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617918347",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617919591"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617919591"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Ah, I was wondering about that :smile: \r\nGood to know.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:39:34Z",
            "diff_hunk": "@@ -0,0 +1,447 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617919591",
            "id": 1617919591,
            "in_reply_to_id": 1617912500,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb35n",
            "original_commit_id": "b213dfb916c50f4ed7c5f0337b58ebfdf549a7b3",
            "original_line": 82,
            "original_position": 82,
            "original_start_line": 80,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083894112,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617919591/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:39:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617919591",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617921509"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617921509"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nwhich will eagerly load the `foo` module and any other modules it imports\r\neagerly, you can lazy load it by moving the `require` into the command's\r\nimplementation.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:40:17Z",
            "diff_hunk": "@@ -0,0 +1,441 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+...which will eagerly load the `foo` module and any other modules it imports\n+eagerly, can lazy load it by moving the `require` into the command's\n+implementation.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617921509",
            "id": 1617921509,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb4Xl",
            "original_commit_id": "ed6d1bf14d1e1de5189fde142cb0a66cd3e3f7a4",
            "original_line": 278,
            "original_position": 282,
            "original_start_line": 280,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083896625,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617921509/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:40:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617921509",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617922520"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617922520"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I guess I could just remove it? The relevant info is in the subsections that follow after it.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:41:28Z",
            "diff_hunk": "@@ -0,0 +1,443 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617922520",
            "id": 1617922520,
            "in_reply_to_id": 1617918347,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb4nY",
            "original_commit_id": "ec200834f5803d0638bd2c3ab2352464079753ac",
            "original_line": 264,
            "original_position": 264,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083898096,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617922520/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:41:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617922520",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617923938"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617923938"
                }
            },
            "author_association": "MEMBER",
            "body": "I think so. I'm aware this is well into nitpick territory but whatever, you'll live",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:43:19Z",
            "diff_hunk": "@@ -0,0 +1,443 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617923938",
            "id": 1617923938,
            "in_reply_to_id": 1617918347,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb49i",
            "original_commit_id": "ec200834f5803d0638bd2c3ab2352464079753ac",
            "original_line": 264,
            "original_position": 264,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083900240,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617923938/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:43:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617923938",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617925164"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925164"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I'm very happy for your feedback :pray:  :smile: ",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:44:53Z",
            "diff_hunk": "@@ -0,0 +1,443 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+---@class FooSubcommand\n+---@field impl fun(args:string[], opts: table)\n+---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+---@type table<string, FooSubcommand>\n+local subcommand_tbl = {\n+    action1 = {\n+        impl = function(args, opts)\n+          -- Implementation (args is a list of strings)\n+        end,\n+        -- This subcommand has no completions\n+    },\n+    action2 = {\n+        impl = function(args, opts)\n+            -- Implementation\n+        end,\n+        complete = function(subcmd_arg_lead)\n+            -- Simplified example\n+            local install_args = {\n+                \"first\",\n+                \"second\",\n+                \"third\",\n+            }\n+            return vim.iter(install_args)\n+                :filter(function(install_arg)\n+                    -- If the user has typed `:Foo action2 fi`,\n+                    -- this will match 'first'\n+                    return install_arg:find(subcmd_arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end,\n+        -- ...\n+    },\n+}\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+---@param opts table :h lua-guide-commands-create\n+local function foo_cmd(opts)\n+    local fargs = opts.fargs\n+    local subcommand_key = fargs[1]\n+    -- Get the subcommand's arguments, if any\n+    local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+    local subcommand = subcommand_tbl[subcommand_key]\n+    if not subcommand then\n+        vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+        return\n+    end\n+    -- Invoke the subcommand\n+    subcommand.impl(args, opts)\n+end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+-- NOTE: the options will vary, based on your use case.\n+vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+    nargs = \"+\",\n+    desc = \"My awesome command with subcommand completions\",\n+    complete = function(arg_lead, cmdline, _)\n+        -- Get the subcommand.\n+        local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+        if subcmd_key \n+\t    and subcmd_arg_lead \n+\t    and subcommand_tbl[subcmd_key] \n+\t    and subcommand_tbl[subcmd_key].complete\n+\tthen\n+            -- The subcommand has completions. Return them.\n+            return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+        end\n+        -- Check if cmdline is a subcommand\n+        if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+            -- Filter subcommands that match\n+            local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+            return vim.iter(subcommand_keys)\n+                :filter(function(key)\n+                    return key:find(arg_lead) ~= nil\n+                end)\n+                :totable()\n+        end\n+    end,\n+    bang = true, -- If you want to support ! modifiers\n+})\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from normal mode\") \n+end, { noremap = true })\n+\n+vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+    print(\"Hello from visual mode\") \n+end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+Think carefully about when which parts of your plugin need to be loaded.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617925164",
            "id": 1617925164,
            "in_reply_to_id": 1617918347,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb5Qs",
            "original_commit_id": "ec200834f5803d0638bd2c3ab2352464079753ac",
            "original_line": 264,
            "original_position": 264,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083902075,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925164/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:44:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925164",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617925212"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925212"
                }
            },
            "author_association": "MEMBER",
            "body": "neovim just got a flat version(?) that is much faster than `vim.validate` (forgot the name). Wonder if we should mention that instead/as well since vim.validate has significant performance impact? Unsure, just mentioning for reference. @gpanders might have some input on this.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:44:57Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617925212",
            "id": 1617925212,
            "line": 330,
            "node_id": "PRRC_kwDOAPphoM5gb5Rc",
            "original_commit_id": "94bf04dcfd5107f0e27a9a57e8cbf9233460f53f",
            "original_line": 330,
            "original_position": 332,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 330,
            "pull_request_review_id": 2083902165,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925212/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:45:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617925212",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617932735"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617932735"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n- User configuration\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:55:15Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+    ---@param path string The path to the field being validated\n+    ---@param tbl table The table to validate\n+    ---@see vim.validate\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    local function validate_path(path, tbl)\n+      local ok, err = pcall(vim.validate, tbl)\n+      return ok, err and path .. \".\" .. err\n+    end\n+>\n+The function can be called like this:\n+>lua\n+    ---@param cfg myplugin.Config\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    function validate(cfg)\n+        return validate_path(\"vim.g.my_plugin\", {\n+            do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+            strategy = { cfg.strategy, \"string\" },\n+        })\n+    end\n+<\n+An invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User cnfiguration",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617932735",
            "id": 1617932735,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb7G_",
            "original_commit_id": "37e69d910286ef0323e0e7e1e442dc8c94d63cb8",
            "original_line": 382,
            "original_position": 382,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083913427,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617932735/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:55:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617932735",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617934068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934068"
                }
            },
            "author_association": "MEMBER",
            "body": "Probably not bad, but it looks like a snoozefest",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:57:03Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+    ---@param path string The path to the field being validated\n+    ---@param tbl table The table to validate\n+    ---@see vim.validate\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    local function validate_path(path, tbl)\n+      local ok, err = pcall(vim.validate, tbl)\n+      return ok, err and path .. \".\" .. err\n+    end\n+>\n+The function can be called like this:\n+>lua\n+    ---@param cfg myplugin.Config\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    function validate(cfg)\n+        return validate_path(\"vim.g.my_plugin\", {\n+            do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+            strategy = { cfg.strategy, \"string\" },\n+        })\n+    end\n+<\n+An invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User cnfiguration\n+- Proper initializaion\n+- Presence of Lua dependencies (e.g. other plugins)\n+- Presence of external dependencies\n+\n+See also |vim.health| and |health-dev|.\n+\n+------------------------------------------------------------------------------\n+Minimal config template             *lua-plugin-troubleshooting-minimal-config*\n+\n+It can be useful to provide a template for a minimal configuration, along with \n+a guide on how to use it to reproduce issues.\n+\n+==============================================================================\n+Versioning and releases                        *lua-plugin-versioning-releases*\n+\n+Consider\n+\n+- Using SemVer https://semver.org/ tags and releases to properly communicate\n+  bug fixes, new features, and breaking changes.\n+- Automating versioning and releases in CI.\n+- Publishing to luarocks https://luarocks.org, especially if your plugin\n+  has dependencies or components that need to be built; or if it could be a\n+  dependency for another plugin.\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t       *lua-plugin-versioning-releases-further-reading*\n+\n+- Luarocks <3 Neovim https://github.com/nvim-neorocks/sample-luarocks-plugin\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                 *lua-plugin-versioning-releases-tools*\n+\n+- luarocks-tag-release\n+  https://github.com/marketplace/actions/luarocks-tag-release\n+- release-please-action\n+  https://github.com/marketplace/actions/release-please-action\n+- semantic-release \n+  https://github.com/semantic-release/semantic-release \n+\n+==============================================================================\n+Documentation                                        *lua-plugin-documentation*\n+\n+Provide vimdoc (see |help-writing|), so that users can read your plugin's\n+documentation in Neovim, by entering `:h {plugin}` in |command-mode|.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t                       *lua-plugin-documentation-tools*\n+\n+- panvimdoc https://github.com/kdheepak/panvimdoc\n+\n+------------------------------------------------------------------------------\n+Further reading\t\t\t     *lua-plugin-documentation-further-reading*\n+\n+- Ditaxis - A systematic approach to technical documentation authoring\n+  https://diataxis.fr/",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617934068",
            "id": 1617934068,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb7b0",
            "original_commit_id": "37e69d910286ef0323e0e7e1e442dc8c94d63cb8",
            "original_line": 437,
            "original_position": 437,
            "original_start_line": 436,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083915426,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-28T21:57:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617934822"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934822"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nNOTE: |vim.validate()| will `error` if it fails validation.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:58:00Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails valdation.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617934822",
            "id": 1617934822,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb7nm",
            "original_commit_id": "37e69d910286ef0323e0e7e1e442dc8c94d63cb8",
            "original_line": 337,
            "original_position": 337,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083916478,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934822/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:58:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617934822",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617935200"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617935200"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nCleanly separated configuration and smart initialization allow your plugin to \r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T21:58:34Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to ",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617935200",
            "id": 1617935200,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb7tg",
            "original_commit_id": "37e69d910286ef0323e0e7e1e442dc8c94d63cb8",
            "original_line": 235,
            "original_position": 235,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083917103,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617935200/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T21:58:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617935200",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617937881"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617937881"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nscript. See also |'runtimepath'|.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:02:35Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617937881",
            "id": 1617937881,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb8XZ",
            "original_commit_id": "1148b14a787f8d265fd960fdfa59a641e5ee07fc",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083921380,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617937881/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:02:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617937881",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938063"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938063"
                }
            },
            "author_association": "MEMBER",
            "body": "Given that neovim now contains most type annotations is there still a reason for neodev? (Other than the luals configuration bits, which we could point out in the luals reference above)",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:02:55Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938063",
            "id": 1617938063,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb8aP",
            "original_commit_id": "1148b14a787f8d265fd960fdfa59a641e5ee07fc",
            "original_line": 37,
            "original_position": 37,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083920760,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938063/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:13:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938063",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938340"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938340"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I suppose you mean this: https://github.com/neovim/neovim/pull/28977",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:03:18Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938340",
            "id": 1617938340,
            "in_reply_to_id": 1617925212,
            "line": 330,
            "node_id": "PRRC_kwDOAPphoM5gb8ek",
            "original_commit_id": "94bf04dcfd5107f0e27a9a57e8cbf9233460f53f",
            "original_line": 330,
            "original_position": 332,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 330,
            "pull_request_review_id": 2083922113,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938340/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:03:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938340",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938678"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938678"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n- |init.lua| scripts that call such a `setup` function may throw an error if the \r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:03:50Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the ",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938678",
            "id": 1617938678,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb8j2",
            "original_commit_id": "1148b14a787f8d265fd960fdfa59a641e5ee07fc",
            "original_line": 185,
            "original_position": 185,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083922637,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938678/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:03:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938678",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938984"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938984"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\nAnother option is to simply expose a Lua function or a |user-commands|.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:04:18Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617938984",
            "id": 1617938984,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb8oo",
            "original_commit_id": "1148b14a787f8d265fd960fdfa59a641e5ee07fc",
            "original_line": 195,
            "original_position": 195,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083923112,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938984/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:04:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617938984",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617940460"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617940460"
                }
            },
            "author_association": "MEMBER",
            "body": "I agree on the UI aspect, but I think we should first do the homework and come up with a better solution for subcommand definitions instead of spreading a chunk of boilerplate for every plugin to copy and paste. \r\n\r\nMy vote goes for leaving this section out for now. But let's see what the others say.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:06:34Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617940460",
            "id": 1617940460,
            "line": 38,
            "node_id": "PRRC_kwDOAPphoM5gb8_s",
            "original_commit_id": "c8e98b474473f3f2423e8eecdf308c486d51b7bf",
            "original_line": 38,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 38,
            "pull_request_review_id": 2083920760,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 8,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 8,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617940460/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:13:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617940460",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617946189"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617946189"
                }
            },
            "author_association": "MEMBER",
            "body": "Reading this I got the impression that this is more an intermediate best practice guide and not a beginner getting started guide.   Maybe this could be rephrased a bit, with more references to the other content? \r\n(E.g compare with the `:h write-plugin` intro)\r\n",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:13:34Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617946189",
            "id": 1617946189,
            "line": 13,
            "node_id": "PRRC_kwDOAPphoM5gb-ZN",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 13,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 13,
            "pull_request_review_id": 2083920760,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617946189/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:15:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617946189",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617948939"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617948939"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It can still be useful for getting lua-ls diagnostics for plugin dependencies.\r\n\r\nI personally prefer to generate a .luarc.json, but that uses Nix and would probably be too niche/overwhelming to recommend in nvim docs.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:17:53Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617948939",
            "id": 1617948939,
            "in_reply_to_id": 1617938063,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gb_EL",
            "original_commit_id": "1148b14a787f8d265fd960fdfa59a641e5ee07fc",
            "original_line": 37,
            "original_position": 37,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2083937881,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 1,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617948939/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:17:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617948939",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617950670"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617950670"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "How about  I remove the \"getting started with\"?",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:20:43Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617950670",
            "id": 1617950670,
            "in_reply_to_id": 1617946189,
            "line": 13,
            "node_id": "PRRC_kwDOAPphoM5gb_fO",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 13,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 13,
            "pull_request_review_id": 2083940625,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617950670/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:20:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617950670",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1617953245"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617953245"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I definitely agree that the boilerplate is horrible for plugin authors.\r\nFrom a user perspective, I find scoped subcommands a lot easier to handle, so I see copy/pasting it as worth it until something better comes along.\r\n\r\nHow about we open an issue for a better solution? I'd be more than happy to draft a POC if I can find some time soon.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-28T22:24:39Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1617953245",
            "id": 1617953245,
            "in_reply_to_id": 1617940460,
            "line": 38,
            "node_id": "PRRC_kwDOAPphoM5gcAHd",
            "original_commit_id": "c8e98b474473f3f2423e8eecdf308c486d51b7bf",
            "original_line": 38,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 38,
            "pull_request_review_id": 2083944791,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617953245/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-28T22:28:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1617953245",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618366751"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618366751"
                }
            },
            "author_association": "MEMBER",
            "body": "Although technically correct (newcomers indeed often do that), I would like to ask to rephrase the \"intro\" or remove it completely due to implied negative connotations (\"newcomers often don't know what they are doing and they do this, so ...\").\r\n\r\nSame with using \"Cleanly separated ...\" (implying that \"not separated is not clean\"). I'd suggest using either \"explicitly separated\", \"intentionally separated\", or just \"separated\" without any description.\r\n\r\nHere is my suggestion:\r\n\r\n```suggestion\r\nSeparated configuration and smart initialization allow your plugin to work out\r\nof the box. Common approaches are:\r\n\r\n- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides\r\n  the default configuration and does not contain any initialization logic.\r\n- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that\r\n  your plugin reads from and validates at initialization time.\r\n  See also |lua-vim-variables|.\r\n\r\nTypically, automatic initialization logic is done in a |plugin| or |ftplugin|\r\nscript. See also |'runtimepath'|.\r\n\r\nIf you want to force users to explicitly enable plugin functionality, using\r\n`setup(opts)` function for both initialization and configuration is a common\r\npractice.\r\n\r\nNOTE: A well designed plugin has minimal impact on startup time.\r\n      See also |lua-plugin-lazy-loading|.\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T07:42:03Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618366751",
            "id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gdlEf",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2084558273,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618366751/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T07:42:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618366751",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618449812"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618449812"
                }
            },
            "author_association": "MEMBER",
            "body": "Derp, never mind. Both versions are called vim.validate, so this isn't applicable ",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T08:33:02Z",
            "diff_hunk": "@@ -0,0 +1,439 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/    *LuaCATS*\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init| scripts that call such a `setup` function may throw an error if the \n+  plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or a |user-command|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initalization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |runtimepath|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618449812",
            "id": 1618449812,
            "in_reply_to_id": 1617925212,
            "line": 330,
            "node_id": "PRRC_kwDOAPphoM5gd5WU",
            "original_commit_id": "94bf04dcfd5107f0e27a9a57e8cbf9233460f53f",
            "original_line": 330,
            "original_position": 332,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 330,
            "pull_request_review_id": 2084685625,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618449812/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-29T08:33:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618449812",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618452592"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618452592"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's change the content to be beginner friendly instead with a way to \"advance\" to the more intermediate topics.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T08:34:59Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618452592",
            "id": 1618452592,
            "in_reply_to_id": 1617946189,
            "line": 13,
            "node_id": "PRRC_kwDOAPphoM5gd6Bw",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 13,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 13,
            "pull_request_review_id": 2084689910,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618452592/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-29T08:34:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618452592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618453510"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618453510"
                }
            },
            "author_association": "MEMBER",
            "body": "I'll rereview it when I have more time with more useful comments.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T08:35:36Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618453510",
            "id": 1618453510,
            "in_reply_to_id": 1617946189,
            "line": 13,
            "node_id": "PRRC_kwDOAPphoM5gd6QG",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 13,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 13,
            "pull_request_review_id": 2084691571,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618453510/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-29T08:35:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618453510",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618475939"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618475939"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": ">  I would like to ask to rephrase the \"intro\" or remove it completely due to implied negative connotations\r\n\r\nI don't know where you read this in between the lines\r\nI think it's perfectly fine and there is value in describing what the current \"de facto standard\" is and why that's not good\r\n\r\n> Same with using \"Cleanly separated ...\" (implying that \"not separated is not clean\"). I'd suggest using either \"explicitly separated\", \"intentionally separated\", or just \"separated\" without any description.\r\n\r\nAs far as I know as a non-native English speaker \"clean separation\" doesn't at all imply that otherwise it's not clean (which imo even is the case here but that's not the discussion right now)\r\nas duckduckgo ai chat said:\r\n> The term \"clean separation\" typically refers to a clear and distinct division or distinction between two things or entities. It does not necessarily imply cleanliness in the literal sense, but rather emphasizes a clear and unambiguous separation.\r\n\r\nI found \"separated configuration\" quite a confusing term though\r\nFor me this more sounds like you'd want people to split up the configuration even further",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T08:44:49Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618475939",
            "id": 1618475939,
            "in_reply_to_id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gd_uj",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2084725752,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618475939/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T08:44:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618475939",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/81827001?v=4",
                "events_url": "https://api.github.com/users/max397574/events{/privacy}",
                "followers_url": "https://api.github.com/users/max397574/followers",
                "following_url": "https://api.github.com/users/max397574/following{/other_user}",
                "gists_url": "https://api.github.com/users/max397574/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/max397574",
                "id": 81827001,
                "login": "max397574",
                "node_id": "MDQ6VXNlcjgxODI3MDAx",
                "organizations_url": "https://api.github.com/users/max397574/orgs",
                "received_events_url": "https://api.github.com/users/max397574/received_events",
                "repos_url": "https://api.github.com/users/max397574/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/max397574/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/max397574/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/max397574"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618505186"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618505186"
                }
            },
            "author_association": "MEMBER",
            "body": "> I think it's perfectly fine and there is value in describing what the current \"de facto standard\" is and why that's not good\r\n\r\nLess opinionated -> more better. A suggested rewrite contains both emphasis on configuration-initialization separation and the \"de facto standard\" which is a perfectly fine alternative if understanding the consequences.\r\n\r\n> I found \"separated configuration\" quite a confusing term though\r\n\r\nIt is not \"\\<separated configuration> and \\<initialization>\" but more like \"configuration and initialization are separate\". Both sound OK to me.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T09:00:14Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618505186",
            "id": 1618505186,
            "in_reply_to_id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5geG3i",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2084771084,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618505186/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T11:10:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618505186",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618653016"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618653016"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Given our previous negative interaction, I will give one response and then leave it to everyone else to decide.\r\n\r\nI disagree with your suggested change for the following reasons:\r\n\r\nIt is important to emphasize the consequences of defaulting to forcing users to call a `setup` function in the way I am doing. As @max397574 points out, it's a fact that newcomers usually default to this without understanding the consequences.\r\nAs mentioned in https://github.com/nvim-neorocks/nvim-best-practices/issues/5#issuecomment-2131367234, plugin authors can choose to diverge if they deem it necessary, which is made clear right at the beginning of this guide:\r\n\r\n> it is not intended as a set of rules...\r\n\r\nI disagree that the way I have phrased it has any negative connotations (which is a nitpick), as I don't make any recommendations not to diverge.\r\n\r\nI second @max397574's statement on \"clean separation\". But I see how this could be misinterpreted as negative for non-native speakers.\r\nHow about \"strict separation\" instead?",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T10:33:13Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618653016",
            "id": 1618653016,
            "in_reply_to_id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5geq9Y",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2085018247,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618653016/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T10:35:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618653016",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618698813"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618698813"
                }
            },
            "author_association": "MEMBER",
            "body": "> It is important to emphasize the consequences of defaulting to forcing users to call a `setup` function\r\n\r\nIt *is* described in the suggested change: \"If you want to force users to explicitly enable plugin functionality, using ...\". Without unnecessary \"Newcomers often\" / \"even if they are happy\", as built-in docs usually prefer to be more on point.\r\n\r\n> How about \"strict separation\" instead?\r\n\r\nTo me this is also fine. Using no description is even better.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T11:11:21Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618698813",
            "id": 1618698813,
            "in_reply_to_id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ge2I9",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2085097683,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618698813/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T11:11:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618698813",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1618789572"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618789572"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I strongly disagree that your suggestion \"is more on point\".\r\nThe sentence as you suggest would be redundant, as it lacks any reason for it, while losing the *emphasis* on the *very often overlooked* consequences. I have often heard people complain about being forced to call a `setup` function. Not once have I had anyone complain about *not being forced* to call one. Hence, I will not actively encourage doing so without good reason.\r\n\r\nIf anything, the phrasing, \"Newcomers will often...\" makes it clear that this advice is directed at newcomers, knowing that more advanced plugin developers will be able to make their own judgement.\r\n\r\n> To me this is also fine. \r\n\r\n~I'll adjust it later today.~\r\nDone.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T12:23:20Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Cleanly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a cleanly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1618789572",
            "id": 1618789572,
            "in_reply_to_id": 1618366751,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gfMTE",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 248,
            "original_position": 250,
            "original_start_line": 230,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2085247695,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 4,
                "-1": 2,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 6,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618789572/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-05-29T21:13:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1618789572",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1619075621"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619075621"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm not sure if just removing \"getting started\" will cut it. I think it would need some more wording updates to position this content a bit differently. It feels more like `plugin-ui-patterns` than `lua-plugin`.\r\n\r\nIt talks about:\r\n\r\n- Best practices in regards to keymap definitions for users\r\n    - Could tie into `lua-guide-mappings`\r\n- Best practices on how to expose configuration options to users\r\n- Best practices on how to design command APIs\r\n    - Could tie into `lua-guide-commands`\r\n\r\n- Performance considerations\r\n    - Partly covered by `lua-guide-modules` and `lua-module-load` and also related to `autoload`\r\n\r\nNone of this is beginner content for how to get a plugin working.\r\nAnd many parts are not exclusive to Lua.\r\n\r\nWhat I'd expect from a \"How to write a plugin\" targeted towards beginner is:\r\n\r\n- Language choices and link to resources to learn them (vim, lua, but also external providers)\r\n- Entry points (runtime path, packages, plugin/, ftplugin, ftdetect, autocmd hooks)\r\n- Available APIs\r\n\r\nBut we also shouldn't duplicate that, a lot of it is covered via `lua-guide` and the various vim resources. I also suspect that writing something like this is not what Justin had in mind, but rather something that's closer to the style of `:h dev-patterns`\r\n\r\n\r\nBut let's wait for @justinmk to clarify what his intentions were.\r\n",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T15:17:20Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1619075621",
            "id": 1619075621,
            "in_reply_to_id": 1617946189,
            "line": 13,
            "node_id": "PRRC_kwDOAPphoM5ggSIl",
            "original_commit_id": "b1c76ee5233ab7d5374254671506e2e8520d8796",
            "original_line": 13,
            "original_position": 13,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 13,
            "pull_request_review_id": 2085724792,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619075621/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-29T15:36:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619075621",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1619077068"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619077068"
                }
            },
            "author_association": "MEMBER",
            "body": "> How about we open an issue for a better solution?\r\n\r\nSounds good to me",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-29T15:18:16Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1619077068",
            "id": 1619077068,
            "in_reply_to_id": 1617940460,
            "line": 38,
            "node_id": "PRRC_kwDOAPphoM5ggSfM",
            "original_commit_id": "c8e98b474473f3f2423e8eecdf308c486d51b7bf",
            "original_line": 38,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 38,
            "pull_request_review_id": 2085727449,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619077068/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-29T15:18:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1619077068",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622256122"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622256122"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n- Proper initialization\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:04:00Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Strictly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a strictly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*\n+\n+Once you have merged the default configuration with the user's config, you\n+should validate configs.\n+\n+Validations could include:\n+\n+- Correct types, see |vim.validate()|\n+- Unknown fields in the user config (e.g. due to typos).\n+  This can be tricky to implement, and may be better suited for a |health| \n+  check, to reduce overhead.\n+\n+NOTE: |vim.validate()| will `error` if it fails validation.\n+\n+It can be useful to wrap |vim.validate()| in `pcall` and enrich error messages \n+with the path to the field in the config table:\n+>lua\n+    ---@param path string The path to the field being validated\n+    ---@param tbl table The table to validate\n+    ---@see vim.validate\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    local function validate_path(path, tbl)\n+      local ok, err = pcall(vim.validate, tbl)\n+      return ok, err and path .. \".\" .. err\n+    end\n+>\n+The function can be called like this:\n+>lua\n+    ---@param cfg myplugin.Config\n+    ---@return boolean is_valid\n+    ---@return string|nil error_message\n+    function validate(cfg)\n+        return validate_path(\"vim.g.my_plugin\", {\n+            do_something_cool = { cfg.do_something_cool, \"boolean\" },\n+            strategy = { cfg.strategy, \"string\" },\n+        })\n+    end\n+<\n+An invalid config will result in an error message like \n+`\"vim.g.my_plugin.strategy: expected string, got number\"`.\n+\n+By doing this, you can use the validation both\n+\n+- At initialization, reporting errors with |vim.notify()|.\n+- In a |health| check.\n+\n+==============================================================================\n+Troubleshooting\t\t\t\t\t   *lua-plugin-troubleshooting*\n+\n+------------------------------------------------------------------------------\n+Health checks\t\t\t       \t    *lua-plugin-troubleshooting-health*\n+\n+Provide health checks in `lua/{plugin}/health.lua`.\n+\n+Some things to validate:\n+\n+- User configuration\n+- Proper initializaion",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622256122",
            "id": 1622256122,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gsan6",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 382,
            "original_position": 382,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090562670,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622256122/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:04:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622256122",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622258341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622258341"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        -- Initialize\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:04:52Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Strictly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a strictly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622258341",
            "id": 1622258341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gsbKl",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 309,
            "original_position": 309,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090566093,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622258341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:04:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622258341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622261063"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622261063"
                }
            },
            "author_association": "MEMBER",
            "body": "Repo is abandoned, link to maintained fork instead.\r\n\r\n```suggestion\r\n- luacheck https://github.com/lunarmodules/luacheck for additional linting\r\n```",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:06:59Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622261063",
            "id": 1622261063,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gsb1H",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 36,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090571424,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622261063/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:06:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622261063",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622284526"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622284526"
                }
            },
            "author_association": "MEMBER",
            "body": "This seems absolutely broken. Have you tried this and gotten it to work? It gives completely different results if you run it for a directory `llscheck scripts` vs `llscheck scripts/*` and both results are wrong. The `--configpath` parameter seems to do nothing. It's impressively bad. What is this doing here?",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:26:05Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622284526",
            "id": 1622284526,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gshju",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 35,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090608663,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622284526/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:26:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622284526",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622308575"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622308575"
                }
            },
            "author_association": "MEMBER",
            "body": "This also seems completely broken. Let's take it easy with the recommendations unless we're certain they're reliable.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:45:56Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622308575",
            "id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gsnbf",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090645973,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622308575/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:45:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622308575",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622312736"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622312736"
                }
            },
            "author_association": "MEMBER",
            "body": "This whole section feels out of place here. If there's some part of the validation functionality that is missing from `vim.validate`, then we should try to improve the functionality in core rather than have every plugin author implement/augment validation functionality on their own.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:50:15Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Strictly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a strictly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622312736",
            "id": 1622312736,
            "line": 323,
            "node_id": "PRRC_kwDOAPphoM5gsocg",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 323,
            "original_position": 324,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 323,
            "pull_request_review_id": 2090653080,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622312736/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:50:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622312736",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319299"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319299"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I maintain this one. How are you testing it?\r\nIt has a workflow that runs on itself: https://github.com/mrcjkb/lua-typecheck-action/actions/workflows/typecheck.yml\r\nIt just needs a properly configured .luarc.json for packages that have dependencies.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:56:59Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319299",
            "id": 1622319299,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gsqDD",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090663577,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319299/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:57:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319299",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319959"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319959"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This one hasn't been touched in a while, so yeah it's very possibly broken.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:57:37Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319959",
            "id": 1622319959,
            "in_reply_to_id": 1622284526,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gsqNX",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 35,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090664581,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319959/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:57:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319959",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319961"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319961"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I use this and also know a few projects which use it where it works just fine",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T11:57:37Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622319961",
            "id": 1622319961,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gsqNZ",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090664582,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319961/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T11:57:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622319961",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/81827001?v=4",
                "events_url": "https://api.github.com/users/max397574/events{/privacy}",
                "followers_url": "https://api.github.com/users/max397574/followers",
                "following_url": "https://api.github.com/users/max397574/following{/other_user}",
                "gists_url": "https://api.github.com/users/max397574/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/max397574",
                "id": 81827001,
                "login": "max397574",
                "node_id": "MDQ6VXNlcjgxODI3MDAx",
                "organizations_url": "https://api.github.com/users/max397574/orgs",
                "received_events_url": "https://api.github.com/users/max397574/received_events",
                "repos_url": "https://api.github.com/users/max397574/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/max397574/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/max397574/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/max397574"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622324601"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622324601"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I've removed the bits about wrapping `vim.validate` in `pcall` - although I do think Neovim needs a proper solution that allows validating configs in health checks and with `vim.notify`.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T12:02:23Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*\n+\n+Many users rely on command completion to discover available user commands. If\n+a plugin pollutes the command namespace with lots of commands, this can\n+quickly become overwhelming.\n+\n+Example:\n+\n+- `FooAction1 {arg}`\n+- `FooAction2 {arg}`\n+- `FooAction3`\n+- `BarAction1`\n+- `BarAction2`\n+\n+Instead of doing this, consider gathering subcommands under scoped commands\n+and implementing completions for each subcommand.\n+\n+Example:\n+\n+- `Foo action1 {arg}`\n+- `Foo action2 {arg}`\n+- `Foo action3`\n+- `Bar action1`\n+- `Bar action2`\n+\n+------------------------------------------------------------------------------\n+Subcommand completions example   *lua-plugin-user-commands-completions-example*\n+\n+In this example, we want to provide:\n+\n+- Subcommand completions if the user has typed `:Foo ...`\n+- Argument completions if they have typed `:Foo {subcommand}`\n+\n+First, define a type for each subcommand, which has:\n+\n+- An implementation: A function which is called when executing the subcommand.\n+- An optional command completion callback, which takes the lead of the\n+  subcommand's arguments.\n+\n+>lua\n+    ---@class FooSubcommand\n+    ---@field impl fun(args:string[], opts: table)\n+    ---@field complete? fun(subcmd_arg_lead: string): string[]\n+<\n+Next, we define a table mapping subcommands to their implementations and\n+completions:\n+>lua\n+    ---@type table<string, FooSubcommand>\n+    local subcommand_tbl = {\n+        action1 = {\n+            impl = function(args, opts)\n+              -- Implementation (args is a list of strings)\n+            end,\n+            -- This subcommand has no completions\n+        },\n+        action2 = {\n+            impl = function(args, opts)\n+                -- Implementation\n+            end,\n+            complete = function(subcmd_arg_lead)\n+                -- Simplified example\n+                local install_args = {\n+                    \"first\",\n+                    \"second\",\n+                    \"third\",\n+                }\n+                return vim.iter(install_args)\n+                    :filter(function(install_arg)\n+                        -- If the user has typed `:Foo action2 fi`,\n+                        -- this will match 'first'\n+                        return install_arg:find(subcmd_arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end,\n+            -- ...\n+        },\n+    }\n+<\n+Then, create a Lua function to implement the main command:\n+>lua\n+    ---@param opts table :h lua-guide-commands-create\n+    local function foo_cmd(opts)\n+        local fargs = opts.fargs\n+        local subcommand_key = fargs[1]\n+        -- Get the subcommand's arguments, if any\n+        local args = #fargs > 1 and vim.list_slice(fargs, 2, #fargs) or {}\n+        local subcommand = subcommand_tbl[subcommand_key]\n+        if not subcommand then\n+            vim.notify(\"Foo: Unknown command: \" .. subcommand_key, vim.log.levels.ERROR)\n+            return\n+        end\n+        -- Invoke the subcommand\n+        subcommand.impl(args, opts)\n+    end\n+<\n+See also |lua-guide-commands-create|.\n+\n+Finally, we register our command, along with the completions:\n+>lua\n+    -- NOTE: the options will vary, based on your use case.\n+    vim.api.nvim_create_user_command(\"Foo\", foo_cmd, {\n+        nargs = \"+\",\n+        desc = \"My awesome command with subcommand completions\",\n+        complete = function(arg_lead, cmdline, _)\n+            -- Get the subcommand.\n+            local subcmd_key, subcmd_arg_lead = cmdline:match(\"^Foo[!]*%s(%S+)%s(.*)$\")\n+            if subcmd_key \n+                and subcmd_arg_lead \n+                and subcommand_tbl[subcmd_key] \n+                and subcommand_tbl[subcmd_key].complete\n+            then\n+                -- The subcommand has completions. Return them.\n+                return subcommand_tbl[subcmd_key].complete(subcmd_arg_lead)\n+            end\n+            -- Check if cmdline is a subcommand\n+            if cmdline:match(\"^Foo[!]*%s+%w*$\") then\n+                -- Filter subcommands that match\n+                local subcommand_keys = vim.tbl_keys(subcommand_tbl)\n+                return vim.iter(subcommand_keys)\n+                    :filter(function(key)\n+                        return key:find(arg_lead) ~= nil\n+                    end)\n+                    :totable()\n+            end\n+        end,\n+        bang = true, -- If you want to support ! modifiers\n+    })\n+<\n+==============================================================================\n+Keymaps\t\t\t\t\t\t\t   *lua-plugin-keymaps*\n+\n+Avoid creating keymaps automatically, unless they are not controversial. Doing\n+so can easily lead to conflicts with user |mapping|s.\n+\n+NOTE: An example for uncontroversial keymaps are buffer-local |mapping|s for \n+      specific file types or floating windows.\n+\n+A common approach to allow keymap configuration is to define a declarative DSL\n+https://en.wikipedia.org/wiki/Domain-specific_language via a `setup` function.\n+\n+However, doing so means that\n+\n+- You will have to implement and document it yourself.\n+- Users will likely face inconsistencies if another plugin has a slightly\n+  different DSL.\n+- |init.lua| scripts that call such a `setup` function may throw an error if\n+  the plugin is not installed or disabled.\n+\n+As an alternative, you can provide |<Plug>| mappings to allow users to define\n+their own keymaps with |vim.keymap.set()|.\n+\n+- This requires one line of code in user configs.\n+- Even if your plugin is not installed or disabled, creating the keymap won't\n+  throw an error.\n+\n+Another option is to simply expose a Lua function or |user-commands|.\n+\n+However, some benefits of |<Plug>| mappings over this are that you can\n+\n+- Enforce options like `expr = true`.\n+- Expose functionality only for specific |map-modes|.\n+- Expose different behavior for different |map-modes| with a single |<Plug>|\n+  mapping, without adding impurity or complexity to the underlying Lua\n+  implementation.\n+\n+NOTE: If you have a function that takes a large options table, creating lots\n+      of |<Plug>| mappings to expose all of its uses could become\n+      overwhelming. It may still be beneficial to create some for the most\n+      common ones.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t\t      *lua-plugin-plug-mapping-example*\n+\n+In your plugin:\n+>lua\n+    vim.keymap.set(\"n\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from normal mode\") \n+    end, { noremap = true })\n+\n+    vim.keymap.set(\"v\", \"<Plug>(SayHello)\", function() \n+        print(\"Hello from visual mode\") \n+    end, { noremap = true })\n+<\n+In the user's config:\n+>lua\n+    vim.keymap.set({\"n\", \"v\"}, \"<leader>h\", \"<Plug>(SayHello)\")\n+<\n+==============================================================================\n+Initialization\t\t\t\t\t    *lua-plugin-initialization*\n+\n+Newcomers to Lua plugin development will often put all initialization logic in\n+a single `setup` function, which takes a table of options.\n+If you do this, users will be forced to call this function in order to use\n+your plugin, even if they are happy with the default configuration.\n+\n+Strictly separated configuration and smart initialization allow your plugin to \n+work out of the box.\n+\n+NOTE: A well designed plugin has minimal impact on startup time.\n+      See also |lua-plugin-lazy-loading|.\n+\n+Common approaches to a strictly separated configuration are:\n+\n+- A Lua function, e.g. `setup(opts)` or `configure(opts)`, which only overrides the\n+  default configuration and does not contain any initialization logic.\n+- A Vimscript compatible table (e.g. in the |vim.g| or |vim.b| namespace) that your\n+  plugin reads from and validates at initialization time.\n+  See also |lua-vim-variables|.\n+\n+Typically, automatic initialization logic is done in a |plugin| or |ftplugin|\n+script. See also |'runtimepath'|.\n+\n+==============================================================================\n+Lazy loading\t\t\t\t\t      *lua-plugin-lazy-loading*\n+\n+When it comes to initializing your plugin, assume your users may not be using\n+a plugin manager that takes care of lazy loading for you.\n+Making sure your plugin does not unnecessarily impact startup time is your\n+responsibility. A plugin's functionality may evolve over time, potentially\n+leading to breakage if users have to hack into the loading mechanisms.\n+Furthermore, a plugin that implements its own lazy initialization properly will\n+likely have less overhead than the mechanisms used by a plugin manager or user\n+to load that plugin lazily.\n+\n+------------------------------------------------------------------------------\n+Defer `require` calls\t\t\t*lua-plugin-lazy-loading-defer-require*\n+\n+|plugin| scripts should not eagerly `require` Lua modules.\n+\n+For example, instead of:\n+>lua\n+    local foo = require(\"foo\")\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+which will eagerly load the `foo` module and any other modules it imports\n+eagerly, you can lazy load it by moving the `require` into the command's\n+implementation.\n+>lua\n+    vim.api.nvim_create_user_command(\"MyCommand\", function()\n+        local foo = require(\"foo\")\n+        foo.do_something()\n+    end, {\n+      -- ...\n+    })\n+<\n+NOTE: For a Vimscript alternative to `require`, see |autoload|.\n+\n+NOTE: In case you are worried about eagerly creating user commands, autocommands\n+      or keymaps at startup:\n+      Plugin managers that provide abstractions for lazy-loading plugins on\n+      such events will need to create these themselves.\n+\n+------------------------------------------------------------------------------\n+Filetype-specific functionality\t\t     *lua-plugin-lazy-loading-filetype*\n+\n+Consider making use of |filetype| for any functionality that is specific to a\n+filetype, by putting the initialization logic in a `ftplugin/{filetype}.lua`\n+script.\n+\n+------------------------------------------------------------------------------\n+Example\t\t\t\t     *lua-plugin-lazy-loading-filetype-example*\n+\n+A plugin tailored to Rust development might have initialization in \n+`ftplugin/rust.lua`:\n+>lua\n+    if not vim.g.loaded_my_rust_plugin then\n+        -- Initialise\n+    end\n+    -- NOTE: Using `vim.g.loaded_` prevents the plugin from initializing twice\n+    -- and allows users to prevent plugins from loading\n+    -- (in both Lua and Vimscript).\n+    vim.g.loaded_my_rust_plugin = true\n+\n+    local bufnr = vim.api.nvim_get_current_buf()\n+    -- do something specific to this buffer,\n+    -- e.g. add a |<Plug>| mapping or create a command\n+    vim.keymap.set(\"n\", \"<Plug>(MyPluginBufferAction)\", function() \n+        print(\"Hello\")\n+    end, { noremap = true, buffer = bufnr, })\n+<\n+==============================================================================\n+Configuration\t\t\t\t             *lua-plugin-configuration*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622324601",
            "id": 1622324601,
            "in_reply_to_id": 1622312736,
            "line": 323,
            "node_id": "PRRC_kwDOAPphoM5gsrV5",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 323,
            "original_position": 324,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 323,
            "pull_request_review_id": 2090672530,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622324601/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T12:02:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622324601",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622326442"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622326442"
                }
            },
            "author_association": "MEMBER",
            "body": ">  How are you testing it?\r\n\r\nhttps://github.com/dundargoc/neovim/actions/runs/9317809971/workflow\r\nhttps://github.com/dundargoc/neovim/actions/runs/9317809971/job/25648875919\r\n\r\nIt complains about file under `/nix/store` for some reason, even though it says only the repo is supposed to be tested?",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T12:04:16Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622326442",
            "id": 1622326442,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gsryq",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090675513,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622326442/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T12:04:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622326442",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622332825"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622332825"
                }
            },
            "author_association": "MEMBER",
            "body": "OK, you know what? Let's continue the discussion in your repo. Leave this in for now.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T12:10:27Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622332825",
            "id": 1622332825,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gstWZ",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090686615,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622332825/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T12:11:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622332825",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622343497"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622343497"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "That's because the neovim `.luarc.json` has\r\n\r\n```json\r\n    \"library\": [\r\n      \"runtime/lua\",\r\n      \"${3rd}/busted/library\", \r\n      \"${3rd}/luv/library\"\r\n    ],\r\n```\r\n\r\n`\"${3rd}/busted/library\"` ([which is deprecated btw](https://github.com/LuaLS/lua-language-server/wiki/Libraries#built-in-libraries)) is what is failing.\r\n\r\nYou need `\"diagnostic.libraryFiles\": \"Disable\"` in the `.luarc.json`. Although I'm not sure if `runtime/lua` is a library for Neovim, as you would probably want to get diagnostics for that.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T12:20:49Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622343497",
            "id": 1622343497,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gsv9J",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2090704855,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622343497/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T12:20:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622343497",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622365470"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622365470"
                }
            },
            "author_association": "MEMBER",
            "body": "Perhaps my weird results with llscheck was due to our .luarc.json being incorrectly configured. Can keep in mind for later.",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T12:41:27Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622365470",
            "id": 1622365470,
            "in_reply_to_id": 1622284526,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5gs1Ue",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 35,
            "original_position": 35,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": null,
            "pull_request_review_id": 2090743060,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622365470/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T12:41:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622365470",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622519795"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622519795"
                }
            },
            "author_association": "MEMBER",
            "body": "@mrcjkb wanna send a separate PR to neovim to fix `.luarc.json` and `test/.luarc.json`? You seem to already have a good grasp of how these should be configured. (I looked at the docs for luals and got scared)",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T14:34:37Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622519795",
            "id": 1622519795,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gta_z",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2091011763,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622519795/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T14:34:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622519795",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622605515"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622605515"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Sure. I'm not quite sure how to fix the `${3rd}` libraries here. That would require [using addons](https://github.com/LuaLS/LLS-Addons). Maybe we should open an issue first?",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T15:39:29Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622605515",
            "id": 1622605515,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5gtv7L",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2091152403,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622605515/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T15:39:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622605515",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622772690"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622772690"
                }
            },
            "author_association": "MEMBER",
            "body": "https://github.com/neovim/neovim/pull/29115",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T17:55:09Z",
            "diff_hunk": "@@ -0,0 +1,432 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Nvim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Nvim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622772690",
            "id": 1622772690,
            "in_reply_to_id": 1622308575,
            "line": 34,
            "node_id": "PRRC_kwDOAPphoM5guYvS",
            "original_commit_id": "23025946b8759e94b86d56b1881856ef29d24f92",
            "original_line": 34,
            "original_position": 34,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 34,
            "pull_request_review_id": 2091417073,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622772690/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T17:55:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622772690",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29073#discussion_r1622793052"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29073"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622793052"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "https://github.com/neovim/neovim/pull/29116",
            "commit_id": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
            "created_at": "2024-05-31T18:14:19Z",
            "diff_hunk": "@@ -0,0 +1,433 @@\n+*lua-plugin.txt*                     Nvim\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\t\t  Guide to developing Lua plugins for Nvim\n+\n+\n+                                       Type |gO| to see the table of contents.\n+\n+==============================================================================\n+Introduction                                                       *lua-plugin*\n+\n+This is a guide for getting started with Neovim plugin development. It is not\n+intended as a set of rules, but as a collection of recommendations for good\n+practices.\n+\n+For a guide to using Lua in Neovim, please refer to |lua-guide|.\n+\n+==============================================================================\n+Type safety                                            *lua-plugin-type-safety*\n+\n+Lua, as a dynamically typed language, is great for configuration. It provides\n+virtually immediate feedback.\n+But for larger projects, this can be a double-edged sword, leaving your plugin\n+susceptible to unexpected bugs at the wrong time.\n+\n+You can leverage LuaCATS https://luals.github.io/wiki/annotations/\n+annotations, along with lua-language-server https://luals.github.io/ to catch\n+potential bugs in your CI before your plugin's users do.\n+\n+------------------------------------------------------------------------------\n+Tools\t\t\t\t\t\t *lua-plugin-type-safety-tools*\n+\n+- lua-typecheck-action https://github.com/marketplace/actions/lua-typecheck-action\n+- llscheck https://github.com/jeffzi/llscheck\n+- luacheck https://github.com/mpeterv/luacheck for additional linting\n+- neodev.nvim https://github.com/folke/neodev.nvim\n+\n+==============================================================================\n+User commands\t\t\t\t\t     *lua-plugin-user-commands*",
            "html_url": "https://github.com/neovim/neovim/pull/29073#discussion_r1622793052",
            "id": 1622793052,
            "in_reply_to_id": 1617940460,
            "line": 38,
            "node_id": "PRRC_kwDOAPphoM5gudtc",
            "original_commit_id": "c8e98b474473f3f2423e8eecdf308c486d51b7bf",
            "original_line": 38,
            "original_position": 40,
            "original_start_line": null,
            "path": "runtime/doc/lua-plugin.txt",
            "position": 38,
            "pull_request_review_id": 2091453237,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622793052/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-05-31T18:14:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1622793052",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "Not sure how to find the invalid tags. I'm pretty new to manually writing help text.",
            "created_at": "2024-05-28T21:50:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/29073#issuecomment-2136165906",
            "id": 2136165906,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29073",
            "node_id": "IC_kwDOAPphoM5_U04S",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2136165906/reactions"
            },
            "updated_at": "2024-05-30T12:47:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2136165906",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/29073/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/29073/commits",
    "created_at": "2024-05-28T21:18:04Z",
    "diff_url": "https://github.com/neovim/neovim/pull/29073.diff",
    "draft": false,
    "head": {
        "label": "mrcjkb:lua-plugin",
        "ref": "lua-plugin",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/mrcjkb/neovim-fork/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/mrcjkb/neovim-fork/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/mrcjkb/neovim-fork/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/mrcjkb/neovim-fork/branches{/branch}",
            "clone_url": "https://github.com/mrcjkb/neovim-fork.git",
            "collaborators_url": "https://api.github.com/repos/mrcjkb/neovim-fork/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/mrcjkb/neovim-fork/comments{/number}",
            "commits_url": "https://api.github.com/repos/mrcjkb/neovim-fork/commits{/sha}",
            "compare_url": "https://api.github.com/repos/mrcjkb/neovim-fork/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/mrcjkb/neovim-fork/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/mrcjkb/neovim-fork/contributors",
            "created_at": "2022-10-03T13:41:23Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/mrcjkb/neovim-fork/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/mrcjkb/neovim-fork/downloads",
            "events_url": "https://api.github.com/repos/mrcjkb/neovim-fork/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/mrcjkb/neovim-fork/forks",
            "full_name": "mrcjkb/neovim-fork",
            "git_commits_url": "https://api.github.com/repos/mrcjkb/neovim-fork/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/mrcjkb/neovim-fork/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/mrcjkb/neovim-fork/git/tags{/sha}",
            "git_url": "git://github.com/mrcjkb/neovim-fork.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/mrcjkb/neovim-fork/hooks",
            "html_url": "https://github.com/mrcjkb/neovim-fork",
            "id": 544931422,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/mrcjkb/neovim-fork/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/mrcjkb/neovim-fork/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/mrcjkb/neovim-fork/issues{/number}",
            "keys_url": "https://api.github.com/repos/mrcjkb/neovim-fork/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/mrcjkb/neovim-fork/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/mrcjkb/neovim-fork/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/mrcjkb/neovim-fork/merges",
            "milestones_url": "https://api.github.com/repos/mrcjkb/neovim-fork/milestones{/number}",
            "mirror_url": null,
            "name": "neovim-fork",
            "node_id": "R_kgDOIHr-Xg",
            "notifications_url": "https://api.github.com/repos/mrcjkb/neovim-fork/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
                "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
                "followers_url": "https://api.github.com/users/mrcjkb/followers",
                "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
                "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mrcjkb",
                "id": 12857160,
                "login": "mrcjkb",
                "node_id": "MDQ6VXNlcjEyODU3MTYw",
                "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
                "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
                "repos_url": "https://api.github.com/users/mrcjkb/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mrcjkb"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/mrcjkb/neovim-fork/pulls{/number}",
            "pushed_at": "2024-06-03T05:14:06Z",
            "releases_url": "https://api.github.com/repos/mrcjkb/neovim-fork/releases{/id}",
            "size": 265640,
            "ssh_url": "git@github.com:mrcjkb/neovim-fork.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/mrcjkb/neovim-fork/stargazers",
            "statuses_url": "https://api.github.com/repos/mrcjkb/neovim-fork/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/mrcjkb/neovim-fork/subscribers",
            "subscription_url": "https://api.github.com/repos/mrcjkb/neovim-fork/subscription",
            "svn_url": "https://github.com/mrcjkb/neovim-fork",
            "tags_url": "https://api.github.com/repos/mrcjkb/neovim-fork/tags",
            "teams_url": "https://api.github.com/repos/mrcjkb/neovim-fork/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/mrcjkb/neovim-fork/git/trees{/sha}",
            "updated_at": "2024-05-31T12:26:49Z",
            "url": "https://api.github.com/repos/mrcjkb/neovim-fork",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
            "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
            "followers_url": "https://api.github.com/users/mrcjkb/followers",
            "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
            "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/mrcjkb",
            "id": 12857160,
            "login": "mrcjkb",
            "node_id": "MDQ6VXNlcjEyODU3MTYw",
            "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
            "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
            "repos_url": "https://api.github.com/users/mrcjkb/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/mrcjkb"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/29073",
    "id": 1892670300,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29073",
    "labels": [
        {
            "color": "c5def5",
            "default": true,
            "description": "",
            "id": 84744038,
            "name": "documentation",
            "node_id": "MDU6TGFiZWw4NDc0NDAzOA==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/documentation"
        }
    ],
    "locked": false,
    "merge_commit_sha": "2bfeff25af6c1561025219e45d0fbd1429c07bc7",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5wz9tc",
    "number": 29073,
    "patch_url": "https://github.com/neovim/neovim/pull/29073.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
            "events_url": "https://api.github.com/users/clason/events{/privacy}",
            "followers_url": "https://api.github.com/users/clason/followers",
            "following_url": "https://api.github.com/users/clason/following{/other_user}",
            "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/clason",
            "id": 2361214,
            "login": "clason",
            "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
            "organizations_url": "https://api.github.com/users/clason/orgs",
            "received_events_url": "https://api.github.com/users/clason/received_events",
            "repos_url": "https://api.github.com/users/clason/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/clason"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/29073/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/6d3ff992ffef6b2eaf2cbe133a25e165cf0ae9a8",
    "title": "docs: add guide for developing Lua plugins",
    "updated_at": "2024-05-31T18:14:19Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/29073",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/12857160?v=4",
        "events_url": "https://api.github.com/users/mrcjkb/events{/privacy}",
        "followers_url": "https://api.github.com/users/mrcjkb/followers",
        "following_url": "https://api.github.com/users/mrcjkb/following{/other_user}",
        "gists_url": "https://api.github.com/users/mrcjkb/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/mrcjkb",
        "id": 12857160,
        "login": "mrcjkb",
        "node_id": "MDQ6VXNlcjEyODU3MTYw",
        "organizations_url": "https://api.github.com/users/mrcjkb/orgs",
        "received_events_url": "https://api.github.com/users/mrcjkb/received_events",
        "repos_url": "https://api.github.com/users/mrcjkb/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/mrcjkb/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mrcjkb/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/mrcjkb"
    }
}